- 인덱스
    - 인덱스(Index)란?
        인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
        특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
        이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.
        디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
        인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.
        이를 위해 데이터가 추가/삭제 될 때마다 자료구조를 정렬하기 때문에 인덱스는 SELECT 성능을 향상시키는 대신 INSERT, UPDATE, DELETE 의 성능이 떨어지게 됩니다.

        인덱스도 하나의 데이터베이스 객체
        데이터베이스 크기의 약 10% 정도의 저장공간 필요

    - 인덱스(Index)를 사용하는 이유
        테이블에 데이터들이 인덱스의 가장 큰 특징은 데이터들이 정렬이 되어있다는 점입니다. 이 특징으로 인해 조건 검색이라는
        영역에서 굉장한 장점이 됩니다.
        인덱스를 사용하게 되면 테이블에 바로 접근하지 않고 인덱스 영역에서 빠르게 ROWID를 찾아낸 후 실제 테이블에서 해당하는 데이터를 찾는다.

        - 조건 검색 Where 절의 효율성
            테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다.
            이렇게 되면 Where 절에 특정 조건에 맞는 데이터들을 찾아낼때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과
            맞는지 비교해야 합니다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 하지만 인덱스 테이블은 데이터들이
            정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠.
            이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다.

        - 정렬 Order by 절의 효율성
            인덱스(Index)를 사용하면 Order by에 의한 Sort 과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이
            걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면
            디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다.
            이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.

        - MIN, MAX 의 효율적인 처리가 가능하다.
            - 이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점입니다. MIN 값과 MAX 값을 레코드의 시작값과 끝 값 한건씩만
              가져오면 되기에 FULL TABLE SCAN 으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.
            - 인덱스가 걸려있는 컬럼을 MIN, MAX를 쓰면 INDEX_ASC, INDEX_DESC 테이블 힌트를 사용하지 않아도 자동으로 인덱스를 사용한다.

        - Index를 사용하면 좋은 경우
            - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
            - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
            - 데이터의 중복도가 낮은 컬럼
            - 필드에 저장된 값을 찾는 작업이 예상되는 경우
            - 필드의 값을 정렬하는 작업이 예상되는 경우

    - 인덱스의 자료구조가 B- TREE 인 이유
        - 탐색시간이 제일 빠른 해시 테이블을 DB 인덱스로 사용할 수 없는 이유
            - 해시 충돌 등으로 최악의 경우에 O(N)이 될 수 있지만, 평균적으로는 O(1)
            - 해시 테이블은 분명 한 가지 키에 대한 탐색은 효율적입니다.
            - 하지만 데이터가 정렬되어 있지 않기 때문에 부등호 (<, >) 를 사용하지 못한다는 단점이 있습니다.

        - 그러면 탐색이 O(logN)인 다른 자료구조나 알고리즘은 왜 사용하지 못하는 것일까? 같은 밸런스 트리 종류임에도 RedBlack-Tree는 DB 인덱스로 선택받지 못한 이유
            - RedBlack-Tree와 B-Tree의 가장 큰 차이는 '하나의 노드가 가지는 데이터 개수'이다.
            - RedBlack-Tree는 무조건 하나의 노드에 하나의 데이터 요소만을, B-Tree는 하나의 노드에 여러 개의 데이터 요소를 저장한다.
            - 같은 노드 공간의 데이터들끼리 굳이 자식 노드처럼 참조 포인터 값으로 접근할 필요가 없다. 실제 메모리 디스크에서 바로 다음 인덱스의 접근을 하는 것
            - 노드에서 배열 형태로 여러 데이터를 저장할 수 있기 때문에 트리 포인터를 참조해서 계속 depth 를 타고 들어가는 것보다 효율적이고 이는 데이터가 많아질수록 차이가 두드러집니다.

        - 모든 면으로 DB 인덱스 용도로 가장 적합한 자료구조인 B-Tree
            - 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
            - 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.
            - 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.

        - 인덱스도 크기가 커져 보조 기억 장치에 저장되게 되는데 이 또한 디스크 I/O가 발생하게 되는 것이다.
          따라서 B-Tree의 깊이를 줄여야 디스크 I/O를 줄일 수 있기 때문에 B-Tree를 사용한다.

    - B-Tree 인덱스의 쿼리별 특징
        - SELECT
            - 특정 키 값을 찾기 위해 자식 노드를 계속 타고 들어가는 방식
            - 마지막 리프 노드에는 레코드의 주소가 존재하고 이 값으로 테이블 레코드를 찾을 수 있음

            - B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
              그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

        - INSERT
            - B-Tree 에 새로운 키값을 저장할 때는 우선 적절한 위치를 찾아야함
            - 새로운 키값과 레코드 정보는 리프 노드에 저장
            - 만약 리프 노드가 꽉찼다면 트리를 재구성하여 리프 노드를 분리
            - 분리 과정에서 해당 리프 노드의 부모 노드까지 영향이 갈 수 있음
            - 이러한 이유로 INSERT 작업은 상대적으로 비용이 많이 듬
            - 인덱스가 많으면 많을수록 이런 비용이 추가로 들기 때문에 너무 많은 인덱스를 추가하는 건 성능에 영향을 줌

            - 페이지 내부에서 작업될 경우 큰 부담은 없지만, 페이지가 꽉 찰 경우 데이터베이스는 비어 있는 페이지를 확보하고
              문제가 있는 페이지의 데이터를 공평하게 나누어 저장. 이는 데이터베이스에 부담이 되는 작업 (페이지 분할)
            - 페이지 분할
                - 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생
                - DB 가 느려지고 성능에 영향을 준다.

        - DELETE
            - B-Tree 에서 키 값 삭제는 간단
            - 해당 키를 찾아서 삭제 마크만 하면 작업이 완료
            - 삭제 마킹된 인덱스 키 공간은 그대로 두거나 재활용 가능

            - 인덱스의 데이터를 실제로 지우지 않고 사용안함 표시를 한다.

        - UPDATE
            - 인덱스는 항상 정렬된 상태로 유지됨
            - 단순히 인덱스 키 값을 수정한다면 트리의 전체 구조를 바꿔야 할 수도 있음
            - 그래서 B-Tree 에선 키 변경이 아닌 기존 키 삭제 (DELETE) 후 새로운 키 추가 (INSERT) 방식을 사용
            - 따라서 키 값의 잦은 수정은 성능에 큰 영향을 미침

            - delete (기존 값 사용안함 표시)
            - insert (변경된 값 삽입)

        -> update, delete 의 경우 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다.
           페이지: 데이터가 저장되는 단위 (16 Kbyte)

    - 인덱스 자료구조 (B * Tree 인덱스)
        인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다.
        그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.
        B * Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다.
        구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node 로 구성됩니다. 특정 컬럼에 인덱스를 생성하는
        순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT 블록을
        기준으로 가지가 되는 BRANCH 블록을 정의하며 마지막으로 잎에 해당하는 LEAF 블록에 인덱스의 키가 되는
        데이터와 데이터의 물리적 주소 정보인 ROWID 를 저장합니다.

        일반적으로 B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
        그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

    - 인덱스 종류
        - Clustered Index vs Non-Clustered Index
            - Clustered Index
                - 이름 그대로 인접한 데이터들을 한곳으로 모았다는 뜻
                - PK 설정 시 자동으로 클러스터드 인덱스로 만들어짐
                - 테이블당 1개씩만 허용
                - 물리적인 데이터를 갖고 있음
                - 항상 정렬된 상태를 유지하고 노드 내에서도 정렬되어 있음
                - Non Clustered 인덱스에 비해 조회 속도가 빠르지만 삽입/수정/삭제는 더 느림

                - 데이터페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
                - 데이터페이지는 리프 레벨
                - 클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 된다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있다.
                - 테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
                - 물리적으로 행을 재배열 (실제 DB의 데이터파일에 정렬이 되어 있는 상태로 디스크에 저장)

                - 실제 데이터 자체가 정렬
                - 리프 페이지 -> 실제 데이터 페이지

            - Non Clustered Index
                - UNIQUE 로 설정된 컬럼에 자동으로 생성됨
                - 인덱스 페이지는 로그 파일에 저장됨
                - 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됨
                - 기본키는 아니지만 성능 향상을 위해 임의의 컬럼을 지정해서 만든 인덱스

                - 데이터 페이지를 건들지 않고, 별도의 장소에 인덱스 페이지를 생성
                - 우선 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬하고 데이터 위치 포인터를 생성한다.
                - 데이터 위치 포인터는 데이터가 위치한 고유한 값이 된다. (리프 페이지 -> 실제 데이터의 주소 페이지)
                - 인덱스 페이지를 별도로 저장
                - 테이블 자체는 되지 않고, 인덱스 페이지에만 정렬

                - 실제 데이터와 다른 무리의 별도의 인덱스
                - 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 같은 역할
                - 별도의 인덱스 페이지 생성 -> 추가 공간 필요
                - unique 제약조건 적용시 자동 생성
                - 직접 index 생성시 논-클러스터링 인덱스 생성 (unique index, index)

            - 클러스터링 + 논-클러스터링 인덱스
                - 클러스터링 인덱스 페이지가 존재하고, 논-클러스터링 인덱스 페이지에는 데이터 페이지의 주소가 존재해서 데이터를 조회?
                  하지만, 데이터 페이지의 주소값이 아닌 클러스터링 인덱스가 적용된 칼럼의 실제값이 들어있다.
                - name 인덱스 페이지에서 해당 name 을 찾고 그 값을 통해 id 인덱스 페이지에서 탐색
                  (name 칼럼의 논-클러스터링 인덱스 페이지, id 칼럼의 클러스트렁 인덱스 페이지 구조 예시)
                - 만약 논-클러스터링 인덱스 페이지에 데이터 페이지의 주소값이 들어있게 되면, 데이터가 추가되거나 삭제될 때마다
                  인덱스 페이지들의 주소들을 계속해서 변경해야 하는 영향을 주게 된다. 따라서 클러스터링 인덱스가 적용된 칼럼의 실제값이
                  들어있으면 id 가 직접 변경되지 않는 한 인덱스 페이지에 영향을 주지 않도록 구성되어 있다.

    - 인덱스 설정 시 고려사항
        - 인덱스 키 값의 크기
            - 키 값이 클수록 디스크 IO 횟수가 많아져서 성능이 떨어진다. -> 인덱스의 키 값은 작을수록 유리
            - 인덱스 키 값의 크기가 클수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지므로 B-Tree 깊이가 깊어진다.
              깊이가 깊어진다는 것은 디스크 IO 횟수가 많아진다는 것.

        - 인덱스의 갯수
            - 인덱스의 갯수는 3 ~ 4 개가 적당
            - 인덱스의 갯수가 너무 많으면 다음과 같은 이슈가 존재
                - 데이터 삽입/수정/삭제 시마다 인덱스도 같이 추가하거나 수정/삭제 해주어야 해서 성능상 이슈가 존재
                - 데이터 삽입시마다 인덱스도 같이 추가하기 때문에 인덱스가 늘어날수록 더 많은 메모리를 차지함
                - 인덱스가 많아지면 옵티마이저가 잘못된 인덱스를 선택할 확률이 높아짐 (인덱스 힌트로 원하는 인덱스를 지정할 순 있음)

        - 인덱스를 걸기에 적절한 컬럼
            - 인덱스는 where 에서 자주 사용되고 수정빈도가 낮으며 카디널리티가 높은 컬럼을 선택하는 것이 좋습니다. 카디널리티가 높다는 것은 중복된 데이터가 적다는 뜻입니다.

            - 인덱스의 갯수에 한계가 있다면 적절한 인덱스 컬럼을 정하는 것도 중요
            - 인덱스는 카디널리티 (Cardinality) 가 높은 컬럼에 지정하는 게 좋습니다.
            - 카디널리티가 높다는 말은 데이터의 중복이 적다는 뜻인데 대표적으로 ID, 주민번호 등이 있습니다.
            - 반대로 성별 같은 중복된 데이터가 많은 경우 카디널리티가 낮다고 표현
            - 성별에 인덱스를 거는 경우 인덱스를 타더라도 남/녀 두가지만 존재하기 때문에 결국 나머지 조건에 맞는 데이터는 직접 풀스캔을 해서 찾아야 합니다.
            - 하지만 ID 같이 중복된 값이 없는 경우 해당하는 데이터를 빠르게 찾을 수 있습니다.

        - 읽어야 하는 레코드 갯수
            - 인덱스는 일반적으로 단 하나의 데이터를 구할 때 가장 효율적
            - 여러 개의 데이터를 구한다면 인덱스를 통해 레코드의 주소를 찾아 데이터의 레코드를 읽는 작업을 반복해야 합니다.
            - 그래서 만약 많은 레코드를 한번에 조회한다면 오히려 인덱스를 사용하지 않고 직접 테이블을 읽는 것이 더 효율적일 수 있습니다.
            - 일반적으로 DBMS 의 옵티마이저는 인덱스를 사용해 레코드 1건을 읽는 것이 테이블에서 직접 읽는 것보다 4 ~ 5배 정도 비용이 더 많이 든다고 예측
            - 그러므로 인덱스를 통해 읽어야 할 레코드가 전체 테이블의 20 ~ 25% 이상이라면 직접 테이블을 읽는 것이 효율적

        - 복합 인덱스를 구성할 때
            - 인덱스는 여러 개의 컬럼을 동시에 지정할 수도 있는데 어떤 순서로 구성하느냐에 따라 성능이 달라집니다.
            - 인덱스는 트리 구조로 되어있다고 했는데, 여러 개의 컬럼을 함께 키 값으로 지정하는 경우 먼저 첫 번재 컬럼을 기준으로 정렬된 뒤에 두번째 컬럼이 정렬되어 있습니다.
            - 이 말은 즉 첫 번째 컬럼 없이 두 번째 컬럼만 갖고 인덱스를 조회하면 제대로 된 위치를 찾을 수 없다는 뜻
            - 그러므로 복합 인덱스를 구성했다면 조회할 때 앞 순서의 조건을 반드시 포함해야 인덱스를 태울 수 있습니다.
            - 여러 개의 컬럼이 있다면 카디널리티가 높은 순에서 낮은 순으로 지정하는게 인덱스의 효율을 이끌어낼 수 있습니다.
            - 과거에는 인덱스의 컬럼 순서와 조회 컬럼 순서를 맞춰야 인덱스를 탔지만 최근에는 옵티마이저가 알아서 인덱스 순서에 맞춰주기 때문에 거의 차이가 없습니다.
            - 그래도 재배열하는 과정을 생략하기 위해 최대한 맞추는게 좋다.

            - 단일 컬럼 인덱스보다 더 비효율적으로 Insert/Update/Delete 를 수행하므로 가급적 업데이트가 안 되는 값을 선정해서 사용하는 것이 좋다.
            - 데이터를 조회할 때 단일 인덱스를 여러 개를 사용해야 하는 경우가 많다면 다중 컬럼 인덱스를 고려해 본다.

        - 인덱스(Index)의 단점
            인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지 시켜줘야 한다는 점입니다.
            INSERT, UPDATE, DELETE 를 통해 데이터가 추가되거나 값이 바뀐다면 INDEX 테이블 내에 있는 값들을 다시
            정렬을 해야겠죠. 그리고 INDEX 테이블, 원본 테이블 이렇게 두 군데에 데이터 수정 작업해줘야 한다는 단점도 있습니다.
            그리고 검색시에도 인덱스가 무조건 좋은 것이 아닙니다. 인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를
            처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫습니다. 그리고 인덱스를
            관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요합니다. 무턱대고 INDEX 를
            만들어서는 결코 안 될 말입니다.

            UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해준다.
            만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어,
            SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.

        - 인덱스(Index)의 관리
            앞서 설명했듯이 인덱스는 항상 최신의 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다.
            그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE 가 수행된다면 계속 정렬을 해주어야 하고 그에
            따른 부하가 발생합니다. 이런 부하를 최소화하기 위해 인덱스는 데이터 삭제라는 개념에서 인덱스를 사용하지 않는다
            라는 작업으로 이를 대신합니다.
            INSERT: 새로운 데이터에 대한 인덱스를 추가합니다.
            DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행합니다.
            UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가합니다.

        - 인덱스 생성 전략
            생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는
            컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된
            Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를
            거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이
            인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.
                1. 조건절에 자주 등장하는 컬럼
                2. 항상 = 으로 비교되는 컬럼
                3. 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은) 컬럼
                4. ORDER BY 절에서 자주 사용되는 컬럼
                5. 조인 조건으로 자주 사용되는 컬럼

        -> 일반적으로 DBMS 의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도
           비용이 드는 작업. 즉, 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 사용하지 않고
           일반 테이블 검색하는 것이 좋다.

    - 인덱스 사용 시 주의사항
        - 다중 인덱스를 사용할 때 범위 조건은 인덱스를 타지만 이후 컬럼들은 인덱스를 타지 않음
            WHERE 컬럼1 = ?
            AND   컬럼2 = ?
            AND   컬럼3 BETWEEN ? AND ? -- 결합인덱스에서 '='이 아닌 연산자를 사용하는 첫 번째
            AND   컬럼4 = ?

            컬럼3에서 BETWEEN을 사용했기에 컬럼3 까지만 인덱스를 타고 후행컬럼인 컬럼4는 인덱스를 타지 않고 필터만 한다.
            그래서 결합인덱스 = 컬럼1 + 컬럼2 + 컬럼4 + 컬럼3으로 순서를 바꿔줘야한다.

        - 인덱스를 타지 않는 경우
            1. 인덱스 컬럼의 변형
                - 인덱스에 변형을 가하게 되면, DBMS가 인덱스를 이용하지 않는다.
                - 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 range scan 가능
                  인덱스 칼럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문
                  그래서 인덱스 칼럼을 가공하면 index full scan 을 하게 된다.
            2. 부정형의 사용
                - NOT일 경우 무조건 인덱스를 안타는 것이 아니라 일반적으로 NOT에 사용된 값이 아닌 데이터 비율이 높은 경우가 많기 때문에 인덱스를 타지 않는다.
            3. IN 연산자 사용
                - IN일 경우에도, IN에 포함된 데이터들의 비율이 매우 높다면 FULL SCAN을 하는 것이 낫다고 DBMS가 판단하면 인덱스를 타지 않는다.
                - Mysql에서는 range_optimizer_max_mem_size 설정의 용량을 In절의 파라미터가 넘어서면 FullScan을 한다.
                  다른 DB의 경우도 파라미터가 많아지면 옵티마이저가 FullScan을 할 수 있다.
                - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.
                  하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능
            4. LIKE문을 사용할 때 전체 범위를 설정할 시
                - 문자열로 이루어진 값을 인덱스로 잡았을 때, %가 앞쪽에 사용되면 정렬 순서를 사용할 수 없으므로 테이블 FULL SCAN이 이루어진다.
                  select * from table  where name like 'word%'; -> 쿼리가 이런 경우 인덱스를 탄다. 문자열 정렬 순서를 그대로 이용할 수 있기 때문이다. (Index Range Scan 이 가능)
                  인덱스를 걸면 해당 컬럼은 정렬이 됩니다. 정렬된 문자열 앞부분부터 검색해야 하는데, LIKE절이 '%'로 시작하면 앞 문자열을 모르니 인덱스를 사용할 수 없게 됩니다.

                - 정규표현식 REGEXP 을 사용해도 인덱스를 더치지 않고 풀 스캔이 일어난다.
                - 가능하면 INSTR 을 사용하는 것도 나쁘지 않다. INSTR('비교할 대상', '비교하고자 하는 값', 비교를 시작할 위치, 검색된 결과의 순번)
                  select * from table where INSTR(column_name, value) > 0  ???
            5. 복합인덱스에서 첫인덱스가 첫조건으로 적용하지 않았을경우
                - select * from table where name = 'word' or idx = 5
                - name과 idx가 둘다 인덱스가 걸려있는 경우라해도, DBMS가 최적의 OR 조건을 뽑기 힘들어, FULL SCAN 하는 경우가 많다.
            6. NULL 조건의 사용
            7. 인덱스 컬럼의 내부적인 데이터 변환
                - 문자값 데이터타입을 갖는 컬럼에 ‘값’ → 값 을 하지 말고 정확한 데이터 타입을 넣어야 인덱스를 탈 수 있다.
            8. OR 조건 사용
                - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

        - Full Table Scan 적용되는 경우
            - 적용 가능한 인덱스가 없는 경우
            - 인덱스 처리 범위가 넓은 경우
            - 크기가 작은 테이블에 엑세스하는 경우
                -> 데이터베이스가 인덱스를 적용해도 성능상의 이점이 없다고 판단했을 때 Full Table Scan 적용

    - 인덱스 튜닝
        1) 인덱스 스캔 효율화 튜닝
            - 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것
            - 인덱스 엑세스 조건(수직적 탐색 ,수평적 탐색)

        2) 랜덤엑세스 최소화 튜닝 (테이블의 엑세스 횟수를 줄이는 것)
            - 인덱스 스캔 후 테이블 레코드를 엑세스 할 때 랜덤 I/O 방식으로 사용하므로 이를 랜덤 액세스 최소화 튜닝이라고함.

    - 인덱스 구조
        - 범위 스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문
        - 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있음
            - 인덱스 수직적 탐색(인덱스 스캔 시작지점을 찾는 과정)
                정렬된 인덱스 레코드 중 조건을 만족하는 첫번째 레코드를 찾는 과정이다. 즉 인덱스 스캔 시작 지점을 찾는 과정
            - 인덱스 수평적 탐색(데이터를 찾는 과정)
                수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔함
                인덱스를 수평적으로 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾기위해  Rowid를 얻기 위해

    - 인덱스 기본 사용법
        - Range Scan을 못 쓰는 경우
            - 인덱스 가공
                - 인덱스 스캔 시작점을 찾을 수 없기 때문이다. 일정 범위를 스캔하려면 ‘시작지점’과 ‘끝지점’이 있어야 한다.

            - Like 문을 사용
                ex) where 업체명 like '%대한%'
                - LIKE로 검색해도 위와 같이 ‘대한’이라는 글자를 가진 인덱스를 중간 글씨에서 찾아야 하기 때문에, Range Scan이 불가능하다.

            - OR 조건
                - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

            - IN 조건
                - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.

    - 인덱스 사용조건
        - range scan을 하기 위해선 가장 첫번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다.
          반대로 말하면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 range scan이 무조건 가능하다.

    - 인덱스를 이용한 소트 연산 생략
        - 인덱스 순으로 이미 정렬된 상태로 order by를 했다. 이것은 order by를 생략할 수 있다.
        - 만약 이렇게 인덱스가 구성되어있지 않다면 SORT ORDER BY 연산이 실행계획에 추가된다.
        - 조건절 뿐만 아니라 ORDER BY절이나 SELECT-LIST 에서 컬럼을 가공하여 인덱스를 정상적으로 못 사용하는 경우가 있다.
            - SELECT-LIST 에서 컬럼 가공
                select NVL(MAX(TO_NUMBER(변경순번)), 0)
                from 상태변경이력
                where 장비번호 = 'C'
                    and 변경일자 = '20180316'

                위와 같이 ‘변경순번’의 값을 숫자로 바꾸면 인덱스를 사용할 수 없다.
                왜냐면 인덱스는 문자열 기준으로 정렬되어 있는데 숫자값으로 바꾸었기 때문이다.

            - 자동 형변환
                select * from 고객 where 생년월일 = 19920920

                -- 이걸 옵티마이저가 이렇게 바꿈
                select * from 고객 where TO_NUMBER(생년월일) = 19920920

                - DBMS마다 다른데 오라클은 자동 형변환 하는 방식을 채택한다.
                - 형변환 우선순위
                    - 오라클에서 숫자형과 문자형이 만나면 숫자형이 이긴다.
                    - 날짜형과 문자형이 만나면 날짜형이 이긴다.
                    - 근데 LIKE가 출동하면 문자형이 이긴다.

    - 인덱스 스캔 방법
        - Index Range Scan
            - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 엑세스 방식
            - 수직적 탐색 후 필요함 범위(Range)만 수평적 탐색
            - 인덱스 스캔 범위와 테이블 액세스 횟수를 줄이는 것이 성능 향상의 길

            - 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
            - B-tree 인덱스에서 루트 노드와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로 인덱스를 읽어 나간다.
            - 리프 노드에서 저장된 레코드 주소로 데이터 파일의 레코드를 읽어 오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 발생한다.
            - 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%를 넘으면 순차 I/O를 사용한 테이블 풀 스캔이 낫다고 하는 것이다.

        - Index Full Scan
            - 수직적 탐색 없이 오직 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
            - 최적의 인덱스가 없을때, 차선으로 선택된다.

            - 선두 컬럼이 조건절에 없으면 옵티마이저가 Index Full Scan을 고려한다.
            - 만약 테이블이 고용량이면 인덱스 활용을 고려하지 않을 수 있다.
            - 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면, 면적이 큰 테이블보다 인덱스를 스캔하는 쪽이 유리하다.

            - 인덱스의 처음부터 끝까지 모두 읽는 방식
            - 쿼리의 조건절에 사용된 칼럼이 첫 번째 칼럼이 아닌 경우 사용된다.
                ex) 인덱스 (a,b,c) 칼럼의 순서로 만들어져 있지만, 쿼리의 조건절은 b 칼럼이나 c 칼럼으로 검색
            - 루트 노드의 첫 번째 인덱스 레코드와 이어진 브랜치 노드를 거쳐 리프 노드로 이동한다.
            - 해당 리프 노드의 첫 번째 페이지의 인덱스 레코드 방향부터 아래로 탐색한다.
            - 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 작은 경우가 많으므로 풀 테이블 스캔보다 적은 IO 로 쿼리를 처리할 수 있다.

        - Index Unique Scan
            - 수직적 탐색으로만 데이터를 찾는 방식으로, Unique 인덱스를 = (equal) 조건으로 탐색하는 경우
            - Unique 인덱스가 존재하는 컬럼은 중복값 없이 입력되지 않게 DBMS가 정합성 관리해준다. 그래서 데이터를 = 조건으로 찾은 후 더이상 탐색이 필요없다.
                - Unique 인덱스가 존재해도 Between, Like 등 범위 조건으로 검색하면 Index Range Scan을 한다.
                - Unique 결합 인덱스도 검색 할 때, Index Range Scan을 사용한다.

        - Index Skip Scan
            - 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 Index Skip Scan을 사용한다.
            - Index Skip Scan은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 갯수가 많을때 유용하다.
            - 선두 컬럼이 조건절에 있고, 중간 컬럼이 조건절에 없어도 Index Skip Scan을 사용할 수 있다.
            - Distinct Value 개수가 적은 두 개의 선두컬럼이 다 조건절에 없어도 Index Skip Scan 사용할 수 있다.
            - 선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위 검색 조건일때도 Index Skip Scan 사용할 수 있다.
            - 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 한다.
              만약 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때, 이들 스캔 방식을 차선책으로 활용하는 전략이 바람직하다.

            - 루스 인덱스 스캔 ??
                - 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
                - 인덱스 레인지 스캔과 비슷하게 동작하지만 중간마다 필요하지 않은 키 값은 무시한다.
                - 일반적으로 group by 또는 max 등의 함수에 대해 최적화할 때 사용한다.
                ex) select dept_no, MIN(emp_no)
                    from dept_emp
                    where dept_no between 'doo2' and 'd004'
                    group by dept_no;

                    dept_emp 테이블은 dept_no와 emp_no 2개의 컬럼으로 인덱스를 구성하고 있다고 가정하며, 이 인덱스는 (dept_no, emp_no)를
                    기준으로 정렬이 되어 있다. 즉 특정 dept_no 그룹 별로 처음에 있는 emp_no만 읽으면 된다. 즉, 인덱스에서 where 조건을
                    만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있으므로 중간 중간 조건에 맞지 않으면 건너 뛴다.

        - Index Fast Full Scan
            - Index Fast Full Scan은 Index Full Scan보다 빠르다.
            - 그 이유는, 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문이다.
            - Index Fast Full Scan은 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다.
            - 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과 발휘한다.
            - 인덱스 키 순서대로 정렬되지 않다. (연결 리스트 구조를 무시해서 결과집합이 인덱스 키 순서대로 정렬되지 않음)
            - 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때 사용 가능함.
            - 병렬스캔 가능

        - Index Range Scan Descending
            - Index Range Scan과 기본적으로 동일 스캔방식이나, 인덱스를 뒤에서 앞으로 스캔하기 때문에 내림차순으로 결과집합을 얻는다.

    - Covering Index
        - 인덱스를 사용하면 특정 컬럼 값을 키로 하여 데이터의 주소값을 구한 뒤 해당 주소값으로 다시 테이블에 접근해서 최종 데이터를 구합니다.
        - 커버링 인덱스란 인덱스에 이미 필요한 데이터가 전부 존재해서 테이블에 접근할 필요가 없는 인덱스를 의미
        - 인덱스는 기본적으로 Non Clustered Index 에서 먼저 값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.
        - 여기서 커버링 인덱스가 사용되었다는건 Clustered Index 까지 통하지 않고 Non Clustered Index 만으로도 데이터를 구할 수 있다는 뜻
        - 커버링 인덱스가 적용되면 EXPLAIN 실행 시 Extra 필드에 Using index 라고 표시

    - 결합 인덱스란
        - 결합 인덱스란?
            결합 인덱스란 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말합니다. 주로 단일 컬럼으로는 나쁜 분포도를 가지지만
            여러 개의 컬럼을 합친다면 좋은 분포도를 가지고,
            Where 절에서 AND 조건에 많이 사용되는 컬럼들을 결합 인덱스로 구성합니다.
            1. where 절에서 and 조건으로 자주 결합되어 사용되면서 각각의 분포도 보다
               두 개 이상의 컬럼이 결합될 때 분포도가 좋아지는 컬럼들
            2. 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
            3. order by 에서 자주 사용되는 컬럼들
            4. 하나 이상의 키 컬럼 조건으로 같은 테이블의 컬럼들이 자주 조회될 때

        - 결합 인덱스의 컬럼 순서 결정
            결합 인덱스를 만들 때 결합 인덱스를 구성하는 컬럼들의 배열 순서는 아주 중요하기에 신중하게 결정하여야 합니다.
            컬럼의 순서를 잘못 배열하면 결합 인덱스의 발동 확률이 매우 낮아질 수 있기 때문입니다. 만약 select 문의
            where 절에 결합 인덱스의 첫 번째 컬럼을 조건에 사용하였다면 그 질의문은 결합 인덱스를 사용할 수 있습니다.
            하지만 개발자가 결합 인덱스의 두번째 컬럼만을 where 절에 조건으로 사용하고 결합 인덱스를 사용하고자 했다면
            실행계획은 인덱스를 사용하지 못합니다. 따라서 쿼리문 작성 시 결합 인덱스를 사용하고자 한다면 반드시 결합 인덱스의
            컬럼 중 선행하는 컬럼부터 조건에 지정하여 사용하여야 합니다. 조건은 컬럼 전체를 순서대로 사용할 수도 있고,
            아니면 선행하는 일부 컬럼을 순서대로 사용할 수 있습니다.

        - 결합 인덱스 컬럼의 설정 시 고려해야 할 우선순위
            1. where 절 조건에 많이 사용되는 컬럼이 우선시
            2. Equal('=')로 사용되는 컬럼 우선
            3. 분포도가 좋은 컬럼을 우선
            4. 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정

        - 결합 인덱스의 효율성이 떨어지는 경우
            결합 인덱스도 일반적인 인덱스와 마찬가지로 데이터들이 정렬되어 보관되기 때문에 소수의 데이터를 빠르게 찾는 것에는
            유리하지만 아래와 같이 스캔이 많이 생기게 된다면 효율성이 떨어지게 됩니다.

            아래의 예시들은 emp_pay_idx 인덱스를 사용하기는 하지만 스캔이 많이 생기는 경우로 인덱스의 효율성이
            떨어지는 경우들의 예시입니다.

            select * from emp_pay where 급여년월 LIKE '2021%' and 급여코드 = '정기급여';
            위 조건절의 경우 결합 인덱스의 첫 번째 컬럼인 급여년월의 조건이 있더라도 Equal(=)이 아닌 범위 연산자인
            LIKE '2021%' 조건을 사용했으므로, 세개의 칼럼이 모두 필요한 emp_pay_idx 인덱스를 찾을 때 두번째 칼럼인
            급여코드에 대한 조건을 B*Tree 에서 쉽게 찾을수가 없게 됩니다. 이는 결합 인덱스가 각 칼럼별로 정렬이 되어 있는
            것이 아니라 첫번째, 두번째, 세번째 칼럼이 결합이 되어 정렬이 되어있기 때문입니다. 이때 급여코드에 대한 조건은
            인덱스를 찾아가는 검색조건이 아니라 인덱스 값이 조건에 맞는지 여부를 검증하는 체크 조건이 됩니다.

            select * from emp_pay where 급여년월 = '202107' and 사원번호 = '20210401';
            위 조건절의 경우는 결합 인덱스의 첫번째 칼럼인 급여년월의 조건이 equal(=)이더라도 두번째 컬럼인 급여코드에
            대한 조건이 없으므로 세번째 칼럼인 사원번호 조건을 검색 조건이 아닌 체크 조건으로 밖에 사용할 수 없게 됩니다.
            즉 결합 인덱스에서 급여년월인 모든 데이터를 찾아서 사원번호 조건에 맞는지 일일이 확인하는
            풀 테이블 스캔이 일어나고 있는 셈입니다.

    - 인덱스를 리빌드하는 이유
        인덱스 파일은 생성 후 insert, update, delete 등을 반복하다보면 성능이 저하됩니다. 생성된 인덱스는
        트리구조를 가집니다. 삽입,수정,삭제등이 오랫동안 일어나다보면 트리의 한쪽이 무거워져 전체적으로 트리의 깊이가
        깊어집니다. 이러한 현상으로 인해 인덱스의 검색속도가 떨어지므로 주기적으로 리빌딩하는 작업을 거치는것이 좋습니다.

        SELECT I.TABLESPACE_NAME,I.TABLE_NAME,I.INDEX_NAME, I.BLEVEL,
               DECODE(SIGN(NVL(I.BLEVEL,99)-3),1,DECODE(NVL(I.BLEVEL,99),99,'?','Rebuild'),'Check') CNF
        FROM   USER_INDEXES I
        WHERE   I.BLEVEL > 4
        ORDER BY I.BLEVEL DESC

        해당쿼리는 index 트리의 깊이가 4이상인 index  를 조회하는 쿼리입니다.
        해당 쿼리문을 실행하여 검색되는 index 가 있다면 리빌딩을 하는것이 좋습니다.

    - 인덱스(Index)를 남발하지 말아야 하는 이유
        개발을 진행할 때에 대개 개발서버와 운영서버를 나누어서 관리합니다. 대부분 개발서버에서 개발을 할때에는 적은량의
        데이터를 가지고 로직검사를 하며 로직검사에 통과한 코드들이 운영서버에 업데이트가 되죠. 하지만 개발서버에는 잘 동작하던
        로직들이 운영서버의 많은량의 데이터들을 처리하다보면 성능이슈가 많이 발생합니다. 그 성능이슈의 주요원인은
        바로 데이터베이스에 있습니다. 데이터베이스 관리자는 성능문제가 발생하면 가장 빨리 생각하는
        해결책이 인덱스 추가 생성입니다.

        하지만 문제를 그저 쉽게 해결하기 위해 쿼리 속도 문제가 날때마다 인덱스를 추가하는것은 바람직하지 못합니다.
        성능 이슈가 나서 인덱스를 만들고 또 다른 SQL 문에서 성능이슈가 발생하여 또 인덱스를 만들었다고 합시다.
        이렇게 문제가 발생할때마다 인덱스를 생성하면서 인덱스가 계속 추가되면 생성된 인덱스를 참조하는 하나의 쿼리문을
        빠르게는 만들 수 있지만 전체적인 데이터베이스의 성능 부하를 초래합니다. 그렇기에 인덱스를 생성하는것 보다는
        SQL 문을 좀 더 효율적으로 짜는 방향으로 나가야합니다. 인덱스 생성은 꼭 마지막 수단으로 강구해야 할 문제입니다.

    - 인덱스 설계과정
        SQL별 접근경로조사 : 개발된 모든 SQL확인, 조건, 형변환등확인 표로정리
        테이블별 접근 경로 정리 : 테이블별 조인 조건 확인
        종합적인 인덱스 설계
        핵심 테이블 및 핵심 SQL 집중 설계
        인덱스 생성 및 모니터링 : 생성 후에 모니터링을 통한 개선 필요.