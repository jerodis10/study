- 인덱스란?
    인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
    특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
    디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
    인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.


- 인덱스(Index)를 사용하는 이유
    인덱스를 사용하면 데이터들이 정렬되어 저장되기 때문에 조건 검색시 빠르게 찾을 수 있다.

    - 조건 검색 Where 절의 효율성
        인덱스를 사용하지 않으면 조건 검색 (WHERE) 시에 풀 테이블 스캔해야 한다.
        인덱스를 사용하면 데이터들이 정렬되어 저장되기 때문에 조건 검색시 빠르게 찾을 수 있다.

    - 정렬 Order by 절의 효율성
        인덱스를 사용하면 ORDER BY에 의한 SORT 과정을 생략할 수 있다.
        ORDER BY 작업은 1차적으로 메모리에서 정렬을 하고, 메모리보다 큰 작업은 디스크 I/O를 통해 정렬을 하는 무거운 작업이다.

    - MIN, MAX 의 효율적인 처리가 가능하다.
        MAX 작업시 레코드의 끝 값을 가져오면 되고, MIN 작업시 레코드의 시작 값을 가져오면 된다.
        풀 테이블 스캔 과정이 필요 없다.
        인덱스가 걸려있는 컬럼을 MIN, MAX를 쓰면 INDEX_ASC, INDEX_DESC 테이블 힌트를 사용하지 않아도 자동으로 인덱스를 사용한다. ??


- Index를 사용하면 좋은 경우
    - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
    - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
    - 데이터의 중복도가 낮은 컬럼
    - 필드에 저장된 값을 찾는 작업이 예상되는 경우
    - 필드의 값을 정렬하는 작업이 예상되는 경우


- 인덱스의 자료구조가 B- TREE 인 이유
    - 탐색시간이 제일 빠른 해시 테이블을 DB 인덱스로 사용할 수 없는 이유
        해시 충돌 등으로 최악의 경우에 O(N)이 될 수 있지만, 평균적으로는 O(1)
        해시 테이블은 분명 한 가지 키에 대한 탐색은 효율적입니다.
        하지만 데이터가 정렬되어 있지 않기 때문에 부등호 (<, >) 를 사용하지 못한다는 단점이 있습니다.

    - 그러면 탐색이 O(logN)인 다른 자료구조나 알고리즘은 왜 사용하지 못하는 것일까?
        같은 밸런스 트리 종류임에도 RedBlack-Tree는 DB 인덱스로 선택받지 못한 이유 RedBlack-Tree와 B-Tree의 가장 큰 차이는
        '하나의 노드가 가지는 데이터 개수'이다.
        RedBlack-Tree는 무조건 하나의 노드에 하나의 데이터 요소만을, B-Tree는 하나의 노드에 여러 개의 데이터 요소를 저장한다.
        Leaf 노드(데이터 노드)들은 LinkedList로 연결되어있다.
        >, <(부등호) 연산을 이용한 순차 검색 연산이 잦으므로 BTree의 Leaf 노드들을 LinkedList로 연결하여 순차 검색에 용이하게 바꾸었다.
        같은 노드 공간의 데이터들끼리 굳이 자식 노드처럼 참조 포인터 값으로 접근할 필요가 없다.
        실제 메모리 디스크에서 바로 다음 인덱스의 접근을 하는 것 노드에서 배열 형태로 여러 데이터를 저장할 수 있기 때문에
        트리 포인터를 참조해서 계속 depth 를 타고 들어가는 것보다 효율적이고 이는 데이터가 많아질수록 차이가 두드러집니다.

    - 모든 면으로 DB 인덱스 용도로 가장 적합한 자료구조인 B-Tree
        - 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
        - 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.
        - 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.
        - 인덱스도 크기가 커져 보조 기억 장치에 저장되게 되는데 이 또한 디스크 I/O가 발생하게 되는 것이다.
          따라서 B-Tree의 깊이를 줄여야 디스크 I/O를 줄일 수 있기 때문에 B-Tree를 사용한다.


- 인덱스 자료구조 (B * Tree 인덱스)
    구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node 로 구성됩니다. 특정 컬럼에 인덱스를 생성하는
    순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT 블록을
    기준으로 가지가 되는 BRANCH 블록을 정의하며 마지막으로 잎에 해당하는 LEAF 블록에 인덱스의 키가 되는
    데이터와 데이터의 물리적 주소 정보인 ROWID 를 저장합니다.

    일반적으로 B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
    그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.


- 인덱스 종류
    - Clustered Index
        - 실제 데이터와 무리(cluster)를 지어 인덱싱 되므로 클러스터형 인덱스라고 부른다.
        - PK를 기준으로 유사한 값들이 함께 조회되는 경우가 많다는 점에서 착안하여, PK가 유사한 레코드들끼리 묶어서 저장한다.
          유사한 것들을 묶는 것을 클러스터링이라고 하는데, 그래서 일반적으로 PK는 클러스터 인덱스(Clustered Index)라고도 불리며,
          그 외의 일반적인 인덱스는 논클러스터 인덱스로 불린다.
        - PK 설정 시 자동으로 클러스터 인덱스로 만들어짐
        - 테이블당 1개씩만 허용
        - 데이터 페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
        - Non Clustered 인덱스에 비해 조회 속도가 빠르지만 삽입/수정/삭제는 더 느림
        - 30% 이내에서 사용해야 좋은 선택도를 가진다.

        - 장점
            - PK로 검색할 때 처리가 매우 빠름
            - 연속되는 PK로 조회할 경우 랜덤 I/O가 아닌 순차 I/O를 사용하여 처리 속도가 더욱 빠름
            - 인덱스가 PK값을 가지므로 인덱스로 PK 값만 조회하는 경우 효율적으로 처리될 수 있음(=커버링 인덱스)
        - 단점
            - 모든 인덱스가 PK에 의존하므로 PK 값이 클 경우 전체적으로 인덱스의 크기가 커지고, 페이지 양이 많아짐
            - 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림
            - INSERT 시에 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
            - PK를 변경할 때 레코드를 DELETE 및 INSERT 해야 하므로 처리 성능이 느림

        먼저 PK는 물리적인 저장 위치를 저장한다.
        그래서 PK로 검색 시에 처리가 매우 빠르며, 특히 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데,
        랜덤 I/O는 임의의 장소에서 데이터를 가져오지만
        순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다. 그 외에도 인덱스가 PK 값을 가지므로,
        인덱스를 통해 PK만 조회하는 경우라면 내부 테이블까지 조회하지 않아도 되므로 효율적으로 처리된다.

        하지만 단점 역시 적지않다. 먼저 PK가 물리적인 저장 위치를 결정하므로 인덱스를 관리할 때 PK를 같이 저장한다. 데이터의 작업 단위는 페이지인데,
        PK가 클수록 다른 인덱스 구조도 커지면서 페이지가 많이 쪼개져 디스크 I/O 횟수가 증가하는 문제가 있다.
        또한 인덱스에 PK가 의존하여 저장되므로 인덱스로 조회 시에 인덱스로 PK를 찾고, PK로 레코드를 찾아야 한다.
        그 외에도 레코드를 INSERT 하거나 PK를 UPDATE 하는 등의 경우에 레코드의 저장 위치를 탐색해야 하므로 추가적인 성능 문제가 생길 수 있다.
        이러한 단점들에도 불구하고 일반적인 온라인 환경에서는 읽기 비중이 훨씬 높다. 그렇기 때문에 쓰기 성능을 희생해서라도 읽기 성능을 확보하는 것이다.

    - Non Clustered Index
        - 데이터 페이지를 건들지 않고, 별도의 장소에 인덱스 페이지를 생성
        - 우선 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬하고 데이터 위치 포인터를 생성한다.
        - 데이터 위치 포인터는 데이터가 위치한 고유한 값이 된다. (리프 페이지 -> 실제 데이터의 주소 페이지)
        - 실제 데이터와 다른 무리의 별도의 인덱스
        - 테이블 자체는 되지 않고, 인덱스 페이지에만 정렬
        - unique 제약조건 적용시 자동 생성
        - 3% 이내에서 사용해야 좋은 선택도를 가진다.


- B-Tree 인덱스의 쿼리별 특징
    트리는 넣는 값에 따라 계속 split과 merge를 통해 트리구조를 계속 변형유지해야 하기 때문입니다.
    또한 이 과정은 동시에 처리될 수 있는 것이 아니기에 병목구간이 될 수 밖에 없습니다.

    - SELECT
        - 특정 키 값을 찾기 위해 자식 노드를 계속 타고 들어가는 방식
        - 마지막 리프 노드에는 레코드의 주소가 존재하고 이 값으로 테이블 레코드를 찾을 수 있음

        - B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
          그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

    - INSERT
        - B-Tree 에 새로운 키 값을 저장할 때는 우선 적절한 위치를 찾아야함
          새로운 키 값과 레코드 정보는 리프 노드에 저장
          만약 리프 노드가 꽉찼다면 트리를 재구성하여 리프 노드를 분리
          분리 과정에서 해당 리프 노드의 부모 노드까지 영향이 갈 수 있음
          이러한 이유로 INSERT 작업은 상대적으로 비용이 많이 듬
          인덱스가 많으면 많을수록 이런 비용이 추가로 들기 때문에 너무 많은 인덱스를 추가하는 건 성능에 영향을 줌

        - 페이지 내부에서 작업될 경우 큰 부담은 없지만, 페이지가 꽉 찰 경우 데이터베이스는 비어 있는 페이지를 확보하고
          문제가 있는 페이지의 데이터를 공평하게 나누어 저장. 이는 데이터베이스에 부담이 되는 작업 (페이지 분할)
        - 페이지 분할
            - 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생
            - DB 가 느려지고 성능에 영향을 준다.

    - DELETE
        - B-Tree 에서 키 값 삭제는 간단
        - 해당 키를 찾아서 삭제 마크만 하면 작업이 완료
        - 삭제 마킹된 인덱스 키 공간은 그대로 두거나 재활용 가능

        - 인덱스의 데이터를 실제로 지우지 않고 사용 안함 표시를 한다.

    - UPDATE
        - 인덱스는 항상 정렬된 상태로 유지됨
          단순히 인덱스 키 값을 수정한다면 트리의 전체 구조를 바꿔야 할 수도 있음
          그래서 B-Tree 에선 키 변경이 아닌 기존 키 삭제 (DELETE) 후 새로운 키 추가 (INSERT) 방식을 사용
          따라서 키 값의 잦은 수정은 성능에 큰 영향을 미침

        - delete (기존 값 사용안함 표시)
        - insert (변경된 값 삽입)

    -> update, delete 의 경우 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다.
       페이지: 데이터가 저장되는 단위 (16 Kbyte)


- 인덱스(Index)의 관리
    인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지 시켜줘야 한다는 점입니다.
    INSERT, UPDATE, DELETE 를 통해 데이터가 추가되거나 값이 바뀐다면 INDEX 테이블 내에 있는 값들을 다시
    정렬을 해야겠죠. 그리고 INDEX 테이블, 원본 테이블 이렇게 두 군데에 데이터 수정 작업해줘야 한다는 단점도 있습니다.
    그리고 검색시에도 인덱스가 무조건 좋은 것이 아닙니다. 인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를
    처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫습니다. 그리고 인덱스를
    관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요합니다. 무턱대고 INDEX 를
    만들어서는 결코 안 될 말입니다.

    UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해준다.
    만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어,
    SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.

    기본적으로 인덱스는 데이터를 삭제하더라도 사용 안함 표시를 해주고 끝이지 실제로 사라지는 것이 아니다.
    또한 update 문을 사용해서 데이터를 수정하는 경우에도 우리 눈에는 그냥 수정만 된 것이지만 내부적으로는 delete 후에
    다시 insert 해주는 로직을 따르고 있다.
    그렇기 때문에 DML 이 자주 일어나는 table 에서는 오히려 인덱스 테이블이 원래 테이블보다 크기가 커지는 경우가 발생하게 되고,
    그렇게 되면 인덱스를 사용하는 의미가 사라진다.


- 인덱스 설정 시 고려사항
    - 인덱스 키 값의 크기
        - 키 값이 클수록 디스크 IO 횟수가 많아져서 성능이 떨어진다. -> 인덱스의 키 값은 작을수록 유리
        - 인덱스 키 값의 크기가 클수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지므로 B-Tree 깊이가 깊어진다.
          깊이가 깊어진다는 것은 디스크 IO 횟수가 많아진다는 것.

    - 인덱스의 갯수
        - 인덱스의 갯수는 3 ~ 4 개가 적당
        - 인덱스의 갯수가 너무 많으면 다음과 같은 이슈가 존재
            - 데이터 삽입/수정/삭제 시마다 인덱스도 같이 추가하거나 수정/삭제 해주어야 해서 성능상 이슈가 존재
            - 데이터 삽입시마다 인덱스도 같이 추가하기 때문에 인덱스가 늘어날수록 더 많은 메모리를 차지함
            - 인덱스가 많아지면 옵티마이저가 잘못된 인덱스를 선택할 확률이 높아짐 (인덱스 힌트로 원하는 인덱스를 지정할 순 있음)

    - 인덱스를 걸기에 적절한 컬럼
        - 인덱스는 where 에서 자주 사용되고 수정 빈도가 낮으며 카디널리티가 높은 컬럼을 선택하는 것이 좋습니다.
          (카디널리티가 높다는 것은 중복된 데이터가 적다는 뜻입니다.)
        - 인덱스의 갯수에 한계가 있다면 적절한 인덱스 컬럼을 정하는 것도 중요
        - 인덱스는 카디널리티 (Cardinality) 가 높은 컬럼에 지정하는 게 좋습니다.

    - 읽어야 하는 레코드 갯수
        - 인덱스는 일반적으로 단 하나의 데이터를 구할 때 가장 효율적
        - 여러 개의 데이터를 구한다면 인덱스를 통해 레코드의 주소를 찾아 데이터의 레코드를 읽는 작업을 반복해야 합니다.
        - 그래서 만약 많은 레코드를 한번에 조회한다면 오히려 인덱스를 사용하지 않고 직접 테이블을 읽는 것이 더 효율적일 수 있습니다.
        - 일반적으로 DBMS 의 옵티마이저는 인덱스를 사용해 레코드 1건을 읽는 것이 테이블에서 직접 읽는 것보다 4 ~ 5배 정도 비용이 더 많이 든다고 예측
        - 그러므로 인덱스를 통해 읽어야 할 레코드가 전체 테이블의 20 ~ 25% 이상이라면 직접 테이블을 읽는 것이 효율적


- 인덱스 생성 전략
    생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는
    컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된
    Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를
    거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이
    인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.
        1. 조건절에 자주 등장하는 컬럼
        2. 항상 = 으로 비교되는 컬럼
        3. 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은) 컬럼
        4. ORDER BY 절에서 자주 사용되는 컬럼
        5. 조인 조건으로 자주 사용되는 컬럼


- 인덱스를 타지 않는 경우
    1. 인덱스 컬럼의 변형
        - 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 range scan 가능.
          인덱스 칼럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문.
          그래서 인덱스 칼럼을 가공하면 index full scan 을 하게 된다.

    2. 부정형의 사용
        - NOT일 경우에도 인덱스를 타긴 타지만, 일반적으로, NOT에 사용된 값이 아닌 데이터의 비율이 높은 경우가 많기 때문에 인덱스를 타지 않는 경우가 많다.

    3. IN 연산자 사용
        - IN일 경우에도, IN에 포함된 데이터들의 비율이 매우 높다면 FULL SCAN을 하는 것이 낫다고 DBMS가 판단하면 인덱스를 타지 않는다.
          Mysql에서는 range_optimizer_max_mem_size 설정의 용량을 In절의 파라미터가 넘어서면 FullScan을 한다.
          다른 DB의 경우도 파라미터가 많아지면 옵티마이저가 FullScan을 할 수 있다.

    4. LIKE문을 사용할 때 전체 범위를 설정할 시
        - 문자열로 이루어진 값을 인덱스로 잡았을 때, %가 앞쪽에 사용되면 정렬 순서를 사용할 수 없으므로 테이블 FULL SCAN이 이루어진다.
          select * from table  where name like 'word%'; -> 쿼리가 이런 경우 인덱스를 탄다. 문자열 정렬 순서를 그대로 이용할 수 있기 때문이다. (Index Range Scan 이 가능)
          인덱스를 걸면 해당 컬럼은 정렬이 됩니다. 정렬된 문자열 앞부분부터 검색해야 하는데, LIKE절이 '%'로 시작하면 앞 문자열을 모르니 인덱스를 사용할 수 없게 됩니다.

    5. 복합인덱스에서 첫 인덱스가 첫 조건으로 적용하지 않았을 경우

    6. NULL 조건의 사용
        오라클에서는 NULL 값을 인덱스에 저장하지 않는다.    https://kihyun-log.tistory.com/entry/NULLABLE-%EC%BB%AC%EB%9F%BC%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%82%AC%EC%9A%A9-Oracle-vs-MySQL
        따라서 오라클에서는 NULL 이 허용된 컬럼에 대해 인덱스를 생성해도
        IS NULL 혹은 IS NOT NULL 조건으로 조회시 인덱스를 사용할 수 없다.
        (NULL이 있는지 없는지 FULL SCAN을 해야만 알 수 있으므로)

        하지만 MySQL/Maria 에서는 NULL 값도 인덱스에 저장한다.
        따라서 컬럼을 IS NULL 혹은 IS NOT NULL로 비교해서 인덱스를 사용할 수 있다.

    7. 인덱스 컬럼의 내부적인 데이터 변환
        - 문자값 데이터타입을 갖는 컬럼에 ‘값’ → 값 을 하지 말고 정확한 데이터 타입을 넣어야 인덱스를 탈 수 있다.
        - 서로 대입되는 항목끼리 데이터 타입이 다르면 내부적인 형 변환에 의해 컬럼이 함수를 사용한 것과 같은 효과를 나타낸다.

    8. OR 조건 사용
        - OR 연산자의 경우에는 다릅니다. 앞 조건이 어떻든 간에 뒷 조건도 확인을 해야합니다. 어차피 뒷 조건도 확인할꺼라면
          (풀 테이블 스캔) + (인덱스 레인지 스캔)보다 (풀 테이블 스캔) 1번이 더 빠르기 때문에 인덱스를 사용하지 않고 전체 조회를 하게 되는 것입니다.
        - OR 연산자를 사용하면 OR 연산자에 관계된 모든 컬럼이 복합키로 설정되어 있지 않다면 인덱스를 사용하지 않습니다.


- Full Table Scan 적용되는 경우
    - 적용 가능한 인덱스가 없는 경우
    - 인덱스 처리 범위가 넓은 경우
    - 크기가 작은 테이블에 엑세스하는 경우
        -> 데이터베이스가 인덱스를 적용해도 성능상의 이점이 없다고 판단했을 때 Full Table Scan 적용


- 인덱스 튜닝
    1) 인덱스 스캔 효율화 튜닝
        - 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것
        - 인덱스 엑세스 조건(수직적 탐색 ,수평적 탐색)

    2) 랜덤엑세스 최소화 튜닝 (테이블의 엑세스 횟수를 줄이는 것)
        - 인덱스 스캔 후 테이블 레코드를 엑세스 할 때 랜덤 I/O 방식으로 사용하므로 이를 랜덤 액세스 최소화 튜닝이라고함.


- 인덱스 구조
    - 범위 스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문
    - 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있음
        - 인덱스 수직적 탐색(인덱스 스캔 시작지점을 찾는 과정)
            정렬된 인덱스 레코드 중 조건을 만족하는 첫번째 레코드를 찾는 과정이다. 즉 인덱스 스캔 시작 지점을 찾는 과정
        - 인덱스 수평적 탐색(데이터를 찾는 과정)
            수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔함
            인덱스를 수평적으로 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾기위해  Rowid를 얻기 위해


- 인덱스 스캔 방법   https://velog.io/@tothek/%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B8%B0%EB%B3%B8-INDEX-SCAN%EC%A2%85%EB%A5%98
    - INDEX RANGE SCAN
        - 수직적 탐색 후 필요함 범위(Range)만 수평적 탐색

    - INDEX FULL SCAN
        - 수직탐색 없이 리프블록 처음부터 끝까지 수평적으로 탐색하는 방식
        - 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택
        - 마땅한 인덱스가없을때 조건절에서 필터후의 데이터량이 소량이라면
          인덱스풀스캔후 필터된 데이터를 대상으로 테이블에 엑세스하는것이 효율적

    - INDEX UNIQUE SCAN
        - 수직적 탐색만으로 데이터를 찾는 방식
        - 동치(=)조건으로 탐색하는 경우에 작동
        - UNIQUE INDEX라해도 범위검색조건 (BETWEEN, 부등호, LIKE)로 검색할때는 IDNEX RANGE SCAN으로 처리된다.

    - INDEX SKIP SCAN
        - 인덱스 선두 컬럼을 조건절에 사용하지 않으면 옵티마이저는 기본적으로 TABLE FULL SCAN을선택
        - TABLE FULL SCAN보다 I/O를 줄이거나 정렬된 결과를 쉽게 얻을 수 있다면 INDEX FULL SCAN 사용
        - 인덱스 skip scan이 작동하기 위한 조건
            - 선두컬럼에 대한 조건절은 있고, 중간컬럼에 대한 조건이 없는 경우에도 SKIP SCAN 사용할 수 있다.
            - 선두컬럼이 부등호, BETWEEN, LIKE같은 범위검색 조건일 때도 SKIP SCAN 사용 가능.

    - INDEX FAST FULL SCAN
        - 논리적 인덱스 트리구조를 무시하고 인덱스 세그먼트 전체를 MULTIBLOCK I/O 방식으로 스캔
        - 디스크로 부터 대량의 인덱스블록을 읽어야할 때 큰 효과를 발휘
        - 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을때만 사용 가능


- Covering Index ?? (내용 보충)
    - 인덱스를 사용하면 특정 컬럼 값을 키로 하여 데이터의 주소값을 구한 뒤 해당 주소값으로 다시 테이블에 접근해서 최종 데이터를 구합니다.
    - 커버링 인덱스란 인덱스에 이미 필요한 데이터가 전부 존재해서 테이블에 접근할 필요가 없는 인덱스를 의미
    - 인덱스는 기본적으로 Non Clustered Index 에서 먼저 값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.
    - 여기서 커버링 인덱스가 사용되었다는건 Clustered Index 까지 통하지 않고 Non Clustered Index 만으로도 데이터를 구할 수 있다는 뜻
    - 커버링 인덱스가 적용되면 EXPLAIN 실행 시 Extra 필드에 Using index 라고 표시

    - SELECT / WHERE / GROUP BY / ORDER BY 등에 활용되는 모든 컬럼이 인덱스의 구성 요소인 경우
    - 커버링 인덱스를 잘 쓰면(특히, 대용량 데이터 처리 시), 조회 성능을 상당 부분 높일 수 있다.


- 커버링 인덱스
    https://jojoldu.tistory.com/476
    https://jojoldu.tistory.com/481

    만약 사용하는 인덱스로 SELECT 질의에 대한 결과를 모두 얻을 수 있는 상황이라면, 데이터 페이지에 저장되어 있는 레코드를 읽어오지 않아도
    인덱스 키의 값만으로도 결과를 얻을 수 있다. 이와 같이 인덱스가 하나의 질의를 모두 '커버'한 경우를 '커버링 인덱스(Covering Index)'라고 한다.
    커버링 인덱스는 데이터 페이지를 읽지 않는다는 점, 그리고 해당 질의를 자주 사용하면 인덱스가 데이터베이스 버퍼에 캐시되어 있을 가능성이 높다는 점에서
    디스크 I/O를 줄이는 데 큰 역할을 한다. 따라서 레코드 크기에 비해 인덱스 키의 크기가 작고, 커버링 인덱스를 이용하는 질의가 자주 수행되는 것이 확실하다면,
    커버링 인덱스를 사용하여 SELECT 질의 성능을 크게 향상시킬 수 있다.


- 결합 인덱스란
    - 결합 인덱스란?
        결합 인덱스란 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말합니다. 주로 단일 컬럼으로는 나쁜 분포도를 가지지만
        여러 개의 컬럼을 합친다면 좋은 분포도를 가지고, Where 절에서 AND 조건에 많이 사용되는 컬럼들을 결합 인덱스로 구성합니다.

        1. where 절에서 and 조건으로 자주 결합되어 사용되면서 각각의 분포도 보다 두 개 이상의 컬럼이 결합될 때 분포도가 좋아지는 컬럼들
        2. 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
        3. order by 에서 자주 사용되는 컬럼들
        4. 하나 이상의 키 컬럼 조건으로 같은 테이블의 컬럼들이 자주 조회될 때

    - 결합 인덱스의 컬럼 순서 결정
        결합 인덱스를 만들 때 결합 인덱스를 구성하는 컬럼들의 배열 순서는 아주 중요하기에 신중하게 결정하여야 합니다.
        컬럼의 순서를 잘못 배열하면 결합 인덱스의 발동 확률이 매우 낮아질 수 있기 때문입니다. 만약 select 문의
        where 절에 결합 인덱스의 첫 번째 컬럼을 조건에 사용하였다면 그 질의문은 결합 인덱스를 사용할 수 있습니다.
        하지만 개발자가 결합 인덱스의 두번째 컬럼만을 where 절에 조건으로 사용하고 결합 인덱스를 사용하고자 했다면
        실행계획은 인덱스를 사용하지 못합니다. 따라서 쿼리문 작성 시 결합 인덱스를 사용하고자 한다면 반드시 결합 인덱스의
        컬럼 중 선행하는 컬럼부터 조건에 지정하여 사용하여야 합니다. 조건은 컬럼 전체를 순서대로 사용할 수도 있고,
        아니면 선행하는 일부 컬럼을 순서대로 사용할 수 있습니다.

    - 결합 인덱스 컬럼의 설정 시 고려해야 할 우선순위
        1. where 절 조건에 많이 사용되는 컬럼이 우선시
        2. Equal('=')로 사용되는 컬럼 우선
        3. 분포도가 좋은 컬럼을 우선
        4. 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정

    - 복합 인덱스를 구성할 때
        - 인덱스는 여러 개의 컬럼을 동시에 지정할 수도 있는데 어떤 순서로 구성하느냐에 따라 성능이 달라집니다.
        - 인덱스는 트리 구조로 되어있다고 했는데, 여러 개의 컬럼을 함께 키 값으로 지정하는 경우 먼저 첫 번재 컬럼을 기준으로 정렬된 뒤에 두번째 컬럼이 정렬되어 있습니다.
        - 이 말은 즉 첫 번째 컬럼 없이 두 번째 컬럼만 갖고 인덱스를 조회하면 제대로 된 위치를 찾을 수 없다는 뜻
        - 그러므로 복합 인덱스를 구성했다면 조회할 때 앞 순서의 조건을 반드시 포함해야 인덱스를 태울 수 있습니다.
        - 여러 개의 컬럼이 있다면 카디널리티가 높은 순에서 낮은 순으로 지정하는게 인덱스의 효율을 이끌어낼 수 있습니다.
        - 과거에는 인덱스의 컬럼 순서와 조회 컬럼 순서를 맞춰야 인덱스를 탔지만 최근에는 옵티마이저가 알아서 인덱스 순서에 맞춰주기 때문에 거의 차이가 없습니다.
        - 그래도 재배열하는 과정을 생략하기 위해 최대한 맞추는게 좋다.

        - 단일 컬럼 인덱스보다 더 비효율적으로 Insert/Update/Delete 를 수행하므로 가급적 업데이트가 안 되는 값을 선정해서 사용하는 것이 좋다.
        - 데이터를 조회할 때 단일 인덱스를 여러 개를 사용해야 하는 경우가 많다면 다중 컬럼 인덱스를 고려해 본다.


- B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기
    1. B-Tree 인덱스와 인덱스가 필요한 이유
        - B-Tree 구조란?
            B-Tree는 자식 2개 만을 갖는 이진 트리(Binary Tree)를 확장하여 N개의 자식을 가질 수 있도록 고안된 것
            좌우 자식 간의 균형이 맞지 않을 경우에는 매우 비효율적이라, 항상 균형을 맞춘다는 의미에서 균형 트리(Balanced Tree)라고 불린다.
            B-Tree는 최상위에 단 하나의 노드 만이 존재하는데, 이를 루트 노드(Root Node)라고 한다. 그리고 중간 노드를 브랜치 노드(Branch Node), 최하위 노드를 리프 노드(Leaf Node)라고 한다.

        - 페이지(Page)란?
            디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위
            반적인 인덱스를 포함해 PK(클러스터 인덱스)와 테이블 등은 모두 페이지 단위로 관리된다.
            따라서 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 블록을 읽어야 하는 것이다.
            그래서 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여, 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 상당히 중요하다.
            페이지에 저장되는 데이터의 크기가 클수록 다음과 같은 문제가 생길 수 있다.
                디스크 I/O가 많아질 수 있음
                메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음
            만약 레코드를 찾는데 1개의 페이지만으로 처리가 안된다면 다른 페이지를 읽어야 하는데, 추가 페이지를 읽는 디스크 I/O 때문에 성능이 떨어지게 된다.
            메모리의 효율을 위해서도 중요하다. 디스크 I/O를 통해 페이지를 읽어오면 버퍼풀이라는 메모리에 캐싱해둔다.
            그런데 개별 데이터의 크기가 커지면 페이지 자체의 크기가 커지면서, 메모리에 캐싱해둘 수 있는 페이지 수가 줄어들게 된다.
            DB 성능 개선 혹은 쿼리 튜닝은 디스크 I/O 자체를 줄이는 것이 핵심인 경우가 많다.

        - B-Tree 인덱스의 구조
            인덱스는 페이지 단위로 저장되며, 인덱스 키를 바탕으로 항상 정렬된 상태를 유지
            정렬된 인덱스 키를 따라서 리프 노드에 도달하면 (인덱스 키, PK) 쌍으로 저장되어 있다.
            모든 페이지는 키 값을 기준으로 정렬되어 있다.
            데이터를 따라 리프노드에 도달하면 인덱스 키에 해당하는 레코드의 PK 값이 저장되어 있다. 테이블 영역도 인덱스와 유사한데, 리프 노드에 실제 테이블의 레코드가 저장되어 있다는 점만 다르다.
            인덱스는 테이블과 독립적인 저장 공간이므로 인덱스를 통해 데이터를 조회하려면 먼저 PK를 찾아야 한다.
            PK로 레코드를 조회할 때는(인덱스 영역에서 테이블 영역으로 넘어가는 경우) PK가 어느 페이지에 저장되어 있는지 알 수 없으므로 랜덤 I/O가 발생한다.
            이후에는 PK를 따라 리프노드에서 실제 레코드를 읽어온다. 참고로 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데,
            랜덤 I/O는 임의의 장소에서 데이터를 가져오지만 순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다.

        - 인덱스가 필요한 이유
            인덱스를 통해 데이터를 조회하는 것은 아래의 2가지 작업이 수행되는 것
                인덱스를 통해 PK를 찾음
                PK를 통해 레코드를 찾음
            이러한 이유로 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블을 통해 직접 읽는 것 보다 4~5배 정도 비용이 더 많이 드는 것으로 예측한다.
            하지만 DBMS는 우리가 원하는 레코드가 어디있는지 모르므로, 모든 테이블을 뒤져서 레코드를 찾아야한다. 이는 엄청난 디스크 읽기 작업이 필요하므로 상당히 느리다.
            하지만 인덱스를 사용한다면 인덱스를 통해 PK를 찾고, PK를 통해 레코드를 저장된 위치에서 바로 가져올 수 있으므로 디스크 읽기가 줄어들게 된다.
            그렇기 때문에 레코드를 찾는 속도가 훨씬 빠르며, 이것이 인덱스를 사용하는 이유이다.
            반면에 인덱스를 타지 않는 것이 효율적일 수도 있다. 인덱스를 통해 레코드 1건을 읽는 것이 4~5배 정도 비싸기 때문에,
            읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 효율적이다. 이런 경우 옵티마이저는 인덱스를 이용하지 않고 테이블 전체를 읽어서 처리한다.

    2. 인덱스 사용에 영향을 주는 요소
        - PK의 크기
            MySQL에서는 PK가 레코드의 물리적인 저장 위치를 결정하는 키
            PK가 레코드의 물리적인 저장 위치를 결정하기 때문에, 인덱스는 PK에 의존한다.
            그래야 인덱스를 타고 들어와서 PK를 통해 레코드의 값을 읽어올 수 있기 때문이다.
            인덱스가 PK가 아닌 실제 레코드의 주소를 갖게 할 수도 있지만, 그러면 PK가 변경될 때 레코드의 주소가 변경되고 모든 인덱스에 저장된 레코드 주소를 변경해야 한다.
            이러한 오버헤드를 피하기 위해 인덱스는 레코드의 주소가 아닌 PK를 저장하고 있다.
            따라서 PK 값이 클수록 인덱스에 좋지 않다. PK가 클수록 한 페이지에 담을 수 있는 인덱스 정보도 줄어들고, 메모리도 비효율적으로 사용되기 때문이다.
            또한 트리의 깊이도 지나치게 깊어지면서 되면서 읽어야 하는 페이지가 많아져서 성능에 좋지 않다.

        - 인덱스의 컬럼 순서
            (PK를 포함하여) 인덱스는 여러 개의 컬럼으로 구성될 수 있는데, 이를 다중 컬럼 인덱스(Multi-column Index)
            두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬된다. 그렇기 때문에 두 번째 컬럼 만으로 질의하는 경우는 인덱스를 제대로 타지 못한다.

        - 카디날리티(Cardinality)
            카디날리티란 특정 컬럼에 존재하는 데이터의 고유성을 의미한다. 따라서 카디날리티가 높을수록 중복도가 낮아지며, 유니크한 값이 많다는 것이다.
            항상 그런 것은 아니지만 일반적으로 값이 유니크할수록 검색 대상이 줄어들어서 처리가 빠르다.
            MySQL은 인덱스의 통계 정보를 관리하는데, 그 중에 유니크한 값의 개수가 있다. 그래서 인덱스 별로 평균적으로 몇 건의 레코드가 있는지를 계산하여 이를 쿼리 시에 활용한다.
            일반적으로 인덱스는 유니크할수록 효율적이다. 하지만 카디날리티가 낮더라도 정렬 또는 그루핑 등에 효율적으로 사용될 수 있으므로, 용도에 맞게 적절히 설계하는 것이 중요하다.
            추가로 MySQL에서 값이 1개만 존재하도록 제약이 필요하다면 다른 방법이 없어서 유니크 인덱스를 만들어야 할 수도 있다.
            유니크 인덱스는 무결성을 위해 중복 검사가 필요하여 쓰기 성능을 희생해야 한다. 대신 1건만 읽어도 되므로 읽기 성능은 높아진다.

        - 인덱스의 정렬 및 스캔 방향
            인덱스는 설정된 정렬 규칙에 따라 정렬되어 저장된다.
            인덱스를 정렬 순서대로만 읽을 수 있는 것은 아니다. 인덱스가 오름차순으로 생성되었어도 내림차순으로 읽는 것이 가능하며,
            인덱스를 읽는 방향은 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.
            이렇듯 인덱스를 순서대로 읽는 것을 인덱스 정순 스캔(Index Forward Scan), 반대 방향으로 읽는 것을 인덱스 역순 스캔(Index Backward Scan)
            인덱스 역순 스캔은 인덱스 정순 스캔보다 느린데, 그 이유는 다음과 같다.
                페이지 잠금이 인덱스 정순 스캔에 적합한 구조임
                페이지 내에서 인덱스 레코드가 단방향으로만 연결뒨 구조임
            리프 노드의 페이지는 이중 연결 리스트로 되어 있다. 하지만 페이지 잠금 과정에서 데드락을 방지하기 위해 잠금을 획득하는 것이 정순에서만 가능하고,
            역순은 복잡한 과정이 필요하다고 한다. 이 부분은 구조적으로 인덱스 스캔이 정순에 적합하다고만 알고 넘어가면 된다.
            그 다음으로는 페이지 내에서 인덱스가 단방향으로만 연결되어 있기 때문이다. 위의 그림에서는 인덱스가 양방향으로 연결된 것처럼 그려져있지만 실제 내부는 조금 다르다.
            페이지 내부에서는 순차적으로 4~8개 정도씩 묶어서 그룹을 만든다. 그리고 그룹의 대표키를 선정해 리스트로 관리하는데, 이를 페이지 디렉토리(Page Directory)라고 한다.
            문제는 페이지 디렉토리가 단방향 연결이라서, 역방향으로 접근이 불가능하다. 그래서 역순 스캔의 경우 일부 단방향 접근이 필요하므로 역순 스캔이 정순 스캔보다 느린 것이다.

    3. 레코드 추가, 삭제, 수정이 인덱스에 미치는 영향
        - 레코드 추가
            레코드가 추가되면 인덱스도 같이 추가되어야 하며, 인덱스는 항상 정렬된 상태를 유지해야 하므로 적절한 위치 탐색 후에 저장된다.
            따라서  레코드 추가 비용이 1이라면 인덱스 추가 비용은 1.5 정도로 가정한다. 인덱스가 없다면 작업 비용이 1이고,
            B-Tree 인덱스가 3개 있다면 작업 비용을 5.5 정도(1+ 1.5*3)로 예측한다. 참고로 이때의 작업 비용은 디스크 I/O 비용이기 때문에 상당히 비싸다.
            그래서 인덱스 추가 작업을 즉시 처리하지 않고, 메모리에 모아서 한 번에 쓰도록 지연시킬 수도 있다. 그러면 디스크 쓰기 횟수를 줄일 수도 있고, 요청 시에 메모리에서 바로 결과를 반환하는 등의 장점이 있다.
            하지만 유니크 인덱스처럼 중복 체크 등의 무결성이 필요하다면 즉각 반영되기도 한다. 유니크 인덱스라면 중복 값의 유/무를 검사한 후에 저장해야 한다.
            이때 중복된 값을 체크하기 위해서는 읽기 잠금을 쓰기를 할 때는 쓰기 잠검을 사용하는데, 이 과정에서 데드락이 아주 빈번히 발생한다.
            유니크 인덱스의 저장이나 변경은 상당히 빠르게 처리되지만, 중복 검사 때문에 작업을 지연할 수 없어서 좋지 않다.
            그렇기에 유니크 인덱스는 반드시 유일성이 보장되어야 하는 경우에 사용하는 것이 좋다.
            레코드를 추가하다가 페이지가 꽉찼다면 추가 디스크 작업이 필요하다. 인덱스의 리프 노드 페이지가 가득 찼다면 리프 노드를 분리해야 하는데,
            그러면 상위 노드(루트 또는 브랜치 노드)에 저장된 자식 노드의 값까지 갱신하는 작업이 필요하다.

        - 레코드 삭제
            레코드를 삭제하면 인덱스도 삭제돼야 하는데, 이는 인덱스의 리프 노드에 삭제 마킹만 하면 된다. 삭제 마킹 역시 디스크 쓰기 작업이므로 이 작업도 지연 처리될 수 있다.
            또한 삭제 마킹된 공간은 계속해서 방치시킬 수도 있고, 재활용할 수도 있다.
            참고로 레코드를 삭제하는 작업이 PK나 인덱스가 사용되는 쿼리라면 이를 활용해서 처리되며, 이는 레코드 수정에서도 동일하다.
            MySQL에서 인덱스는 조금 더 특별한 주의가 필요하다. MySQL의 잠금 중 일부(레코드 잠금, 넥스트 키락 또는 갭락)는 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.
            따라서 UPDATE나 DELETE를 실행 시에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그며, 심지어 테이블의 모든 레코드를 잠글 수도 있기 때문이다.

        - 레코드 수정
            레코드 수정은 결국 레코드를 추가하고 삭제하는 것이며, 수정 대상은 크게 PK, 인덱스, 일반 값이 있다.
            먼저 PK가 수정되는 경우는 살펴봤듯 최소 2번(DELETE, INSERT)의 쓰기 작업이 필요하다.
            그리고 해당 테이블에 인덱스가 있다면 인덱스에도 추가 작업이 필요하므로 상당히 비용이 많이 든다. 인덱스가 수정되는 경우에는 테이블 뿐만 아니라 인덱스에 추가 작업이 반드시 필요하므로,
            해당 작업도 비용이 많이든다. 따라서 인덱스와 PK는 최대한 변경을 피해야 한다.
            그 외의 값이 수정되는 경우는 테이블만 작업하면 되므로 비교적 수월하다.
            참고로 레코드 수정은 결국 DELETE 후에 INSERT하는 작업이라서 PK나 인덱스가 사용되는 쿼리라면 이를 활용하여 처리된다.

        - 레코드 검색
            레코드를 검색하는 작업 역시 PK를 사용하는 경우, 인덱스를 사용하는 경우, 그 외의 값을 사용하는 경우가 있다. 앞서 살펴보았듯 인덱스는 쓰기 작업에 비용이 많이 필요한데, 그럼에도 불구하는 이유는 빠른 검색을 위해서이다.
            PK로 검색하는 경우는 데이터가 저장된 위치를 바로 알 수 있기 가장 효율적이다.
            그 다음 인덱스로 조회하는 것은 인덱스를 통해 PK 값을 찾고, PK를 통해 레코드를 읽어온다. 그래서 PK 보다는 조금 비효율적이지만,
            그래도 효율적이다. PK와 인덱스 모두 키를 기반으로 트리 검색을 통해 빠르게 값을 찾아온다.
            만약 인덱스가 유니크 인덱스라면 쓰기 작업과 마찬가지로 약간의 차이가 있다. 인덱스의 유니크 여부는 DBMS 쿼리를 실행하는
            옵티마이저에게 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 알려주는 것이다.
            그 외에도 유니크 인덱스로 인한 MySQL의 처리 방식 변화나 차이점이 상당히 많이 있는데, 유니크 인덱스는 결국 다른 인덱스보다 읽기가 빠르다.
            PK나 인덱스가 아닌 일반 값으로 레코드를 찾는 경우라면 작업이 오래 걸린다. 왜냐하면 해당 레코드가 어디에 저장되어 있는지 모르기 때문에, 모든 테이블을 전체 탐색(풀 스캔)하여 찾아야 하기 때문이다.
            B-Tree는 인덱스 키 값을 변형하지 않고 정렬된 상태로 저장한다. (물론 VARCHAR 255를 넘어가면 앞 부분만 잘라서 인덱스를 생성하긴 한다.)
            그래서 동등 조건 연산(=)이나 부등호 검색 등 대부분의 경우에 인덱스를 활용할 수 있다.
            하지만 키 값의 뒷부분만 검색(LIKE “%name%”)하거나 변형된 값으로 쿼리하는 등의 경우라면 인덱스를 활용할 수 없다.

    4. 읽기 방식에 따른 인덱스의 분류
        - 인덱스 레인지 스캔
            범위가 결정된 인덱스를 읽는 방식으로,  정해진 범위만 접근하면 되므로 이 방식은 다른 방식들보다 빠르다.
            일반적으로 인덱스를 탄다고 하면 인덱스 레인지 스캔으로 데이터를 조회하는 것을 의미한다.
            해당 테이블의 name 컬럼에 인덱스가 걸려있다고 할 때, 쿼리의 실행 순서를 정리하면 다음과 같다.
                (인덱스 탐색) 인덱스의 조건을 만족하는 값이 저장된 위치를 찾는다.
                (인덱스 스캔) 시작 위치부터 필요한 만큼 인덱스를 순서대로 읽는다.
                (랜덤 I/O) 읽어들인 인덱스와 PK를 이용해 최종 레코드를 읽어온다.

            먼저 루트 노드에서 시작해서 브랜치 노드를 거쳐 원하는 인덱스가 저장된 리프 노드(페이지8)로 이동한다. 읽고 쓰는 단위는 페이지이므로
            원하는 인덱스를 찾기 위해서는 8번 페이지의 처음부터 시작해서 시작점(Lemon)을 찾는데, 이를 탐색이라고 한다.
            시작점을 찾았으면 이후에는 순서대로 검색 범위의 마지막 인덱스(Mango)까지 읽으면 되는데, 이를 스캔이라고 한다.
            이것이 가능한 이유는 인덱스가 정렬되어 있기 때문이며, 스캔을 하다가 페이지의 끝에 도달하면 페이지 간의 링크를 이용해 다음 페이지(9)로 넘어간다.
            그리고 계속해서 스캔하다가 마지막 인덱스를 찾으면 지금까지 읽은 레코드를 반환하고 쿼리를 종료한다.
            만약 쿼리가 인덱스나 PK 외의가 아닌 레코드의 다른 값을 필요로 한다면 테이블로부터 레코드를 조회해와야 하며, 이때는 PK를 이용해 랜덤 I/O를 통해 레코드들을 조회해야 한다.
            만약 인덱스나 PK만 필요로 한다면 해당 작업은 실행되지 않는데, 이를 커버링 인덱스라고 한다.  커버링 인덱스는 디스크 랜덤 I/O 작업을 줄일 수 있어서 성능이 훨씬 뛰어나다.
            다시 한번 설명하지만, 인덱스에 PK가 저장되는 것은 MySQL의 InnoDB가 클러스터 테이블이기 때문에 이러한 구조를 갖는 것이다. 다른 DBMS의 경우에는 다를 수 있음을 참고하도록 하자.

        - 인덱스 풀 스캔
            처음부터 끝까지 페이지를 이동하며 모든 인덱스를 읽는 방식
            쿼리가 인덱스나 PK 만 필요로 한다면 해당 방식이 주로 사용되고, 그 외의 컬럼이 필요하다면 절대 이 방식으로 처리되지 않는다.
            또한 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우에 사용된다.

            인덱스 풀 스캔이 사용되는 이유는 테이블에는 다른 레코드들도 포함되어 있으니 비효율적이기 때문이다.
            해당 방식이 아주 빠르지는 않지만 테이블 풀 스캔보다는 적은 디스크 I/O로 쿼리를 처리할 수 있다.
            그렇다고 하여 인덱스 풀 스캔을 위해서 인덱스를 생성해서는 안되며, 인덱스 풀 스캔은 일반적으로 “인덱스를 사용한다”고 하지도 않는다.

        - 루스 인덱스 스캔
            말 그대로 인덱스를 듬성듬성 읽는 방식
            일반적으로 GROUP BY나 MIN() 또는 MAX()와 같은 집합 함수를 사용하는 쿼리를 최적화할 때 사용되며, 중간에 불필요한 인덱스는 무시하고 넘어간다.

                SELECT
                    dept_no, MIN(emp_no)
                FROM
                    dept_emp
                WHERE
                    dept_no BETWEEN 'D002' AND 'D004'
                GROUP BY
                    dept_no;

                위의 쿼리에서 emp_no는 dept_no에 의존하여 정렬되므로, dept_no 그룹 별로 가장 처음의 emp_no 값만 읽으면 된다. 옵티마이저는 이러한 부분을 알고 있기 때문에, 처음이 아닌 emp_no는 무시하고 넘어간다.

            이러한 부분은 인덱스의 정렬 특성 때문이므로, 인덱스를 구성하는 컬럼의 순서는 상당히 중요한 것이다.
            앞선 인덱스 레인지 스캔과 인덱스 풀 스캔은 모든 인덱스를 스캔하므로 타이트 인덱스 스캔으로 묶이는데, 이와 반대되는 스캔 방식이다.

        - 인덱스 스킵 스캔
            인덱스 스킵 스캔은 MySQL 8.0부터 추가된 기능으로, 인덱스의 뒷 컬럼만으로 검색하는 경우에 옵티마이저가 자동으로 쿼리를 최적화하여 인덱스를 타도록 하는 읽기 방식이다.
            인덱스 스킵 스캔이 실행되기 위해서는 다음의 조건들을 모두 만족시켜줘야만 한다.
                조회되는 컬럼은 인덱스 만으로 처리 가능해야 함(커버링 인덱스)
                인덱스의 선행 컬럼은 WHERE 절에 없어야 함
                인덱스 선행 컬럼의 카디날리티가 낮아야 함(유니크한 값이 적어야 함)

            먼저 조회되는 컬럼이 인덱스 만으로 처리 가능해야 한다. 만약 모든 컬럼을 조회하는 쿼리라면 풀 테이블 스캔을 타게 된다.
            인덱스 스킵 스캔은 MySQL 8.0부터 추가된 기능이라 아직 최적화가 되지 못한 부분이 많은데, 이 부분이 그 중 하나이다.
            그 다음으로는 인덱스 선행 컬럼이 WHERE 절에 없으며, 선행 컬럼이 갖는 값이 유니크한 개수가 적을 때에만 최적화가 가능하다는 것이다.
            일반적으로는 유니크한 값의 개수가 많을수록 좋다. 하지만 인덱스 스킵 스캔의 경우에는 유니크한 값의 개수가 많다면 인덱스의 스캔 시작 지점을 검색하는 작업이 많아진다.
            그래서 쿼리 최적화를 하려다가 오히려 느려질 수 있다.

        - 인덱스를 사용하지 않는 경우
            풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 방식이다. 옵티마이저는 아래의 경우에 주로 풀 테이블 스캔을 이용한다.
                WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
                테이블의 레코드 건수가 너무 적어서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 것이 더 빠른 경우 (일반적으로 테이블이 1개의 페이지 만으로 구성되는 경우)
                인덱스 레인지 스캔을 사용할 수 있더라도 일치되는 레코드 건수가 너무 많은 경우

            일반적으로 전체 테이블의 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기를 필요로한다.
            그래서 MySQL은 특정 테이블의 연속된 페이지가 읽히면 백그라운드 쓰레드를 통해 다음 페이지의 작업을 미리 읽어 메모리(버퍼풀)에 넣어두는 리드 어헤드(Read ahead) 기능을 갖고 있다.
            리드 어헤드 작업은 4개 또는 8개의 페이지부터 시작하여 최대 64개의 페이지까지 읽어오도록 증가된다. 참고로 이는 풀 인덱스 스캔에도 동일하게 적용된다.

    5. 인덱스 사용 시의 주의 사항
        - 인덱스 사용 시의 주의 사항
            - 인덱스를 통해 필요한 레코드만 조회하면 효율적일 수 있음
                만약 쿼리로 조회하는 데이터가 PK 뿐이라면 프라이머리 키 인덱스 영역까지 넘어갈 필요가 없다. 따라서 B-Tree 인덱스 영역의 리프 노드에서 조회한 PK 값을 바로 반환하는데, 이를 커버링 인덱스라고도 한다.

            - 인덱스는 SELECT 외에 UPDATE, DELETE 등에도 사용될 수 있음
                또한 인덱스는 검색 조건에서만 활용되는 것이 아니고 DELETE, UPDATE 시에도 활용될 수 있으며, WHERE절 뿐만 아니라 GROUP BY와 ORDER BY에서도 동일하게 사용될 수 있다.

            - 인덱스는 값이 변형되는 경우에 사용될 수 없음
                결국 인덱스는 키 값으로 정렬되기 때문에, 정렬된 효과를 누릴 수 없는 경우라면 인덱스를 사용할 수 없다.
                예를 들어 값을 잘라서 쿼리에 사용하는 경우가 그러하다. 또한 레코드를 “%Kyu”와 같이 후방 일치 검색하는 경우도 정렬 효과가 전혀 없으므로 인덱스를 타지 않는다.

            - 인덱스는 정순으로 검색하는 것이 효율적임
                인덱스를 정순으로 검색하는 것이 효율적인 이유는 앞에서 살펴보았듯 정순 정렬에 최적화되어있기 대문이다.

            - 인덱스를 무조건적으로 생성하는 것은 좋지 않음
                인덱스를 무조건적으로 생성하는 것은 좋지 않다. WHERE 절에 사용되는 속성이라고 전부 인덱스를 생성하면 데이터의 저장 성능은 떨어지고 인덱스는 비대해져 오히려 역효과만 불러올 수 있다.
                정렬된 상태를 유지하기 위해서는 데이터를 저장할 때 정렬된 위치를 찾고 넣어줘야 한다. 값이 수정된다면 추가적인 작업이 수반되기도 한다.
                즉, 인덱스는 저장(INSERT, UPDATE, DELETE)의 성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다. 인덱스가 필요한 이유는 쓰기 작업이 조금 느리더라도,
                읽기 작업을 빠르게 유지하도록 하기 위함이다. 왜냐하면 일반적인 온라인 환경에서 읽기와 쓰기의 비율이 8:2, 9:1이기 때문이다.


- InnoDB 스토리지 엔진에서 클러스터링 인덱스와 세컨더리 인덱스가 동작하는 과정을 설명하라.
    - 클러스터링 인덱스
        클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면,
        해당 클러스터링 인덱스 키에 해당하는 레코드의 모든 정보를 가져온다.

    - 세컨더리 인덱스
        세컨더리 인덱스의 리프 노드에는 클러스터링 인덱스의 리프 노드와는 달리 PK가 존재한다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면,
        해당 세컨더리 인덱스 키에 해당하는 레코드의 PK를 이용하여 데이터 파일을 탐색한다. 이때 데이터 파일은 클러스터링 인덱스이므로
        이 데이터 파일의 리프 노드에는 해당 PK에 해당하는 레코드의 모든 정보를 가져온다.


- 설정된 Index가 DML(Data Manipulation Language)에 미치는 영향
    Index는 주로 SELECT 쿼리에서는 성능이 잘 나온다. 하지만 INSERT/UPDATE/DELETE에서는 경우에 따라 다르다.

    UPDATE, DELETE
    인덱스로 설정된 컬럼에 대해 조건(WHERE)을 사용할 수도 있는 UPDATE, DELETE사용 시 조회에서는 성능이 크게 저하되지 않는다.
    ※ 여기서 수정/삭제할 데이터를 찾는 때의 속도가 빠르다는 것이지 수정이나 삭제 그 자체를 빠르게 처리한다는 뜻은 아니다.

    INSERT
    반면, INSERT의 경우에는 효율이 좋지 않다.
    새로운 데이터를 추가하면서 인덱스가 설정되어 있던 컬럼의 테이블이 수정되어야 하기 때문이다.


- Single Column Index와 Multi Column Index의 비교
    Multi Column Index의 장점
    ① 질의(SQL) 컬럼이 모두 조합 인덱스에 있는 경우, 물리적인 데이터 블록을 읽을 필요가 없다.
    (인덱스 테이블만 읽으면 된다.)

    Multi Column Index를 고려해야 하는 경우
    ① WHERE에 사용될 때 AND 연산자에 의해 자주 같이 질의되는 컬럼들인 경우.



인덱스가 걸려있는 컬럼을 MIN, MAX를 쓰면 INDEX_ASC, INDEX_DESC 테이블 힌트를 사용하지 않아도 자동으로 인덱스를 사용한다. ??

- 그러면 탐색이 O(logN)인 다른 자료구조나 알고리즘은 왜 사용하지 못하는 것일까? 같은 밸런스 트리 종류임에도 RedBlack-Tree는 DB 인덱스로 선택받지 못한 이유 ??


group-by 혹은 distinct 사용시 인덱스를 사용할 수 없다.??

- Index Skip Scan ??

- Index Fast Full Scan ??

- Covering Index ??

- https://hoon93.tistory.com/52

- https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC