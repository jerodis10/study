- 인덱스
    - 인덱스(Index)란?
        인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
        특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
        이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.
        디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
        인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.
        이를 위해 데이터가 추가/삭제 될 때마다 자료구조를 정렬하기 때문에 인덱스는 SELECT 성능을 향상시키는 대신 INSERT, UPDATE, DELETE 의 성능이 떨어지게 됩니다.

        인덱스도 하나의 데이터베이스 객체
        데이터베이스 크기의 약 10% 정도의 저장공간 필요

    - 인덱스(Index)를 사용하는 이유
        테이블에 데이터들이 인덱스의 가장 큰 특징은 데이터들이 정렬이 되어있다는 점입니다. 이 특징으로 인해 조건 검색이라는
        영역에서 굉장한 장점이 됩니다.
        인덱스를 사용하게 되면 테이블에 바로 접근하지 않고 인덱스 영역에서 빠르게 ROWID를 찾아낸 후 실제 테이블에서 해당하는 데이터를 찾는다.

        - 조건 검색 Where 절의 효율성
            테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다.
            이렇게 되면 Where 절에 특정 조건에 맞는 데이터들을 찾아낼때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과
            맞는지 비교해야 합니다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 하지만 인덱스 테이블은 데이터들이
            정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠.
            이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다.

        - 정렬 Order by 절의 효율성
            인덱스(Index)를 사용하면 Order by에 의한 Sort 과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이
            걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면
            디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다.
            이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.

        - MIN, MAX 의 효율적인 처리가 가능하다.
            - 이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점입니다. MIN 값과 MAX 값을 레코드의 시작값과 끝 값 한건씩만
              가져오면 되기에 FULL TABLE SCAN 으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.
            - 인덱스가 걸려있는 컬럼을 MIN, MAX를 쓰면 INDEX_ASC, INDEX_DESC 테이블 힌트를 사용하지 않아도 자동으로 인덱스를 사용한다.

        - Index를 사용하면 좋은 경우
            - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
            - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
            - 데이터의 중복도가 낮은 컬럼
            - 필드에 저장된 값을 찾는 작업이 예상되는 경우
            - 필드의 값을 정렬하는 작업이 예상되는 경우

    - 인덱스의 자료구조가 B- TREE 인 이유
        - 탐색시간이 제일 빠른 해시 테이블을 DB 인덱스로 사용할 수 없는 이유
            - 해시 충돌 등으로 최악의 경우에 O(N)이 될 수 있지만, 평균적으로는 O(1)
            - 해시 테이블은 분명 한 가지 키에 대한 탐색은 효율적입니다.
            - 하지만 데이터가 정렬되어 있지 않기 때문에 부등호 (<, >) 를 사용하지 못한다는 단점이 있습니다.

        - 그러면 탐색이 O(logN)인 다른 자료구조나 알고리즘은 왜 사용하지 못하는 것일까? 같은 밸런스 트리 종류임에도 RedBlack-Tree는 DB 인덱스로 선택받지 못한 이유
            - RedBlack-Tree와 B-Tree의 가장 큰 차이는 '하나의 노드가 가지는 데이터 개수'이다.
            - RedBlack-Tree는 무조건 하나의 노드에 하나의 데이터 요소만을, B-Tree는 하나의 노드에 여러 개의 데이터 요소를 저장한다.
            - 같은 노드 공간의 데이터들끼리 굳이 자식 노드처럼 참조 포인터 값으로 접근할 필요가 없다. 실제 메모리 디스크에서 바로 다음 인덱스의 접근을 하는 것
            - 노드에서 배열 형태로 여러 데이터를 저장할 수 있기 때문에 트리 포인터를 참조해서 계속 depth 를 타고 들어가는 것보다 효율적이고 이는 데이터가 많아질수록 차이가 두드러집니다. ??

        - 모든 면으로 DB 인덱스 용도로 가장 적합한 자료구조인 B-Tree
            - 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
            - 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.
            - 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.

        - 인덱스도 크기가 커져 보조 기억 장치에 저장되게 되는데 이 또한 디스크 I/O가 발생하게 되는 것이다. ??
          따라서 B-Tree의 깊이를 줄여야 디스크 I/O를 줄일 수 있기 때문에 B-Tree를 사용한다.

    - 인덱스 자료구조 (B * Tree 인덱스)
        인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다.
        그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.
        B * Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다.
        구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node 로 구성됩니다. 특정 컬럼에 인덱스를 생성하는
        순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT 블록을
        기준으로 가지가 되는 BRANCH 블록을 정의하며 마지막으로 잎에 해당하는 LEAF 블록에 인덱스의 키가 되는
        데이터와 데이터의 물리적 주소 정보인 ROWID 를 저장합니다.

        일반적으로 B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
        그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

    - B-Tree 인덱스의 쿼리별 특징
        - SELECT
            - 특정 키 값을 찾기 위해 자식 노드를 계속 타고 들어가는 방식
            - 마지막 리프 노드에는 레코드의 주소가 존재하고 이 값으로 테이블 레코드를 찾을 수 있음

            - B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
              그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

        - INSERT
            - B-Tree 에 새로운 키값을 저장할 때는 우선 적절한 위치를 찾아야함
            - 새로운 키값과 레코드 정보는 리프 노드에 저장
            - 만약 리프 노드가 꽉찼다면 트리를 재구성하여 리프 노드를 분리
            - 분리 과정에서 해당 리프 노드의 부모 노드까지 영향이 갈 수 있음
            - 이러한 이유로 INSERT 작업은 상대적으로 비용이 많이 듬
            - 인덱스가 많으면 많을수록 이런 비용이 추가로 들기 때문에 너무 많은 인덱스를 추가하는 건 성능에 영향을 줌

            - 페이지 내부에서 작업될 경우 큰 부담은 없지만, 페이지가 꽉 찰 경우 데이터베이스는 비어 있는 페이지를 확보하고
              문제가 있는 페이지의 데이터를 공평하게 나누어 저장. 이는 데이터베이스에 부담이 되는 작업 (페이지 분할)
            - 페이지 분할
                - 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생
                - DB 가 느려지고 성능에 영향을 준다.

        - DELETE
            - B-Tree 에서 키 값 삭제는 간단
            - 해당 키를 찾아서 삭제 마크만 하면 작업이 완료
            - 삭제 마킹된 인덱스 키 공간은 그대로 두거나 재활용 가능

            - 인덱스의 데이터를 실제로 지우지 않고 사용안함 표시를 한다.

        - UPDATE
            - 인덱스는 항상 정렬된 상태로 유지됨
            - 단순히 인덱스 키 값을 수정한다면 트리의 전체 구조를 바꿔야 할 수도 있음
            - 그래서 B-Tree 에선 키 변경이 아닌 기존 키 삭제 (DELETE) 후 새로운 키 추가 (INSERT) 방식을 사용
            - 따라서 키 값의 잦은 수정은 성능에 큰 영향을 미침

            - delete (기존 값 사용안함 표시)
            - insert (변경된 값 삽입)

        -> update, delete 의 경우 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다.
           페이지: 데이터가 저장되는 단위 (16 Kbyte)

    - 인덱스 종류
        - Clustered Index vs Non-Clustered Index
            - Clustered Index
                - 이름 그대로 인접한 데이터들을 한곳으로 모았다는 뜻
                - PK 설정 시 자동으로 클러스터드 인덱스로 만들어짐
                - 테이블당 1개씩만 허용
                - 물리적인 데이터를 갖고 있음
                - 항상 정렬된 상태를 유지하고 노드 내에서도 정렬되어 있음
                - Non Clustered 인덱스에 비해 조회 속도가 빠르지만 삽입/수정/삭제는 더 느림

                - 데이터페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
                - 데이터페이지는 리프 레벨
                - 클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 된다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있다.
                - 테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
                - 물리적으로 행을 재배열 (실제 DB의 데이터파일에 정렬이 되어 있는 상태로 디스크에 저장)

                - 실제 데이터 자체가 정렬
                - 리프 페이지 -> 실제 데이터 페이지

            - Non Clustered Index
                - UNIQUE 로 설정된 컬럼에 자동으로 생성됨 ??
                - 인덱스 페이지는 로그 파일에 저장됨
                - 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됨
                - 기본키는 아니지만 성능 향상을 위해 임의의 컬럼을 지정해서 만든 인덱스

                - 데이터 페이지를 건들지 않고, 별도의 장소에 인덱스 페이지를 생성
                - 우선 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬하고 데이터 위치 포인터를 생성한다.
                - 데이터 위치 포인터는 데이터가 위치한 고유한 값이 된다. (리프 페이지 -> 실제 데이터의 주소 페이지)
                - 인덱스 페이지를 별도로 저장
                - 테이블 자체는 되지 않고, 인덱스 페이지에만 정렬

                - 실제 데이터와 다른 무리의 별도의 인덱스
                - 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 같은 역할
                - 별도의 인덱스 페이지 생성 -> 추가 공간 필요
                - unique 제약조건 적용시 자동 생성
                - 직접 index 생성시 논-클러스터링 인덱스 생성 (unique index, index)

            - 클러스터링 + 논-클러스터링 인덱스
                - 클러스터링 인덱스 페이지가 존재하고, 논-클러스터링 인덱스 페이지에는 데이터 페이지의 주소가 존재해서 데이터를 조회?
                  하지만, 데이터 페이지의 주소값이 아닌 클러스터링 인덱스가 적용된 칼럼의 실제값이 들어있다.
                - name 인덱스 페이지에서 해당 name 을 찾고 그 값을 통해 id 인덱스 페이지에서 탐색
                  (name 칼럼의 논-클러스터링 인덱스 페이지, id 칼럼의 클러스트렁 인덱스 페이지 구조 예시)
                - 만약 논-클러스터링 인덱스 페이지에 데이터 페이지의 주소값이 들어있게 되면, 데이터가 추가되거나 삭제될 때마다
                  인덱스 페이지들의 주소들을 계속해서 변경해야 하는 영향을 주게 된다. 따라서 클러스터링 인덱스가 적용된 칼럼의 실제값이
                  들어있으면 id 가 직접 변경되지 않는 한 인덱스 페이지에 영향을 주지 않도록 구성되어 있다.

            - Clustered Key
                (1) PK
                (2) PK가 없을 땐, Unique Key
                (3) PK가 없고 Unique Key도 없을 땐, 6 bytes의 Hidden Key 생성

            - 흐름   https://tecoble.techcourse.co.kr/post/2021-10-12-covering-index/
                현재 age와 PK에 인덱스가 걸려있다. 따라서 Non-clustered Key는 age에, Clustered Key는 PK에 인덱스가 있다. 그리고 Non-clustered Key는 age 순으로, Clustered Key는 PK 순으로 정렬된다.
                Non-clustered Key에는 인덱스 컬럼(age)의 값들과 PK의 값들이 있고, Clustered Key는 테이블의 실제 레코드 위치를 알고 있다. MySQL에서는 Non-clustered Key에 Clustered Key가 항상 포함되어 있다. Non-clustered Key엔 데이터 블록의 위치가 없기 때문이다.
                그러므로 인덱스 조건에 부합하는 WHERE가 있더라도, SELECT 문에 인덱스에 포함되어 있는 컬럼 외의 다른 컬럼 값이 필요할 때는 Non-clustered Key에 있는 Clustered Key 값으로 데이터 블록을 찾는 과정이 필요하다.
                그렇지만, PK를 사용하는 경우에는 테이블 액세스 시간이 없어져서 필요로 하는 데이터에 더 빠르게 접근할 수 있다.
                결국 커버링 인덱스는 이미지의 2. 실제 데이터 접근 과정 없이, 인덱스에 존재하는 컬럼 값으로만 쿼리를 완성하는 것을 얘기한다.

    - 인덱스 설정 시 고려사항
        - 인덱스 키 값의 크기
            - 키 값이 클수록 디스크 IO 횟수가 많아져서 성능이 떨어진다. -> 인덱스의 키 값은 작을수록 유리
            - 인덱스 키 값의 크기가 클수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지므로 B-Tree 깊이가 깊어진다.
              깊이가 깊어진다는 것은 디스크 IO 횟수가 많아진다는 것.

        - 인덱스의 갯수
            - 인덱스의 갯수는 3 ~ 4 개가 적당
            - 인덱스의 갯수가 너무 많으면 다음과 같은 이슈가 존재
                - 데이터 삽입/수정/삭제 시마다 인덱스도 같이 추가하거나 수정/삭제 해주어야 해서 성능상 이슈가 존재
                - 데이터 삽입시마다 인덱스도 같이 추가하기 때문에 인덱스가 늘어날수록 더 많은 메모리를 차지함
                - 인덱스가 많아지면 옵티마이저가 잘못된 인덱스를 선택할 확률이 높아짐 (인덱스 힌트로 원하는 인덱스를 지정할 순 있음)

        - 인덱스를 걸기에 적절한 컬럼
            - 인덱스는 where 에서 자주 사용되고 수정빈도가 낮으며 카디널리티가 높은 컬럼을 선택하는 것이 좋습니다. 카디널리티가 높다는 것은 중복된 데이터가 적다는 뜻입니다.

            - 인덱스의 갯수에 한계가 있다면 적절한 인덱스 컬럼을 정하는 것도 중요
            - 인덱스는 카디널리티 (Cardinality) 가 높은 컬럼에 지정하는 게 좋습니다.
            - 카디널리티가 높다는 말은 데이터의 중복이 적다는 뜻인데 대표적으로 ID, 주민번호 등이 있습니다.
            - 반대로 성별 같은 중복된 데이터가 많은 경우 카디널리티가 낮다고 표현
            - 성별에 인덱스를 거는 경우 인덱스를 타더라도 남/녀 두가지만 존재하기 때문에 결국 나머지 조건에 맞는 데이터는 직접 풀스캔을 해서 찾아야 합니다.
            - 하지만 ID 같이 중복된 값이 없는 경우 해당하는 데이터를 빠르게 찾을 수 있습니다.

        - 읽어야 하는 레코드 갯수
            - 인덱스는 일반적으로 단 하나의 데이터를 구할 때 가장 효율적
            - 여러 개의 데이터를 구한다면 인덱스를 통해 레코드의 주소를 찾아 데이터의 레코드를 읽는 작업을 반복해야 합니다.
            - 그래서 만약 많은 레코드를 한번에 조회한다면 오히려 인덱스를 사용하지 않고 직접 테이블을 읽는 것이 더 효율적일 수 있습니다.
            - 일반적으로 DBMS 의 옵티마이저는 인덱스를 사용해 레코드 1건을 읽는 것이 테이블에서 직접 읽는 것보다 4 ~ 5배 정도 비용이 더 많이 든다고 예측
            - 그러므로 인덱스를 통해 읽어야 할 레코드가 전체 테이블의 20 ~ 25% 이상이라면 직접 테이블을 읽는 것이 효율적

        - 인덱스(Index)의 단점
            인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지 시켜줘야 한다는 점입니다.
            INSERT, UPDATE, DELETE 를 통해 데이터가 추가되거나 값이 바뀐다면 INDEX 테이블 내에 있는 값들을 다시
            정렬을 해야겠죠. 그리고 INDEX 테이블, 원본 테이블 이렇게 두 군데에 데이터 수정 작업해줘야 한다는 단점도 있습니다.
            그리고 검색시에도 인덱스가 무조건 좋은 것이 아닙니다. 인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를
            처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫습니다. 그리고 인덱스를
            관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요합니다. 무턱대고 INDEX 를
            만들어서는 결코 안 될 말입니다.

            UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해준다.
            만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어,
            SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.

            기본적으로 인덱스는 데이터를 삭제하더라도 사용안함 표시를 해주고 끝이지 실제로 사라지는 것이 아니다.
            또한 update 문을 사용해서 데이터를 수정하는 경우에도 우리 눈에는 그냥 수정만 된것이지만 내부적으로는 delete 후에
            다시 insert 해주는 로직을 따르고 있다.
            그렇기 때문에 DML 이 자주 일어나는 table 에서는 오히려 인덱스 테이블이 원래 테이블보다 크기가 커지는 경우가 발생하게 되고,
            그렇게 되면 인덱스를 사용하는 의미가 사라진다.

        - 인덱스(Index)의 관리
            앞서 설명했듯이 인덱스는 항상 최신의 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다.
            그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE 가 수행된다면 계속 정렬을 해주어야 하고 그에
            따른 부하가 발생합니다. 이런 부하를 최소화하기 위해 인덱스는 데이터 삭제라는 개념에서 인덱스를 사용하지 않는다
            라는 작업으로 이를 대신합니다.
            INSERT: 새로운 데이터에 대한 인덱스를 추가합니다.
            DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행합니다.
            UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가합니다.

        - 인덱스 생성 전략
            생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는
            컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된
            Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를
            거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이
            인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.
                1. 조건절에 자주 등장하는 컬럼
                2. 항상 = 으로 비교되는 컬럼
                3. 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은) 컬럼
                4. ORDER BY 절에서 자주 사용되는 컬럼
                5. 조인 조건으로 자주 사용되는 컬럼

        -> 일반적으로 DBMS 의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도
           비용이 드는 작업. 즉, 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 사용하지 않고
           일반 테이블 검색하는 것이 좋다.

    - 인덱스 사용 시 주의사항
        - 다중 인덱스를 사용할 때 범위 조건은 인덱스를 타지만 이후 컬럼들은 인덱스를 타지 않음
            WHERE 컬럼1 = ?
            AND   컬럼2 = ?
            AND   컬럼3 BETWEEN ? AND ? -- 결합인덱스에서 '='이 아닌 연산자를 사용하는 첫 번째
            AND   컬럼4 = ?

            컬럼3에서 BETWEEN을 사용했기에 컬럼3 까지만 인덱스를 타고 후행컬럼인 컬럼4는 인덱스를 타지 않고 필터만 한다.
            그래서 결합인덱스 = 컬럼1 + 컬럼2 + 컬럼4 + 컬럼3으로 순서를 바꿔줘야한다.

        - 인덱스를 타지 않는 경우
            1. 인덱스 컬럼의 변형
                - 인덱스에 변형을 가하게 되면, DBMS가 인덱스를 이용하지 않는다.
                - 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 range scan 가능
                  인덱스 칼럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문
                  그래서 인덱스 칼럼을 가공하면 index full scan 을 하게 된다. ??

                - 수식이나 함수 등으로 인덱스 컬럼 절을 변형하였을 경우 인덱스를 타지 않는다.
                - 반드시 함수나 수식을 사용해야하는 경우에는 인덱스 컬럼에 적용하지 말고, 대입되는 컬럼이나 상수에 적용해야 한다.
                - 기존에 저장된 데이터 기준으로 소트하여 인덱스를 만들어 놓았는데 칼럼이 변형되면 인덱스 스캔 시작점을 찾을 수 없다.
                  따라서 table full scan 하게 된다. ??

            2. 부정형의 사용
                - NOT일 경우 무조건 인덱스를 안타는 것이 아니라 일반적으로 NOT에 사용된 값이 아닌 데이터 비율이 높은 경우가 많기 때문에 인덱스를 타지 않는다. ??
                - 예를 들어 CAR가 아닌 것을 조회하라고 한다면
                  무었 무었을 찾아라 가 아니고 CAR 가 아닌 것이 무었인지 모르지만 그것을 찾아라
                  이런 문장은 CAR가 아닌것이 무었인지 전부 찾아 보아라 하는 말이다
                - 또는 테이블을 한 번 더 읽어 NOT EXISTS 를 사용 ??

            3. IN 연산자 사용
                - IN일 경우에도, IN에 포함된 데이터들의 비율이 매우 높다면 FULL SCAN을 하는 것이 낫다고 DBMS가 판단하면 인덱스를 타지 않는다.
                - Mysql에서는 range_optimizer_max_mem_size 설정의 용량을 In절의 파라미터가 넘어서면 FullScan을 한다.
                  다른 DB의 경우도 파라미터가 많아지면 옵티마이저가 FullScan을 할 수 있다.
                - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다. ??
                  하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

            4. LIKE문을 사용할 때 전체 범위를 설정할 시
                - 문자열로 이루어진 값을 인덱스로 잡았을 때, %가 앞쪽에 사용되면 정렬 순서를 사용할 수 없으므로 테이블 FULL SCAN이 이루어진다.
                  select * from table  where name like 'word%'; -> 쿼리가 이런 경우 인덱스를 탄다. 문자열 정렬 순서를 그대로 이용할 수 있기 때문이다. (Index Range Scan 이 가능)
                  인덱스를 걸면 해당 컬럼은 정렬이 됩니다. 정렬된 문자열 앞부분부터 검색해야 하는데, LIKE절이 '%'로 시작하면 앞 문자열을 모르니 인덱스를 사용할 수 없게 됩니다.

                - 정규표현식 REGEXP 을 사용해도 인덱스를 더치지 않고 풀 스캔이 일어난다.
                - 가능하면 INSTR 을 사용하는 것도 나쁘지 않다. INSTR('비교할 대상', '비교하고자 하는 값', 비교를 시작할 위치, 검색된 결과의 순번)
                  select * from table where INSTR(column_name, value) > 0  ???

            5. 복합인덱스에서 첫인덱스가 첫조건으로 적용하지 않았을경우
                - select * from table where name = 'word' or idx = 5 ??
                - name과 idx가 둘다 인덱스가 걸려있는 경우라해도, DBMS가 최적의 OR 조건을 뽑기 힘들어, FULL SCAN 하는 경우가 많다. (내용이 안맞음)

            6. NULL 조건의 사용
                - NULL 인 값이 많지 않아 인덱스를 통해 엑세스를 하고자 한다면 데이터 생성 시 디폴트로 0과 같이 데이터를 만들어주 는 것이 좋다.
                - 만약, NOT NULL 이 분석 대상이라면 해당 컬럼을 NULL 허용 컬럼으로 두는 것이 좋다.

                오라클에서는 NULL 값을 인덱스에 저장하지 않는다.    https://kihyun-log.tistory.com/entry/NULLABLE-%EC%BB%AC%EB%9F%BC%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%82%AC%EC%9A%A9-Oracle-vs-MySQL
                따라서 오라클에서는 NULL 이 허용된 컬럼에 대해 인덱스를 생성해도
                IS NULL 혹은 IS NOT NULL 조건으로 조회시 인덱스를 사용할 수 없고, group-by 혹은 distinct 사용시 인덱스를 사용할 수 없다.
                (NULL이 있는지 없는지 FULL SCAN을 해야만 알 수 있으므로)

                하지만 MySQL/Maria 에서는 NULL 값도 인덱스에 저장한다.
                따라서 컬럼을 IS NULL 혹은 IS NOT NULL로 비교해서 인덱스를 사용할 수 있고,
                group-by 및 distinct 사용시 인덱스를 사용할 수 있다.

            7. 인덱스 컬럼의 내부적인 데이터 변환 ??(1번과 차이)
                - 문자값 데이터타입을 갖는 컬럼에 ‘값’ → 값 을 하지 말고 정확한 데이터 타입을 넣어야 인덱스를 탈 수 있다.
                - 서로 대입되는 항목끼리 데이터 타입이 다르면 내부적인 형 변환에 의해 컬럼이 함수를 사용한 것과 같은 효과를 나타낸다.

            8. OR 조건 사용
                - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다. ??
                - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

        - Full Table Scan 적용되는 경우
            - 적용 가능한 인덱스가 없는 경우
            - 인덱스 처리 범위가 넓은 경우
            - 크기가 작은 테이블에 엑세스하는 경우
                -> 데이터베이스가 인덱스를 적용해도 성능상의 이점이 없다고 판단했을 때 Full Table Scan 적용

    - 인덱스 튜닝
        1) 인덱스 스캔 효율화 튜닝
            - 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것
            - 인덱스 엑세스 조건(수직적 탐색 ,수평적 탐색)

        2) 랜덤엑세스 최소화 튜닝 (테이블의 엑세스 횟수를 줄이는 것)
            - 인덱스 스캔 후 테이블 레코드를 엑세스 할 때 랜덤 I/O 방식으로 사용하므로 이를 랜덤 액세스 최소화 튜닝이라고함.

    - 인덱스 구조
        - 범위 스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문
        - 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있음
            - 인덱스 수직적 탐색(인덱스 스캔 시작지점을 찾는 과정)
                정렬된 인덱스 레코드 중 조건을 만족하는 첫번째 레코드를 찾는 과정이다. 즉 인덱스 스캔 시작 지점을 찾는 과정
            - 인덱스 수평적 탐색(데이터를 찾는 과정)
                수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔함
                인덱스를 수평적으로 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾기위해  Rowid를 얻기 위해

    - 인덱스 기본 사용법
        - Range Scan을 못 쓰는 경우
            - 인덱스 가공
                - 인덱스 스캔 시작점을 찾을 수 없기 때문이다. 일정 범위를 스캔하려면 ‘시작지점’과 ‘끝지점’이 있어야 한다.

            - Like 문을 사용
                ex) where 업체명 like '%대한%'
                - LIKE로 검색해도 위와 같이 ‘대한’이라는 글자를 가진 인덱스를 중간 글씨에서 찾아야 하기 때문에, Range Scan이 불가능하다.

            - OR 조건
                - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능 ??

            - IN 조건
                - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다. ??

    - 인덱스 사용조건
        - range scan을 하기 위해선 가장 첫번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다.
          반대로 말하면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 range scan이 무조건 가능하다.

    - 인덱스를 이용한 소트 연산 생략
        - 인덱스 순으로 이미 정렬된 상태로 order by를 했다. 이것은 order by를 생략할 수 있다.
        - 만약 이렇게 인덱스가 구성되어있지 않다면 SORT ORDER BY 연산이 실행계획에 추가된다.
        - 조건절 뿐만 아니라 ORDER BY절이나 SELECT-LIST 에서 컬럼을 가공하여 인덱스를 정상적으로 못 사용하는 경우가 있다.
            - SELECT-LIST 에서 컬럼 가공
                select NVL(MAX(TO_NUMBER(변경순번)), 0)
                from 상태변경이력
                where 장비번호 = 'C'
                    and 변경일자 = '20180316'

                위와 같이 ‘변경순번’의 값을 숫자로 바꾸면 인덱스를 사용할 수 없다.
                왜냐면 인덱스는 문자열 기준으로 정렬되어 있는데 숫자값으로 바꾸었기 때문이다.

            - 자동 형변환
                select * from 고객 where 생년월일 = 19920920

                -- 이걸 옵티마이저가 이렇게 바꿈
                select * from 고객 where TO_NUMBER(생년월일) = 19920920

                - DBMS마다 다른데 오라클은 자동 형변환 하는 방식을 채택한다.
                - 형변환 우선순위
                    - 오라클에서 숫자형과 문자형이 만나면 숫자형이 이긴다.
                    - 날짜형과 문자형이 만나면 날짜형이 이긴다.
                    - 근데 LIKE가 출동하면 문자형이 이긴다.

    - 인덱스 스캔 방법
        - Index Range Scan
            - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 엑세스 방식
            - 수직적 탐색 후 필요함 범위(Range)만 수평적 탐색
            - 인덱스 스캔 범위와 테이블 액세스 횟수를 줄이는 것이 성능 향상의 길

            - 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
            - B-tree 인덱스에서 루트 노드와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로 인덱스를 읽어 나간다.
            - 리프 노드에서 저장된 레코드 주소로 데이터 파일의 레코드를 읽어 오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 발생한다.
            - 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%를 넘으면 순차 I/O를 사용한 테이블 풀 스캔이 낫다고 하는 것이다.

        - Index Full Scan
            - 수직적 탐색 없이 오직 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
            - 최적의 인덱스가 없을때, 차선으로 선택된다.

            - 선두 컬럼이 조건절에 없으면 옵티마이저가 Index Full Scan을 고려한다.
            - 만약 테이블이 고용량이면 인덱스 활용을 고려하지 않을 수 있다.
            - 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면, 면적이 큰 테이블보다 인덱스를 스캔하는 쪽이 유리하다.

            - 인덱스의 처음부터 끝까지 모두 읽는 방식
            - 쿼리의 조건절에 사용된 칼럼이 첫 번째 칼럼이 아닌 경우 사용된다.
                ex) 인덱스 (a,b,c) 칼럼의 순서로 만들어져 있지만, 쿼리의 조건절은 b 칼럼이나 c 칼럼으로 검색
            - 루트 노드의 첫 번째 인덱스 레코드와 이어진 브랜치 노드를 거쳐 리프 노드로 이동한다.
            - 해당 리프 노드의 첫 번째 페이지의 인덱스 레코드 방향부터 아래로 탐색한다.
            - 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 작은 경우가 많으므로 풀 테이블 스캔보다 적은 IO 로 쿼리를 처리할 수 있다.

        - Index Unique Scan
            - 수직적 탐색으로만 데이터를 찾는 방식으로, Unique 인덱스를 = (equal) 조건으로 탐색하는 경우
            - Unique 인덱스가 존재하는 컬럼은 중복값 없이 입력되지 않게 DBMS가 정합성 관리해준다. 그래서 데이터를 = 조건으로 찾은 후 더이상 탐색이 필요없다.
                - Unique 인덱스가 존재해도 Between, Like 등 범위 조건으로 검색하면 Index Range Scan을 한다.
                - Unique 결합 인덱스도 검색 할 때, Index Range Scan을 사용한다.

        - Index Skip Scan
            - 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 Index Skip Scan을 사용한다.
            - Index Skip Scan은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 갯수가 많을때 유용하다.
            - 선두 컬럼이 조건절에 있고, 중간 컬럼이 조건절에 없어도 Index Skip Scan을 사용할 수 있다.
            - Distinct Value 개수가 적은 두 개의 선두컬럼이 다 조건절에 없어도 Index Skip Scan 사용할 수 있다.
            - 선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위 검색 조건일때도 Index Skip Scan 사용할 수 있다.
            - 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 한다.
              만약 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때, 이들 스캔 방식을 차선책으로 활용하는 전략이 바람직하다.

            - 루스 인덱스 스캔 ??
                - 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
                - 인덱스 레인지 스캔과 비슷하게 동작하지만 중간마다 필요하지 않은 키 값은 무시한다.
                - 일반적으로 group by 또는 max 등의 함수에 대해 최적화할 때 사용한다.
                ex) select dept_no, MIN(emp_no)
                    from dept_emp
                    where dept_no between 'doo2' and 'd004'
                    group by dept_no;

                    dept_emp 테이블은 dept_no와 emp_no 2개의 컬럼으로 인덱스를 구성하고 있다고 가정하며, 이 인덱스는 (dept_no, emp_no)를
                    기준으로 정렬이 되어 있다. 즉 특정 dept_no 그룹 별로 처음에 있는 emp_no만 읽으면 된다. 즉, 인덱스에서 where 조건을
                    만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있으므로 중간 중간 조건에 맞지 않으면 건너 뛴다.

        - Index Fast Full Scan ?? (Index Full Scan 과 차이)
            - Index Fast Full Scan은 Index Full Scan보다 빠르다.
            - 그 이유는, 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문이다.
            - Index Fast Full Scan은 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다.
            - 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과 발휘한다.
            - 인덱스 키 순서대로 정렬되지 않다. (연결 리스트 구조를 무시해서 결과집합이 인덱스 키 순서대로 정렬되지 않음)
            - 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때 사용 가능함.
            - 병렬스캔 가능

        - Index Range Scan Descending
            - Index Range Scan과 기본적으로 동일 스캔방식이나, 인덱스를 뒤에서 앞으로 스캔하기 때문에 내림차순으로 결과집합을 얻는다.

    - Covering Index ?? (내용 보충)
        - 인덱스를 사용하면 특정 컬럼 값을 키로 하여 데이터의 주소값을 구한 뒤 해당 주소값으로 다시 테이블에 접근해서 최종 데이터를 구합니다.
        - 커버링 인덱스란 인덱스에 이미 필요한 데이터가 전부 존재해서 테이블에 접근할 필요가 없는 인덱스를 의미
        - 인덱스는 기본적으로 Non Clustered Index 에서 먼저 값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.
        - 여기서 커버링 인덱스가 사용되었다는건 Clustered Index 까지 통하지 않고 Non Clustered Index 만으로도 데이터를 구할 수 있다는 뜻
        - 커버링 인덱스가 적용되면 EXPLAIN 실행 시 Extra 필드에 Using index 라고 표시

        - SELECT / WHERE / GROUP BY / ORDER BY 등에 활용되는 모든 컬럼이 인덱스의 구성 요소인 경우
        - 커버링 인덱스를 잘 쓰면(특히, 대용량 데이터 처리 시), 조회 성능을 상당 부분 높일 수 있다.

    - 결합 인덱스란
        - 결합 인덱스란?
            결합 인덱스란 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말합니다. 주로 단일 컬럼으로는 나쁜 분포도를 가지지만
            여러 개의 컬럼을 합친다면 좋은 분포도를 가지고,
            Where 절에서 AND 조건에 많이 사용되는 컬럼들을 결합 인덱스로 구성합니다.
            1. where 절에서 and 조건으로 자주 결합되어 사용되면서 각각의 분포도 보다
               두 개 이상의 컬럼이 결합될 때 분포도가 좋아지는 컬럼들
            2. 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
            3. order by 에서 자주 사용되는 컬럼들
            4. 하나 이상의 키 컬럼 조건으로 같은 테이블의 컬럼들이 자주 조회될 때

        - 결합 인덱스의 컬럼 순서 결정
            결합 인덱스를 만들 때 결합 인덱스를 구성하는 컬럼들의 배열 순서는 아주 중요하기에 신중하게 결정하여야 합니다.
            컬럼의 순서를 잘못 배열하면 결합 인덱스의 발동 확률이 매우 낮아질 수 있기 때문입니다. 만약 select 문의
            where 절에 결합 인덱스의 첫 번째 컬럼을 조건에 사용하였다면 그 질의문은 결합 인덱스를 사용할 수 있습니다.
            하지만 개발자가 결합 인덱스의 두번째 컬럼만을 where 절에 조건으로 사용하고 결합 인덱스를 사용하고자 했다면
            실행계획은 인덱스를 사용하지 못합니다. 따라서 쿼리문 작성 시 결합 인덱스를 사용하고자 한다면 반드시 결합 인덱스의
            컬럼 중 선행하는 컬럼부터 조건에 지정하여 사용하여야 합니다. 조건은 컬럼 전체를 순서대로 사용할 수도 있고,
            아니면 선행하는 일부 컬럼을 순서대로 사용할 수 있습니다.

        - 결합 인덱스 컬럼의 설정 시 고려해야 할 우선순위
            1. where 절 조건에 많이 사용되는 컬럼이 우선시
            2. Equal('=')로 사용되는 컬럼 우선
            3. 분포도가 좋은 컬럼을 우선
            4. 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정

        - 복합 인덱스를 구성할 때
            - 인덱스는 여러 개의 컬럼을 동시에 지정할 수도 있는데 어떤 순서로 구성하느냐에 따라 성능이 달라집니다.
            - 인덱스는 트리 구조로 되어있다고 했는데, 여러 개의 컬럼을 함께 키 값으로 지정하는 경우 먼저 첫 번재 컬럼을 기준으로 정렬된 뒤에 두번째 컬럼이 정렬되어 있습니다.
            - 이 말은 즉 첫 번째 컬럼 없이 두 번째 컬럼만 갖고 인덱스를 조회하면 제대로 된 위치를 찾을 수 없다는 뜻
            - 그러므로 복합 인덱스를 구성했다면 조회할 때 앞 순서의 조건을 반드시 포함해야 인덱스를 태울 수 있습니다.
            - 여러 개의 컬럼이 있다면 카디널리티가 높은 순에서 낮은 순으로 지정하는게 인덱스의 효율을 이끌어낼 수 있습니다.
            - 과거에는 인덱스의 컬럼 순서와 조회 컬럼 순서를 맞춰야 인덱스를 탔지만 최근에는 옵티마이저가 알아서 인덱스 순서에 맞춰주기 때문에 거의 차이가 없습니다.
            - 그래도 재배열하는 과정을 생략하기 위해 최대한 맞추는게 좋다.

            - 단일 컬럼 인덱스보다 더 비효율적으로 Insert/Update/Delete 를 수행하므로 가급적 업데이트가 안 되는 값을 선정해서 사용하는 것이 좋다.
            - 데이터를 조회할 때 단일 인덱스를 여러 개를 사용해야 하는 경우가 많다면 다중 컬럼 인덱스를 고려해 본다.

        - 결합 인덱스의 효율성이 떨어지는 경우
            결합 인덱스도 일반적인 인덱스와 마찬가지로 데이터들이 정렬되어 보관되기 때문에 소수의 데이터를 빠르게 찾는 것에는
            유리하지만 아래와 같이 스캔이 많이 생기게 된다면 효율성이 떨어지게 됩니다.

            아래의 예시들은 emp_pay_idx 인덱스를 사용하기는 하지만 스캔이 많이 생기는 경우로 인덱스의 효율성이
            떨어지는 경우들의 예시입니다.

            select * from emp_pay where 급여년월 LIKE '2021%' and 급여코드 = '정기급여';
            위 조건절의 경우 결합 인덱스의 첫 번째 컬럼인 급여년월의 조건이 있더라도 Equal(=)이 아닌 범위 연산자인
            LIKE '2021%' 조건을 사용했으므로, 세개의 칼럼이 모두 필요한 emp_pay_idx 인덱스를 찾을 때 두번째 칼럼인
            급여코드에 대한 조건을 B*Tree 에서 쉽게 찾을수가 없게 됩니다. 이는 결합 인덱스가 각 칼럼별로 정렬이 되어 있는
            것이 아니라 첫번째, 두번째, 세번째 칼럼이 결합이 되어 정렬이 되어있기 때문입니다. 이때 급여코드에 대한 조건은
            인덱스를 찾아가는 검색조건이 아니라 인덱스 값이 조건에 맞는지 여부를 검증하는 체크 조건이 됩니다.

            select * from emp_pay where 급여년월 = '202107' and 사원번호 = '20210401';
            위 조건절의 경우는 결합 인덱스의 첫번째 칼럼인 급여년월의 조건이 equal(=)이더라도 두번째 컬럼인 급여코드에
            대한 조건이 없으므로 세번째 칼럼인 사원번호 조건을 검색 조건이 아닌 체크 조건으로 밖에 사용할 수 없게 됩니다.
            즉 결합 인덱스에서 급여년월인 모든 데이터를 찾아서 사원번호 조건에 맞는지 일일이 확인하는
            풀 테이블 스캔이 일어나고 있는 셈입니다.

    - 인덱스를 리빌드하는 이유
        인덱스 파일은 생성 후 insert, update, delete 등을 반복하다보면 성능이 저하됩니다. 생성된 인덱스는
        트리구조를 가집니다. 삽입,수정,삭제등이 오랫동안 일어나다보면 트리의 한쪽이 무거워져 전체적으로 트리의 깊이가
        깊어집니다. 이러한 현상으로 인해 인덱스의 검색속도가 떨어지므로 주기적으로 리빌딩하는 작업을 거치는것이 좋습니다.

        SELECT I.TABLESPACE_NAME,I.TABLE_NAME,I.INDEX_NAME, I.BLEVEL,
               DECODE(SIGN(NVL(I.BLEVEL,99)-3),1,DECODE(NVL(I.BLEVEL,99),99,'?','Rebuild'),'Check') CNF
        FROM   USER_INDEXES I
        WHERE   I.BLEVEL > 4
        ORDER BY I.BLEVEL DESC

        해당쿼리는 index 트리의 깊이가 4이상인 index  를 조회하는 쿼리입니다.
        해당 쿼리문을 실행하여 검색되는 index 가 있다면 리빌딩을 하는것이 좋습니다.

    - 인덱스(Index)를 남발하지 말아야 하는 이유
        개발을 진행할 때에 대개 개발서버와 운영서버를 나누어서 관리합니다. 대부분 개발서버에서 개발을 할때에는 적은량의
        데이터를 가지고 로직검사를 하며 로직검사에 통과한 코드들이 운영서버에 업데이트가 되죠. 하지만 개발서버에는 잘 동작하던
        로직들이 운영서버의 많은량의 데이터들을 처리하다보면 성능이슈가 많이 발생합니다. 그 성능이슈의 주요원인은
        바로 데이터베이스에 있습니다. 데이터베이스 관리자는 성능문제가 발생하면 가장 빨리 생각하는
        해결책이 인덱스 추가 생성입니다.

        하지만 문제를 그저 쉽게 해결하기 위해 쿼리 속도 문제가 날때마다 인덱스를 추가하는것은 바람직하지 못합니다.
        성능 이슈가 나서 인덱스를 만들고 또 다른 SQL 문에서 성능이슈가 발생하여 또 인덱스를 만들었다고 합시다.
        이렇게 문제가 발생할때마다 인덱스를 생성하면서 인덱스가 계속 추가되면 생성된 인덱스를 참조하는 하나의 쿼리문을
        빠르게는 만들 수 있지만 전체적인 데이터베이스의 성능 부하를 초래합니다. 그렇기에 인덱스를 생성하는것 보다는
        SQL 문을 좀 더 효율적으로 짜는 방향으로 나가야합니다. 인덱스 생성은 꼭 마지막 수단으로 강구해야 할 문제입니다.

    - 인덱스 설계과정
        SQL별 접근경로조사 : 개발된 모든 SQL확인, 조건, 형변환등확인 표로정리
        테이블별 접근 경로 정리 : 테이블별 조인 조건 확인
        종합적인 인덱스 설계
        핵심 테이블 및 핵심 SQL 집중 설계
        인덱스 생성 및 모니터링 : 생성 후에 모니터링을 통한 개선 필요.


- B- 트리
    - B- 트리란?
        - B트리는 이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 벨런스를 맞추는 트리
        - 정렬된 순서를 보장
        - B-Tree 인덱스는 Root Block, Branch Block, Leaf Block 으로 나누어지며, 그림과 같이 Leaf block 은 양방향 링크를 가지고 있어서, 오름차순, 내림차순 검색이 가능하다.
        - 보통 B 트리라고 하면 B- 트리를 의미한다. B 트리는 트리 자료구조의 일종으로 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.
            - 노드에는 2개 이상의 데이터(key)가 들어갈 수 있으며, 항상 정렬된 상태로 저장된다.
            - 내부 노드는 M/2 ~ M개의 자식을 가질 수 있다. 최대 M개의 자식을 가질 수 있는 B 트리를 M차 B트리라고 한다.
            - 특정 노드의 데이터(key)가 K개라면, 자식 노드의 개수는 K+1개여야 한다.
            - 특정 노드의 왼쪽 서브 트리는 특정 노드의 key 보다 작은 값들로, 오른쪽 서브 트리는 큰 값들로 구성된다.
            - 노드 내에 데이터는 floor(M/2)-1개부터 최대 M-1개까지 포함될 수 있다
            - 모든 리프 노드들이 같은 레벨에 존재한다.

    - B-Tree 동작 방식
        1단계, 브랜치 블록의 가장 왼쪽 값이 찾고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동
        2단계, 찾고자 하는 값이 브랜치 블록의 값 사이에 존재하면 가운데 포인터로 이동
        3단계, 오른쪽에 있는 값보다 크면 오른쪽 포인터로 이동

    - B- 트리 탐색 과정
        - B- 트리는 루트 노드에서 탐색을 시작하여 하향식으로 탐색을 진행한다. 찾고자 하는 값이 K라면 다음과 같은 과정을 거친다.
            1. 루트 노드에서 탐색을 시작한다.
            2. K를 찾았다면 탐색을 종료한다.
            3. K와 노드의 key값을 비교해 알맞은 자식 노드로 내려간다.
            4. 해당 과정을 리프 노드에 도달할 때까지 반복한다.
            5. 리프 노드에서도 K를 찾지 못한다면 트리에 값이 존재하지 않는 것이다.

    - B- 트리 삽입 과정
        - 탐색과는 다르게 상향식으로 진행된다. B- 에서의 데이터 삽입은 항상 리프 노드에서 시작된다.
            1. 트리가 비어있다면 루트 노드를 할당하고 K를 삽입한다.
            2. 트리가 비어있지 않다면, 데이터를 넣을 적절한 리프 노드를 탐색한다.
            3. 리프 노드에 데이터를 넣고 리프 노드가 적절한 상태에 있다면 종료한다.
            4. 리프 노드가 부적절한 상태에 있다면 분리한다.

            이때, 적절한 상태란 해당 노드의 데이터 개수가 허용 범위 안에 있는 것이다. 반대로 부적절한 상태란 해당 노드의 데이터 개수가 허용 범위를 벗어나 너무 많은 상태를 뜻한다.

            - Case 1 : 분리가 일어나지 않는 경우
                1. 데이터를 삽입할 리프 노드를 탐색하고, 해당 노드에 데이터를 삽입한다.
                2. 해당 노드가 적절한 상태에 있다면, 삽입을 종료한다.

            - Case 2 : 분리가 일어나는 경우
                1. 데이터를 삽입할 리프 노드를 탐색하고, 해당 노드에 데이터를 삽입한다.
                 2-2. 해당 노드의 왼쪽 키들은 왼쪽 자식으로, 오른쪽 키들은 오른쪽 자식으로 분리된다.
                 2-3. 부모 노드를 검사해 부모 노드가 부적절한 상태에 있다면 위와 같은 분리를 반복한다.

    - B- 트리 삭제 과정
        - 노드를 삭제하는 과정 중 조건이 위반되면 조건에 맞도록 트리를 재구조화시켜야 한다.

        - Case 1. 리프 노드에서 삭제
            - Case 1-1) 리프 노드에서 값을 삭제하더라도 최소 유지 개수 조건을 만족하는 경우
                - 이 경우 바로 노드를 삭제해주면 된다.
            - Case 1-2) 리프 노드에서 값을 삭제할 때, 최소 유지 개수를 만족하지 못하지만 바로 옆 형제 노드들에게 값을 빌려올 수 있는 경우
                - K를 Parent와 바꿔준다. 이후 왼쪽 형제 노드에게서 값을 빌려올 수 있다면 Lmax와 Parent를, 오른쪽 형제에게서 값을 빌려올 수 있다면
                  Rmin과 Parent를 바꿔주면 된다. 둘 다 가능하면 하나를 선택하면 된다.
            - Case 1-3) 리프 노드에서 값을 삭제할 때, 최소 유지 개수를 만족하지 못하고 형제 노드들에게 값을 빌려올 수 없지만, 부모 노드를 분할할 수 있을 때
                - K를 삭제하고, Parent를 부모 노드에서 분할하여 형제 노드에 합친다. 이렇게 하면 부모 노드의 key가 하나 줄고, 자식 노드의 수도 하나 줄어들어 최소 유지 개수를 만족한다.
            - Case 1-4) 리프 노드에서 값을 삭제할 때, 최소 유지 개수를 만족하지 못하고, 형제 노드들에게 값을 빌려올 수 없고 부모 노드도 분할할 수 없을 때
                - 이 경우는 Case 2-2)의 경우와 동일

        - Case 2. 리프 노드가 아닌 내부 노드에서 삭제
            - Case 2-1) 내부 노드에서 값을 삭제할 때, 현재 노드 혹은 자식 노드의 최소 유지 개수의 최소보다 큰 경우
                - K의 Lmax 혹은 Rmin과 자리를 바꿔준다. 이후 리프 노드에서의 K 삭제와 과정이 동일
            - Case 2-2) 내부 노드에서 값을 삭제할 때, 현재 노드와 자식 노드 모두 key 개수가 최소인 경우
                - 트리의 재구조화가 필요

- 커버링 인덱스
    https://jojoldu.tistory.com/476
    https://jojoldu.tistory.com/481


- 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기
    1. 프라이머리 키(PK, Primary Key)와 클러스터링 테이블
        - 프라이머리 키(PK, Primary Key)의 특성
            데이터베이스, 특히 MySQL에서 프라이머리 키(PK, Primary Key)는 상당히 신중하게 결정되어야 한다.
            그 이유는 PK가 레코드의 저장 위치를 결정하기 때문이다. 그래서 PK는 NOT NULL, 유니크 등의 특성을 갖는다.
            MySQL은 PK를 기준으로 유사한 값들이 함께 조회되는 경우가 많다는 점에서 착안하여, PK가 유사한 레코드들끼리 묶어서 저장한다.
            유사한 것들을 묶는 것을 클러스터링이라고 하는데, 그래서 일반적으로 PK는 클러스터 인덱스(Clustered Index)라고도 불리며, 그 외의 일반적인 인덱스는 논클러스터 인덱스로 불린다.
            그리고 이러한 클러스터링 특성 때문에 레코드의 저장이나 PK의 변경은 처리 속도가 느리다.
            왜냐하면 우선 레코드를 추가하기 위해 PK 기반으로 레코드의 저장 위치를 탐색해야 하기 때문이다. 그리고 PK를 변경하는 것은 레코드가 저장된 물리적인 위치를 변경하는 작업이 수반되기 때문이다.
            하지만 그럼에도 불구하고 이러한 특성을 갖는 이유는 쓰기 작업을 희생해서라도 빠르게 읽기 작업을 처리하기 위함이다. 읽기 작업이 더욱 우선시 되는 이유는 일반적인 온라인 환경에서 읽기와 쓰기의 비율이 8:2, 9:1 정도이기 때문이다.

        - 클러스터링 테이블의 저장 방식
            클러스터링 테이블이란 클러스터 인덱스를 갖는 테이블이다. MySQL에서는 기본적으로 PK가 클러스터 인덱스이며,
            PK가 없으면 내부적으로 PK를 만들어내므로 모든 테이블이 클러스터링 테이블이라고 볼 수 있다.
            PK는 인덱스와 마찬가지로 별도의 자료구조에서 관리가 된다. PK와 테이블의 저장 방식을 살펴보면 다음과 같은데,
            이는 리프 노드에 실제 레코드의 모든 컬럼 값이 저장되어 있다는 점을 제외하면 일반적인 인덱스와 동일하다.

        - PK와 인덱스의 관계
            PK가 레코드의 물리적인 저장 위치를 결정하기 때문에, 인덱스는 PK에 의존한다.
            그래야 인덱스를 타고 들어와서 PK를 통해 저장된 위치에서 레코드를 읽어올 수 있기 때문이다.

        - 클러스터 인덱스의 장점과 단점
            - 장점
                - PK로 검색할 때 처리가 매우 빠름
                - 연속되는 PK로 조회할 경우 랜덤 I/O가 아닌 순차 I/O를 사용하여 처리 속도가 더욱 빠름
                - 인덱스가 PK값을 가지므로 인덱스로 PK 값만 조회하는 경우 효율적으로 처리될 수 있음(=커버링 인덱스)
            - 단점
                - 모든 인덱스가 PK에 의존하므로 PK 값이 클 경우 전체적으로 인덱스의 크기가 커지고, 페이지 양이 많아짐
                - 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림
                - INSERT 시에 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
                - PK를 변경할 때 레코드를 DELETE 및 INSERT 해야 하므로 처리 성능이 느림

            먼저 PK는 물리적인 저장 위치를 저장한다.
            그래서 PK로 검색 시에 처리가 매우 빠르며, 특히 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데, 랜덤 I/O는 임의의 장소에서 데이터를 가져오지만
            순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다. 그 외에도 인덱스가 PK 값을 가지므로,
            인덱스를 통해 PK만 조회하는 경우라면 내부 테이블까지 조회하지 않아도 되므로 효율적으로 처리된다.

            하지만 단점 역시 적지않다. 먼저 PK가 물리적인 저장 위치를 결정하므로 인덱스를 관리할 때 PK를 같이 저장한다. 데이터의 작업 단위는 페이지인데,
            PK가 클수록 다른 인덱스 구조도 커지면서 페이지가 많이 쪼개져 디스크 I/O 횟수가 증가하는 문제가 있다.
            또한 인덱스에 PK가 의존하여 저장되므로 인덱스로 조회 시에 인덱스로 PK를 찾고, PK로 레코드를 찾아야 한다.
            그 외에도 레코드를 INSERT 하거나 PK를 UPDATE 하는 등의 경우에 레코드의 저장 위치를 탐색해야 하므로 추가적인 성능 문제가 생길 수 있다.
            이러한 단점들에도 불구하고 일반적인 온라인 환경에서는 읽기 비중이 훨씬 높다. 그렇기 때문에 쓰기 성능을 희생해서라도 읽기 성능을 확보하는 것이다.

    2. 프라이머리 키(PK, Primary Key)의 동작 방식
        - PK가 없는 경우
            MySQL에서 테이블은 PK 기반으로 저장되기 때문에 PK가 필수적이다. PK가 없다면 데이터베이스(구체적으로는 스토리지 엔진)에서 별도의 처리를 통해 PK를 설정하는데, 다음과 같은 순서를 따른다.
                1. 기본적으로 PK를 클러스터링 키로 선택함
                2. PK가 없다면 NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택함
                3. 후보군이 없다면 내부적으로 자동 증가 유니크 컬럼을 추가한 후 클러스터링 키로 선택함

            3번으로 생성되는 내부 PK는 사용자에게 노출되지 않으며, 쿼리에서 사용할 수도 없다. 클러스터 인덱스는 테이블 당 하나만 가질 수 있는 엄청난 혜택이므로 반드시 생성해주는 것이 좋다.

        - PK를 변경하는 경우
            PK는 레코드의 저장 위치를 결정한다. 이 말은 PK가 변경되는 경우에 레코드가 저장된 물리적인 위치도 변경되어야 함을 의미
            PK는 물리적인 레코드의 저장 위치를 결정하기 때문에 단순히 값만 변경해서는 안되고, 레코드를 DELETE 한 후에 INSERT 해주어야 한다.
            따라서 2번의 디스크 I/O 작업이 필요하고, 인덱스 쪽에도 추가 작업을 유발할 수 있어서 비용이 상당히 크므로 PK는 변하지 않는 값으로 설정하는 것이 중요하다.


- B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기
    1. B-Tree 인덱스와 인덱스가 필요한 이유
        - B-Tree 구조란?
            B-Tree는 자식 2개 만을 갖는 이진 트리(Binary Tree)를 확장하여 N개의 자식을 가질 수 있도록 고안된 것
            좌우 자식 간의 균형이 맞지 않을 경우에는 매우 비효율적이라, 항상 균형을 맞춘다는 의미에서 균형 트리(Balanced Tree)라고 불린다.
            B-Tree는 최상위에 단 하나의 노드 만이 존재하는데, 이를 루트 노드(Root Node)라고 한다. 그리고 중간 노드를 브랜치 노드(Branch Node), 최하위 노드를 리프 노드(Leaf Node)라고 한다.

        - 페이지(Page)란?
            디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위
            반적인 인덱스를 포함해 PK(클러스터 인덱스)와 테이블 등은 모두 페이지 단위로 관리된다.
            따라서 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 블록을 읽어야 하는 것이다.
            그래서 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여, 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 상당히 중요하다.
            페이지에 저장되는 데이터의 크기가 클수록 다음과 같은 문제가 생길 수 있다.
                디스크 I/O가 많아질 수 있음
                메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음
            만약 레코드를 찾는데 1개의 페이지만으로 처리가 안된다면 다른 페이지를 읽어야 하는데, 추가 페이지를 읽는 디스크 I/O 때문에 성능이 떨어지게 된다.
            메모리의 효율을 위해서도 중요하다. 디스크 I/O를 통해 페이지를 읽어오면 버퍼풀이라는 메모리에 캐싱해둔다.
            그런데 개별 데이터의 크기가 커지면 페이지 자체의 크기가 커지면서, 메모리에 캐싱해둘 수 있는 페이지 수가 줄어들게 된다.
            DB 성능 개선 혹은 쿼리 튜닝은 디스크 I/O 자체를 줄이는 것이 핵심인 경우가 많다.

        - B-Tree 인덱스의 구조
            인덱스는 페이지 단위로 저장되며, 인덱스 키를 바탕으로 항상 정렬된 상태를 유지
            정렬된 인덱스 키를 따라서 리프 노드에 도달하면 (인덱스 키, PK) 쌍으로 저장되어 있다.
            모든 페이지는 키 값을 기준으로 정렬되어 있다.
            데이터를 따라 리프노드에 도달하면 인덱스 키에 해당하는 레코드의 PK 값이 저장되어 있다. 테이블 영역도 인덱스와 유사한데, 리프 노드에 실제 테이블의 레코드가 저장되어 있다는 점만 다르다.
            인덱스는 테이블과 독립적인 저장 공간이므로 인덱스를 통해 데이터를 조회하려면 먼저 PK를 찾아야 한다.
            PK로 레코드를 조회할 때는(인덱스 영역에서 테이블 영역으로 넘어가는 경우) PK가 어느 페이지에 저장되어 있는지 알 수 없으므로 랜덤 I/O가 발생한다.
            이후에는 PK를 따라 리프노드에서 실제 레코드를 읽어온다. 참고로 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데,
            랜덤 I/O는 임의의 장소에서 데이터를 가져오지만 순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다.

        - 인덱스가 필요한 이유
            인덱스를 통해 데이터를 조회하는 것은 아래의 2가지 작업이 수행되는 것
                인덱스를 통해 PK를 찾음
                PK를 통해 레코드를 찾음
            이러한 이유로 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블을 통해 직접 읽는 것 보다 4~5배 정도 비용이 더 많이 드는 것으로 예측한다.
            하지만 DBMS는 우리가 원하는 레코드가 어디있는지 모르므로, 모든 테이블을 뒤져서 레코드를 찾아야한다. 이는 엄청난 디스크 읽기 작업이 필요하므로 상당히 느리다.
            하지만 인덱스를 사용한다면 인덱스를 통해 PK를 찾고, PK를 통해 레코드를 저장된 위치에서 바로 가져올 수 있으므로 디스크 읽기가 줄어들게 된다.
            그렇기 때문에 레코드를 찾는 속도가 훨씬 빠르며, 이것이 인덱스를 사용하는 이유이다.
            반면에 인덱스를 타지 않는 것이 효율적일 수도 있다. 인덱스를 통해 레코드 1건을 읽는 것이 4~5배 정도 비싸기 때문에,
            읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 효율적이다. 이런 경우 옵티마이저는 인덱스를 이용하지 않고 테이블 전체를 읽어서 처리한다.

    2. 인덱스 사용에 영향을 주는 요소
        - PK의 크기
            MySQL에서는 PK가 레코드의 물리적인 저장 위치를 결정하는 키
            PK가 레코드의 물리적인 저장 위치를 결정하기 때문에, 인덱스는 PK에 의존한다.
            그래야 인덱스를 타고 들어와서 PK를 통해 레코드의 값을 읽어올 수 있기 때문이다.
            인덱스가 PK가 아닌 실제 레코드의 주소를 갖게 할 수도 있지만, 그러면 PK가 변경될 때 레코드의 주소가 변경되고 모든 인덱스에 저장된 레코드 주소를 변경해야 한다.
            이러한 오버헤드를 피하기 위해 인덱스는 레코드의 주소가 아닌 PK를 저장하고 있다.
            따라서 PK 값이 클수록 인덱스에 좋지 않다. PK가 클수록 한 페이지에 담을 수 있는 인덱스 정보도 줄어들고, 메모리도 비효율적으로 사용되기 때문이다.
            또한 트리의 깊이도 지나치게 깊어지면서 되면서 읽어야 하는 페이지가 많아져서 성능에 좋지 않다.

        - 인덱스의 컬럼 순서
            (PK를 포함하여) 인덱스는 여러 개의 컬럼으로 구성될 수 있는데, 이를 다중 컬럼 인덱스(Multi-column Index)
            두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬된다. 그렇기 때문에 두 번째 컬럼 만으로 질의하는 경우는 인덱스를 제대로 타지 못한다.

        - 카디날리티(Cardinality)
            카디날리티란 특정 컬럼에 존재하는 데이터의 고유성을 의미한다. 따라서 카디날리티가 높을수록 중복도가 낮아지며, 유니크한 값이 많다는 것이다.
            항상 그런 것은 아니지만 일반적으로 값이 유니크할수록 검색 대상이 줄어들어서 처리가 빠르다.
            MySQL은 인덱스의 통계 정보를 관리하는데, 그 중에 유니크한 값의 개수가 있다. 그래서 인덱스 별로 평균적으로 몇 건의 레코드가 있는지를 계산하여 이를 쿼리 시에 활용한다.
            일반적으로 인덱스는 유니크할수록 효율적이다. 하지만 카디날리티가 낮더라도 정렬 또는 그루핑 등에 효율적으로 사용될 수 있으므로, 용도에 맞게 적절히 설계하는 것이 중요하다.
            추가로 MySQL에서 값이 1개만 존재하도록 제약이 필요하다면 다른 방법이 없어서 유니크 인덱스를 만들어야 할 수도 있다.
            유니크 인덱스는 무결성을 위해 중복 검사가 필요하여 쓰기 성능을 희생해야 한다. 대신 1건만 읽어도 되므로 읽기 성능은 높아진다.

        - 인덱스의 정렬 및 스캔 방향
            인덱스는 설정된 정렬 규칙에 따라 정렬되어 저장된다.
            인덱스를 정렬 순서대로만 읽을 수 있는 것은 아니다. 인덱스가 오름차순으로 생성되었어도 내림차순으로 읽는 것이 가능하며,
            인덱스를 읽는 방향은 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.
            이렇듯 인덱스를 순서대로 읽는 것을 인덱스 정순 스캔(Index Forward Scan), 반대 방향으로 읽는 것을 인덱스 역순 스캔(Index Backward Scan)
            인덱스 역순 스캔은 인덱스 정순 스캔보다 느린데, 그 이유는 다음과 같다.
                페이지 잠금이 인덱스 정순 스캔에 적합한 구조임
                페이지 내에서 인덱스 레코드가 단방향으로만 연결뒨 구조임
            리프 노드의 페이지는 이중 연결 리스트로 되어 있다. 하지만 페이지 잠금 과정에서 데드락을 방지하기 위해 잠금을 획득하는 것이 정순에서만 가능하고,
            역순은 복잡한 과정이 필요하다고 한다. 이 부분은 구조적으로 인덱스 스캔이 정순에 적합하다고만 알고 넘어가면 된다.
            그 다음으로는 페이지 내에서 인덱스가 단방향으로만 연결되어 있기 때문이다. 위의 그림에서는 인덱스가 양방향으로 연결된 것처럼 그려져있지만 실제 내부는 조금 다르다.
            페이지 내부에서는 순차적으로 4~8개 정도씩 묶어서 그룹을 만든다. 그리고 그룹의 대표키를 선정해 리스트로 관리하는데, 이를 페이지 디렉토리(Page Directory)라고 한다.
            문제는 페이지 디렉토리가 단방향 연결이라서, 역방향으로 접근이 불가능하다. 그래서 역순 스캔의 경우 일부 단방향 접근이 필요하므로 역순 스캔이 정순 스캔보다 느린 것이다.

    3. 레코드 추가, 삭제, 수정이 인덱스에 미치는 영향
        - 레코드 추가
            레코드가 추가되면 인덱스도 같이 추가되어야 하며, 인덱스는 항상 정렬된 상태를 유지해야 하므로 적절한 위치 탐색 후에 저장된다.
            따라서  레코드 추가 비용이 1이라면 인덱스 추가 비용은 1.5 정도로 가정한다. 인덱스가 없다면 작업 비용이 1이고,
            B-Tree 인덱스가 3개 있다면 작업 비용을 5.5 정도(1+ 1.5*3)로 예측한다. 참고로 이때의 작업 비용은 디스크 I/O 비용이기 때문에 상당히 비싸다.
            그래서 인덱스 추가 작업을 즉시 처리하지 않고, 메모리에 모아서 한 번에 쓰도록 지연시킬 수도 있다. 그러면 디스크 쓰기 횟수를 줄일 수도 있고, 요청 시에 메모리에서 바로 결과를 반환하는 등의 장점이 있다.
            하지만 유니크 인덱스처럼 중복 체크 등의 무결성이 필요하다면 즉각 반영되기도 한다. 유니크 인덱스라면 중복 값의 유/무를 검사한 후에 저장해야 한다.
            이때 중복된 값을 체크하기 위해서는 읽기 잠금을 쓰기를 할 때는 쓰기 잠검을 사용하는데, 이 과정에서 데드락이 아주 빈번히 발생한다.
            유니크 인덱스의 저장이나 변경은 상당히 빠르게 처리되지만, 중복 검사 때문에 작업을 지연할 수 없어서 좋지 않다.
            그렇기에 유니크 인덱스는 반드시 유일성이 보장되어야 하는 경우에 사용하는 것이 좋다.
            레코드를 추가하다가 페이지가 꽉찼다면 추가 디스크 작업이 필요하다. 인덱스의 리프 노드 페이지가 가득 찼다면 리프 노드를 분리해야 하는데,
            그러면 상위 노드(루트 또는 브랜치 노드)에 저장된 자식 노드의 값까지 갱신하는 작업이 필요하다.

        - 레코드 삭제
            레코드를 삭제하면 인덱스도 삭제돼야 하는데, 이는 인덱스의 리프 노드에 삭제 마킹만 하면 된다. 삭제 마킹 역시 디스크 쓰기 작업이므로 이 작업도 지연 처리될 수 있다.
            또한 삭제 마킹된 공간은 계속해서 방치시킬 수도 있고, 재활용할 수도 있다.
            참고로 레코드를 삭제하는 작업이 PK나 인덱스가 사용되는 쿼리라면 이를 활용해서 처리되며, 이는 레코드 수정에서도 동일하다.
            MySQL에서 인덱스는 조금 더 특별한 주의가 필요하다. MySQL의 잠금 중 일부(레코드 잠금, 넥스트 키락 또는 갭락)는 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.
            따라서 UPDATE나 DELETE를 실행 시에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그며, 심지어 테이블의 모든 레코드를 잠글 수도 있기 때문이다.

        - 레코드 수정
            레코드 수정은 결국 레코드를 추가하고 삭제하는 것이며, 수정 대상은 크게 PK, 인덱스, 일반 값이 있다.
            먼저 PK가 수정되는 경우는 살펴봤듯 최소 2번(DELETE, INSERT)의 쓰기 작업이 필요하다.
            그리고 해당 테이블에 인덱스가 있다면 인덱스에도 추가 작업이 필요하므로 상당히 비용이 많이 든다. 인덱스가 수정되는 경우에는 테이블 뿐만 아니라 인덱스에 추가 작업이 반드시 필요하므로,
            해당 작업도 비용이 많이든다. 따라서 인덱스와 PK는 최대한 변경을 피해야 한다.
            그 외의 값이 수정되는 경우는 테이블만 작업하면 되므로 비교적 수월하다.
            참고로 레코드 수정은 결국 DELETE 후에 INSERT하는 작업이라서 PK나 인덱스가 사용되는 쿼리라면 이를 활용하여 처리된다.

        - 레코드 검색
            레코드를 검색하는 작업 역시 PK를 사용하는 경우, 인덱스를 사용하는 경우, 그 외의 값을 사용하는 경우가 있다. 앞서 살펴보았듯 인덱스는 쓰기 작업에 비용이 많이 필요한데, 그럼에도 불구하는 이유는 빠른 검색을 위해서이다.
            PK로 검색하는 경우는 데이터가 저장된 위치를 바로 알 수 있기 가장 효율적이다.
            그 다음 인덱스로 조회하는 것은 인덱스를 통해 PK 값을 찾고, PK를 통해 레코드를 읽어온다. 그래서 PK 보다는 조금 비효율적이지만,
            그래도 효율적이다. PK와 인덱스 모두 키를 기반으로 트리 검색을 통해 빠르게 값을 찾아온다.
            만약 인덱스가 유니크 인덱스라면 쓰기 작업과 마찬가지로 약간의 차이가 있다. 인덱스의 유니크 여부는 DBMS 쿼리를 실행하는
            옵티마이저에게 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 알려주는 것이다.
            그 외에도 유니크 인덱스로 인한 MySQL의 처리 방식 변화나 차이점이 상당히 많이 있는데, 유니크 인덱스는 결국 다른 인덱스보다 읽기가 빠르다.
            PK나 인덱스가 아닌 일반 값으로 레코드를 찾는 경우라면 작업이 오래 걸린다. 왜냐하면 해당 레코드가 어디에 저장되어 있는지 모르기 때문에, 모든 테이블을 전체 탐색(풀 스캔)하여 찾아야 하기 때문이다.
            B-Tree는 인덱스 키 값을 변형하지 않고 정렬된 상태로 저장한다. (물론 VARCHAR 255를 넘어가면 앞 부분만 잘라서 인덱스를 생성하긴 한다.)
            그래서 동등 조건 연산(=)이나 부등호 검색 등 대부분의 경우에 인덱스를 활용할 수 있다.
            하지만 키 값의 뒷부분만 검색(LIKE “%name%”)하거나 변형된 값으로 쿼리하는 등의 경우라면 인덱스를 활용할 수 없다.

    4. 읽기 방식에 따른 인덱스의 분류
        - 인덱스 레인지 스캔
            범위가 결정된 인덱스를 읽는 방식으로,  정해진 범위만 접근하면 되므로 이 방식은 다른 방식들보다 빠르다.
            일반적으로 인덱스를 탄다고 하면 인덱스 레인지 스캔으로 데이터를 조회하는 것을 의미한다.
            해당 테이블의 name 컬럼에 인덱스가 걸려있다고 할 때, 쿼리의 실행 순서를 정리하면 다음과 같다.
                (인덱스 탐색) 인덱스의 조건을 만족하는 값이 저장된 위치를 찾는다.
                (인덱스 스캔) 시작 위치부터 필요한 만큼 인덱스를 순서대로 읽는다.
                (랜덤 I/O) 읽어들인 인덱스와 PK를 이용해 최종 레코드를 읽어온다.

            먼저 루트 노드에서 시작해서 브랜치 노드를 거쳐 원하는 인덱스가 저장된 리프 노드(페이지8)로 이동한다. 읽고 쓰는 단위는 페이지이므로
            원하는 인덱스를 찾기 위해서는 8번 페이지의 처음부터 시작해서 시작점(Lemon)을 찾는데, 이를 탐색이라고 한다.
            시작점을 찾았으면 이후에는 순서대로 검색 범위의 마지막 인덱스(Mango)까지 읽으면 되는데, 이를 스캔이라고 한다.
            이것이 가능한 이유는 인덱스가 정렬되어 있기 때문이며, 스캔을 하다가 페이지의 끝에 도달하면 페이지 간의 링크를 이용해 다음 페이지(9)로 넘어간다.
            그리고 계속해서 스캔하다가 마지막 인덱스를 찾으면 지금까지 읽은 레코드를 반환하고 쿼리를 종료한다.
            만약 쿼리가 인덱스나 PK 외의가 아닌 레코드의 다른 값을 필요로 한다면 테이블로부터 레코드를 조회해와야 하며, 이때는 PK를 이용해 랜덤 I/O를 통해 레코드들을 조회해야 한다.
            만약 인덱스나 PK만 필요로 한다면 해당 작업은 실행되지 않는데, 이를 커버링 인덱스라고 한다.  커버링 인덱스는 디스크 랜덤 I/O 작업을 줄일 수 있어서 성능이 훨씬 뛰어나다.
            다시 한번 설명하지만, 인덱스에 PK가 저장되는 것은 MySQL의 InnoDB가 클러스터 테이블이기 때문에 이러한 구조를 갖는 것이다. 다른 DBMS의 경우에는 다를 수 있음을 참고하도록 하자.

        - 인덱스 풀 스캔
            처음부터 끝까지 페이지를 이동하며 모든 인덱스를 읽는 방식
            쿼리가 인덱스나 PK 만 필요로 한다면 해당 방식이 주로 사용되고, 그 외의 컬럼이 필요하다면 절대 이 방식으로 처리되지 않는다.
            또한 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우에 사용된다.

            인덱스 풀 스캔이 사용되는 이유는 테이블에는 다른 레코드들도 포함되어 있으니 비효율적이기 때문이다.
            해당 방식이 아주 빠르지는 않지만 테이블 풀 스캔보다는 적은 디스크 I/O로 쿼리를 처리할 수 있다.
            그렇다고 하여 인덱스 풀 스캔을 위해서 인덱스를 생성해서는 안되며, 인덱스 풀 스캔은 일반적으로 “인덱스를 사용한다”고 하지도 않는다.

        - 루스 인덱스 스캔
            말 그대로 인덱스를 듬성듬성 읽는 방식
            일반적으로 GROUP BY나 MIN() 또는 MAX()와 같은 집합 함수를 사용하는 쿼리를 최적화할 때 사용되며, 중간에 불필요한 인덱스는 무시하고 넘어간다.

                SELECT
                    dept_no, MIN(emp_no)
                FROM
                    dept_emp
                WHERE
                    dept_no BETWEEN 'D002' AND 'D004'
                GROUP BY
                    dept_no;

                위의 쿼리에서 emp_no는 dept_no에 의존하여 정렬되므로, dept_no 그룹 별로 가장 처음의 emp_no 값만 읽으면 된다. 옵티마이저는 이러한 부분을 알고 있기 때문에, 처음이 아닌 emp_no는 무시하고 넘어간다.

            이러한 부분은 인덱스의 정렬 특성 때문이므로, 인덱스를 구성하는 컬럼의 순서는 상당히 중요한 것이다.
            앞선 인덱스 레인지 스캔과 인덱스 풀 스캔은 모든 인덱스를 스캔하므로 타이트 인덱스 스캔으로 묶이는데, 이와 반대되는 스캔 방식이다.

        - 인덱스 스킵 스캔
            인덱스 스킵 스캔은 MySQL 8.0부터 추가된 기능으로, 인덱스의 뒷 컬럼만으로 검색하는 경우에 옵티마이저가 자동으로 쿼리를 최적화하여 인덱스를 타도록 하는 읽기 방식이다.
            인덱스 스킵 스캔이 실행되기 위해서는 다음의 조건들을 모두 만족시켜줘야만 한다.
                조회되는 컬럼은 인덱스 만으로 처리 가능해야 함(커버링 인덱스)
                인덱스의 선행 컬럼은 WHERE 절에 없어야 함
                인덱스 선행 컬럼의 카디날리티가 낮아야 함(유니크한 값이 적어야 함)

            먼저 조회되는 컬럼이 인덱스 만으로 처리 가능해야 한다. 만약 모든 컬럼을 조회하는 쿼리라면 풀 테이블 스캔을 타게 된다.
            인덱스 스킵 스캔은 MySQL 8.0부터 추가된 기능이라 아직 최적화가 되지 못한 부분이 많은데, 이 부분이 그 중 하나이다.
            그 다음으로는 인덱스 선행 컬럼이 WHERE 절에 없으며, 선행 컬럼이 갖는 값이 유니크한 개수가 적을 때에만 최적화가 가능하다는 것이다.
            일반적으로는 유니크한 값의 개수가 많을수록 좋다. 하지만 인덱스 스킵 스캔의 경우에는 유니크한 값의 개수가 많다면 인덱스의 스캔 시작 지점을 검색하는 작업이 많아진다.
            그래서 쿼리 최적화를 하려다가 오히려 느려질 수 있다.

        - 인덱스를 사용하지 않는 경우
            풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 방식이다. 옵티마이저는 아래의 경우에 주로 풀 테이블 스캔을 이용한다.
                WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
                테이블의 레코드 건수가 너무 적어서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 것이 더 빠른 경우 (일반적으로 테이블이 1개의 페이지 만으로 구성되는 경우)
                인덱스 레인지 스캔을 사용할 수 있더라도 일치되는 레코드 건수가 너무 많은 경우

            일반적으로 전체 테이블의 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기를 필요로한다.
            그래서 MySQL은 특정 테이블의 연속된 페이지가 읽히면 백그라운드 쓰레드를 통해 다음 페이지의 작업을 미리 읽어 메모리(버퍼풀)에 넣어두는 리드 어헤드(Read ahead) 기능을 갖고 있다.
            리드 어헤드 작업은 4개 또는 8개의 페이지부터 시작하여 최대 64개의 페이지까지 읽어오도록 증가된다. 참고로 이는 풀 인덱스 스캔에도 동일하게 적용된다.

    5. 인덱스 사용 시의 주의 사항
        - 인덱스 사용 시의 주의 사항
            - 인덱스를 통해 필요한 레코드만 조회하면 효율적일 수 있음
                만약 쿼리로 조회하는 데이터가 PK 뿐이라면 프라이머리 키 인덱스 영역까지 넘어갈 필요가 없다. 따라서 B-Tree 인덱스 영역의 리프 노드에서 조회한 PK 값을 바로 반환하는데, 이를 커버링 인덱스라고도 한다.

            - 인덱스는 SELECT 외에 UPDATE, DELETE 등에도 사용될 수 있음
                또한 인덱스는 검색 조건에서만 활용되는 것이 아니고 DELETE, UPDATE 시에도 활용될 수 있으며, WHERE절 뿐만 아니라 GROUP BY와 ORDER BY에서도 동일하게 사용될 수 있다.

            - 인덱스는 값이 변형되는 경우에 사용될 수 없음
                결국 인덱스는 키 값으로 정렬되기 때문에, 정렬된 효과를 누릴 수 없는 경우라면 인덱스를 사용할 수 없다.
                예를 들어 값을 잘라서 쿼리에 사용하는 경우가 그러하다. 또한 레코드를 “%Kyu”와 같이 후방 일치 검색하는 경우도 정렬 효과가 전혀 없으므로 인덱스를 타지 않는다.

            - 인덱스는 정순으로 검색하는 것이 효율적임
                인덱스를 정순으로 검색하는 것이 효율적인 이유는 앞에서 살펴보았듯 정순 정렬에 최적화되어있기 대문이다.

            - 인덱스를 무조건적으로 생성하는 것은 좋지 않음
                인덱스를 무조건적으로 생성하는 것은 좋지 않다. WHERE 절에 사용되는 속성이라고 전부 인덱스를 생성하면 데이터의 저장 성능은 떨어지고 인덱스는 비대해져 오히려 역효과만 불러올 수 있다.
                정렬된 상태를 유지하기 위해서는 데이터를 저장할 때 정렬된 위치를 찾고 넣어줘야 한다. 값이 수정된다면 추가적인 작업이 수반되기도 한다.
                즉, 인덱스는 저장(INSERT, UPDATE, DELETE)의 성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다. 인덱스가 필요한 이유는 쓰기 작업이 조금 느리더라도,
                읽기 작업을 빠르게 유지하도록 하기 위함이다. 왜냐하면 일반적인 온라인 환경에서 읽기와 쓰기의 비율이 8:2, 9:1이기 때문이다.







