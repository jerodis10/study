- analyze table
    - ANALYZE 는 인덱스, 테이블, 클러스터의 통계정보를 생성 한다.
    - ANALYZE 가 생성한 통계정보들은 비용기준(Cost-based)의 옵티마이저가 가장 효율적인 실행계획을 수립하기 위해 최소비용을 계산할 때 사용된다.
    - 각 오브젝트의 구조를 확인하는 것과 체인(Chain) 생성 여부를 확인할 수 있으므로 시스템의 저장공간 관리를 도와준다.
    - ANALYZE 는 다음과 같은 통계정보를 생성하여 데이터 사전에 저장 한다.
        - 테이블 : 총 로우의수, 총 블럭의 수, 비어있는 블럭에 쓰여질 수 있는 빈 공간의 평군, 체인이 발생된 로우의 수, 로우의 평균 길이
        - 인덱스 : 인덱스의 깊이(Depth), Leaf block 의 개수, Distinct Key 의 수, Leaf Blocks/Key 의 평균,
                  Data blocks/key 의 평균, Clustering Factor, 가장 큰 key 값, 가장 작은 key 값
        - 컬럼 : Distinct 한 값의 수, 히스토그램 정보
        - 클러스터 : Cluster Key 당 길이의 평균

    - 주기적인 ANALYZE 작업을 수행 시켜 주어야 한다.
      테이블을 재생성 하거나, 새로 클러스터링을 한 경우, 인덱스를 추가하거나 재생성한 경우, 다량의 데이터를 SQL 이나
      배치 애플리케이션을 통해 작업한 경우 ANALYZE 를 수행 시켜 주는 것이 좋다.
      사용자는 USER_TABLES, USER_COLUMNS, USER_INDEXS, USER_CLUSTER 등의 자료사전 뷰를 통해 정보를 확인할 수 있다
      테이블을 ANALYZE 시킨다면 거기에 따르는 인덱스들도 같이 실시하는 것이 좋다.

- 실행계획
- sql 최적화
    https://developer-talk.tistory.com/420

- 옵티마이저
    - 가장 효율적인 방법으로 SQL 을 수행할 최적의 처리 경로를 생성해주는 DBMS 의 핵심 엔진
    - 컴퓨터의 두뇌가 CPU 인 것처럼 DBMS 의 두뇌는 옵티마이저
    - SQL 을 작성하고 실행하면 소프트웨어 실행파일처럼 즉시 실행되는 것이 아니라 옵티마이저(Optimizer)라는 곳에서 "이 쿼리문을
      어떻게 실행시키겠다!"라는 여러 가지 실행계획을 세우게 됩니다. 이렇게 실행계획을 세운 뒤 시스템 통계정보를 활용하여
      각 실행계획의 예상 비용을 산정한 후 각 실행계획을 비교해서 최고의 효율을 가지고 있는 실행계획을 판별한 후 그 실행계획에
      따라 쿼리를 수행하게 되는 것입니다.

    - 옵티마이져의 종류
        - 옵티마이저는 실행 계획을 세우는 방식에 따라 규칙 기반 옵티마이저와 비용 기반 옵티마이저로 나뉩니다.

        항목	        규칙 기반 옵티마이저	                    비용 기반 옵티마이저
        개념	        사전에 정의된 규칙 기반	                    최소비용 계산 실행계획 수립
        기준	        실행우선 순위(Ranking)	                액세스 비용(Cost)
        인덱스	    인덱스 존재 시 가장 우선시 사용	            Cost 에 의한 결정
        성능	        사용자 SQL 작성 숙련도	                    옵티마이저 예측 성능
        장점	        판단이 매우 규칙적 실행 예상 가능	            통계 정보를 통한 현실 요소 적용
        단점	        예측 통계정보 요소 무시	                    최소 성능 보장 계획의 예측 제어 어려움
        사례	        AND 중심 양쪽 ‘=’ 시 Index Merge 사용	    AND 중심 양쪽 ‘=’ 시 분포도별 Index 선택

        규칙 기반 옵티마이저 (RBO)
        오라클8 이하의 버전에서 기본으로 설정된 옵티마이저가 바로 규칙 기반 옵티마이저입니다. 규칙 기반 옵티마이저는
        말 그대로 실행 속도가 빠른 순으로 규칙을 먼저 세워두고 우선순위가 앞서는 방법을 채택하는 것.
        과거에는 옵티마이저의 비용을 예측하는 능력이 그다지 좋지 않아 이러한 방식을 사용.
        옵티마이저의 실행계획을 유도할 수 있는 힌트와 HASH JOIN 의 경우에는 규칙 기반 이후에 나온 개념들이므로
        여기서는 사용하실 수 없다는 단점이 있습니다.

        비용 기반 옵티마이저
        최근에 많이 사용하고 있는 옵티마이저 방식이며 오라클 10 이후 버전부터는 공식적으로 비용 기반 옵티마이저만 사용.
        비용 기반 옵티마이저는 옵티마이저에서 실행 계획을 세운 뒤(최대 2천개까지) 비용이 최소한으로 나온 실행 계획을 수행.
        비용을 예측하기 위해서 규칙 기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의
        다양한 객체 통계정보와 시스템 통계정보를 이용.

    - 옵티마이저 동작 방식
        Parser : SQL 문장을 분석하여 문법 검사와 구성요소를 파악하고 이를 파싱 해서 파싱 트리를 만듭니다.
        Query Transformer : 파싱된 SQL 을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL 로 변환이
            가능한지를 판단하여 변환 작업을 수행합니다.
        Estimator : 시스템 통계정보를 딕셔너리로부터 수집하여 SQL 을 실행할 때 소요되는 총비용을 계산합니다.
        Plan Generator : Estimator 를 통해 계산된 값들을 토대로 후보군이 되는 실행계획을 도출합니다.
        Row-Source Generator : 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는
            코드나 프로시저 형태로 포맷팅 합니다.
        SQL Engine : SQL 을 실행합니다.

    - 옵티마이저는 결코 만능이 아니다.
        칼럼의 통계 정보만 가지고는 조건절에서 사용된 조건을 만족하는 데이터의 양이 어느 정도인지 알 수가 없기에 비용 계산 결과가
        정확하지가 않습니다. 그리고 비용산정시 쿼리문 단독으로 실행된다고 가정하기에 운영 서버와 같이 쿼리가 동시 실행된다면
        실제 비용은 달라질 수 있기도 하고 히스토그램 버킷이 최대 254까지만 사용할 수 있어 254개 이상의 값을 갖는 컬럼의 경우
        비용 예측 결과가 정확하지 않는 등의 옵티마이저에 여러 가지 빈틈들이 많습니다.
        쿼리 튜닝을 할 때에는 쿼리 문의 실행계획을 꼭 보시고 옵티마이저가 비효율적으로 작동하고 있다면 오라클의 힌트 같은
        부가적인 장치를 통해 올바르게 작동될 수 있도록 유도하는 방법도 필요합니다.

- 실행 계획
    - 실행 계획이란?
        실행계획이란 사용자가 SQL 을 실행하여 데이터를 추출하려고 할 때 옵티마이저가 수립하는 작업 절차

    - 쿼리문의 실행 계획을 확인하는 방법
        쿼리문의 실행 계획을 확인하는 방법은 EXPLAIN PLAN, AUTOTRACE, SQL TRACE 이렇게 3가지가 있습니다.

    - SCAN 의 종류와 속도
        FULL TABLE SCAN : 테이블의 전체 데이터를 읽어 조건에 맞는 데이터를 추출하는 방식 입니다.
        ROWID SCAN : ROWID 를 기준으로 데이터를 추출하며 단일 행에 접근하는 방식 중에서 가장 빠릅니다.
        INDEX SCAN : 말 그대로 인덱스를 활용하여 원하는 데이터를 추출하는 방식입니다.

        이 두 가지 SCAN 방법 중 개발자가 손쉽게 유도할 수 있는 SCAN 의 방법은 FULL TABLE SCAN 과 INDEX SCAN 입니다.
        이 중에서 테이블에 데이터가 많지 않아 INDEX 를 타야 하는 시간 소요가 불필요하다고 느껴지거나 테이블에서 추출해야 하는
        데이터 양이 엄청 많다면 FULL TABLE SCAN 을 하는 것이 유리할 수 있고 반대로 많은 데이터가 있는 테이블에서 내가 원하는
        데이터를 추출해야 하는 상황이라면 INDEX SCAN 을 하는것이 좋습니다.

        FULL TABLE SCAN 을 타는 상황
            1. 조건절에서 비교한 칼럼에 인덱스가 없는 경우
            2. 조건절에서 비교한 컬럼에 최적화된 인덱스는 있지만 조건에 만족하는 데이터가 테이블의 많은 양을 차지하여
               FULL TABLE SCAN 이 낫다고 옵티마이저가 판단하는 경우
            3. 인덱스는 있으나, 테이블의 데이터 자체가 적어 FULL TABLE SCAN 이 낫다고 옵티마이저가 판단하는 상황
            4. 테이블 생성 시 DEGREE 속성 값이 크게 설정되어 있는 경우

            옵티마이저가 판단 후 TABLE FULL SCAN 을 탄다면 그냥 두는 것이 좋고 INDEX SCAN 이 더 유리한데도 불구하고
            INDEX 가 없어 부득이하게 FULL TABLE SCAN 을 한다면 INDEX 를 하나 만드는 것이 좋습니다. 물론 INDEX 를
            필요할 때마다 만드는 것도 UPDATE 와, DELETE 등의 속도를 저해하기에 마냥 좋은 것은 아닙니다.

        ROWID SCAN 을 타는 상황
            1. 조건절에 ROWID 를 직접 명시할 경우
            2. INDEX SCAN 을 통해 ROWID 를 추출한 후 테이블에 접근할 경우

            ROWID SCAN 은 단일 행 접근이 매우 빠르기 때문에 ROWID SCAN 가 유리하다고 판단되면서
            ROWID SCAN 을 탈 수 있는 상황이라면 유도해주는 것이 좋습니다.

        INDEX SCAN 을 타는 상황
            인덱스 종류	                    상황
            INDEX UNIQUE SCAN	            UNIQUE INDEX 를 구성하는 모든 컬럼이 조건에 "="로 명시된 경우
            INDEX RANGE SCAN	            1. UNIQUE 성격의 결합 인덱스의 선두 컬럼이 WHERE 절에 사용되는 경우
                                            2. 일반 인덱스의 컬럼이 WHERE 절에 존재하는 경우
            INDEX RANGE SCAN DESCENDING	    INDEX RANGE SCAN 을 수행함과 동시에 ORDER BY DESC 절을 만족하는 경우
            INDEX SKIP SCAN	                1. 결합 인덱스의 선행 컬럼이 WHERE 절는 경우
                                            2. 옵티마이저가 INDEX SKIP SCAN 이 FULL TABLE SCAN
                                               보다 낫다고 판단하는 경우
            INDEX FULL SCAN	                1. ORDER BY / GROUP BY의 모든 컬럼이 인덱스의 전체 또는 일부로 정의된 경우
                                            2. 정렬이 필요한 명령에서 INDEX ENTRY 를 순차적으로 읽는 방식으로 처리된 경우
            INDEX FULL SCAN DESCENDING	    INDEX FULL SCAN 을 수행함과 동시에 ORDER BY DESC 절을 만족하는 경우
            INDEX FAST FULL SCAN	        FULL TABLE SCAN 을 하지 않고도 INDEX FAST FULL SCAN 으로 원하는 데이터를
                                            추출할 수 있고 추출된 데이터의 정렬이 필요 없으며 결합 인덱스를 구성하는
                                            컬럼 중에 최소 한개 이상은 NOT NULL 인 경우
            INDEX JOIN	                    추출하고자 하는 데이터가 조인하는 인덱스에 모두 포함되어 있고
                                            추출하는 데이터의 정렬이 필요없는 경우

- 인덱스
    - 인덱스(Index)란?
        인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
        특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
        이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면
        옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.
        인덱스에서 내가 원하는 데이터를 먼저 찾고 저장되어 있는 물리적 주소로 찾아갑니다.

        인덱스는 데이터베이스 테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스 객체이며 일종의 색인기술입니다.
        테이블에 index 를 생성하게 되면 index Table 을 생성해 관리합니다.
        가장 일반적인 B-tree 인덱스는 인덱스 키(인덱스로 만들 테이블의 컬럼 값)와 이 키에 해당하는 컬럼 값을 가진
        테이블의 로우가 저장된 주소 값으로 구성됩니다.

    - 인덱스(Index)를 사용하는 이유
        테이블에 데이터들이 인덱스의 가장 큰 특징은 데이터들이 정렬이 되어있다는 점입니다. 이 특징으로 인해 조건 검색이라는
        영역에서 굉장한 장점이 됩니다.

        - 조건 검색 Where 절의 효율성
            테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다.
            이렇게 되면 Where 절에 특정 조건에 맞는 데이터들을 찾아낼때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과
            맞는지 비교해야 합니다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 하지만 인덱스 테이블은 데이터들이
            정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠.
            이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다.

        - 정렬 Order by 절의 효율성
            인덱스(Index)를 사용하면 Order by에 의한 Sort 과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이
            걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면
            디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다.
            이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.

        - MIN, MAX 의 효율적인 처리가 가능하다.
            이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점입니다. MIN 값과 MAX 값을 레코드의 시작값과 끝 값 한건씩만
            가져오면 되기에 FULL TABLE SCAN 으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.

    - 인덱스의 자료구조가 B- TREE 인 이유   https://helloinyong.tistory.com/296
        - 탐색시간이 제일 빠른 해시 테이블을 DB 인덱스로 사용할 수 없는 이유
            - 해시 충돌 등으로 최악의 경우에 O(N)이 될 수 있지만, 평균적으로는 O(1)
              BUT, DB에서 등호(=) 뿐 아니라 부등호(<, >)도 사용할 수 있다
            - 모든 값이 정렬되어있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 수 없다.

        - 그러면 탐색이 O(logN)인 다른 자료구조나 알고리즘은 왜 사용하지 못하는 것일까? 같은 밸런스 트리 종류임에도 RedBlack-Tree는 DB 인덱스로 선택받지 못한 이유
            - RedBlack-Tree와 B-Tree의 가장 큰 차이는 '하나의 노드가 가지는 데이터 개수'이다.
            - RedBlack-Tree는 무조건 하나의 노드에 하나의 데이터 요소만을, B-Tree는 하나의 노드에 여러 개의 데이터 요소를 저장한다.
            - 같은 노드 공간의 데이터들끼리 굳이 자식 노드처럼 참조 포인터 값으로 접근할 필요가 없다. 실제 메모리 디스크에서 바로 다음 인덱스의 접근을 하는 것

        - 모든 면으로 DB 인덱스 용도로 가장 적합한 자료구조인 B-Tree
            - 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
            - 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.
            - 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.

        - B트리 탐색, 삽입, 삭제 과정
            https://code-lab1.tistory.com/217

        - B-Tree는 자식 2개 만을 갖는 이진 트리(Binary Tree)를 확장하여 N개의 자식을 가질 수 있도록 고안된 것

    - 인덱스(Index)의 단점
        인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지 시켜줘야 한다는 점입니다.
        INSERT, UPDATE, DELETE 를 통해 데이터가 추가되거나 값이 바뀐다면 INDEX 테이블 내에 있는 값들을 다시
        정렬을 해야겠죠. 그리고 INDEX 테이블, 원본 테이블 이렇게 두 군데에 데이터 수정 작업해줘야 한다는 단점도 있습니다.
        그리고 검색시에도 인덱스가 무조건 좋은 것이 아닙니다. 인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를
        처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫습니다. 그리고 인덱스를
        관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요합니다. 무턱대고 INDEX 를
        만들어서는 결코 안 될 말입니다.

    - 인덱스(Index)의 관리
        앞서 설명했듯이 인덱스는 항상 최신의 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다.
        그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE 가 수행된다면 계속 정렬을 해주어야 하고 그에
        따른 부하가 발생합니다. 이런 부하를 최소화하기 위해 인덱스는 데이터 삭제라는 개념에서 인덱스를 사용하지 않는다
        라는 작업으로 이를 대신합니다.
        INSERT: 새로운 데이터에 대한 인덱스를 추가합니다.
        DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행합니다.
        UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가합니다.

    - 인덱스 생성 전략
        생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는
        컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된
        Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를
        거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이
        인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.
        1. 조건절에 자주 등장하는 컬럼
        2. 항상 = 으로 비교되는 컬럼
        3. 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은) 컬럼
        4. ORDER BY 절에서 자주 사용되는 컬럼
        5. 조인 조건으로 자주 사용되는 컬럼

    - 인덱스 자료구조 (B * Tree 인덱스)
        인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다.
        그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.
        B * Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다.
        구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node 로 구성됩니다. 특정 컬럼에 인덱스를 생성하는
        순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT 블록을
        기준으로 가지가 되는 BRANCH 블록을 정의하며 마지막으로 잎에 해당하는 LEAF 블록에 인덱스의 키가 되는
        데이터와 데이터의 물리적 주소 정보인 ROWID 를 저장합니다.

    - 결합 인덱스란
        - 결합 인덱스란?
            결합 인덱스란 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말합니다. 주로 단일 컬럼으로는 나쁜 분포도를 가지지만
            여러 개의 컬럼을 합친다면 좋은 분포도를 가지고,
            Where 절에서 AND 조건에 많이 사용되는 컬럼들을 결합 인덱스로 구성합니다.
            1. where 절에서 and 조건으로 자주 결합되어 사용되면서 각각의 분포도 보다
               두 개 이상의 컬럼이 결합될 때 분포도가 좋아지는 컬럼들
            2. 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
            3. order by 에서 자주 사용되는 컬럼들
            4. 하나 이상의 키 컬럼 조건으로 같은 테이블의 컬럼들이 자주 조회될 때

        - 결합 인덱스의 컬럼 순서 결정
            결합 인덱스를 만들 때 결합 인덱스를 구성하는 컬럼들의 배열 순서는 아주 중요하기에 신중하게 결정하여야 합니다.
            컬럼의 순서를 잘못 배열하면 결합 인덱스의 발동 확률이 매우 낮아질 수 있기 때문입니다. 만약 select 문의
            where 절에 결합 인덱스의 첫 번째 컬럼을 조건에 사용하였다면 그 질의문은 결합 인덱스를 사용할 수 있습니다.
            하지만 개발자가 결합 인덱스의 두번째 컬럼만을 where 절에 조건으로 사용하고 결합 인덱스를 사용하고자 했다면
            실행계획은 인덱스를 사용하지 못합니다. 따라서 쿼리문 작성 시 결합 인덱스를 사용하고자 한다면 반드시 결합 인덱스의
            컬럼 중 선행하는 컬럼부터 조건에 지정하여 사용하여야 합니다. 조건은 컬럼 전체를 순서대로 사용할 수도 있고,
            아니면 선행하는 일부 컬럼을 순서대로 사용할 수 있습니다.

        - 결합 인덱스 컬럼의 설정 시 고려해야 할 우선순위
            1. where 절 조건에 많이 사용되는 컬럼이 우선시
            2. Equal('=')로 사용되는 컬럼 우선
            3. 분포도가 좋은 컬럼을 우선
            4. 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정

        - 결합 인덱스의 효율성이 떨어지는 경우
            결합 인덱스도 일반적인 인덱스와 마찬가지로 데이터들이 정렬되어 보관되기 때문에 소수의 데이터를 빠르게 찾는 것에는
            유리하지만 아래와 같이 스캔이 많이 생기게 된다면 효율성이 떨어지게 됩니다.

            아래의 예시들은 emp_pay_idx 인덱스를 사용하기는 하지만 스캔이 많이 생기는 경우로 인덱스의 효율성이
            떨어지는 경우들의 예시입니다.

            select * from emp_pay where 급여년월 LIKE '2021%' and 급여코드 = '정기급여';
            위 조건절의 경우 결합 인덱스의 첫 번째 컬럼인 급여년월의 조건이 있더라도 Equal(=)이 아닌 범위 연산자인
            LIKE '2021%' 조건을 사용했으므로, 세개의 칼럼이 모두 필요한 emp_pay_idx 인덱스를 찾을 때 두번째 칼럼인
            급여코드에 대한 조건을 B*Tree 에서 쉽게 찾을수가 없게 됩니다. 이는 결합 인덱스가 각 칼럼별로 정렬이 되어 있는
            것이 아니라 첫번째, 두번째, 세번째 칼럼이 결합이 되어 정렬이 되어있기 때문입니다. 이때 급여코드에 대한 조건은
            인덱스를 찾아가는 검색조건이 아니라 인덱스 값이 조건에 맞는지 여부를 검증하는 체크 조건이 됩니다.

            select * from emp_pay where 급여년월 = '202107' and 사원번호 = '20210401';
            위 조건절의 경우는 결합 인덱스의 첫번째 칼럼인 급여년월의 조건이 equal(=)이더라도 두번째 컬럼인 급여코드에
            대한 조건이 없으므로 세번째 칼럼인 사원번호 조건을 검색 조건이 아닌 체크 조건으로 밖에 사용할 수 없게 됩니다.
            즉 결합 인덱스에서 급여년월인 모든 데이터를 찾아서 사원번호 조건에 맞는지 일일이 확인하는
            풀 테이블 스캔이 일어나고 있는 셈입니다.

    - 인덱스를 리빌드하는 이유
        인덱스 파일은 생성 후 insert, update, delete 등을 반복하다보면 성능이 저하됩니다. 생성된 인덱스는
        트리구조를 가집니다. 삽입,수정,삭제등이 오랫동안 일어나다보면 트리의 한쪽이 무거워져 전체적으로 트리의 깊이가
        깊어집니다. 이러한 현상으로 인해 인덱스의 검색속도가 떨어지므로 주기적으로 리빌딩하는 작업을 거치는것이 좋습니다.

        SELECT I.TABLESPACE_NAME,I.TABLE_NAME,I.INDEX_NAME, I.BLEVEL,
               DECODE(SIGN(NVL(I.BLEVEL,99)-3),1,DECODE(NVL(I.BLEVEL,99),99,'?','Rebuild'),'Check') CNF
        FROM   USER_INDEXES I
        WHERE   I.BLEVEL > 4
        ORDER BY I.BLEVEL DESC

        해당쿼리는 index 트리의 깊이가 4이상인 index  를 조회하는 쿼리입니다.
        해당 쿼리문을 실행하여 검색되는 index 가 있다면 리빌딩을 하는것이 좋습니다.

    - 인덱스(Index)를 남발하지 말아야 하는 이유
        개발을 진행할 때에 대개 개발서버와 운영서버를 나누어서 관리합니다. 대부분 개발서버에서 개발을 할때에는 적은량의
        데이터를 가지고 로직검사를 하며 로직검사에 통과한 코드들이 운영서버에 업데이트가 되죠. 하지만 개발서버에는 잘 동작하던
        로직들이 운영서버의 많은량의 데이터들을 처리하다보면 성능이슈가 많이 발생합니다. 그 성능이슈의 주요원인은
        바로 데이터베이스에 있습니다. 데이터베이스 관리자는 성능문제가 발생하면 가장 빨리 생각하는
        해결책이 인덱스 추가 생성입니다.

        하지만 문제를 그저 쉽게 해결하기 위해 쿼리 속도 문제가 날때마다 인덱스를 추가하는것은 바람직하지 못합니다.
        성능 이슈가 나서 인덱스를 만들고 또 다른 SQL 문에서 성능이슈가 발생하여 또 인덱스를 만들었다고 합시다.
        이렇게 문제가 발생할때마다 인덱스를 생성하면서 인덱스가 계속 추가되면 생성된 인덱스를 참조하는 하나의 쿼리문을
        빠르게는 만들 수 있지만 전체적인 데이터베이스의 성능 부하를 초래합니다. 그렇기에 인덱스를 생성하는것 보다는
        SQL 문을 좀 더 효율적으로 짜는 방향으로 나가야합니다. 인덱스 생성은 꼭 마지막 수단으로 강구해야 할 문제입니다.


- NESTED LOOP JOIN (중첩 루프 조인)
    - NESTED LOOP JOIN 이란?
        NL JOIN 이라고도 불리는 NESTED LOOP JOIN 은 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row 를
        결합하여 원하는 결과를 조합하는 조인 방식
        조인해야 할 데이터가 많지 않은 경우에 유용하게 사용
        드라이빙 테이블로 한 테이블을 선정하고 이 테이블로부터 where 절에 정의된 검색 조건을 만족하는 데이터들을 걸러낸 후,
        이 값을 가지고 조인 대상 테이블을 반복적으로 검색하면서 조인 조건을 만족하는 최종 결과값을 얻어냅니다.

    - Driving Table 과 Driven Table
        조인을 할때 먼저 액세스 되는 테이블을 Driving Table 이라고 하며 나중에 액세스 되는 테이블을 Driven Table
        Driving Table 은 옵티마이저가 결정하고 자연스레 Driving Table 이 아닌 테이블은 Driven Table 로 결정

    - NESTED LOOPS JOIN 의 장단점
        1. 인덱스에 의한 랜덤 액세스에 기반하고 있기 때문에 대량의 데이터 처리 시 적합하지 않습니다.
        2. Driving Table 로는 데이터가 적거나 where 절 조건으로 row 의 숫자를 줄일 수 있는 테이블이어야 합니다.
        3. Driven Table 에는 조인을 위한 적절한 인덱스가 생성되어 있어야 합니다.
        4. 선행 테이블의 결과를 통해 후행 테이블을 액세스 할 때 랜덤 I/O가 발생합니다.

         for(i=0; i<dept.length; i++) { -- driving table
            for(j=0; j<emp.length; j++) { -- driven table
               // Search
            }
        }
        동작 순서를 보시면 아시겠지만  위와 같은 이중 for 문과 작동원리는 비슷합니다.

        이렇듯 NESTED LOOP JOIN 의 동작 방식은 Driving Table 의 처리 범위를 하나씩 액세스 하면서 추출된 값으로
        Driven Table 을 조인하는 방식으로 동작하게 됩니다.

    - NESTED LOOP JOIN 의 성능 개선 포인트
        - 적절한 드라이빙 테이블의 선정
            Driving Table 은 WHERE 절로 최대한의 데이터를 거를 수 있는 테이블이나
            애초에 데이터의 양이 적은 테이블로 선정하는 것이 좋습니다.

            - 드라이빙 테이블 유도 방법
                1. 힌트의 사용
                    /*+ORDERED*/ -- FROM절에 기술한 테이블 순서대로 제어
                    /*+LEADING (table명)*/ -- 힌트 내에 제시된 테이블이 드라이빙으로 처리됨

                    가장 쉬운 방법은 위와 같이 힌트를 사용하는 방법입니다. 위의 두가지 힌트 중 하나를 사용하시면 됩니다.
                    만약 위의 두가지 힌트를 동시에 사용하게 되면 LEADING 힌트는 적용되지 않습니다.

                2. 뷰를 사용한다.
                    뷰를 통해서 데이터를 먼저 읽어낼 수 있고 뷰로 데이터를 읽은 결과로 다음 테이블로 연결을 시도한다면
                    조인 순서를 제어할 수 있습니다.

        - Driven Table 의 조인 컬럼에 인덱스 존재 유무
            Driven Table 에 인덱스가 존재하지 않는다면 Driving Table 에서 도출된 결과와 맞는지를
            FULL TABLE SCAN 으로 일일이 비교해야 하기 때문입니다.
            Driven Table 의 Join 컬럼에 인덱스가 생성되지 않았다면 인덱스 생성을 고려해 보는 것이 좋고 그것이 어렵다면
            조인 방식을 SORT / MERGE 방식등 다른 방식으로 바꾸는것이 성능 향상에 도움이 됩니다.

- SORT MERGE JOIN (정렬 병합 조인)
    - SORT MERGE JOIN 이란?
        조회의 범위가 많을 때 주로 사용하는 조인 방법론이며 양쪽 테이블을 각각 Access 하여 그 결과를 정렬하고
        그 정렬한 결과를 차례로 Scan 해 나가면서 연결고리의 조건으로 Merge 를 하는 방식
        주로 조인 조건 칼럼에 인덱스가 없거나, 출력해야 할 결과 값이 많을 때 사용
        조회의 범위가 좁을 때 유리한 Nested Loop Join 의 조인 방식과 장단점이 서로 바뀌어있다고 생각하시면 이해하기 쉽습니다.

    - SORT MERGE JOIN 의 사용처
        1. 연결 고리에 인덱스가 전혀 없는 경우
        2. 대용량의 자료를 조인할때 유리한 경우
        3. 조인 조건으로 <, >, <=, >=와 같은 범위 비교 연산자가 사용된 경우
        4. 인덱스 사용에 따른 랜덤 액세스의 오버헤드가 많은 경우

    - SORT MERGE JOIN 의 동작 방식
        1. 각 테이블에 대해 동시에 독립적으로 데이터를 먼저 읽어 들인다.
        2. 읽혀진 각 테이블의 데이터를 조인을 위한 연결고리에 대하여 정렬을 수행한다.
        3. 정렬이 모두 끝난 후에 조인 작업이 수행한다.

    - SORT MERGE JOIN 의 성능 개선 포인트
        - ACCESS 하는 속도를 향상 시킨다.
            SORT MERGE JOIN 은 가장 먼저 양쪽 테이블을 Access 하는 과정을 거쳐야 합니다. 이 속도를 빠르게 해 준다면
            속도 향상에 도움이 되겠죠. 테이블을 Access 할 때 FULL TABLE SCAN 이냐 INDEX RANGE SCAN 이냐 하는 등
            테이블을 Access 하는 방법을 다양한 방법을 통해 최적화시킨다면 SORT MERGE JOIN 의 속도도
            자연스럽게 최적화할 수 있습니다.

        - 정렬 속도의 향상
            SORT MERGE JOIN 은 양쪽 테이블에서 조회한 데이터들을 정렬시켜야 합니다. 이때 조인 조건 컬럼이
            이미 정렬되어 있다면 정렬을 하는 작업을 단축시켜 검색 속도 향상에 도움이 될 것입니다.

        - 양쪽의 정렬까지 완료되는 속도를 맞추어줌
            SORT MERGE JOIN 은 양쪽 테이블을 ACCESS 하고 조회한 데이터들을 정렬할때 어느 한쪽이라도 정렬 작업이
            종료되지 않으면 한쪽이 대기 상태가 되고 다른 한쪽의 정렬이 완전히 끝날 때까지 조인이 시작될 수 없습니다.
            그렇기에 두 테이블 ACCESS 속도와 정렬 속도를 최대한 비슷하게 맞추어주는 것이 좋습니다.
            비교해야 할 두 테이블의 데이터 양이나 정렬 속도를 고려하여 최대한 맞춰주는 것이 효율성 측면에서 좋습니다.

        - SORT_AREA_SIZE 최적화
            SORT MERGE JOIN 은 두 테이블 간의 비교가 이루어지기 전에 수행하는 정렬 작업을 위해 별도의 정렬 공간이 필요하며
            이 공간은 SORT_AREA_SIZE 크기만큼 메모리를 할당받아 사용하게 되고, 메모리가 부족하다면
            Temporary Table Space 를 이용하여 정렬을 수행하게 됩니다. 이때 Temporary Table Space 를 사용하면
            딜레이가 생기므로 SORT_AREA_SIZE 를 적당한 크기로 설정해두는 것이 속도 향상에 도움이 됩니다.

- HASH JOIN (해시 조인)
    - HASH JOIN 이란?
        HASH 조인은 조인될 두 테이블 중 하나를 해시 테이블로 선정하여 조인될 테이블의 조인 키 값을 해시 알고리즘으로
        비교하여 매치되는 결과값을 얻는 방식
        HASH JOIN 은 비용 기반 옵티마이저를 사용할 때만 사용될 수 있는 조인 방식이며 '=' 비교를 통한 조인에서만
        사용될 수 있습니다. 주로 많은 양의 데이터를 조인해야 하는 경우에 주로 사용

    - HASH JOIN 의 사용처
        1. JOIN 컬럼에 적당한 인덱스가 없어 NL JOIN 이 비효율적일 때
        2. JOIN Access 량이 많아 Random Access 부하가 심하여 NL JOIN 이 비효율적일 때
        3. Sort Merge Join 을 하기에는 두 테이블이 너무 커 Sort 부하가 심할 때
        4. 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 JOIN 할 때

    - HASH JOIN 의 동작 방식
        1. 둘 중 작은 집합(Build Input)을 읽어 Hash Area 에 해시 테이블을 생성한다.
            (해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인에 엔트리를 연결)
        2. 반대쪽 큰 집합(Probe Input)을 읽어 해시 테이블을 탐색하면서 JOIN 한다.
        3. 해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인을 스캔하면서 데이터를 찾는다.

    - HASH JOIN 의 성능 개선 포인트
        - HASH TABLE 을 만드는 과정을 효율화 한다.
            HASH JOIN 은 해시 테이블을 생성하는 비용이 수반되므로 이 과정을 효율화하는 것이 성능 개선에 있어 가장 중요합니다.
            그렇기에 HASH TABLE 로 만들 Build Input 이 Hash Area 에 담길 정도로 충분히 작아야 하며
            Build Input 해시 키 칼럼에 중복 값이 거의 없어야 효율적인 동작을 기대할 수 있습니다.

        - CPU 의 성능을 향상한다.
            HASH BUCKET 이 조인 집합에 구성되어 해시 함수 결과를 저장해야 하는데 기본적으로 HASH_AREA_SIZE 에
            지정된 크기만큼의 메모리가 할당되어 사용됩니다. 이러한 처리에는 많은 메모리와 CPU 자원을 소모하게 됩니다.
            그렇기에 CPU 의 자원이 넉넉하다면 다른 조인에 비해 보다 좋은 효율을 내지만 부족한 상황에서는 다른 조인 방법보다
            느려질 수도 있습니다. 그러므로 CPU 의 성능을 향상한다면 HASH JOIN 의 성능을 향상할 수 있습니다.

        - 충분한 PGA 메모리 확보
            Hash Area 는 PGA 메모리에 할당되는데 Build Input 이 HASH_AREA_SIZE 를 초과하게 되면 가장 큰 순서대로
            Hash Bucket 이 Temporary Table Space 로 내려가서 구성됩니다. 디스크로 내려간 Hash Bucket 에
            변경이 일어날 때마다 디스크 I/O가 발생하게 되어 성능이 현저하게 저하됩니다.

        * HASH_AREA_SIZE
          HASH JOIN 에 사용되는 최대 메모리 SIZE 를 지정하는 설정값입니다. Hash Join 에서 사용되는
          해쉬 메모리 크기(HASH_AREA_SIZE)의 기본 값은 SORT_AREA_SIZE 의 2배입니다. 9i 이상에서 값을 지정하는 것을
          권장하지 않고, PGA_AGGREGATE_TARGET parameter 사용을 권장합니다.

    - 사용법
        /*+leading(a c) use_hash(c)*/
        아마 힌트를 주지 않아도 옵티마이저가 알아서 hash 조인을 하는 경우도 있지만, 이러한 힌트를 명시해주는 것이 바람직

    - 힌트에 관해서  https://devuna.tistory.com/35
        - 힌트란 SQL 튜닝의 핵심 부분으로 일종의 지시 구문이다.
          즉, 오라클 옵티마이저(Optimizer)에게 SQL 문 실행을 위한 데이터를 스캐닝하는 경로, 조인하는 방법 등을 알려주기 위해
          SQL 사용자가 SQL 구문에 작성하는 것을 뜻한다. 오라클이 항상 최적의 실행 경로를 만들어 내기는 불가능하기 때문에
          직접 최적의 실행 경로를 작성해 주는 것이다. 사용자가 특정 SQL 문장에서 어떤 인덱스가 선택도가 높은지 알고 있는 경우
          Optimizer 에 의존한 실행 계획보다 훨씬 효율적인 실행 계획을 구사할 수 있다.

        - 단, 힌트, 인덱스, 조인의 개념을 정확히 알고 사용하지 않은 무분별한 힌트의 사용은 성능의 저하를 초래하기 때문에
          잘 알고 최적의 실행 경로를 알고 있을 경우 적절하게 사용하여야 한다.

        - (힌트에 오타가 있는 경우는 큰 관계가 없다. 왜냐하면, 잘못 사용된 힌트는 무시되어 힌트가 없는 것처럼 동작하기 때문)

        - 힌트를 사용하여 아래와 같은 것들을 할 수 있다.
          액세스 경로, 조인 순서, 병렬 및 직렬 처리, Optimizer 의 목표(Goal)를 변경 가능하다.
          데이터 값을 정렬해야 하는 경우, 힌트의 사용이 필요
          드라이빙 테이블을 원하는 대로 선정하고자 할 때도 사용

- connection timeout 과 read timeout 차이
    - connection time out
        - 클라이언트가 서버측으로 connection 맺길 원하지만 서버와 connection 이 맺어지지 못할 때 발생한다.
          이 경우, 클라이언트의 OUTBOUND, 서버 측의 INBOUND 방화벽을 확인해 볼 필요가 있다.

        - 웹 브라우저가 네이버 서버에 접속하기 위해서 서버와 연결된 상태가 되어야한다. 보통 연결을 구성하기위해
          TCP Connection 과 동일하게 3-way-HandShake 방식으로 수행하게 된다. 3-way HandShake 가 정상적으로
          수행하게 되면 웹 브라우저와 네이버 서버는 연결된 상태가 되는데, 이때까지 소요된 시간을 Connection 에
          소요된 시간이라고 할 수 있다.
          "즉, ConnectionTimeout 이란 3-way HandShake 가 정상적으로 수행되어 서버에 연결되기까지 소요된 시간이다."

    - Read time out
        - Connection time out 과는 다르게 클라이언트와 서버가 connection 은 맺어졌지만, I/O 작업이 길어지거나 데이터를 읽어가지 못하는
          상황이 되어, 설정된 시간을 초과하여 생기는 문제이다. 보통 Tcp connection 은 3way-HandShake 방식으로 수행한다.
          해당 방식을 통해 정상적으로 수행하게 되면 connection 이 맺어지고, 서버 측에서 데이터를 전달, 클라이언트에서 읽어가는 형식이다.
        - "Connection 맺은 후 Response(응답)을 받기까지 소요될 시간의 임계치이다."
        - client 가 server 에 접속을 성공 했으나 서버가 로직을 수행하는 시간이 너무 길어 제대로 응답을 못준 상태에서
          client 가 연결을 해제하는것이 Read timeout 입니다.

- noSQL
    - NoSQL 정의
        - Not Only SQL
        - NoSQL 은 비관계형 데이터베이스를 지칭한다. 즉, 관계형 데이터 모델을 지양 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며
          스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.
        - NoSQL 은 기존 RDBMS 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며,
          관계형 데이터베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태이다.

    - NoSQL 의 특징
        - RDBMS 와 달리 데이터 간의 관계를 정의하지 않는다.
            - RDBMS 는 데이터 관계를 외래키 등으로 정의하고 JOIN 연산을 수행할 수 있지만, NoSQL 은 JOIN 연산이 불가능하다.
        - RDBMS 에 비해 대용량의 데이터를 저장할 수 있다.
            - 페타바이트 급의 대용량 데이터를 저장할 수 있다.
        - 분산형 구조이다.
            - 여러 곳의 서버에 데이터를 분산 저장해 특정 서버에 장애가 발생했을 때도 데이터 유실 혹은 서비스 중지가 발생하지 않도록 한다.
        - 고정되지 않은 테이블 스키마를 갖는다.
            - RDBMS 와 달리 테이블의 스키마가 유동적이다. 데이터를 저장하는 칼럼이 각기 다른 이름과 다른 데이터 타입을 갖는 것이 허용된다.

    - NoSQL 의 장점
        - RDBMS 에 비해 저렴한 비용으로 분산처리와 병렬 처리 가능
        - 비정형 데이터 구조 설계로 설계 비용 감소
        - Big Data 처리에 효과적
        - 가변적인 구조로 데이터 저장이 가능
        - 데이터 모델의 유연한 변화가 가능

    - NoSQL 의 단점
        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 데이터 일관성이 항상 보장되지 않음

    - NoSQL 의 종류
        - Key-Value Database
            - 기본적인 패턴으로 KEY-VALUE 하나의 묶음(Unique)으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장 시 용이하다.
            - Key 안에 (COLUMN, VALUE) 형태로 된 여러 개의 필드, 즉 COLUMN FAMILIES 갖는다.
              주로 SERVER CONFIG, SESSION CLUSTERING 등에 사용되고 엑세스 속도는 빠르지만, SCAN 에는 용이하지 않다.
            Ex) Redis, Oracle NoSQL Database, VoldeMorte

        - Wide-Column Database
            - 행마다 키와 해당 값을 저장할 때마다 각각 다른값의 다른 수의 스키마를 가질 수 있다.
              위 그림을 참고하면 사용자의 이름(key)에 해당하는 값에 스키마들이 각각 다름을 볼 수 있다.
              이러한 구조를 갖는 WIDE COLUMN DATABASE 는 대량의 데이터의 압축, 분산처리, 집계 쿼리 (SUM, COUNT, AVG 등)및
              쿼리 동작 속도 그리고 확장성이 뛰어난 것이 그 대표적 특징이라 할 수 있다.
            EX) Hbase, GoogleBigTable, Vertica

        - Document Database
            - 테이블의 스키마가 유동적, 즉 레코드마다 각각 다른 스키마를 가질 수 있다.
              보통 XML, JSON 과 같은 DOCUMENT 를 이용해 레코드를 저장한다.
              트리형 구조로 레코드를 저장하거나 검색하는 데 효과적이다.
            Ex) MongoDB, CouchDB, Azure Cosmos DB

        - Graph Database
            - 데이터를 노드로(그림에서 파란, 녹색 원) 표현하며 노드 사이의 관계를 엣지(그림에서 화살표)로 표현
              일반적으로 RDBMS 보다 성능이 좋고 유연하며 유지보수에 용이한 것이 특징.
              Social networks, Network diagrams 등에 사용할 수 있다.
            Ex) Neo4j, BlazeGraph, OrientDB

-  릴레이션 키 개념&종류 (슈퍼키,대체키,후보키,기본키,외래키)
    https://jerryjerryjerry.tistory.com/49
    https://jhnyang.tistory.com/71
    https://velog.io/@00yubin00/DB-%ED%82%A4%EC%9D%98-%EC%A2%85%EB%A5%98-%EC%8A%88%ED%8D%BC%ED%82%A4-%ED%9B%84%EB%B3%B4%ED%82%A4-%EA%B8%B0%EB%B3%B8%ED%82%A4-%EB%8C%80%EC%B2%B4%ED%82%A4-%EC%99%B8%EB%9E%98%ED%82%A4

* DDL vs DML vs DCl
    - DDL : 스키마, 도메인, 테이블, 뷰, 인덱스 등을 정의하거나 결정하는 언어.
    - DML : 저장된 데이터를 실질적으로 처리하는데 쓰이는 언어.
    - DCL : 데이터의 보안, 무결성, 수행 제어 등을 정의하는 데 사용

* 조인 순서
    https://loklee9.tistory.com/96

***** querydsl 성능개선
    https://www.youtube.com/watch?v=zMAX7g6rO_Y&t=295s

* 힌트 인덱스    https://tnsgud.tistory.com/400
    지정된 테이블access에 Index Scan 유도.

    하나의 Index만 지정되면 Optimizer는 해당index를 이용.

    여러개의 인덱스가 지정되면 Optimizer가 각 Index의 Scan시 Cost를 분석 한 후 최소비용이 드는 Index사용. 경우에 따라 Optimizer는 여러 Index를 사용한 후 결과를 Merge하는 Acees방식도 선택합니다.

    Index가 지정되지 않으면 Optimizer는 테이블의 이용가능한 모든 Index에 대해 Scan Cost를 고려 후 최저비용이 드는 Index Scan을 선택합니다.


- 마이바티스
    http://125.132.25.164/dokuwiki/doku.php?id=wiki:spring:mybatis
- DML, DDL, DCL
- union vs union all

- SQL SELECT 쿼리 실행 순서 처리 과정
    https://myjamong.tistory.com/172
    http://www.yes24.com/Product/Goods/6960931

***** Real MySQL 8.0
    http://www.yes24.com/Product/Goods/103415627

* SELECT 쿼리문에서의 문법 순서와 실행 순서
    https://soo-vely-dev.tistory.com/220

* 인덱스 튜닝
    https://sigmasabjil.tistory.com/17


****** 인덱스  https://bcp0109.tistory.com/365
    - 인덱스 란
        - 인덱스를 설정하면 특정 컬럼들을 키 값으로 메모리 영역에 트리 구조로 저장해둡니다.
          그리고 디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
          인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.
          이를 위해 데이터가 추가/삭제 될 때마다 자료구조를 정렬하기 때문에 인덱스는 SELECT 성능을 향상시키는 대신 INSERT, UPDATE, DELETE 의 성능이 떨어지게 됩니다.

    - 인덱스 종류
        - Clustered Index vs Non-Clustered Index
            - Clustered Index
                - 이름 그대로 인접한 데이터들을 한곳으로 모았다는 뜻
                - PK 설정 시 자동으로 클러스터드 인덱스로 만들어짐
                - 테이블당 1개씩만 허용
                - 물리적인 데이터를 갖고 있음
                - 항상 정렬된 상태를 유지하고 노드 내에서도 정렬되어 있음
                - Non Clustered 인덱스에 비해 조회 속도가 빠르지만 삽입/수정/삭제는 더 느림

            - Non Clustered Index
                - UNIQUE 로 설정된 컬럼에 자동으로 생성됨
                - 인덱스 페이지는 로그 파일에 저장됨
                - 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됨
                - 기본키는 아니지만 성능 향상을 위해 임의의 컬럼을 지정해서 만든 인덱스

    - 인덱스 자료구조
        - B-Tree 인덱스
            - Balanced Tree 의 약자로서 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적으로 사용되는 알고리즘
            - B-Tree 인덱스는 컬럼의 값을 변경시키지 않고 구조체 내에서 항상 정렬된 상태를 유지
            - B-Tree 는 최상위에 루트 (Root) 노드가 존재하고 하위에 브랜치 (Branch) 노드, 마지막에 리프 (Leaf) 노드로 되어 있습니다.
            - 부모 노드를 기준으로 왼쪽 자식 노드는 더 작은 값 오른쪽 자식 노드는 더 큰값을 갖고 있습니다.

        - 왜 B-Tree 인가?
            - 인덱스로 사용할 수 있는 자료구조는 여러 개가 있을 겁니다.
            - Tree 구조의 Worst 시간복잡도는 한쪽으로 모든 자식 노드가 쏠려있는 형태인 O(n) 입니다.
            - 그래서 우리는 자식 노드가 양쪽에 골고루 퍼져있는 Balanced Tree 를 사용합니다.
            - Balanced Tree 중에는 RedBlack Tree 도 있는데 왜 사용하지 않을까요? 해시 테이블은 O(1) 인데 왜 사용하지 않을까요?

        - 다른 트리 구조를 사용하지 않는 이유
            - RedBlack Tree 는 B-Tree 와 마찬가지로 정렬된 상태와 밸런스를 유지
            - B-Tree 와 차이가 없을 것 같은데 왜 사용하지 않을까요?
            - 가장 큰 차이점은 B-Tree 는 노드 하나에 여러 개의 데이터를 저장할 수 있다
            - 노드에서 배열 형태로 여러 데이터를 저장할 수 있기 때문에 트리 포인터를 참조해서 계속 depth 를 타고 들어가는 것보다 효율적이고 이는 데이터가 많아질수록 차이가 두드러집니다.

        - Hash 테이블을 사용하지 않는 이유
            - 해시 테이블은 Hash 함수를 사용해서 키 값을 해싱한 후에 테이블에 저장합니다.
            - 해시 테이블은 분명 한 가지 키에 대한 탐색은 효율적입니다.
            - 하지만 데이터가 정렬되어 있지 않기 때문에 부등호 (<, >) 를 사용하지 못한다는 단점이 있습니다.

        - B-Tree 인덱스의 쿼리별 특징
            - SELECT
                - 특정 키 값을 찾기 위해 자식 노드를 계속 타고 들어가는 방식
                - 마지막 리프 노드에는 레코드의 주소가 존재하고 이 값으로 테이블 레코드를 찾을 수 있음

                - B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
                  그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

            - INSERT
                - B-Tree 에 새로운 키값을 저장할 때는 우선 적절한 위치를 찾아야함
                - 새로운 키값과 레코드 정보는 리프 노드에 저장
                - 만약 리프 노드가 꽉찼다면 트리를 재구성하여 리프 노드를 분리
                - 분리 과정에서 해당 리프 노드의 부모 노드까지 영향이 갈 수 있음
                - 이러한 이유로 INSERT 작업은 상대적으로 비용이 많이 듬
                - 인덱스가 많으면 많을수록 이런 비용이 추가로 들기 때문에 너무 많은 인덱스를 추가하는 건 성능에 영향을 줌

            - DELETE
                - B-Tree 에서 키 값 삭제는 간단
                - 해당 키를 찾아서 삭제 마크만 하면 작업이 완료
                - 삭제 마킹된 인덱스 키 공간은 그대로 두거나 재활용 가능

            - UPDATE
                - 인덱스는 항상 정렬된 상태로 유지됨
                - 단순히 인덱스 키 값을 수정한다면 트리의 전체 구조를 바꿔야 할 수도 있음
                - 그래서 B-Tree 에선 키 변경이 아닌 기존 키 삭제 (DELETE) 후 새로운 키 추가 (INSERT) 방식을 사용
                - 따라서 키 값의 잦은 수정은 성능에 큰 영향을 미침

    - 인덱스 설정 시 고려사항
        - 인덱스의 갯수
            - 인덱스의 갯수는 3 ~ 4 개가 적당
            - 인덱스의 갯수가 너무 많으면 다음과 같은 이슈가 존재
                - 데이터 삽입/수정/삭제 시마다 인덱스도 같이 추가하거나 수정/삭제 해주어야 해서 성능상 이슈가 존재
                - 데이터 삽입시마다 인덱스도 같이 추가하기 때문에 인덱스가 늘어날수록 더 많은 메모리를 차지함
                - 인덱스가 많아지면 옵티마이저가 잘못된 인덱스를 선택할 확률이 높아짐 (인덱스 힌트로 원하는 인덱스를 지정할 순 있음)

        - 인덱스를 걸기에 적절한 컬럼
            - 인덱스의 갯수에 한계가 있다면 적절한 인덱스 컬럼을 정하는 것도 중요
            - 인덱스는 카디널리티 (Cardinality) 가 높은 컬럼에 지정하는 게 좋습니다.
            - 카디널리티가 높다는 말은 데이터의 중복이 적다는 뜻인데 대표적으로 ID, 주민번호 등이 있습니다.
            - 반대로 성별 같은 중복된 데이터가 많은 경우 카디널리티가 낮다고 표현
            - 성별에 인덱스를 거는 경우 인덱스를 타더라도 남/녀 두가지만 존재하기 때문에 결국 나머지 조건에 맞는 데이터는 직접 풀스캔을 해서 찾아야 합니다.
            - 하지만 ID 같이 중복된 값이 없는 경우 해당하는 데이터를 빠르게 찾을 수 있습니다.

        - 읽어야 하는 레코드 갯수
            - 인덱스는 일반적으로 단 하나의 데이터를 구할 때 가장 효율적
            - 여러 개의 데이터를 구한다면 인덱스를 통해 레코드의 주소를 찾아 데이터의 레코드를 읽는 작업을 반복해야 합니다.
            - 그래서 만약 많은 레코드를 한번에 조회한다면 오히려 인덱스를 사용하지 않고 직접 테이블을 읽는 것이 더 효율적일 수 있습니다.
            - 일반적으로 DBMS 의 옵티마이저는 인덱스를 사용해 레코드 1건을 읽는 것이 테이블에서 직접 읽는 것보다 4 ~ 5배 정도 비용이 더 많이 든다고 예측
            - 그러므로 인덱스를 통해 읽어야 할 레코드가 전체 테이블의 20 ~ 25% 이상이라면 직접 테이블을 읽는 것이 효율적

        - 복합 인덱스를 구성할 때
            - 인덱스는 여러 개의 컬럼을 동시에 지정할 수도 있는데 어떤 순서로 구성하느냐에 따라 성능이 달라집니다.
            - 인덱스는 트리 구조로 되어있다고 했는데, 여러 개의 컬럼을 함께 키 값으로 지정하는 경우 먼저 첫 번재 컬럼을 기준으로 정렬된 뒤에 두번째 컬럼이 정렬되어 있습니다.
            - 이 말은 즉 첫 번째 컬럼 없이 두 번째 컬럼만 갖고 인덱스를 조회하면 제대로 된 위치를 찾을 수 없다는 뜻
            - 그러므로 복합 인덱스를 구성했다면 조회할 때 앞 순서의 조건을 반드시 포함해야 인덱스를 태울 수 있습니다.
            - 여러 개의 컬럼이 있다면 카디널리티가 높은 순에서 낮은 순으로 지정하는게 인덱스의 효율을 이끌어낼 수 있습니다.
            - 과거에는 인덱스의 컬럼 순서와 조회 컬럼 순서를 맞춰야 인덱스를 탔지만 최근에는 옵티마이저가 알아서 인덱스 순서에 맞춰주기 때문에 거의 차이가 없습니다.
            - 그래도 재배열하는 과정을 생략하기 위해 최대한 맞추는게 좋다.

    - 인덱스 사용 시 주의사항
        - 다중 인덱스를 사용할 때 범위 조건은 인덱스를 타지만 이후 컬럼들은 인덱스를 타지 않음
            WHERE 컬럼1 = ?
            AND   컬럼2 = ?
            AND   컬럼3 BETWEEN ? AND ? -- 결합인덱스에서 '='이 아닌 연산자를 사용하는 첫 번째
            AND   컬럼4 = ?

            컬럼3에서 BETWEEN을 사용했기에 컬럼3 까지만 인덱스를 타고 후행컬럼인 컬럼4는 인덱스를 타지 않고 필터만 한다.
            그래서 결합인덱스 = 컬럼1 + 컬럼2 + 컬럼4 + 컬럼3으로 순서를 바꿔줘야한다.

        - 인덱스를 타지 않는 경우
            1. 인덱스 컬럼의 변형
                - 인덱스에 변형을 가하게 되면, DBMS가 인덱스를 이용하지 않는다.
                - 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 range scan 가능
                  인덱스 칼럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문
                  그래서 인덱스 칼럼을 가공하면 index full scan 을 하게 된다.
            2. 부정형의 사용
                - NOT일 경우 무조건 인덱스를 안타는 것이 아니라 일반적으로 NOT에 사용된 값이 아닌 데이터 비율이 높은 경우가 많기 때문에 인덱스를 타지 않는다.
            3. IN 연산자 사용
                - IN일 경우에도, IN에 포함된 데이터들의 비율이 매우 높다면 FULL SCAN을 하는 것이 낫다고 DBMS가 판단하면 인덱스를 타지 않는다.
                - Mysql에서는 range_optimizer_max_mem_size 설정의 용량을 In절의 파라미터가 넘어서면 FullScan을 한다.
                  다른 DB의 경우도 파라미터가 많아지면 옵티마이저가 FullScan을 할 수 있다.
                - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.
                  하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능
            4. LIKE문을 사용할 때 전체 범위를 설정할 시
                - 문자열로 이루어진 값을 인덱스로 잡았을 때, %가 앞쪽에 사용되면 정렬 순서를 사용할 수 없으므로 테이블 FULL SCAN이 이루어진다.
                  select * from table  where name like 'word%'; -> 쿼리가 이런 경우 인덱스를 탄다. 문자열 정렬 순서를 그대로 이용할 수 있기 때문이다. (Index Range Scan 이 가능)
                  인덱스를 걸면 해당 컬럼은 정렬이 됩니다. 정렬된 문자열 앞부분부터 검색해야 하는데, LIKE절이 '%'로 시작하면 앞 문자열을 모르니 인덱스를 사용할 수 없게 됩니다.

                - 정규표현식 REGEXP 을 사용해도 인덱스를 더치지 않고 풀 스캔이 일어난다.
                - 가능하면 INSTR 을 사용하는 것도 나쁘지 않다. INSTR('비교할 대상', '비교하고자 하는 값', 비교를 시작할 위치, 검색된 결과의 순번)
                  select * from table where INSTR(column_name, value) > 0  ???
            5. 복합인덱스에서 첫인덱스가 첫조건으로 적용하지 않았을경우
                - select * from table where name = 'word' or idx = 5
                - name과 idx가 둘다 인덱스가 걸려있는 경우라해도, DBMS가 최적의 OR 조건을 뽑기 힘들어, FULL SCAN 하는 경우가 많다.
            6. NULL 조건의 사용
            7. 인덱스 컬럼의 내부적인 데이터 변환
                - 문자값 데이터타입을 갖는 컬럼에 ‘값’ → 값 을 하지 말고 정확한 데이터 타입을 넣어야 인덱스를 탈 수 있다.
            8. OR 조건 사용
                - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

    - InnoDB Adaptive Hash Index
        - MySQL 은 기본으로 InnoDB 를 사용하고 InnoDB 는 B-Tree 를 사용합니다.
        - PK 가 아닌 컬럼으로 인덱스를 지정하면 Non Clustered Index 가 생성됩니다.
        - 그래서 인덱스로 컬럼을 조회하면 Secondary 인덱스를 기반으로 PK 를 찾은 뒤 다시 Primary Index 로 데이터를 찾아냅니다.
        - 인덱스를 두번 타기 때문에 2 * O(log n) 비용이 듭니다.
        - 그래서 자주 사용되는 컬럼을 해시로 정의해서 B-Tree 를 타지 않고 바로 데이터에 접근할 수 있게 하는 걸 Adaptive Hash Index
        - 미리 캐싱한 해시값으로 조회하기 때문애 O(1) 의 속도를 보여주지만 어떤 값을 해싱할지는 옵티마이저가 판단하기 때문에 제어할 수 없다는 약점이 있습니다.

    - Covering Index
        - 인덱스를 사용하면 특정 컬럼 값을 키로 하여 데이터의 주소값을 구한 뒤 해당 주소값으로 다시 테이블에 접근해서 최종 데이터를 구합니다.
        - 커버링 인덱스란 인덱스에 이미 필요한 데이터가 전부 존재해서 테이블에 접근할 필요가 없는 인덱스를 의미
        - 인덱스는 기본적으로 Non Clustered Index 에서 먼저 값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.
        - 여기서 커버링 인덱스가 사용되었다는건 Clustered Index 까지 통하지 않고 Non Clustered Index 만으로도 데이터를 구할 수 있다는 뜻
        - 커버링 인덱스가 적용되면 EXPLAIN 실행 시 Extra 필드에 Using index 라고 표시

    - 인덱스 스캔 방식  https://jungmina.com/720
        - Index Range Scan
            - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식(수직적 탐색 후 필요한 범위만 수평적 탐색)
            - 항상 빠른 속도를 보장하진 않음
            - 인덱스 스캔 범위를 얼만큼 줄일 수 있느냐, 테이블 액세스 횟수를 얼만큼 줄일 수 있느냐가 관건
                 => 인덱스 설계와 SQL 튜닝의 핵심 원리
            - 인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 함
            - where 조건에서 =, >, <, like 'abc%' 같은 경우에 선택됨

        - Index Full Scan
            - 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
            - 최적의 인덱스가 없을 때 차선책(인덱스 선두 컬럼이 조건절에 없을 경우)
            - 최종 결과값이 적을때 Table Full Scan보다 Index Full Scan이 훨씬 효율적

        - Index Unique Scan
            - 수직적 탐색만으로 데이터를 찾는 스캔 방식
            - Unique Index를 통해 '=' 조건으로 탐색하는 경우
            * Unique Index를 이용했지만 Index Range Scan이 나타나는 경우
                - Unique Index를 통해 범위 조건(between, 부등호, like)으로 검색하는 경우
                - 결합 형태인 Unique Index의 일부 컬럼만으로(선두 컬럼 포함) 검색하는 경우

        - Index Skip Scan
            - 인덱스가 세 개의 컬럼으로 구성되어 있는데 중간 컬럼에 대한 조건절만 누락된 경우나 Distinct Value가 적은 두 개의 선두 컬럼이 모두 누락된 경우
            - 선두 컬럼이 범위 조건(between, 부등호, like) 검색인 경우
            - 조회 조건에 인덱스 선두 컬럼이 없는데 선두 컬럼의 Distinct Value 개수가 적은 경우

        - Index Fast Full Scan
            - Index Full Scan보다 빠름
            - Index를 논리적 구조 순으로 읽지 않고 물리적으로 디스크에 저장된 순서대로 읽음(Segment 전체를 Scan)
            - Multiblock I/O
            - 결과 집합이 Sorting된 상태가 아닐 수 있음
            - 쿼리에 사용되는 모든 컬럼이 인덱스 컬럼에 포함돼 있을 때만 사용 가능
            - 병렬스캔 가능

* like 검색을 대체할 방법
    - Instr(칼럼, 검색어) > 0
    - 정규식 사용 regexp_like, regexp_instr


* like 검색을 개선할 방법
    - 오라클 text 기능 사용 : 도메인 인덱스
    - 별도의 인덱스 구성 : 공백을 기준으로 단어들을 나누어 테이블 키와 함께 별도의 인덱스 테이블 구성
    - 별도 검색엔진 사용


* Index Fast Full Scan을 활용한 튜닝 사례
    select * from 공급업체
    where 업체명 like '%네트웍스%'
    - TABLE ACCESS Full
    - 실행시간 5초 이상 소요
    - 결과 건수 21
    =>
    select /*+ ordered use_nl(b) no_merge(b) rowid(b) */ b.*
    from (select /*+ index_ffs(공급업체 공급업체_X01) */ rowid rid
           from 공급업체
          where instr(업체명, '네트웍스') > 0) a, 공급업체 b
    where b.rowid = a.rid
    - 업체명 컬럼의 인덱스를 Fast Full Scan 해서 얻은 rowid를 이용해 테이블을 다시 억세스.
    - like 연산자보다 빠른 instr 함수 사용.
    - 최종 결과 건수가 많아지더라도 부분범위 처리가 가능한 애플리케이션 환경이면 유리.
    - 11g라면 결과 건수가 많더라도 인라인 뷰에 'order by rowid'를 추가함으로써 큰 효과를 얻을 수 있다(5절 (5)항에서 설명)
    - 데이터 건수가 많다면 parallel_index 힌트를 이용해 병렬쿼리도 가능.


* like '% ...' 성능 튜닝
    SELECT /*+ ordered use_nl(B) no_merge(B) rowid(B) */ B.*

      FROM ( SELECT /*+ index_ffs(공급업체 공급업체_X01) */ ROWID RID

                    FROM 공급업체

      WHERE INSTR(업체명, '네트웍스') > 0 ) A, 공급업체 B

    WHERE B.ROWID = A.RID;

    -- Index Fast Full Scan은 모든 컬럼이 인덱스에 포함돼 있을 때만 사용 가능

    -- 일단 해당 레코드의 ROWID만 Index Fast Full Scan으로 빠르게 get

    -- 인덱스로부터 얻은 ROWID로 테이블 액세스


****** 친절한 SQL 튜닝
    https://camel-context.tistory.com/2
    https://camel-context.tistory.com/3
    https://camel-context.tistory.com/4
    https://camel-context.tistory.com/5
    https://camel-context.tistory.com/6
    https://camel-context.tistory.com/9

    https://wooncloud.tistory.com/98 ~ 109

* 인덱스 튜닝
    https://tychejin.tistory.com/198
    https://tychejin.tistory.com/199
    https://tychejin.tistory.com/202
    https://tychejin.tistory.com/205

* 조인 방법
    - 중첩 루프 조인(Nested Loop Join, NLJ)
        - where 절에 있는 조건에 따라 두 테이블에서 하나의 테이블을 기준으로 삼아 다른 하나의 테이블에 있는 데이터를 읽는 방식으로 조인을 수행.
        - 기준이 되는 테이블을 드라이빙 테이블/아우터 테이블 이라고 하며, 나머지 테이블을 이너 테이블 이라고 한다.
        - 프로그래밍의 for 이중루프랑 같다.
        - NLJ는 메모리가 필요없는 조인 방법으로 추가적인 메모리 비용이 들지 않는다.
        - 어떤 테이블을 드라이빙 테이블로 선택하느냐가 중요하다. 왜냐면 드라이빙 테이블의 로우를 가지고 이너를 검색하기 때문

    - 정렬 병합 조인(Sorted Merge Join, SMJ)
        - 두 테이블을 각각 정렬한 다음 조인조건에 맞는 건을 찾아 합치는 방식이다.
        - 드라이빙 테이블이 별도로 존재하지 않으며, 모두 독립적으로 동등한 레벨에 있다.
        - 정렬 작업을 위해 추가적인 메모리를 사용한다. 디스크 I/O가 발생한다.
        - NJL보다 많은 양의 데이터를 처리할 때 유리하며, 메모리만 사용해서 정렬 작업을 수행한다면 넓은 범위의 값을 검색하는데 유용하다.
        - 두 테이블의 데이터를 각각 정렬하는 작업이 전체 성능에 영향을 많이 끼치게 된다. 해서 select 리스트에서 불필요한 칼럼은 제거해서
          정렬 작업 수행 시 부하를 적게 줘야 한다.
        - 일반적으로 >, >=, <, <= 와 같은 비동등 연산자가 사용될 때 쓰인다.

    - 해쉬 조인(HJ)
        - 두 테이블 중 where 조건에 의해 필터링된 로우 수가 적은 테이블을 대상으로 해쉬 테이블을 만든 후에 조인 조건에 따라 다른 하나의 테이블의 데이터를 검색하는 방법이다.
        - HJ 방법은 해시 테이블이 드라이빙 테이블이 되어 NLJ를 수행한다고 보면 된다.
        - 해시 테이블은 HASH_AREA_SIZE에 지정된 메모리 값 내에서 해시 테이블을 만들게 되므로 대상 테이블의 크기가 이 값 내에 있을 경우 유용한 조인
        - 보통 HASH_AREA_SIZE 값은 SORT_AREA_SIZE 값의 2배로 설정한다.
        - 해시 조인은 조인 조건에서 동등조건이 사용되었을 때만 가능하다.
        - 보통 반환되는 로우수가 적은 테이블(이 테이블을 대상으로 해시 테이블을 만든다.)과 이에 반해 반환되는 로우수가 상당히 많은 테이블을 조인 시에 유리하다.


* null 값은 인덱스 생성안함

*  어떤 선행이 좋은 선행일까?
          - where 절에 자주 검색 되는 컬럼 선행
          - 분포도 좋은 것이 선행
          - 데이터 양이 적은 것이 선생
          - BETWEEN,> AND <, LIKE 보다( = )동등 조건으로 검색 되는 컬럼을 선행...데이터량을 줄이기 때문에

* B-Tree의 장점과 단점
    장점
    노드가 균형 있게 구성되어 있어서, 최악의 경우이더라도 일관된 탐색 시간(O(logN))을 가질 수 있다.

    단점
    재정렬을 해야 하는 작업으로 인해, 노드를 삽입 하거나 삭제 할 때 일반적인 트리보다 성능이 떨어진다.


* 인덱스는 어떻게 작동하는가?
    일반적으로 B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
    그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

* 인덱스 설계과정
  SQL별 접근경로조사 : 개발된 모든 SQL확인, 조건, 형변환등확인 표로정리
  테이블별 접근 경로 정리 : 테이블별 조인조건 확인
  종합적인 인덱스 설계
  핵심 테이블 및 핵심 SQL 집중 설계
  인덱스 생성 및 모니터링 : 생성후에 모니터링을 통한 개선필요.

* 인덱스를 사용하게 되면 테이블에 바로 접근하지 않고 인덱스 영역에서 빠르게 ROWID를 찾아낸 후 실제 테이블에서 해당하는 데이터를 찾는다.

* 주의사항 :
  /*+ 다음에 스페이스를 반드시 줘야 함.
  테이블 알리아스를 사용해야 한다. 테이블의 물리명을 사용하면 안됨.

   SINGLE TABLE QUERY에서는 HINT 절에 table 명을 주는 것이 원칙이다.

  * Hint 내의 table_name은 alias를 사용하였을 경우에는 반드시 table alias name으로 지정하여야 한다.

  * 그 이유는 다음과 같이 SQL이 사용될 경우도 있기 때문니다.

  (SELF-JOIN)

  select /*+ index_desc(a a_pk) */
  *
  from t1 a, t1 b
  where a.key1 = 'a'
  and a.key1 = b.prev_c1(+)
  and a.seq = b.pseq_no(+)
  and rownum = 1

  위와 같이 동일한 TABLE이 FROM 절 뒤에 복수로 나오는 경우 (Recursive 관계)가 있을 수 있는데 이 때 Hint 절의 table 명을
  유일하게 줄 수가 없으므로 반드시 table alias name을 주어야  원하는 답이 나온다.

https://programmingyoon.tistory.com/264    http://ojc.asia/bbs/board.php?bo_table=LecHINT&wr_id=169
1-1 해당 쿼리가 왜 인덱스 타지 않았는지? (인덱스를 저장하는 구조를 활용하여)
    - 양방향 like 검색
1-2 양방향 LIKE 검색 경우 인덱스를 타지 않는데 힌트만 줘서는 인덱스가 타도록 유도가 안되는데 구체적으로 어떻게 해결한건지?
    - 문자열 % like 검색 으로 바꿈
1-3 여러가지 인덱스가 있을텐데 어떤 인덱스를 타고 있기 때문에 다른 인덱스를 타도록 유도하기 위해서 힌트를 사용했을텐데 그 과정
    - 결합인덱스의 선행 칼럼 조건이 입력되지 않아 INDEX FAST FULL SCAN 이던걸 INDEX_SS 를 통해 INDEX SKIP SCAN 유도

***** INDEX 기본 구조와 사용
    https://kwomy.tistory.com/72

***** Oracle 반드시 알아야 하는 오라클 힌트절 7가지
    https://exmemory.tistory.com/44

* 인덱스가 걸려있는 컬럼을 MIN, MAX를 쓰면 INDEX_ASC, INDEX_DESC 테이블 힌트를 사용하지 않아도 자동으로 인덱스를 사용한다.

* [Real MySQL] B-Tree 인덱스
    https://12bme.tistory.com/138

* 커버링 인덱스
    https://frogand.tistory.com/195

****** 데이터베이스 인덱스는 왜 'B-Tree'를 선택하였는가
    https://helloinyong.tistory.com/296

****** 옵티마이저와 힌트
    https://velog.io/@tastestar/%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80%EC%99%80-%ED%9E%8C%ED%8A%B8

* SQL 쿼리를 짤 때 주의해야 하는 것들  https://medium.com/watcha/%EC%BF%BC%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%B2%AB%EA%B1%B8%EC%9D%8C-%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-7%EA%B0%80%EC%A7%80-%EC%B2%B4%ED%81%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8-bafec9d2c073
    1. where 조건절 걸 때, index 순서에 맞게 거는게 좋다.
    2. SQL 쿼리에서 풀스캔이 있는지 없는지 확인한다.
        - SQL 실행 속도를 현저하게 비효율적으로 만드는 것이 풀스캔이다. 데이터가 많은 경우 out of memory가 발생하거나 DB 서버가 죽어버린다.
    3. Driving Table 을 정한 후에 사용해야 한다.
        - 데이터 수가 적은 테이블을 Driving Table 로 선정
    4  같은 내용의 조건이라면, GROUP BY 연산 시에는 가급적 HAVING보다는 WHERE 절을 사용하는 것이 좋습니다.
    5. SELECT DISTINCT, UNION DISTINCT와 같이 중복 값을 제거하는 연산은 최대한 사용하지 않아야 합니다.
    6. 3개 이상의 테이블을 INNER JOIN 할 때는, 크기가 가장 큰 테이블을 FROM 절에 배치하고, INNER JOIN 절에는 남은 테이블을 작은 순서대로 배치하는 것이 좋습니다
    7. IN 대신 EXISTS 사용
        - 서브 쿼리의 결과가 많으면 EXISTS가 나은 성능을 제공하며 그렇지 않으면 IN을 사용하는 것이 좋습니다.
        - EXISTS는 일치하는 항목이 발견되는 즉시 검색 프로세스를 종료하지만 IN은 모든 항목을 비교하기 때문입니다.
    8. ORDER BY 금지
        - RDBMS마다 다르지만 서브 쿼리(Sub Query)에서 Order By를 사용하는 경우 많은 비용이 발생합니다. 그러므로 서브 쿼리에서 Order By를 사용하지 않도록 합니다.
    9. WHERE문에 함수 사용 제한
        - COL1이라는 컬럼이 인덱스로 잡혀있는데 WHERE문에서 함수와 함께 사용되면 인덱스가 깨지므로 검색 속도가 느려집니다.
          인덱스로 잡혀있는 칼럼은 WHERE문 또는 JOIN에서 함수와 사용하는 것을 피해야 합니다.


* SQL 성능 향상 팁   https://link2me.tistory.com/544
    - index를 타는지 항상 체크하라.
    - select 쿼리문 작성시 필요한 칼럼(column)만 명시
    - where조건문의 왼쪽은 되도록 변형되지 않은 순수한 column만을 선언
    - JOIN을 사용하는 경우 INNER JOIN을 되도록 사용
    - 서브쿼리 사용시 불필요한 select 구문을 줄여라.

    -> 전반적인 성능향상을 꾀하려면 CPU, 메모리, I/O 의 밸런스를 맞추어야 한다. DB성능 튜닝은 이 세가지 자원에 걸리는 부하를 적절하게 분산시켜 비용대비 최적의 성능을 뽑아내는것이 핵심이다.

    * 일반적으로 대용량 테이블이라 하더라도 인덱스가 제대로 작동하고 있다면 검색 자체가 성능저하를 가져 오지는 않는다.
      다만, 복수의 JOIN과 같이 대량의 Nested Loop 가 발생한다면 엄청난 양의 I/O가 발생하고 이것이 RDB전체의 성능을 크게 저하시키는 원인이 되기도 한다.

    * HDD의 I/O 속도는 메모리에 비하여 많이 느리다. 10,000RPM HDD와 DDR3-2500 메모리의 성능 차이는 약 800배에 이른다.
      DBMS 같은 시스템에서는 효과적으로 버퍼(캐시)를 구현하여 I/O 발생을 최소화하도록 구현하고 있다. 그래서 히트(hit)율이 높을 때는,
      HDD에서 SSD로 교체해도 성능 향상 효과가 미미한 경우가 있다. 하지만 SSD를 사용하면 버퍼 크기를 작게 유지해도 되기 때문에 대용량의 메모리를 유지할 필요가 적어지기도 한다.


- 인덱스가 무엇인가요?
    - RDB에서 테이블의 검색성능을 높여주는 방법중 하나입니다. 사전의 목차처럼 인덱스를 이용하여 원하는 데이터에 빠르게 접근할 수 있습니다.
      특정 컬럼을 서치키로 설정하여 인덱스를 생성하면 그 값으로 정렬하여 별도 파일에 저장합니다. 인덱스는 보통 테이블의 10% 정도 저장공간을 차지하는 데
      이유는 서치키와 포인터만 저장하기 때문입니다. 여러가지 자료구조로 인덱스를 구현할 수 있지만 대부분 B+트리를 이용하여 인덱스의 구조를 이룹니다.


- 인덱스의 종류가 있나요?
    1) 클러스터형 인덱스 : 보통 PK를 기준으로 정렬하여 데이터를 저장합니다. 그렇게 되면 테이블 자체가 하나의 인덱스가 되고 이를 클러스터형 인덱스라고 합니다.
    2) 보조 인덱스 : 별도 공간에 생성되는 인덱스를 의미합니다. PK 외에 원하는 컬럼에 대해서 인덱스를 생성할 수 있습니다. secondary index 라고도 합니다.


- 인덱스를 많이 쓰면 되나요?
    - 안됩니다. 검색성능은 향상될 수 있으나 추가 저장공간도 필요하고 변경작업이 많아지면 인덱스 재구성에 필요한 비용이 커집니다.
      예를 들어, 어떤 테이블의 인덱스가 5개 있다고 한다면 데이터의 변경이 일어나는 경우 5개의 인덱스 자료구조의 재구성이 필요합니다.


- 어떤 컬럼에 인덱스를 써야하나요?
    - 인덱스는 where 에서 자주 사용되고 수정빈도가 낮으며 카디널리티가 높은 컬럼을 선택하는 것이 좋습니다. 카디널리티가 높다는 것은 중복된 데이터가 적다는 뜻입니다.


- 왜 해쉬테이블을 쓰지 않고 B+트리를 쓰나요?
    - 해쉬테이블의 단건 검색 시간복잡도는 O(1) 입니다. 하지만 해쉬테이블은 정렬되어있지 않기 때문에 부등호를 사용하는 쿼리에 비효율적입니다. 그래서 정렬해서 사용하는 B+트리를 사용합니다.


- RDBMS에서 트랜잭션이 무엇인가요?
    - 데이터베이스에서 수행되는 작업의 최소단위입니다.
    - 데이터베이스의 무결성을 유지하면서 데이터베이스의 상태를 변화시키는 작업을 수행합니다.
    - 데이터베이스는 하나 이상의 쿼리를 포함하고 있으며 ACID 규칙을 만족합니다.
    - 트랜잭션을 쓰는 이유는 데이터를 다룰 때 장애가 일어난 경우 복구하는 작업의 단위이며 여러 작업이 같은 데이터를 동시에 접근했을 때
      오류가 나지 않도록 작업을 분리하기 위해 트랜잭션이 이용됩니다. 즉, 데이터의 무결성을 위한 모든 작업에 트랜잭션이 이용됩니다.


- LOCK의 부작용이 있을까요?
    - LOCK의 제어를 잘 못하면 데드락이 걸릴 수 있습니다.

    1) 트랜잭션 1이 A 를 읽기 위해 LOCK을 검
    2) 트랜잭션 2가 B를 읽기 위해 LOCK을 검
    3) 트랜잭션 1이 B를 읽어 오려고 했으나 LOCK이 걸려 대기
    4) 트랜잭션 2가 A를 읽어 오려고 했으나 LOCK이 걸려 대기


- SQL 대량 데이터 처리
    - 하나의 테이블에 대량의 데이터가 존재하는 경우
        - 인덱스의 Tree 구조가 너무 커져 호율성이 떨어져 데이터를 처리(입력, 수정, 삭제, 조회)할 때 디스크 I/O를 많이 유발
        - 인덱스를 생성할 때 인덱스의 크기가 커지게 되고 그렇게 되면 인덱스를 찾아가는 단계가 깊어지게 되어 조회의 성능에도 영향을 미치게 된다.
        - 영향을 미치는 정도가 작지만 데이터를 입력 / 수정 / 삭제하는 트랜잭션의 경우 인덱스의 특성상 일량이 증가하여 성능저하를 유발

        - 파티셔닝을 적용하거나 PK에 의해 테이블을 분할
            - Oracle의 경우 List Partition(특정 값 지정), Range Partition(범위), Hash Partition(해쉬적용), Composite Partition(범위와 해쉬가 복합)**등이 가능
            - 논리적으로는 하나의 테이블로 보이지만 물리적으로는 여러 개의 테이블 스페이지에 쏘개어 저장될 수 있는 구조의 파티셔닝을 사용하면 성능을 개선
                - Range Partition
                    - 요금테이블에 PK가 요금일자+요금번호로 구성
                    - 특성상 월단위로 데이터를 처리하는 경우가 많으므로 PK인 요금일자의 년+월을 이용하여 12개의 파티션 테이블 구성
                    - 가장 많이 사용되는 파티셔닝 기능
                    - 데이터 보관 주기에 따른 테이블 관리가 용이
                - List Partition
                    - 값 각각에 의해 파티셔닝
                - Hash Partition
                    - 지정된 Hash 조건에 따라 해슁 알고리즘이 적용되어 테이블이 분리
                    - 설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 없다.

    - 하나의 테이블에 많은 수의 칼럼이 존재
        - 물리적인 디스크에 여러 블록에 데이터가 저장되게 된다.
          따라서 데이터를 처리할 때 여러 블록에서 데이터를 I/O해야 하는 SQL 문장의 성능이 저하

        - 트랜잭션이 발생할 때 어떤 칼럼에 대해 집중적으로 발생하는지 분석하여 테이블을 쪼개어주면 디스크 I/O가 감소하게 되어 성능이 개선
        - 분리된 테이블은 디스크에 적어진 칼럼이 저장이 되므로 로우마이그레이션과 로우체이닝이 많이 줄어들 수 있다. 따라서 성능이 개선

    * 로우체이닝(Row Chaining)
        - 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
    * 로우마이그레이션(Row Migration)
        - 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

    - 로우 길이가 너무 긴 경우 로우 체이닝과 마이그레이션이 발생
    - 많은 블록에 데이터가 저장되면, 데이터베이스 메모리에서 디스크와 I/O(입력/ 출력)가 발생할 때 불필요하게 I/O가 많이 발생해 성능이 저하된다.

    -> 칼럼 수가 많은 경우 트랜잭션 특성에 따라 테이블을 1:1 형태로 분리할 수 있는지 검증하면 된다.
       그러나 칼럼의 수가 적지만 데이터 용량이 많아 성능 저하가 예상이 되는 경우 테이블에 대해 파티셔닝 전략을 도모


- NoSQL
    - 정의
        - NoSQL은 RDBMS의 형태가 아닌 일관성 모델(비관계형 모델)을 이용하는 데이터 저장을 말하는 것
        - 단순 검색 및 추가작업에 있어서 매우 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에 있어서 매우 뛰어난 성능

    - 대표적인 NoSQL (NoSQL은 다양한 모델을 기반으로 데이터베이스를 설계할 수 있는데, 크게 4가지로 분류할 수 있다.)
        - key-value Database
            - 기본적인 패턴으로 KEY-VALUE 하나의 묶음(Unique)으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장시 용이
            ex) Riak, Redis, Voldmort
        - Document Database
            - 테이블의 스키마가 유동적, 즉 레코드마다 각각 다른 스키마를 가질 수 있다.
            - 보통 XML, JSON과 같은 DOCUMENT를 이용해 레코드를 저장
            - 트리형 구조로 레코드를 저장하거나 검색하는 데 효율적
            ex) MongoDB, CouchDB
        - BigTable Database
            ex) Hbase, Casandra
        - Graph Database
            - 데이터를 노드로(그림에서 파란, 녹색 원) 표현하며 노드 사이의 관계를 엣지(그림에서 화살표)로 표현
            - 일반적으로 RDBMS보다 성능이 좋고 유연하며 유지보수에 용이
            ex) Sones, AllegroGraph

    - 장점
        - RDBMS에 비해 저렴한 비용으로 분산 처리와 병렬 처리가 가능
        - 비정형 데이터 구조 설계로 설계 비용이 감소
        - 관계형 데이터베이스의 relation과 join 구조를 linking과 embedded로 구현하여 성능이 빠름
        - Big Data 처리에 효과적
            - Scale out 구조를 채댁하여 서버 확장에 용이하며 더 많은 데이터를 저장
        - 가변적인 구조로 데이터 저장이 가능
        - Document based(Schema-less) 구조로 데이터 모델의 유연한 변화가 가능
        - json 구조로 RDBMS 테이블 구조에 비해 데이터를 직관적으로 파악
        - Auto Sharding을 지원

        * sharding이란
            - 단일의 논리적 데이터셋을 다수의 데이터베이스에 쪼개고 나누는 방법
            - 샤딩은 데이터셋이 단일 데이터베이스에서 저장하기에 너무 클 때 필수적으로 사용된다.

    - 단점
        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 복잡한 join은 어려움(다양하고 복잡한 데이터 쿼리), document based이기 때문
        - NoSQL은 sharding 방식을 사용해서 큰 테이블을 여러 서버에 나누어 저장한다.
          어떤 데이터가 update 되었을 때, NoSQL은 중복 저장된 서버들에 해당 update가 적용되기까지는 시간이 걸린다.
        - RDBMS는 모든 서버를 update 되기전까지는 해당 데이터 또는 테이블에 lock을 걸어 읽기 금지를 한다. 따라서 데이터에 대한 일관성이 보장된다.
          하지만 NoSQL에서는 lock을 하게 될 경우 느려지므로 RDBMS와 같은 lock을 하지 않는다.
        - 데이터 일관성이 항상 보장되지 않는다.


- 트랜잭션 격리 수준
    - 정의
        - 트랜잭션들끼리 얼마나 고립되어있는지(잠금수준)를 나타내는 것
        - 특정 트랜잭션이 다른 트랜잭션에 의해 변경된 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
        - 트랜잭션 격리 수준은 고립도와 성능의 Trade-off를 조절한다.

    - 트랜잭션 격리 수준이 필요한 이유
        - 트랜잭션 수준 읽기 일관성 (Transaction-Level Read Consistency)을 지키기 위해서이다.(다시 말해 동시성 제어 문제 해결을 위해서이다.
        - 트랜잭션 수준 읽기 일관성이란
          트랜잭션이 시작된 시점으로부터 일관성 있게 데이터를 읽어 들이는 것을 말한다. 하나의 트랜잭션이 진행되는 동안 다른 트랜잭션에 의해
          변경사항이 발생하더라도 이를 무시하고 계속 일관성 있는 데이터를 보여준다. (물론 트랜잭션 자신이 발생한 변경사항은 읽을 수 있다.)

    - READ UNCOMMITTED
        - 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
        - Dirty Read, Non-Repeatable Read, Phantom Read 현상이 발생
            - PHANTOM READ
                - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
                - 이를 방지하기 위해서는 쓰기 잠금을 걸어야 한다.
            - DIRTY READ
                - 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 것을 의미한다.
                - Oracle은 다중 버전 읽기 일관성 모델을 채택하여 lock을 사용하지 않고 Dirty Read를 피해 일관성 있는 데이터 읽기가 가능하게 하였다.
        - 데이터 정합성에 문제가 많다. 그렇기에 RDBMS 표준에서는 격리수준으로 인정하지 않는다.

    - READ COMMITTED
        - RDB에서 대부분 기본적으로 사용되고 있는 격리 수준
        - 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.

        - Dirty Read가 발생하지 않는다. -> 트랜잭션이 COMMIT되어 확정된 데이터만 읽는 것을 허용
        - Non-Repeatable Read, Phantom Read 현상은 여전히 발생
        - 온라인 서비스에서 가장 많이 선택되는 격리수준
            - Oracle은 Lock을 사용하지 않고 쿼리시작 시점의 Undo 데이터를 제공
            - DB2, SQL Server, Sybase의 경우 읽기, 공유 Lock을 이용하여 구현한다.

    - REPEATABLE READ
        - 트랜잭션이 시작되기 전에 COMMIT된 내용에 대해서만 조회할 수 있는 격리수준
        - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID 보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
        - 변경되기 전 레코드는 Undo 공간에 백업해 두고 실제 레코드 값을 변경한다.
        - UPDATE 부정합와 Phantom Read가 발생할 수 있다.

        - 하나의 트랜잭션 실행시간이 길어질수록 Undo에 백업된 레코드가 많아져서 멀티 버전을 관리해야 하는 단점
          (하지만 영향을 미칠정도로 트랜잭션이 오래 지속되는 경우가 없어서 READ COMMITTED와 REPEATABLE READ의 성능 차이는 거의 없다고 한다.)

    - SERIALIZABLE
        - 공유 잠금(shared lock)을 걸어, 다른 트랜잭션에서 해당 테이블의 데이터를 UPDATE, DELETE, INSERT 작업을 못하도록 막는다.
        - Phantom Read가 발생하지 않는다.

- Clustered Index vs Non-Clustered Index
    - Clustered Index
        - 정의
            - 데이터페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
            - 데이터페이지는 리프 레벨
            - 클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 된다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있다.
        - 특징
            - 테이블 당 1개만 허용
            - 기본 키 설정시 자동으로 만들어짐
            - 테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
            - 데이터 입력, 수정, 삭제 시 항상 정렬을 유지함
            - 물리적으로 행을 재배열 (실제 DB의 데이터파일에 정렬이 되어 있는 상태로 디스크에 저장)

    - Non-Clustered Index
        - 정의
            - 데이터 페이지를 건들지 않고, 별도의 장소에 인덱스 페이지를 생성
            - 우선 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬하고 데이터 위치 포인터를 생성한다.
            - 데이터 위치 포인터는 데이터가 위치한 고유한 값이 된다.
        - 특징
            - 인덱스 페이지를 별도로 저장
            - 테이블 자체는 되지 않고, 인덱스 페이지에만 정렬


- 인덱스 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어진다.
    - 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다.
      UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해준다.
      만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어,
      SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.


- Index를 사용하면 좋은 경우
    - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
    - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
    - 데이터의 중복도가 낮은 컬럼
    - 필드에 저장된 값을 찾는 작업이 예상되는 경우
    - 필드의 값을 정렬하는 작업이 예상되는 경우


- 왜 Index를 생성하는데 b-tree를 사용하는가
    - 인덱스도 크기가 커져 보조 기억 장치에 저장되게 되는데 이 또한 디스크 I/O가 발생하게 되는 것이다.
      따라서 B-Tree의 깊이를 줄여야 디스크 I/O를 줄일 수 있기 때문에 B-Tree를 사용한다.


- 역색인
    - 하나의 값(term)이 들어간 문서번호를 지정하는 것
    - 전통적인 RDBMS에서는 위와 같이 like 검색을 사용하기 때문에 기본적으로 속도가 느리다.
    - Elastic Search는 데이터를 저장할 때 다음과 같이 역 인덱스(inverted index)라는 구조를 만들어 저장한다.
    - 하나의 값(Term)이 해당 Term이 들어간 document id 를 지정
    - 데이터가 늘어나도 찾아가야 할 행이 늘어나는 것이 아니라 역인덱스가 가리키는 id의 배열값이 추가되는 것 뿐이기 때문에 큰 속도의 저하 없이 빠른 속도로 검색이 가능
    - 다만 수정과 삭제는 엘라스틱서치 내부적으로 굉장히 많은 리소스가 소요된다.


- InnoDB 스토리지 엔진에서 클러스터링 인덱스와 세컨더리 인덱스가 동작하는 과정을 설명하라.
    - 클러스터링 인덱스
        클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면, 해당 클러스터링 인덱스 키에 해당하는 레코드의 모든 정보를 가져온다.
    - 세컨더리 인덱스
        세컨더리 인덱스의 리프 노드에는 클러스터링 인덱스의 리프 노드와는 달리 PK가 존재한다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면, 해당 세컨더리 인덱스 키에 해당하는 레코드의 PK를 이용하여 데이터 파일을 탐색한다. 이때 데이터 파일은 클러스터링 인덱스이므로 이 데이터 파일의 리프 노드에는 해당 PK에 해당하는 레코드의 모든 정보를 가져온다.


- SELECT 쿼리의 수행 순서를 알려주세요.
    - FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > DISTINCT > ORDER BY > LIMIT

    1. FROM
        - 각 테이블을 확인한다.

    2. ON
        - JOIN 조건을 확인한다.

    3. JOIN
        - JOIN이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함께 포함되어 임시 테이블을 만들 수 있게 도와준다.

    2. WHERE
        - 데이터셋을 형성하게 되면 WHERE의 조건이 개별 행에 적용된다. WHERE절의 제약 조건은 FROM절로 가져온 테이블에 적용될 수 있다.

    3. GROUP BY
        - WHERE의 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화된다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야 한다.

    4. HAVING
        - GROUP BY절이 쿼리에 있을 경우 HAVING 절의 제약조건이 그룹화된 행에 적용된다.

    5. SELECT
        - SELECT에 표현된 식이 마지막으로 적용된다.

    6. DISTINCT
        - 표현된 행에서 중복된 행은 삭제

    7.ORDER BY
        - 지정된 데이터를 기준으로 오름차순, 내림차순 지정

    8. LIMIT
        - LIMIT에서 벗어나는 행들은 제외되어 출력된다.


-  트리거(Trigger)에 대해 설명해주세요.
    - 트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.
    - 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.


- 정규화에 대해 설명해주세요.
    하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.

    제1 정규형 : 테이블의 컬럼이 원자 값(Atomic Value; 하나의 값)을 갖도록 분해합니다.
    제2 정규형: 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다.
    ※ 여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미

    제3 정규형 : 제2 정규형을 만족하고, 이행적 함수 종속을 없애도록 분해합니다.
    ※ 여기서 이행적 종속이란 A → B, B → C가 성립할 때 A → C가 성립되는 것을 의미

    BCNF 정규형 : 제3 정규형을 만족하고, 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해합니다.

    장점
    1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.
    2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

    단점
    릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.
    + 정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로
      한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.


- 역정규화를 하는 이유에 대해 아는대로 설명해주세요.
    - 정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하될 우려가 있습니다.
    - 역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.


- SQL Injection이 무엇인지 설명해주세요.
    - SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다.
    - SQL Injection을 방어 및 방지하기 위한 방법
        1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값) 인지 검증합니다.
        2. 저장 프로시저를 사용합니다.
            ※ 저장 프로시저란 사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상한다.


- RDBMS와 NoSQL의 차이에 대해 설명해주세요.
    - RDBMS는 모든 데이터를 2차원 테이블 형태로 표현합니다.
        장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
        단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)

    - NoSQL(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.
        장점 : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
              데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.
        단점 : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
              스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.


- 그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?
    - RDBMS
        - 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다.
        - 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합

    - NoSQL
        - 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다.
        - 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋다.
        - Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합


- 트랜잭션이란 무엇인지 설명해주세요.
    - 트랜잭션은 작업의 완전성을 보장해줍니다.
    - 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
    - 하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됩니다.


-  트랜잭션의 특성(ACID)에 대해 설명해주세요.
    1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
    2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
    3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
    4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.


- Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
    - RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다.
        (MySQL 최신 버전에서 n-gram 기반의 Full-Text 검색을 지원하긴 하지만, 한글 검색의 경우 아직 많이 빈약한 감이 있습니다.)
    - 하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능합니다.
        Full-Text : 이미지, CSS, 글 등의 복합적으로 이뤄진 컨텐츠에서 순수하게 텍스트만 추출한 데이터를 의미. 이 과정을 보통 크롤링으로 구현함



- 옵티마이저(Optimizer)에 대해 아는대로 말해주세요.
    - 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
    - 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있습니다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라
      옵티마이저라는 곳에서 “이 쿼리문을 어떻게 실행시키겠다!”라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것입니다.


- SQL 튜닝
    - Join, Indexing, SQL Execution Plan


- DELETE, TRUNCATE, DROP의 차이를 설명해주세요.
    - DELETE는 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. 삭제 후 되돌릴 수 있습니다.
    - TRUNCATE는 전체 데이터를 한번에 삭제하는 방식입니다. 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없습니다.
    - DROP은 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. 삭제 후 되돌릴 수 없습니다.


- 데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요.
    - 클러스터링
        - 여러 개의 DB를 수평적인 구조로 구축하는 방식입니다. 동기 방식으로 사용

        - 장점
            - DB 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
            - 1개의 DB가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영할 수 있다. (높은 가용성)
            - 기존에 하나의 DB서버에 몰리던 부하를 여러 곳으로 분산시킬 수 있다. (로드밸런싱)
        - 단점
            - 저장소 하나를 공유하면 병목현상이 발생할 수 있다.
                ※ 병목현상 : 전체 시스템이 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상이다.
            - 서버를 동시에 운영하기 위한 비용이 많이 든다.

    - 리플리케이션
        - 여러 개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식입니다. 비동기 방식으로 사용

        - 장점
            - DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
            - 비동기 방식으로 운영되어 지연 시간이 거의 없다.
        - 단점
            - 노드들 간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
            - Master DB가 다운되면 복구 및 대처가 까다롭다.


- HAVING과 WHERE의 차이를 설명해주세요.
    - having은 그룹을 필터링 하는데 사용되고, where은 개별 행을 필터링하는데 사용됩니다.
    - having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고,
      where은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용됩니다.


- JOIN에서 ON과 WHERE의 차이를 설명해주세요.
    - ON 이 WHERE 보다 먼저 실행되어 JOIN 을 하기 전에 필터링을 하고 (=ON 조건으로 필터링이 된 레코들간 JOIN이 이뤄진다)
    - WHERE은 JOIN 을 한 후에 필터링을 합니다. (=JOIN을 한 결과에서 WHERE 조건절로 필터링이 이뤄진다)


- 저장 프로시저(Stored PROCEDURE)
    - 정의
        - 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
        - 원하는 결과물을 얻기 위해 사용할 여러줄의 쿼리문을 한 번의 요청으로 실행
          인자 값만 상황에 따라 바뀌고 동일한 로직의 복잡한 쿼리문을 필요할 때마다 작성한다면 비효율적. 이럴 때 사용할 수 있는 것이 바로 프로시저다.

    - 장점
        1. 최적화 & 캐시
            프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다.
            만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.

        2. 유지 보수
            작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다. (But, 장점이 단점이 될 수도 있는 부분이기도.. )

        3. 트래픽 감소
            클라이언트가 직접 SQL문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 된다. 즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서버 간 네트워크 상 트래픽이 감소된다.

        4. 보안
            프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.

    - 단점
        1. 호환성
            구문 규칙이 SQL / PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁘다.

        2. 성능
            문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느리다.

        3. 디버깅
            에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.




- 데드락은 어떻게 피하나요?


* x-lock vs s-lock
    https://velog.io/@soongjamm/Select-%EC%BF%BC%EB%A6%AC%EB%8A%94-S%EB%9D%BD%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4.-X%EB%9D%BD%EA%B3%BC-S%EB%9D%BD%EC%9D%98-%EC%B0%A8%EC%9D%B4

***** SQL과 NOSQL의 차이
    https://gyoogle.dev/blog/computer-science/data-base/SQL%20&%20NOSQL.html

***** 저장 프로시저
    https://gyoogle.dev/blog/computer-science/data-base/Stored%20PROCEDURE.html

***** DB Connection Pool
    https://hyuntaeknote.tistory.com/12


* 역인덱스?

* 역정규화

* 오라클 힌트
    https://devuna.tistory.com/35


***** 자연키(Natural key)와 대체키(Surrogate Key), PK(기본키)를 대체키로 설정해야 하는 이유
    https://mangkyu.tistory.com/287

*******  B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기
    https://mangkyu.tistory.com/286

******* 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기
    https://mangkyu.tistory.com/285

***** 리플리케이션(Replication) vs 클러스터링(Clustering)
    https://mangkyu.tistory.com/97

***** 인덱스(index)란?
    https://mangkyu.tistory.com/96

***** MVCC(다중 버전 동시성 제어)란?
    https://mangkyu.tistory.com/53

***** 데이터베이스 프로그래밍
    https://mangkyu.tistory.com/26

***** 정규화(Normalization)
    https://mangkyu.tistory.com/28

***** 인덱스와 인덱싱 알고리즘 (hash table, b-tree, b+tree)
    https://hudi.blog/db-index-and-indexing-algorithms/

***** 클러스터형 인덱스와 비클러스터형 인덱스
    https://hudi.blog/db-clustered-and-non-clustered-index/

***** NOT IN 쿼리 성능 개선하기
    https://jojoldu.tistory.com/632

******* Oracle Real-Time SQL Monitoring

- JPA
    - 영속성 컨텍스트 관련 (이점 등)
- index
    - 사용 이유
    - 어떤 경우에 index 가 안걸리는지
- 분산 락 구현 방식(redis)
- 쿼리 튜닝
    튜닝관련 https://dncjf0223.tistory.com/69
    - 실행 계획  https://velog.io/@haron/SQL-%EC%BF%BC%EB%A6%AC-%ED%8A%9C%EB%8B%9D%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%A4%80%EB%B9%84-%EC%8B%A4%ED%96%89-%EA%B3%84%ED%9A%8D
    - select, from, join 등 키워드 기준으로 설명?


- 와탭(WhaTap) 소개 및 설치
    https://archmond.net/archives/3137

- 와탭(WhaTap)의 모니터링 기능에 빠져보자
    https://archmond.net/archives/3241

- 동시성 제어 기법들
- 트랜잭션 격리 수준  https://code-lab1.tistory.com/52
- 데이터베스 종류별 lock
- JPA 의 lock

- b+ tree
- 다중 칼럼 인덱스

