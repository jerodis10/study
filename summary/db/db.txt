- 옵티마이저
    - 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
    - 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있습니다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라
      옵티마이저라는 곳에서 “이 쿼리문을 어떻게 실행시키겠다!”라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것입니다.

    - 가장 효율적인 방법으로 SQL 을 수행할 최적의 처리 경로를 생성해주는 DBMS 의 핵심 엔진
    - 컴퓨터의 두뇌가 CPU 인 것처럼 DBMS 의 두뇌는 옵티마이저
    - SQL 을 작성하고 실행하면 소프트웨어 실행파일처럼 즉시 실행되는 것이 아니라 옵티마이저(Optimizer)라는 곳에서 "이 쿼리문을
      어떻게 실행시키겠다!"라는 여러 가지 실행계획을 세우게 됩니다. 이렇게 실행계획을 세운 뒤 시스템 통계정보를 활용하여
      각 실행계획의 예상 비용을 산정한 후 각 실행계획을 비교해서 최고의 효율을 가지고 있는 실행계획을 판별한 후 그 실행계획에
      따라 쿼리를 수행하게 되는 것입니다.

    - 옵티마이져의 종류
        - 옵티마이저는 실행 계획을 세우는 방식에 따라 규칙 기반 옵티마이저와 비용 기반 옵티마이저로 나뉩니다.

        항목	        규칙 기반 옵티마이저	                    비용 기반 옵티마이저
        개념	        사전에 정의된 규칙 기반	                    최소비용 계산 실행계획 수립
        기준	        실행우선 순위(Ranking)	                액세스 비용(Cost)
        인덱스	    인덱스 존재 시 가장 우선시 사용	            Cost 에 의한 결정
        성능	        사용자 SQL 작성 숙련도	                    옵티마이저 예측 성능
        장점	        판단이 매우 규칙적 실행 예상 가능	            통계 정보를 통한 현실 요소 적용
        단점	        예측 통계정보 요소 무시	                    최소 성능 보장 계획의 예측 제어 어려움
        사례	        AND 중심 양쪽 ‘=’ 시 Index Merge 사용	    AND 중심 양쪽 ‘=’ 시 분포도별 Index 선택

        규칙 기반 옵티마이저 (RBO)
        오라클8 이하의 버전에서 기본으로 설정된 옵티마이저가 바로 규칙 기반 옵티마이저입니다. 규칙 기반 옵티마이저는
        말 그대로 실행 속도가 빠른 순으로 규칙을 먼저 세워두고 우선순위가 앞서는 방법을 채택하는 것.
        과거에는 옵티마이저의 비용을 예측하는 능력이 그다지 좋지 않아 이러한 방식을 사용.
        옵티마이저의 실행계획을 유도할 수 있는 힌트와 HASH JOIN 의 경우에는 규칙 기반 이후에 나온 개념들이므로
        여기서는 사용하실 수 없다는 단점이 있습니다.

        비용 기반 옵티마이저
        최근에 많이 사용하고 있는 옵티마이저 방식이며 오라클 10 이후 버전부터는 공식적으로 비용 기반 옵티마이저만 사용.
        비용 기반 옵티마이저는 옵티마이저에서 실행 계획을 세운 뒤(최대 2천개까지) 비용이 최소한으로 나온 실행 계획을 수행.
        비용을 예측하기 위해서 규칙 기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의
        다양한 객체 통계정보와 시스템 통계정보를 이용.

    - 옵티마이저 동작 방식
        Parser : SQL 문장을 분석하여 문법 검사와 구성요소를 파악하고 이를 파싱 해서 파싱 트리를 만듭니다.
        Query Transformer : 파싱된 SQL 을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL 로 변환이
            가능한지를 판단하여 변환 작업을 수행합니다.
        Estimator : 시스템 통계정보를 딕셔너리로부터 수집하여 SQL 을 실행할 때 소요되는 총비용을 계산합니다.
        Plan Generator : Estimator 를 통해 계산된 값들을 토대로 후보군이 되는 실행계획을 도출합니다.
        Row-Source Generator : 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는
            코드나 프로시저 형태로 포맷팅 합니다.
        SQL Engine : SQL 을 실행합니다.

    - 옵티마이저는 결코 만능이 아니다.
        칼럼의 통계 정보만 가지고는 조건절에서 사용된 조건을 만족하는 데이터의 양이 어느 정도인지 알 수가 없기에 비용 계산 결과가
        정확하지가 않습니다. 그리고 비용산정시 쿼리문 단독으로 실행된다고 가정하기에 운영 서버와 같이 쿼리가 동시 실행된다면
        실제 비용은 달라질 수 있기도 하고 히스토그램 버킷이 최대 254까지만 사용할 수 있어 254개 이상의 값을 갖는 컬럼의 경우
        비용 예측 결과가 정확하지 않는 등의 옵티마이저에 여러 가지 빈틈들이 많습니다.
        쿼리 튜닝을 할 때에는 쿼리 문의 실행계획을 꼭 보시고 옵티마이저가 비효율적으로 작동하고 있다면 오라클의 힌트 같은
        부가적인 장치를 통해 올바르게 작동될 수 있도록 유도하는 방법도 필요합니다.

- 실행 계획
    - 실행 계획이란?
        실행계획이란 사용자가 SQL 을 실행하여 데이터를 추출하려고 할 때 옵티마이저가 수립하는 작업 절차

    - 쿼리문의 실행 계획을 확인하는 방법
        쿼리문의 실행 계획을 확인하는 방법은 EXPLAIN PLAN, AUTOTRACE, SQL TRACE 이렇게 3가지가 있습니다.

    - SCAN 의 종류와 속도
        FULL TABLE SCAN : 테이블의 전체 데이터를 읽어 조건에 맞는 데이터를 추출하는 방식 입니다.
        ROWID SCAN : ROWID 를 기준으로 데이터를 추출하며 단일 행에 접근하는 방식 중에서 가장 빠릅니다.
        INDEX SCAN : 말 그대로 인덱스를 활용하여 원하는 데이터를 추출하는 방식입니다.

        이 두 가지 SCAN 방법 중 개발자가 손쉽게 유도할 수 있는 SCAN 의 방법은 FULL TABLE SCAN 과 INDEX SCAN 입니다.
        이 중에서 테이블에 데이터가 많지 않아 INDEX 를 타야 하는 시간 소요가 불필요하다고 느껴지거나 테이블에서 추출해야 하는
        데이터 양이 엄청 많다면 FULL TABLE SCAN 을 하는 것이 유리할 수 있고 반대로 많은 데이터가 있는 테이블에서 내가 원하는
        데이터를 추출해야 하는 상황이라면 INDEX SCAN 을 하는것이 좋습니다.

        FULL TABLE SCAN 을 타는 상황
            1. 조건절에서 비교한 칼럼에 인덱스가 없는 경우
            2. 조건절에서 비교한 컬럼에 최적화된 인덱스는 있지만 조건에 만족하는 데이터가 테이블의 많은 양을 차지하여
               FULL TABLE SCAN 이 낫다고 옵티마이저가 판단하는 경우
            3. 인덱스는 있으나, 테이블의 데이터 자체가 적어 FULL TABLE SCAN 이 낫다고 옵티마이저가 판단하는 상황
            4. 테이블 생성 시 DEGREE 속성 값이 크게 설정되어 있는 경우

            옵티마이저가 판단 후 TABLE FULL SCAN 을 탄다면 그냥 두는 것이 좋고 INDEX SCAN 이 더 유리한데도 불구하고
            INDEX 가 없어 부득이하게 FULL TABLE SCAN 을 한다면 INDEX 를 하나 만드는 것이 좋습니다. 물론 INDEX 를
            필요할 때마다 만드는 것도 UPDATE 와, DELETE 등의 속도를 저해하기에 마냥 좋은 것은 아닙니다.

        ROWID SCAN 을 타는 상황
            1. 조건절에 ROWID 를 직접 명시할 경우
            2. INDEX SCAN 을 통해 ROWID 를 추출한 후 테이블에 접근할 경우

            ROWID SCAN 은 단일 행 접근이 매우 빠르기 때문에 ROWID SCAN 가 유리하다고 판단되면서
            ROWID SCAN 을 탈 수 있는 상황이라면 유도해주는 것이 좋습니다.

        INDEX SCAN 을 타는 상황
            인덱스 종류	                    상황
            INDEX UNIQUE SCAN	            UNIQUE INDEX 를 구성하는 모든 컬럼이 조건에 "="로 명시된 경우
            INDEX RANGE SCAN	            1. UNIQUE 성격의 결합 인덱스의 선두 컬럼이 WHERE 절에 사용되는 경우
                                            2. 일반 인덱스의 컬럼이 WHERE 절에 존재하는 경우
            INDEX RANGE SCAN DESCENDING	    INDEX RANGE SCAN 을 수행함과 동시에 ORDER BY DESC 절을 만족하는 경우
            INDEX SKIP SCAN	                1. 결합 인덱스의 선행 컬럼이 WHERE 절는 경우
                                            2. 옵티마이저가 INDEX SKIP SCAN 이 FULL TABLE SCAN
                                               보다 낫다고 판단하는 경우
            INDEX FULL SCAN	                1. ORDER BY / GROUP BY의 모든 컬럼이 인덱스의 전체 또는 일부로 정의된 경우
                                            2. 정렬이 필요한 명령에서 INDEX ENTRY 를 순차적으로 읽는 방식으로 처리된 경우
            INDEX FULL SCAN DESCENDING	    INDEX FULL SCAN 을 수행함과 동시에 ORDER BY DESC 절을 만족하는 경우
            INDEX FAST FULL SCAN	        FULL TABLE SCAN 을 하지 않고도 INDEX FAST FULL SCAN 으로 원하는 데이터를
                                            추출할 수 있고 추출된 데이터의 정렬이 필요 없으며 결합 인덱스를 구성하는
                                            컬럼 중에 최소 한개 이상은 NOT NULL 인 경우
            INDEX JOIN	                    추출하고자 하는 데이터가 조인하는 인덱스에 모두 포함되어 있고
                                            추출하는 데이터의 정렬이 필요없는 경우


- 조인 방법
    - NESTED LOOP JOIN (중첩 루프 조인)
        - NESTED LOOP JOIN 이란?
            where 절에 있는 조건에 따라 두 테이블에서 하나의 테이블을 기준으로 삼아 다른 하나의 테이블에 있는 데이터를 읽는 방식으로 조인을 수행.
            프로그래밍의 for 이중루프랑 같다.
            NLJ는 메모리가 필요없는 조인 방법으로 추가적인 메모리 비용이 들지 않는다.
            어떤 테이블을 드라이빙 테이블로 선택하느냐가 중요하다. 왜냐면 드라이빙 테이블의 로우를 가지고 이너를 검색하기 때문

            NL JOIN 이라고도 불리는 NESTED LOOP JOIN 은 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row 를
            결합하여 원하는 결과를 조합하는 조인 방식
            조인해야 할 데이터가 많지 않은 경우에 유용하게 사용
            드라이빙 테이블로 한 테이블을 선정하고 이 테이블로부터 where 절에 정의된 검색 조건을 만족하는 데이터들을 걸러낸 후,
            이 값을 가지고 조인 대상 테이블을 반복적으로 검색하면서 조인 조건을 만족하는 최종 결과값을 얻어냅니다.

        - Driving Table 과 Driven Table
            조인을 할때 먼저 액세스 되는 테이블을 Driving Table 이라고 하며 나중에 액세스 되는 테이블을 Driven Table
            Driving Table 은 옵티마이저가 결정하고 자연스레 Driving Table 이 아닌 테이블은 Driven Table 로 결정

        - NESTED LOOPS JOIN 의 장단점
            1. 인덱스에 의한 랜덤 액세스에 기반하고 있기 때문에 대량의 데이터 처리 시 적합하지 않습니다.
            2. Driving Table 로는 데이터가 적거나 where 절 조건으로 row 의 숫자를 줄일 수 있는 테이블이어야 합니다.
            3. Driven Table 에는 조인을 위한 적절한 인덱스가 생성되어 있어야 합니다.
            4. 선행 테이블의 결과를 통해 후행 테이블을 액세스 할 때 랜덤 I/O가 발생합니다.

             for(i=0; i<dept.length; i++) { -- driving table
                for(j=0; j<emp.length; j++) { -- driven table
                   // Search
                }
            }
            동작 순서를 보시면 아시겠지만  위와 같은 이중 for 문과 작동원리는 비슷합니다.

            이렇듯 NESTED LOOP JOIN 의 동작 방식은 Driving Table 의 처리 범위를 하나씩 액세스 하면서 추출된 값으로
            Driven Table 을 조인하는 방식으로 동작하게 됩니다.

        - NESTED LOOP JOIN 의 성능 개선 포인트
            - 적절한 드라이빙 테이블의 선정
                Driving Table 은 WHERE 절로 최대한의 데이터를 거를 수 있는 테이블이나
                애초에 데이터의 양이 적은 테이블로 선정하는 것이 좋습니다.

                - 드라이빙 테이블 유도 방법
                    1. 힌트의 사용
                        /*+ORDERED*/ -- FROM절에 기술한 테이블 순서대로 제어
                        /*+LEADING (table명)*/ -- 힌트 내에 제시된 테이블이 드라이빙으로 처리됨

                        가장 쉬운 방법은 위와 같이 힌트를 사용하는 방법입니다. 위의 두가지 힌트 중 하나를 사용하시면 됩니다.
                        만약 위의 두가지 힌트를 동시에 사용하게 되면 LEADING 힌트는 적용되지 않습니다.

                    2. 뷰를 사용한다.
                        뷰를 통해서 데이터를 먼저 읽어낼 수 있고 뷰로 데이터를 읽은 결과로 다음 테이블로 연결을 시도한다면
                        조인 순서를 제어할 수 있습니다.

            - Driven Table 의 조인 컬럼에 인덱스 존재 유무
                Driven Table 에 인덱스가 존재하지 않는다면 Driving Table 에서 도출된 결과와 맞는지를
                FULL TABLE SCAN 으로 일일이 비교해야 하기 때문입니다.
                Driven Table 의 Join 컬럼에 인덱스가 생성되지 않았다면 인덱스 생성을 고려해 보는 것이 좋고 그것이 어렵다면
                조인 방식을 SORT / MERGE 방식등 다른 방식으로 바꾸는것이 성능 향상에 도움이 됩니다.

    - SORT MERGE JOIN (정렬 병합 조인)
        - 두 테이블을 각각 정렬한 다음 조인조건에 맞는 건을 찾아 합치는 방식이다.
        - 드라이빙 테이블이 별도로 존재하지 않으며, 모두 독립적으로 동등한 레벨에 있다.
        - 정렬 작업을 위해 추가적인 메모리를 사용한다. 디스크 I/O가 발생한다.
        - NJL보다 많은 양의 데이터를 처리할 때 유리하며, 메모리만 사용해서 정렬 작업을 수행한다면 넓은 범위의 값을 검색하는데 유용하다.
        - 두 테이블의 데이터를 각각 정렬하는 작업이 전체 성능에 영향을 많이 끼치게 된다. 해서 select 리스트에서 불필요한 칼럼은 제거해서
          정렬 작업 수행 시 부하를 적게 줘야 한다.
        - 일반적으로 >, >=, <, <= 와 같은 비동등 연산자가 사용될 때 쓰인다.

    - HASH JOIN (해시 조인)
        - 두 테이블 중 where 조건에 의해 필터링된 로우 수가 적은 테이블을 대상으로 해쉬 테이블을 만든 후에 조인 조건에 따라 다른 하나의 테이블의 데이터를 검색하는 방법이다.
        - HJ 방법은 해시 테이블이 드라이빙 테이블이 되어 NLJ를 수행한다고 보면 된다.
        - 해시 테이블은 HASH_AREA_SIZE에 지정된 메모리 값 내에서 해시 테이블을 만들게 되므로 대상 테이블의 크기가 이 값 내에 있을 경우 유용한 조인
        - 보통 HASH_AREA_SIZE 값은 SORT_AREA_SIZE 값의 2배로 설정한다.
        - 해시 조인은 조인 조건에서 동등조건이 사용되었을 때만 가능하다.
        - 보통 반환되는 로우수가 적은 테이블(이 테이블을 대상으로 해시 테이블을 만든다.)과 이에 반해 반환되는 로우수가 상당히 많은 테이블을 조인 시에 유리하다.

        - HASH JOIN 의 사용처
            1. JOIN 컬럼에 적당한 인덱스가 없어 NL JOIN 이 비효율적일 때
            2. JOIN Access 량이 많아 Random Access 부하가 심하여 NL JOIN 이 비효율적일 때
            3. Sort Merge Join 을 하기에는 두 테이블이 너무 커 Sort 부하가 심할 때
            4. 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 JOIN 할 때

        - 사용법
            /*+leading(a c) use_hash(c)*/
            아마 힌트를 주지 않아도 옵티마이저가 알아서 hash 조인을 하는 경우도 있지만, 이러한 힌트를 명시해주는 것이 바람직


- 힌트에 관해서  https://devuna.tistory.com/35
    - 힌트란 SQL 튜닝의 핵심 부분으로 일종의 지시 구문이다.
      즉, 오라클 옵티마이저(Optimizer)에게 SQL 문 실행을 위한 데이터를 스캐닝하는 경로, 조인하는 방법 등을 알려주기 위해
      SQL 사용자가 SQL 구문에 작성하는 것을 뜻한다. 오라클이 항상 최적의 실행 경로를 만들어 내기는 불가능하기 때문에
      직접 최적의 실행 경로를 작성해 주는 것이다. 사용자가 특정 SQL 문장에서 어떤 인덱스가 선택도가 높은지 알고 있는 경우
      Optimizer 에 의존한 실행 계획보다 훨씬 효율적인 실행 계획을 구사할 수 있다.

    - 단, 힌트, 인덱스, 조인의 개념을 정확히 알고 사용하지 않은 무분별한 힌트의 사용은 성능의 저하를 초래하기 때문에
      잘 알고 최적의 실행 경로를 알고 있을 경우 적절하게 사용하여야 한다.

    - (힌트에 오타가 있는 경우는 큰 관계가 없다. 왜냐하면, 잘못 사용된 힌트는 무시되어 힌트가 없는 것처럼 동작하기 때문)

    - 힌트를 사용하여 아래와 같은 것들을 할 수 있다.
      액세스 경로, 조인 순서, 병렬 및 직렬 처리, Optimizer 의 목표(Goal)를 변경 가능하다.
      데이터 값을 정렬해야 하는 경우, 힌트의 사용이 필요
      드라이빙 테이블을 원하는 대로 선정하고자 할 때도 사용

    - 힌트 인덱스
        - 지정된 테이블access에 Index Scan 유도.
        - 하나의 Index만 지정되면 Optimizer는 해당index를 이용.
        - 여러개의 인덱스가 지정되면 Optimizer가 각 Index의 Scan시 Cost를 분석 한 후 최소비용이 드는 Index사용. 경우에 따라 Optimizer는
          여러 Index를 사용한 후 결과를 Merge하는 Acees방식도 선택합니다.
        - Index가 지정되지 않으면 Optimizer는 테이블의 이용가능한 모든 Index에 대해 Scan Cost를 고려 후 최저비용이 드는 Index Scan을 선택합니다.


- 릴레이션 키
    1. 슈퍼키(Super Key)
        - 테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합
        - 유일성만 만족하면 슈퍼키가 될 수 있다.
        - 유일성이란 하나의 키로 특정 행을 바로 찾아낼수 있는 고유한 데이터 속성

    2. 후보키(Candidate Key)
        - 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합
        - 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족해야한다.

    3. 기본키(Primary Key)
        - 후보키들 중에서 하나를 선택한 키로 최소성과 유일성을 만족
        - 테이블에서 기본키는 오직 1개만 지정할 수 있다.
        - 기본키는 NULL 값을 절대 가질수 없고, 중복된 값을 가질 수 없다.
        - 각 행들을 구별하려면 값이 없어선 안되고, 중복되어서도 안되기 때문이다.

    4. 대체키(Alternate Key)
        - 후보키가 두개 이상일 경우 그 중에서 어느 하나를 기본키로 지정하고 남은 후보키들을 대체키

    5. 외래키(Foreign Key)
        - 다른 테이블의 데이터를 참조할 때 없는 값을 참조할 수 없도록 제약을 주는 것
        - 이때, 참조될(A) 열의 값은 참조될(A) 테이블에서 기본키(Primary Key)로 설정되어 있어야한다.
        - 외래키는 참조되는 테이블의 기본키와 동일한 키 속성을 가진다.

    - 자연키
        비즈니스 모델에서 자연스럽게 나오는 속성
        ex) 회원 테이블에서 아이디 속성을 자연키로 설정

    - 인조키
        비즈니스 모델과 달리 오로지 키 역할을 하기 위해 인조적으로 만든 속성
        ex) UUID, Auto Increment


- DDL vs DML vs DCl
    - DDL : 스키마, 도메인, 테이블, 뷰, 인덱스 등을 정의하거나 결정하는 언어.
    - DML : 저장된 데이터를 실질적으로 처리하는데 쓰이는 언어.
    - DCL : 데이터의 보안, 무결성, 수행 제어 등을 정의하는 데 사용


- DELETE, TRUNCATE, DROP의 차이를 설명해주세요.
    - DELETE는 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. 삭제 후 되돌릴 수 있습니다.
    - TRUNCATE는 전체 데이터를 한번에 삭제하는 방식입니다. 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없습니다.
    - DROP은 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. 삭제 후 되돌릴 수 없습니다.


- RDBMS에서 트랜잭션이 무엇인가요?
    - 데이터베이스에서 수행되는 작업의 최소단위입니다.
    - 데이터베이스의 무결성을 유지하면서 데이터베이스의 상태를 변화시키는 작업을 수행합니다.
    - 데이터베이스는 하나 이상의 쿼리를 포함하고 있으며 ACID 규칙을 만족합니다.
    - 트랜잭션을 쓰는 이유는 데이터를 다룰 때 장애가 일어난 경우 복구하는 작업의 단위이며 여러 작업이 같은 데이터를 동시에 접근했을 때
      오류가 나지 않도록 작업을 분리하기 위해 트랜잭션이 이용됩니다. 즉, 데이터의 무결성을 위한 모든 작업에 트랜잭션이 이용됩니다.

    - 트랜잭션은 작업의 완전성을 보장해줍니다.
    - 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
    - 하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됩니다.


-  트랜잭션의 특성(ACID)에 대해 설명해주세요.
    1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
    2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
    3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
    4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.


- 트랜잭션 격리 수준
    - 정의
        - 트랜잭션들끼리 얼마나 고립되어있는지(잠금수준)를 나타내는 것
        - 특정 트랜잭션이 다른 트랜잭션에 의해 변경된 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
        - 트랜잭션 격리 수준은 고립도와 성능의 Trade-off를 조절한다.

    - 트랜잭션 격리 수준이 필요한 이유
        - 트랜잭션 수준 읽기 일관성 (Transaction-Level Read Consistency)을 지키기 위해서이다.(다시 말해 동시성 제어 문제 해결을 위해서이다.
        - 트랜잭션 수준 읽기 일관성이란
          트랜잭션이 시작된 시점으로부터 일관성 있게 데이터를 읽어 들이는 것을 말한다. 하나의 트랜잭션이 진행되는 동안 다른 트랜잭션에 의해
          변경사항이 발생하더라도 이를 무시하고 계속 일관성 있는 데이터를 보여준다. (물론 트랜잭션 자신이 발생한 변경사항은 읽을 수 있다.)

    - READ UNCOMMITTED
        - 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
        - Dirty Read, Non-Repeatable Read, Phantom Read 현상이 발생
            - PHANTOM READ
                - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
                - 이를 방지하기 위해서는 쓰기 잠금을 걸어야 한다.
            - DIRTY READ
                - 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 것을 의미한다.
                - Oracle은 다중 버전 읽기 일관성 모델을 채택하여 lock을 사용하지 않고 Dirty Read를 피해 일관성 있는 데이터 읽기가 가능하게 하였다.
        - 데이터 정합성에 문제가 많다. 그렇기에 RDBMS 표준에서는 격리수준으로 인정하지 않는다.

    - READ COMMITTED
        - RDB에서 대부분 기본적으로 사용되고 있는 격리 수준
        - 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.

        - Dirty Read가 발생하지 않는다. -> 트랜잭션이 COMMIT되어 확정된 데이터만 읽는 것을 허용
        - Non-Repeatable Read, Phantom Read 현상은 여전히 발생
        - 온라인 서비스에서 가장 많이 선택되는 격리수준
            - Oracle은 Lock을 사용하지 않고 쿼리시작 시점의 Undo 데이터를 제공
            - DB2, SQL Server, Sybase의 경우 읽기, 공유 Lock을 이용하여 구현한다.

    - REPEATABLE READ
        - 트랜잭션이 시작되기 전에 COMMIT된 내용에 대해서만 조회할 수 있는 격리수준
        - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID 보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
        - 변경되기 전 레코드는 Undo 공간에 백업해 두고 실제 레코드 값을 변경한다.
        - UPDATE 부정합와 Phantom Read가 발생할 수 있다.

        - 하나의 트랜잭션 실행시간이 길어질수록 Undo에 백업된 레코드가 많아져서 멀티 버전을 관리해야 하는 단점
          (하지만 영향을 미칠정도로 트랜잭션이 오래 지속되는 경우가 없어서 READ COMMITTED와 REPEATABLE READ의 성능 차이는 거의 없다고 한다.)

    - SERIALIZABLE
        - 공유 잠금(shared lock)을 걸어, 다른 트랜잭션에서 해당 테이블의 데이터를 UPDATE, DELETE, INSERT 작업을 못하도록 막는다.
        - Phantom Read가 발생하지 않는다.


- Transaction Update
    1. 행 레벨 LOCK
    2. UNDO SEGMENT BUFFER 확보 및 정보 기록
    3. 데이터 UPDATE
    4. COMMIT & 행 UNLOCK

    Transaction에서 Update를 할 경우 읽기 일관성을 유지하기 위해 행레벨에서 LOCK을 걸어버립니다. 다른 Transaction에서 Update 작업을 할 수 없도록 막는 작업입니다.
    그 후 다른 Transaction에서 SELECT를 할 경우 아직 COMMIT을 하지 않았기 때문에 이전 정보를 UNDO BLOCK에서 조회할 수 있도록 정보를 기록해주고 데이터 UPDATE 작업을 진행합니다.
    Transaction이 최종적으로 끝나면 행레벨 락을 풀어 줍니다.


- 트랜잭션 매커니즘
    1. update accounts SET balance = balance - 10000 where user = '구매자' 쿼리 실행
    2. 업데이트에 필요한 데이터를 데이터 캐시에 요청하는데, 데이터 캐시에 해당 데이터가 없다.
    3. 데이터 파일에서 데이터를 가져와야 한다.
    4. 그리고 데이터 캐시에 필요한 데이터가 로드된다.
    5. 데이터가 로드된 후, 업데이트를 하면 되는데 그 전에 로그 캐시에 로그를 기록해야 한다.
    6. ReDo 로그와 UnDo 로그에 기록한다.
        - ReDo 로그: 변경 후의 값을 기록
        - UnDo 로그: 변경 전의 값을 기록
    7. 로그 기록 후 데이터 캐시에 있는 값을 변경하면 된다.
    8. update accounts set balance = balance + 10000 where user = '판매자' 쿼리 실행
    9. 판매자의 데이터가 없으므로 데이터 파일에서 데이터 캐시로 로드
    10. ReDo 로그와 UnDo 로그에 기록한다.
    11. 데이터 캐시의 데이터 업데이트
    12. 트랜잭션의 한 단위가 끝났다.

    - 데이터 롤백 시 UnDO 로그를 통해 롤백한다. UnDo 를 통해 역순으로 기록을 하게 되면 데이터가 이전 상태로 원복
    - 예상치 못한 오류 발생 시 ReDo 로그와 UnDO 로그를 통해 복구한다.
        - ReDo 로그를 순차적으로 실행해서 데이터들을 다시 일관성 있게 만들어줌.
          커밋된 것을 다시 실행
        - UnDo 로그를 역순으로 실행하여 다시 커밋되지 않은 것들을 다시 이전 상태로 돌려준다.
          트랜잭션은 시작瑩嗤 커밋되지 않은 연산을 취소

    - Transaction 관리를 위한 DBMS 전략
        - DBMS 구조
            - Query Processor(질의 처리기), Storage System(저장 시스템)
            - 입출력 단위: 고정 길이의 page 단위로 disk 에 읽거나 쓴다.
            - 저장 공간: 비휘발성 저장 장치인 disk 에 저장, 일부분을 Main Memory 에 저장

        - Buffer 관리 정책
            - DBMS 의 Storage System 에 속하는 모듈 중 하나로, Main Memory 에 유지하는 페이지를 관리하는 모듈
            - Buffer 관리 정책에 따라, UnDo 복구와 ReDo 복구가 요구되거나 그렇지 않게 되므로 transaction 관리에 매우 중요한 결정을 가져옴

        - UnDo
            - 수정된 페이지들이 Buffer 교체 알고리즘에 따라서 디스크에 출력될 수 있음.
              Buffer 교체는 transaction 과는 무관하게 buffer 의 상태에 따라서 결정됨
              따라서 정상적으로 종료되지 않은 transaction 이 변경한 페이지들은 원상 복구되어야 하는데 이 복구를 undo 라고 함

            - 2 개의 정책 (수정된 페이지를 디스크에 쓰는 시점으로 분류)
                - steal: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
                    - 대부분의 DBMS 가 채택하는 Buffer 관리 정책
                    - UnDo logging 과 복구를 필요로 함
                - no-steal: 수정된 페이지들을 EOT(End Of Transaction)까지는 버퍼에 유지하는 정책
                    - UnDo 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함

        - ReDo
            - 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업
            - Buffer 관리 정책에 영향을 받음 (트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지를 디스크에 쓸것인가 아닌가로 기준)
                - FORCE: 수정했던 모든 페이지를 트랜잭션 커밋 시점에 disk 에 반영
                    - 트랜잭션이 커밋되었을 때 수정된 페이지들이 disk 상에 반영되므로 redo 필요없음
                - no-FORCE: 커밋 시점에 반영하지 않는 정책
                    - 트랜잭션이 disk 상의 db 에 반영되지 않을 수 있기에 redo 복구가 필요 (대부분의 DBMS 정책)


- 데드락(교착상태)
    - 발생 원인
        - 두개의 트랜잭션작업이 서로 완료 될때까지 기다리게되며 결과적으로 아무것도 완료가 되지 않는 상태일 경우 발생

    - 해결 방법
        1) 트랜잭션 진행방향을 같은방향으로 처리
            - 업데이트시 begintran로 인하여 블록킹이 될 수는 있으나 데드락이 발생할 확률이 줄어지게 됩니다.

        2)트랜잭션 처리속도를 최소화
            - 트랜잭션속도가 빨라 commit 처리가 되면 다른 트랜잭션에서 테이블이 잠길 일이 없습니다.

        3) SET LOCK_TIMEOUT문을 이용하여 잠금해제 시간을 조절
            - 데드락이 발생했을때 잠금 시간을 해제 해주면 무기한 대기하지 않고 만료가 되어 다음작업을 진행할수 있습니다.
            - -1(기본값)은 제한시간없이 무기한대기

    - 데드락이 발생 줄이기
        - 인덱스 설정
            - 인덱스가 없으면 Lock이 걸리는 범위가 훨씬 넓어지기 때문에 교착상태가 발생하기 쉬워진다.

        - Isolation Level 조정
            1) READ UNCOMMITED : Share-lock 사용안함.
            2) READ COMMITED : 매번의 read 마다 Consistent read를 통한 새로운 snap shot을 생성하며, Share-lock을 사용안함
            3) REPEATABLE READ : Shared Lock도 트랜잭션 종료시까지 지속된다. UPDATE, DELETE 상태일때 unique index에 대해 찾으면 → index record에만 lock (record lock)
                                 range-type (범위로) 찾으면 → gap lock 사용
            4) SERIALIZABLE : Shared Lock이 트랜잭션 종료시까지 지속된다.

        - Lock Timeout 설정 ( 트랜잭션 처리속도를 최소화 )

        - 프로시저 우선순위 설정. 트랜잭션 진행방향을 같은방향으로 처리

        - 데드락 발생시 DBMS는 둘 중 한 트랜잭션에 에러를 발생시킴으로써 문제를 해결.

    - 발생 조건
        1. 상호배제
        2. 점유 대기
        3. 비선점
        4. 순환 대기
        => 네 가지 조건을 모두 만족하면 교착 상태가 발생

    - 해결 방법
        1. 교착 상태 예방
            - 위의 발생 중 하나 이상을 제거
        2. 교착 상태 회피
            - 교착 상태 발생 가능성을 검사해서 발생 가능성이 있다면 사전에 회피하는 방식
        3. 교착 상태 탐지 및 회복
            - 교착 상태를 허용하지만 상태를 탐지하고 회복하는 방식
        4. 교착 상태 무시
            - 교착 상태 자체를 무시하고, 특별한 조치를 취하지 않는 방법


- 블로킹 (Blocking)
    - 정의
        Lock들의 경합이 발생하여 특정 프로세스의 작업이 진행되지않고 멈춘 상태를 의미. S-Lock/X-Lock, X-Lock/X-Lock끼리 발생할 수 있다.
        해결방법은 Commit, Rollback이 있다.

    - 해결방안
        - SQL문 속도개선
        - Transaction 허용시간 단축
        - 동일한 데이터 수정작업 개선
        - 주 사용시간대 대용량 작업 지양
        - 대용량작업의 작업단위 분할 또는 lock시간 조율


- 데이터베이스 Lock
    - 데이터베이스 잠금이 왜 필요할까? - 동시성 제어
        - 동시성 제어
            - 트랜잭션들이 동시에 수행될 때, 일관성을 해치지 않도록 데이터 접근을 제어하는 DBMS 의 기능
              Lock 을 이용하여 동시성 제어
            - 트랜잭션이 시작되면 이용하고 있는 (ROW, TABLE)은 트랜잭션이 끝날 때까지 점유

    - Lock 의 종류 - 낙관적, 비관적
        - 낙관적 잠금 (Optimistic Lock)
            - 데이터 경신 시 경합이 발생하지 않을 것이라고 보고 잠그는 기법
            - 데이터를 업데이트 시켜주기 전 버전을 다시 읽어온다. 처음에 읽어온 버전과 그 다음 읽어온 버전이 같다면 버전을 다시
              업데이트. 반면 다른 사용자는 뒤늦게 구매를 완료하고 버전을 다시 읽어온다. 이미 버전이 업데이트 되었으므로 버전이 달라서
              충돌이 발생하고 롤백을 시켜줌.
            - 동시 업데이트가 거의 없는 경우
        - 비관적 잠금 (Pessimistic Lock)
            - 동일한 데이터를 동시에 수정할 가능성이 높다고 보는 잠금
            - 데이터에 접근하기 전 Lock 을 걸어줌. 일련의 과정들을 거치고 Unlock 을 시켜줌. Lock 이 걸리고 Unlock 이 걸리는 동안
              다른 사용자는 무조건 대기해야함.
            - 동시 업데이트가 빈번한 경우, 롤백을 하기 힘든 외부 시스템과 연동한 경우

    - Pessimistic Lock 연산의 종류 - 공유, 베타
        - 공유 락 (shared lock)
            - read 연산 실행 가능, write 연산 실행 불가능
            - read 연산은 데이터에 영향을 안 미치므로 데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음
        - 베타 락 (exclusive lock)
            - read 연산과 write 연산을 모두 실행 가능
            - 베타 락 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 가짐

    - Lock 의 단위
        - 데이터베이스 / 파일 / 레코드 / 필드
        - 단위를 크게 가져간다면 구현이 단순하지만 병행성이 떨어지고, 단위를 작게 가져가면 구현이 복잡하지만 병행성이 높아짐
        - 락의 단위는 데이터베이스의 종류마다 다름

    - Lock 으로 발생할 수 있는 문제점 - 블로킹, 데드락
        - Blocking
            - Lock 들의 경합이 발생하여 특정세션이 작업을 진행하지 못하고 멈춰 선 상태
            - 데이터에 대해서 하나의 트랜잭션이 베타락을 걸면 다른 트랜잭션들은 어떠한 락도 걸지 못하고 대기해야하기 때문
            - 블로킹이 풀리는 시점은 트랜잭션이 커밋 혹은 롤백할 때
            - 해결 방안
                1. 트랜잭션을 짧게 정의
                2. 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절

        - DeadLock 교착 상태
            - 각 트랜잭션의 락들이 서로 맞물려 무한 대기하는 상태
            - 해결 방안
                1. 트랜잭션 진행 방향을 같은 방향으로 처리
                    -> 이렇게 하면 블로킹은 발생할 수 있지만, 데드락 발생 확률은 현저히 줄어듬.
                2. 트랜잭션 처리 속도를 최소화
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절


- 트리거(Trigger)에 대해 설명해주세요.
    - 트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 자동적으로 수행되는 사용자 정의 프로시저이다.
    - 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.
    - 프로시저나 함수는 사용자가 직접 호출해야 하지만, 트리거는 오라클에서 사용자에게 알려주지 않고 자동으로 호출하여 처리
    - Before, After 두 가지 트리거가 있다.
    - 트랜잭션 일부로 처리됨 (COMMIT, ROLLBACK, SAVEPOINT 문장 포함 못함)


- 프로시저
    - 정의
        - 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
        - 원하는 결과물을 얻기 위해 사용할 여러줄의 쿼리문을 한 번의 요청으로 실행
          인자 값만 상황에 따라 바뀌고 동일한 로직의 복잡한 쿼리문을 필요할 때마다 작성한다면 비효율적. 이럴 때 사용할 수 있는 것이 바로 프로시저다.

        - 오라클에서의 프로시저는 PL/SQL을 통해 만들어집니다. 자주 사용하는 SQL을 프로시저로 만든 뒤 필요 할때마다 호출,사용하여 작업 효율을 늘릴 수 있습니다.
          함수는 특정 연산을 수행한 뒤 결과 값을 반환하지만 프로시저는 특정한 로직을 처리하기만 하고 결과 값은 반환하지 않는 서브 프로그램입니다.

    - 장점
        1. 최적화 & 캐시
            프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다.
            만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.

        2. 유지 보수
            작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다. (But, 장점이 단점이 될 수도 있는 부분이기도.. )

        3. 트래픽 감소
            클라이언트가 직접 SQL문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 된다.
            즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서버 간 네트워크 상 트래픽이 감소된다.

        4. 보안
            프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.

    - 단점
        1. 호환성
            구문 규칙이 SQL / PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁘다.

        2. 성능
            문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느리다.

        3. 디버깅
            에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.


- 함수(Function)
    - 정의
        - 매개변수를 받아 특정 계산(작업)을 수행하고 결과를 반환하는 구조
        - 데이터베이스 내에서는 특정 값(매개변수)을 입력 받아 여러 쿼리문을 작업한 뒤 반환하는 기능을 의미


- 함수와 프로시저의 차이
    - 프로시저
        - 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합이며, 일련의 작업을 정리한 절차입니다.
        - 보통 단독으로 실행해야 할 작업을 위임받았을 때 사용합니다.

        - 매개변수 : 입력,출력,입출력 형식으로 받을 수 있습니다.
        - 반환값 : 반환값을 가질 수도 있고 가지지 않을 수도 있습니다.
        - 쿼리문 : SELECT,WHERE 문 등에서 사용 불가
        - 처리 장소 : 클라이언트(화면)에서 값을 건네받아 서버에서 작업을 한 뒤 클라이언트에게 전달
                     즉, 서버에서 실행이 되어 속도면에서 빠른 성능을 보여줍니다.

    - 함수
        - 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합
        - 함수가 여러 작업을 위한 기능이라면 프로시저는 작업을 정리한 절차
        - 보통 로직을 도와주는 역할이며, 간단한 계산, 수치 등을 나타낼 때 사용

        - 매개변수 : 매개변수를 입력 형식으로만 받을 수 있습니다.
        - 반환값 : 반환값을 반드시 가져야 합니다.
        - 쿼리문 : SELECT,WHERE 문 등에서 사용 가능
        - 처리 장소 : 클라이언트(화면)에서 값을 건네 받고 서버에서 필요한 값을 가져와서 클라이언트에서 작업을 하고 반환
                     즉, 클라이언트(화면)에서 실행이 되어 프로시저보단 속도가 느립니다.


- 정규화에 대해 설명해주세요.
    하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.

    제1 정규형 : 테이블의 컬럼이 원자 값(Atomic Value; 하나의 값)을 갖도록 분해합니다.
    제2 정규형: 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다.
    ※ 여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미

    제3 정규형 : 제2 정규형을 만족하고, 이행적 함수 종속을 없애도록 분해합니다.
    ※ 여기서 이행적 종속이란 A → B, B → C가 성립할 때 A → C가 성립되는 것을 의미

    BCNF 정규형 : 제3 정규형을 만족하고, 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해합니다.

    장점
    1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.
    2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

    단점
    릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.
    + 정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로
      한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.


- 정규화란
    - 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정

    - 비정규형
        - 하나의 튜플에서 속성을 입력되는 도메인 값으로 여러 개의 값이 들어와서 원자성(Atomic)을 가지지 못한 경우
    - 제1정규형 (원자값이 아닌 도메인을 분해)
        - 원자값이 아닌 도메인을 분해하여 어떤 릴레이션 R에 속한 모든 도메인이 원자값으로만 되어 있도록 설계
    - 제2정규형 (부분 함수 종속 제거)
        - 어떤 릴레이션 R이 제1정규화에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수적 종속이면 충족하는 정규화
    - 제3정규형 (이행 함수 종속 제거)
        - 어떤 릴레이션 R이 제2정규화에 있으며 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아닌 상태의 관계
    - 보이스 코드 정규형 (결정자가 후보키가 아닌 함수 종속 제거)
        - 릴레이션 R의 모든 결정자가 후보키이면 릴레이션 R은 Boyce-Codd 정규형에 속하는 상태.
    - 제4정규형 (다중치 종속 제거)
    - 제5정규형 (후보키를 통하지 않은 조인 종속 제거)


- 역정규화를 하는 이유에 대해 아는대로 설명해주세요.
    - 정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하될 우려가 있습니다.
    - 역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.


- SELECT 쿼리의 수행 순서를 알려주세요.
    - FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > DISTINCT > ORDER BY > LIMIT

    1. FROM
        - 각 테이블을 확인한다.

    2. ON
        - JOIN 조건을 확인한다.

    3. JOIN
        - JOIN이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함께 포함되어 임시 테이블을 만들 수 있게 도와준다.

    2. WHERE
        - 데이터셋을 형성하게 되면 WHERE의 조건이 개별 행에 적용된다. WHERE절의 제약 조건은 FROM절로 가져온 테이블에 적용될 수 있다.

    3. GROUP BY
        - WHERE의 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화된다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야 한다.

    4. HAVING
        - GROUP BY절이 쿼리에 있을 경우 HAVING 절의 제약조건이 그룹화된 행에 적용된다.

    5. SELECT
        - SELECT에 표현된 식이 마지막으로 적용된다.

    6. DISTINCT
        - 표현된 행에서 중복된 행은 삭제

    7.ORDER BY
        - 지정된 데이터를 기준으로 오름차순, 내림차순 지정

    8. LIMIT
        - LIMIT에서 벗어나는 행들은 제외되어 출력된다.


- union vs union all
    - union
        - 쿼리의 결과를 합친다. 중복된 ROW는 제거
        - 중복을 제거하기 위해 불가피하게 sort 함
            - 데이터가 많거나 index 가 되어있지 않은 칼럼을 대상으로 하면 쿼리 시간이 길어질 수 있음

    - union all
        - 모든 컬럼값이 같은 ROW도 결과로 보여준다. 중복제거 하지 않는다.


- HAVING과 WHERE의 차이를 설명해주세요.
    - having은 그룹을 필터링 하는데 사용되고, where은 개별 행을 필터링하는데 사용됩니다.
    - having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고,
      where은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용됩니다.


- JOIN에서 ON과 WHERE의 차이를 설명해주세요.
    - ON 이 WHERE 보다 먼저 실행되어 JOIN 을 하기 전에 필터링을 하고 (=ON 조건으로 필터링이 된 레코들간 JOIN이 이뤄진다)
    - WHERE은 JOIN 을 한 후에 필터링을 합니다. (=JOIN을 한 결과에서 WHERE 조건절로 필터링이 이뤄진다)


- like 검색을 대체할 방법
    - Instr(칼럼, 검색어) > 0
    - 정규식 사용 regexp_like, regexp_instr


- like 검색을 개선할 방법
    - 오라클 text 기능 사용 : 도메인 인덱스
    - 별도의 인덱스 구성 : 공백을 기준으로 단어들을 나누어 테이블 키와 함께 별도의 인덱스 테이블 구성
    - 별도 검색엔진 사용


- connection timeout 과 read timeout 차이
    - connection time out
        - 클라이언트가 서버측으로 connection 맺길 원하지만 서버와 connection 이 맺어지지 못할 때 발생한다.
          이 경우, 클라이언트의 OUTBOUND, 서버 측의 INBOUND 방화벽을 확인해 볼 필요가 있다.

        - 웹 브라우저가 네이버 서버에 접속하기 위해서 서버와 연결된 상태가 되어야한다. 보통 연결을 구성하기위해
          TCP Connection 과 동일하게 3-way-HandShake 방식으로 수행하게 된다. 3-way HandShake 가 정상적으로
          수행하게 되면 웹 브라우저와 네이버 서버는 연결된 상태가 되는데, 이때까지 소요된 시간을 Connection 에
          소요된 시간이라고 할 수 있다.
          "즉, ConnectionTimeout 이란 3-way HandShake 가 정상적으로 수행되어 서버에 연결되기까지 소요된 시간이다."

    - Read time out
        - Connection time out 과는 다르게 클라이언트와 서버가 connection 은 맺어졌지만, I/O 작업이 길어지거나 데이터를 읽어가지 못하는
          상황이 되어, 설정된 시간을 초과하여 생기는 문제이다. 보통 Tcp connection 은 3way-HandShake 방식으로 수행한다.
          해당 방식을 통해 정상적으로 수행하게 되면 connection 이 맺어지고, 서버 측에서 데이터를 전달, 클라이언트에서 읽어가는 형식이다.
        - "Connection 맺은 후 Response(응답)을 받기까지 소요될 시간의 임계치이다."
        - client 가 server 에 접속을 성공 했으나 서버가 로직을 수행하는 시간이 너무 길어 제대로 응답을 못준 상태에서
          client 가 연결을 해제하는것이 Read timeout 입니다.


- database timeout
    - TransactionTimeout
        - 전체 Statement 수행 시간을 허용할 수 있는 최대 시간 이내로 제한하려 할 때 TransactionTimeout을 사용한다.

    - StatementTimeout
        - Statement 하나가 얼마나 오래 수행되어도 괜찮은지에 대한 한계 값이다.

        - 요즘 개발 환경에서는 개발자가 직접 StatementTimeout을 Java 코드로 설정하는 경우는 드물며, 프레임워크를 이용하여 해결하는 경우가 많다
        - iBatis를 예로 들어 설명하자면 "sql-map-config.xml" 파일의 sqlMapConfig/settings에 @defaultStatementTimeout 값으로 기본값을 설정할 수 있다
        - "sql-map.xml" 파일의 statement, select, insert, update 구문마다 @timeout 값으로 개별적으로 설정할 수 있다

    - JDBC 드라이버의 SocketTimeout
        - JDBC 드라이버의 SocketTimeout 값은 DBMS가 비정상으로 종료되었거나 네트워크 장애(기기 장애 등)가 발생했을 때 필요한 값이다.

        - TCP/IP의 구조상 소켓에는 네트워크의 장애를 감지할 수 있는 방법이 없다. 그렇기 때문에 애플리케이션은 DBMS와의 연결 끊김을 알 수 없다.
        - 이럴 때 SocketTimeout이 설정되어 있지 않다면 애플리케이션은 DBMS로부터의 결과를 무한정 기다릴 수도 있다(Dead Connection이라고 부르기도 한다)
        - SocketTimeout 값은 StatementTimeout 값보다는 크게 설정해야 한다.


- noSQL
    - NoSQL 정의
        - Not Only SQL
        - NoSQL 은 비관계형 데이터베이스를 지칭한다. 즉, 관계형 데이터 모델을 지양 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며
          스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.
        - NoSQL 은 기존 RDBMS 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며,
          관계형 데이터베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태이다.

    - NoSQL 의 특징
        - RDBMS 와 달리 데이터 간의 관계를 정의하지 않는다.
            - RDBMS 는 데이터 관계를 외래키 등으로 정의하고 JOIN 연산을 수행할 수 있지만, NoSQL 은 JOIN 연산이 불가능하다.
        - RDBMS 에 비해 대용량의 데이터를 저장할 수 있다.
            - 페타바이트 급의 대용량 데이터를 저장할 수 있다.
        - 분산형 구조이다.
            - 여러 곳의 서버에 데이터를 분산 저장해 특정 서버에 장애가 발생했을 때도 데이터 유실 혹은 서비스 중지가 발생하지 않도록 한다.
        - 고정되지 않은 테이블 스키마를 갖는다.
            - RDBMS 와 달리 테이블의 스키마가 유동적이다. 데이터를 저장하는 칼럼이 각기 다른 이름과 다른 데이터 타입을 갖는 것이 허용된다.

    - NoSQL 의 장점
        - RDBMS 에 비해 저렴한 비용으로 분산처리와 병렬 처리 가능
        - 비정형 데이터 구조 설계로 설계 비용 감소
        - Big Data 처리에 효과적
        - 가변적인 구조로 데이터 저장이 가능
        - 데이터 모델의 유연한 변화가 가능

        - RDBMS에 비해 저렴한 비용으로 분산 처리와 병렬 처리가 가능
        - 비정형 데이터 구조 설계로 설계 비용이 감소
        - 관계형 데이터베이스의 relation과 join 구조를 linking과 embedded로 구현하여 성능이 빠름
        - Big Data 처리에 효과적
            - Scale out 구조를 채댁하여 서버 확장에 용이하며 더 많은 데이터를 저장
        - 가변적인 구조로 데이터 저장이 가능
        - Document based(Schema-less) 구조로 데이터 모델의 유연한 변화가 가능
        - json 구조로 RDBMS 테이블 구조에 비해 데이터를 직관적으로 파악
        - Auto Sharding을 지원

        * sharding이란
            - 단일의 논리적 데이터셋을 다수의 데이터베이스에 쪼개고 나누는 방법
            - 샤딩은 데이터셋이 단일 데이터베이스에서 저장하기에 너무 클 때 필수적으로 사용된다.

    - NoSQL 의 단점
        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 데이터 일관성이 항상 보장되지 않음

        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 복잡한 join은 어려움(다양하고 복잡한 데이터 쿼리), document based이기 때문
        - NoSQL은 sharding 방식을 사용해서 큰 테이블을 여러 서버에 나누어 저장한다.
          어떤 데이터가 update 되었을 때, NoSQL은 중복 저장된 서버들에 해당 update가 적용되기까지는 시간이 걸린다.
        - RDBMS는 모든 서버를 update 되기전까지는 해당 데이터 또는 테이블에 lock을 걸어 읽기 금지를 한다. 따라서 데이터에 대한 일관성이 보장된다.
          하지만 NoSQL에서는 lock을 하게 될 경우 느려지므로 RDBMS와 같은 lock을 하지 않는다.
        - 데이터 일관성이 항상 보장되지 않는다.

    - NoSQL 의 종류
        - Key-Value Database
            - 기본적인 패턴으로 KEY-VALUE 하나의 묶음(Unique)으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장 시 용이하다.
            - Key 안에 (COLUMN, VALUE) 형태로 된 여러 개의 필드, 즉 COLUMN FAMILIES 갖는다.
              주로 SERVER CONFIG, SESSION CLUSTERING 등에 사용되고 엑세스 속도는 빠르지만, SCAN 에는 용이하지 않다.
            Ex) Redis, Oracle NoSQL Database, VoldeMorte

        - Wide-Column Database
            - 행마다 키와 해당 값을 저장할 때마다 각각 다른값의 다른 수의 스키마를 가질 수 있다.
              위 그림을 참고하면 사용자의 이름(key)에 해당하는 값에 스키마들이 각각 다름을 볼 수 있다.
              이러한 구조를 갖는 WIDE COLUMN DATABASE 는 대량의 데이터의 압축, 분산처리, 집계 쿼리 (SUM, COUNT, AVG 등)및
              쿼리 동작 속도 그리고 확장성이 뛰어난 것이 그 대표적 특징이라 할 수 있다.
            EX) Hbase, GoogleBigTable, Vertica

        - Document Database
            - 테이블의 스키마가 유동적, 즉 레코드마다 각각 다른 스키마를 가질 수 있다.
              보통 XML, JSON 과 같은 DOCUMENT 를 이용해 레코드를 저장한다.
              트리형 구조로 레코드를 저장하거나 검색하는 데 효과적이다.
            Ex) MongoDB, CouchDB, Azure Cosmos DB

        - Graph Database
            - 데이터를 노드로(그림에서 파란, 녹색 원) 표현하며 노드 사이의 관계를 엣지(그림에서 화살표)로 표현
              일반적으로 RDBMS 보다 성능이 좋고 유연하며 유지보수에 용이한 것이 특징.
              Social networks, Network diagrams 등에 사용할 수 있다.
            Ex) Neo4j, BlazeGraph, OrientDB


- RDBMS와 NoSQL의 차이에 대해 설명해주세요.
    - RDBMS는 모든 데이터를 2차원 테이블 형태로 표현합니다.
        장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
        단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)

    - NoSQL(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.
        장점 : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
              데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.
        단점 : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
              스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.


- 그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?
    - RDBMS
        - 데이터 구조가 명확하고, 변경될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다.
        - 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합

    - NoSQL
        - 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다.
        - 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋다.
        - Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합


- LOCK의 부작용이 있을까요?
    - LOCK의 제어를 잘 못하면 데드락이 걸릴 수 있습니다.

    1) 트랜잭션 1이 A 를 읽기 위해 LOCK을 검
    2) 트랜잭션 2가 B를 읽기 위해 LOCK을 검
    3) 트랜잭션 1이 B를 읽어 오려고 했으나 LOCK이 걸려 대기
    4) 트랜잭션 2가 A를 읽어 오려고 했으나 LOCK이 걸려 대기


- SQL 대량 데이터 처리
    - 하나의 테이블에 대량의 데이터가 존재하는 경우
        - 인덱스의 Tree 구조가 너무 커져 호율성이 떨어져 데이터를 처리(입력, 수정, 삭제, 조회)할 때 디스크 I/O를 많이 유발
        - 인덱스를 생성할 때 인덱스의 크기가 커지게 되고 그렇게 되면 인덱스를 찾아가는 단계가 깊어지게 되어 조회의 성능에도 영향을 미치게 된다.
        - 영향을 미치는 정도가 작지만 데이터를 입력 / 수정 / 삭제하는 트랜잭션의 경우 인덱스의 특성상 일량이 증가하여 성능저하를 유발

        - 파티셔닝을 적용하거나 PK에 의해 테이블을 분할
            - Oracle의 경우 List Partition(특정 값 지정), Range Partition(범위), Hash Partition(해쉬적용), Composite Partition(범위와 해쉬가 복합)**등이 가능
            - 논리적으로는 하나의 테이블로 보이지만 물리적으로는 여러 개의 테이블 스페이지에 쏘개어 저장될 수 있는 구조의 파티셔닝을 사용하면 성능을 개선
                - Range Partition
                    - 요금테이블에 PK가 요금일자+요금번호로 구성
                    - 특성상 월단위로 데이터를 처리하는 경우가 많으므로 PK인 요금일자의 년+월을 이용하여 12개의 파티션 테이블 구성
                    - 가장 많이 사용되는 파티셔닝 기능
                    - 데이터 보관 주기에 따른 테이블 관리가 용이
                - List Partition
                    - 값 각각에 의해 파티셔닝
                - Hash Partition
                    - 지정된 Hash 조건에 따라 해슁 알고리즘이 적용되어 테이블이 분리
                    - 설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 없다.

    - 하나의 테이블에 많은 수의 칼럼이 존재
        - 물리적인 디스크에 여러 블록에 데이터가 저장되게 된다.
          따라서 데이터를 처리할 때 여러 블록에서 데이터를 I/O해야 하는 SQL 문장의 성능이 저하

        - 트랜잭션이 발생할 때 어떤 칼럼에 대해 집중적으로 발생하는지 분석하여 테이블을 쪼개어주면 디스크 I/O가 감소하게 되어 성능이 개선
        - 분리된 테이블은 디스크에 적어진 칼럼이 저장이 되므로 로우마이그레이션과 로우체이닝이 많이 줄어들 수 있다. 따라서 성능이 개선

    * 로우체이닝(Row Chaining)
        - 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
    * 로우마이그레이션(Row Migration)
        - 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

    - 로우 길이가 너무 긴 경우 로우 체이닝과 마이그레이션이 발생
    - 많은 블록에 데이터가 저장되면, 데이터베이스 메모리에서 디스크와 I/O(입력/ 출력)가 발생할 때 불필요하게 I/O가 많이 발생해 성능이 저하된다.

    -> 칼럼 수가 많은 경우 트랜잭션 특성에 따라 테이블을 1:1 형태로 분리할 수 있는지 검증하면 된다.
       그러나 칼럼의 수가 적지만 데이터 용량이 많아 성능 저하가 예상이 되는 경우 테이블에 대해 파티셔닝 전략을 도모


- 역색인
    - 하나의 값(term)이 들어간 문서번호를 지정하는 것
    - 전통적인 RDBMS에서는 위와 같이 like 검색을 사용하기 때문에 기본적으로 속도가 느리다.
    - Elastic Search는 데이터를 저장할 때 다음과 같이 역 인덱스(inverted index)라는 구조를 만들어 저장한다.
    - 하나의 값(Term)이 해당 Term이 들어간 document id 를 지정
    - 데이터가 늘어나도 찾아가야 할 행이 늘어나는 것이 아니라 역인덱스가 가리키는 id의 배열값이 추가되는 것 뿐이기 때문에 큰 속도의 저하 없이 빠른 속도로 검색이 가능
    - 다만 수정과 삭제는 엘라스틱서치 내부적으로 굉장히 많은 리소스가 소요된다.


- Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
    - RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다.
        (MySQL 최신 버전에서 n-gram 기반의 Full-Text 검색을 지원하긴 하지만, 한글 검색의 경우 아직 많이 빈약한 감이 있습니다.)
    - 하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능합니다.
        Full-Text : 이미지, CSS, 글 등의 복합적으로 이뤄진 컨텐츠에서 순수하게 텍스트만 추출한 데이터를 의미. 이 과정을 보통 크롤링으로 구현함


- InnoDB 스토리지 엔진에서 클러스터링 인덱스와 세컨더리 인덱스가 동작하는 과정을 설명하라.
    - 클러스터링 인덱스
        클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면,
        해당 클러스터링 인덱스 키에 해당하는 레코드의 모든 정보를 가져온다.

    - 세컨더리 인덱스
        세컨더리 인덱스의 리프 노드에는 클러스터링 인덱스의 리프 노드와는 달리 PK가 존재한다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면,
        해당 세컨더리 인덱스 키에 해당하는 레코드의 PK를 이용하여 데이터 파일을 탐색한다. 이때 데이터 파일은 클러스터링 인덱스이므로
        이 데이터 파일의 리프 노드에는 해당 PK에 해당하는 레코드의 모든 정보를 가져온다.


- 데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요.
    - 클러스터링
        - 여러 개의 DB를 수평적인 구조로 구축하는 방식입니다. 동기 방식으로 사용

        - 장점
            - DB 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
            - 1개의 DB가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영할 수 있다. (높은 가용성)
            - 기존에 하나의 DB서버에 몰리던 부하를 여러 곳으로 분산시킬 수 있다. (로드밸런싱)
        - 단점
            - 저장소 하나를 공유하면 병목현상이 발생할 수 있다.
                ※ 병목현상 : 전체 시스템이 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상이다.
            - 서버를 동시에 운영하기 위한 비용이 많이 든다.

    - 리플리케이션
        - 여러 개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식입니다. 비동기 방식으로 사용

        - 장점
            - DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
            - 비동기 방식으로 운영되어 지연 시간이 거의 없다.
        - 단점
            - 노드들 간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
            - Master DB가 다운되면 복구 및 대처가 까다롭다.


- connection pool
    - 정의
        - 애플리케이션의 스레드에서 데이터베이스에 접근하기위해 Connection이 필요
        - 데이터베이스와 Connection한 객체들을 미리 생성해 Pool에 저장해두었다가, 클라이언트의 요청이 들어올 때마다 사용/반환하는 방식

    - 데이터베이스 접근 과정
        (1) 웹 컨테이너가 실행되면 데이터베이스와 연결된 Connection 객체들을 미리 생성해 Pool에 저장
        (2) 클라이언트 요청 시 Pool에서 Connection 객체를 가져와 데이터베이스 접근
        (3) 요청 처리가 끝나면 사용된 Connection 객체를 다시 Pool에 반환

    - 장점
        - 매 연결마다 Connection 객체를 생성/제거하는 비용 감소
        - 미리 생성된 Connection 객체를 사용하므로 데이터베이스 접근 시간 단축
        - Connection 수를 제한해 부하 조정

    - 단점
        - Connection 또한 객체이므로 메모리 차지
        - Connection 개수를 잘 못 설정할 경우, 쓸모없는 Connection이 발생할 수 있음

    - Connection이 부족할 경우
        - 모든 Connection이 요청을 처리 중일 때, 해당 클라이언트의 요청을 대기 상태로 전환
        - Pool에 Connection 객체가 반환되면 순차적으로 요청을 처리

    - Thread Pool과 Connection Pool
        - Thread Pool은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것
        - WAS(Web Application Server)에서 Thread Pool과 Connection Pool의 Thread와 Connection의 수는 메모리와 직접적으로 관련이 있음
        - Connection과 Thread 수를 많이 설정하면 메모리를 많이 차지하고, 반대로 적게 설정할 경우 처리하지 못하는 대기 요청이 많아짐


- Statement 와 PrepareStatement 의 차이
    - PrepareStatement 는 Statement 를 상속받았다. 그리고 이 둘의 가장 큰 차이점은 캐시 사용 여부이다.
        쿼리 문장 분석
        컴파일
        실행
        Statement 를 사용하면 매번 쿼리를 수행할 때마다, 위 3단계를 거친다. 하지만 PrepareStatement 의 경우는
        처음 한 번만 위의 단계를 거치고 그 다음에는 캐시에 담아 재사용한다.

    - PrepareStatement 는 동적인 쿼리문을 처리할 수 있다. 그래서 같은 SQL 문에서 값만 변경하여 사용한다던지, 인수가 많은 경우에 사용하기 좋다.
      Statement 는 쿼리 실행이 적을 경우 사용하면 좋을 것이고, PrepareStatement 는 쿼리 실행이 많고 동적인 쿼리문이 있을 경우 사용하면 좋을 것이다.


- RDBMS vs NoSQL
    - RDBMS
        - 정의
            - RDBMS는 정해져있는 데이터 스키마에 따라 데이터베이스 테이블에 저장되며, 관계를 통한 테이블간 연결을 통해 사용된다.
              이 때문에 RDBMS는 데이터 관리를 효율적으로 하기위해 구조화가 굉장히 중요하다.

            ※스키마란?
            데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조이다.
            데이터베이스 관리 시스템(DBMS)이 주어진 설정에 따라 데이터베이스 스키마를 생성하며, 데이터베이스 사용자가 자료를 CURD 할 때,
            DBMS는 자신이 생성한 데이터베이스 스키마를 참조하여 명령을 수행한다.

        - 장점
            - 스키마가 정해져 있기 때문에, 명확한 데이터 구조를 보장 (데이터 무결성 보장)
            - 데이터의 중복을 피해 데이터 공간을 절약할 수 있음

        - 단점
            - 시스템 복잡도를 고려하여 구조화 해야함
            - 복잡한 시스템일수록 쿼리문이 복잡해지고 성능이 떨어짐
            - 수평 확장이 어려워 수직 확장을 대부분 함.

    - NoSQL
        - 정의
            - 관계형 데이터베이스와 반대되는 방식을 사용하여 스키마와 관계라는 개념이 없다.
            - RDBMS에서는 스키마에 맞추어 데이터를 관리하여야 하지만 NOSQL은 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있다.
            - NOSQL에서 테이블과 같은 개념으로 컬렉션이라는 형태로 데이터를 관리한다.

        - 장점
            - 스키마가 없기 때문에 자유롭게 데이터를 추가할 수 있음
            - 수평적 확장이 RDBMS보다는 쉬움
            - 프레임워크에서 분산처리 기능을 포함

        - 단점
            - 컬렉션엔 중복된 데이터의 저장이 가능함


- 샤딩
    - 데이터가 많아서 검색이 느린데 더 빠르게 할 수 있는 방법은 없을까?
        - 샤딩은 수평 분할(Horizontal Partitioning)과 동일하며, 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위한 것이다.
        - 수평 분할(Horizontal Partitioning)이란 스키마(schema)가 같은 데이터를 두 개 이상의 테이블에 나누어 저장하는 디자인을 말한다.
        - 가령 같은 주민 데이터를 처리하기 위해 스키마가 같은 '서현동주민 테이블'과 '정자동주민 테이블'을 사용하는 것을 말한다.
        - 데이터베이스를 샤딩하게 되면 기존에 하나로 구성될 스키마를 다수의 복제본으로 구성하고 각각의 샤드에 어떤 데이터가 저장될지를 샤드키를 기준으로 분리한다.

    - 프로그래밍, 운영적인 복잡도는 더 높아지는 단점이 있습니다.
        - 가능하면 Sharding을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선되어야 합니다.

    - Scale-in
        - Hardware Spec이 더 좋은 컴퓨터를 사용합니다.

    - Read 부하가 크다면?
        - Cache나 Database의 Replication을 적용하는 것도 하나의 방법입니다.

    - Table의 일부 컬럼만 자주 사용한다면?
        - Vertically Partition도 하나의 방법입니다. Data를 Hot, Warm, Cold Data로 분리하는 것입니다.

    - 기본개념을 넘어 좀더 자세히 알자보자면!!
        - 분산된 DB에서 어떻게 Data를 읽어오기 위해 Shard Key에 대한 방식을 선택해야 한다.

    - Algorithm Sharding
        - Database id를 단순하게 나누어 샤딩하는 방식
        - Sharding Key는 hash(key) % NUM_DB 같은 방식

        - 장점 같은 값을 가지는 key-value 데이터베이스에 적합하다.
        - 단점 Cluster를 포함하는 Node 갯수가 변하게 되면 Resharding이 필요하다. Hash Key로 분산되기 때문에 공간에 대한 효율이 부족하다.

    - Dynamic Sharding
        - 클라이언트는 Locator Service에 접근하여 Shard Key를 얻는다.
        - 장점 Cluster가 포함하는 Node 갯수가 변하면 Shard Key를 추가하기만 하면 된다.
            - 확장에 유연하게 대처가능하다.
        - 단점 Data Relocation시에는 Locator Service의 Shard key Table도 일치시켜야 한다.
            - Locator에 의존할 수 밖에 없는 구조이다.

    - Entity Group
        - Database id를 단순하게 나누어 샤딩하는 방식
        - Sharding Key는 hash(key) % NUM_DB 같은 방식

        - 장점 같은 값을 가지는 key-value 데이터베이스에 적합하다.
        - 단점 Cluster를 포함하는 Node 갯수가 변하게 되면 Resharding이 필요하다. Hash Key로 분산되기 때문에 공간에 대한 효율이 부족하다.


- Clustering
    데이터베이스 서버가 동작하지 않게 되면 전체 서비스가 동작할 수 없는 점을 해결하기 위해 Clustering을 통하여 서버를 한 대가 아닌 두 대로 구성하게 된다.
    이 때 DB서버는 서로 다른 인스턴스테서 동작한다.

    이 경우 같은 데이터베이스 서버 두 대를 하나로 묶어 운영하고 있다. 이때 두 서버의 상태가 모두 Active인 상태다.
    이렇게 되면 서버 한 대가 죽게 되더라도 하나의 서버가 동작하고 있어서 서비스에 큰 문제가 발생하지 않는다.
    다른 서버가 동작하는 동안 복구를 하여 서비스의 중단이 없도록 할 수 있다. 또한 이렇게 구성함으로써
    하나의 데이터베이스 서버에 가해지던 부하가 두 개로 나눠져 지므로 CPU와 Memory도 부하가 줄어들게 된다.

    - Active & Stand-By
        위와 같이 구성하면 무조건 좋은점만 있을까? 여러 개의 서버가 하나의 스토리지를 공유함으로써 병목현상이 발생할 수 있다.
        이러한 문제점을 해결하기 위해 하나의 서버는 Active 상태 다른 하나는 Stand-by 상태로 두는 방법이 있다.
        Active 상태의 서버에 문제가 생겼을 때 Fail over를 하여 Stand-by 서버를 Active로 전환하여 문제에 대응 할 수 있다.
        비용적인 부분에서는 별다른 차이가 없을 수 있지만 한 대로 서버가 운영되기 때문에 병목현상을 해결 할 수있다.

        하지만 Active & Stand-by에도 문제점이 있다. Fail over가 발생하는 시간 동안에는 서비스가 중단될 수 밖에 없다.
        또한 결론적으로 한 대로 운영하기 때문에 효율은 Active & Active의 1/2 정도가 된다.
        서버를 하나 더 둠으로써 문제를 해결하고 싶지만 뭔가 찜찜한 기분이 든다. 아마 서버는 늘리지만, 스토리지는 그대로 두는 점 일 것이다.
        그래서 이번에는 스토리지를 여러개 가지는 Replication에 대하여 알아보자.


- Replication
    여기서는 데이터베이스 스토리지를 복제하는 것을 의미한다.
    Clustering은 단순히 데이터베이스 서버를 확장한 것이라면 Replication은 데이터베이스 서버와 스토리지 모두를 확장하게 된다.
    이 때 단순히 확장만 하는 것이 아니라 메인으로 사용할 Master 서버와 이를 복제한 Slave 서버로 구성하게 된다.

    Master와 Slave로 구성된 구조를 자세히 살펴보면 Master 서버에는 INSERT, UPDATE, DELETE 작업이 전달되고 Slave 서버에는 SELECT 작업이 전달되는 것을 볼 수 있다.
    Slave는 결국 Master 서버에서 복제된 데이터이기 때문에 데이터의 조작이 발생할 수 있는 INSERT, UPDATE, DELETE 작업은 Master로 전달이 되고
    조회만을 하는 SELECT 작업은 Slave 서버를 통하여 진행하게 된다. 서비스에 맞게 Slave 서버를 여러 개 가져갈 수 있다.
    데이터베이스에서 발생하는 대부분의 쿼리는 조회인 SELECT인데 이러한 것을 Slave 서버를 통해 분산하여 처리할 수 있으니 좀 더 성능 향상을 가져갈 수 있다.

    - Replication의 단점
        각각의 서로 다른 서버로 운영하다보니 버전을 관리해야한다. 이 때 Master와 Slave의 데이터베이스 버전을 동일하게 맞춰주는 것이 좋다.
        버전이 다를 경우 적어도 Slave 서버가 상위 버전이어야 한다.
        또 한가지의 단점으로는 Master에서 Slave로 비동기 방식으로 데이터를 동기화 하기 때문에 일관성있는 데이터를 얻지 못할 수 있다.
        동기방식으로 Replication을 할 수 있지만 이럴 경우 속도가 느려진다는 문제점이 있다.
        마지막으로는 Master 서버가 다운이 될경우 복구 및 대처가 까다롭다는 단점이 있다.


    - 2개 이상의 DBMS를 Master와 Slave로 나누어 동일한 데이터를 저장한다.
    - Master DB는 Insert, Update, Delete의 기능을 수행하고, Slave DB에 실제 데이터를 복사한다.
    - Slave DB 시간이 오래걸리는 Select문의 기능을 수행하여 전체적인 Select문 성능을 향상시킨다.

    - DB 이중화
        - master db에서는 insert , update ,delete 작업 , slave db에서는 read용으로 사용
        - mysql replication을 통해 데이터 복제

    - replication 장점
        - DB 서버 부하 분산
        - master db 장애시 slave db로 대체 가능

    - replication 단점
        - Master-Slave pair 관리:서버들이 많아질 경우, Master와 Slave의 짝을 관리하는 것이 쉽지 않다.
        - 실패 상황에서의 복구 : Master가 실패시 Master와 Slave의 교체, 혹은 Slave의 데이터를 Master로 복사하는 등의 작업을 수동으로 진행하여야 한다.
          Slave의 실패인 경우도 마찬가지이다.
        - binary log의 관리: Master 에 쌓이는 binary log에 대한 관리 또한 수동으로 처리하여야 한다.(cron등을 이용하여 정기적인 삭제 필요)
        - replication 지연발생: Master의 처리량이 많은 경우 Slave는 지연시간이 발생하게 되고 그 시간동안의 데이터는 일치하지 않는 문제가 있다.


- 파티셔닝
    - VLDB(Very large DBMS)
    - 전체 DB가 하나의 DBMS시스템에 다 들어가기 힘들어지는 경우, 테이블들을 여러 개의 군으로 나눠 분산 저장
    - 하나의 테이블이 방대한 경우에는 사전방식과 같이 나눠 저장
    - 파티셔닝 DBMS 레벨 분할
      샤딩 DBMS 외부에서 분할 / 응용레벨에서 구별해야 함

    - 파티셔닝 이점
        - 데이터 전체 검색시 필요한 부분만 탐색해 성능 증가
        - 전체 데이터를 손실할 가능성이 줄어듦 -> 가용성향상
        - 파티션별 백업/복구 가능
        - 파티션 단위로 I/O 분산가능 -> 업데이트 성능 증가

    - 파티셔닝 방식
        - 범위(range) a-m/n-r/s-z
        - 해시(hash) 해시함수 파티션별로 크기를 비슷하게 나눔
        - 리스트(list) 특정한 컬럼을 기준
        ex) Card 테이블에 연도 (CreationTime) 컬럼을 추가하고 파티셔닝하시오.


- mybatis_캐시
    - Local cache
        - MyBatis에는 Local cache라는게 있는데 이녀석은 끌 수없고 항상 활성화
        - SESSION과 STATEMENT라는 설정 범위를 갖고있고 SESSION이 기본값
        - STATEMENT와 SESSION의 차이는 캐시데이터의 생존범위

        - 따로 설정이 없다면 기본설정인 SESSION과 범위로 되어 있습니다.

    - SESSION
        SESSION을 적용했을때 cache의 정보의 생존범위는 session이 유지되는 순간까지 이다.
        즉 Transaction이 끝나거나(commit이나 rollback) 아니면 insert, update, delete 가 실행되면
        Local cache가 보유하고 있던 cache 정보는 폐기된다.

    - STATEMENT
        mapper에 정의된 액션( .. , ..) 하나까지 유지
        사실상 cache를 거의 사용하지 않는 것과 같은 효과이다.

    - Second level cache
        - Second level cache 는 Local cache 와는 다르게 비활성화 활성화가 가능
        - Second level cache를 활성화 하고 싶다면 mapper.xml에서 설정을 해줘야한다.

        - eviction: 캐시 알고리즘 속성으로 기본은 LRU(사용빈도가 낮은것)이고 그 외에 3가지가 있음. FIFO(선입선출).
        - flushInterval: 캐시 유지 설정1분 뒤 캐시 비움.(단, 특정 시각을 정하지는 못함)
        - size: 디폴트 값은 1024이며, 메모리 여부를 확인 후 사용해야 할 듯.
        - readOnly: 캐시 데이터를 읽기만 가능하게 할지 설정. (읽기/쓰기 모두 가능한 경우에는 반환된 캐시 데이터에 대한 변경이 가능하며, 캐시 복사본을 반환한다고 함)

        - 위에 선언을 해주고 사용할 statement에 select 안에 useCache 옵션을 True로 설정해주면 해당 Statement의 결과가 캐시된다.
            - Second level cache는 Session 범위 밖에서의 캐시사용 여부를 조정한다.
            - Local cache는 Statement 실행후 Commit이 되면 캐시를 지우는데 반해 Second level cache는 commit을 해도 캐시데이터가 살아있다.

        - mybatis cache는 이와같고 mybatis cache는 잘사용하지 않으며 DAO단의 캐시보단는 ehcache ,redis를 이용한 service단의 캐시를 고려하는게 좋은거 같다.


- mybatis # $ 차이점
    - #
        - 쿼리문을 작성할 때 #{}을 사용하는 경우 PreparedStatement를 생성하게 되는데 위의 ?에 파라미터가 바인딩되어 수행된다.
        - 파싱된 쿼리문은 재활용(캐싱)되기 때문에 효율적이다
        - 변수에 작은 따옴표(‘)가 자동으로 붙여 쿼리가 수행되기 때문에 '#{id}'와 같은 식으로 쿼리문을 작성하지 않아도 된다
        - 쿼리 주입을 예방 할 수 있어 보안상 유리하다.

    - $
        - 값이 넣어진 채로 쿼리문이 수행된다. 그렇기 때문에 파라미터의 값이 바뀔 때마다 항상 쿼리문 파싱을 진행해야 한다.
        - 성능상의 단점이 존재한다.
        - 쿼리 주입 예방이 되지 않아 보안상 좋지 않다.
        - 테이블,칼럼명을 파라미터로 전달 할 때 사용한다.

    - SQL Injection
        상황에 따라서 달라질 수 있겠으나 보안을 고려한다면 #{}를 사용해야 한다.

        <select id="selectUserFromTable" parameterType="Map" resultType="...">
            SELECT
                *
            FROM
                user
            WHERE
                id = '${id}' AND password = '${password}'
        </select>

        SELECT
            *
        FROM
            user
        WHERE
            id = 'admin' -- 'AND password = ''

        즉, where 절에서 비밀번호에 대한 조건은 사라지게 되어 id만 입력해도 관리자 계정 정보를 조회할 수 있게 된다.
        이처럼 ${}를 사용하게 되는 경우 #{}을 사용하는 것보다 SQL Injection에 취약하다.


- SQL Injection이 무엇인지 설명해주세요.
    - SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다.
    - SQL Injection을 방어 및 방지하기 위한 방법
        1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값) 인지 검증합니다.
        2. 저장 프로시저를 사용합니다.
            ※ 저장 프로시저란 사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상한다.


- SQL 쿼리를 짤 때 주의해야 하는 것들
    1. where 조건절 걸 때, index 순서에 맞게 거는게 좋다.
    2. SQL 쿼리에서 풀스캔이 있는지 없는지 확인한다.
        - SQL 실행 속도를 현저하게 비효율적으로 만드는 것이 풀스캔이다. 데이터가 많은 경우 out of memory가 발생하거나 DB 서버가 죽어버린다.
    3. Driving Table 을 정한 후에 사용해야 한다.
        - 데이터 수가 적은 테이블을 Driving Table 로 선정
    4  같은 내용의 조건이라면, GROUP BY 연산 시에는 가급적 HAVING보다는 WHERE 절을 사용하는 것이 좋습니다.
    5. SELECT DISTINCT, UNION DISTINCT와 같이 중복 값을 제거하는 연산은 최대한 사용하지 않아야 합니다.
    6. 3개 이상의 테이블을 INNER JOIN 할 때는, 크기가 가장 큰 테이블을 FROM 절에 배치하고, INNER JOIN 절에는 남은 테이블을 작은 순서대로 배치하는 것이 좋습니다
    7. IN 대신 EXISTS 사용
        - 서브 쿼리의 결과가 많으면 EXISTS가 나은 성능을 제공하며 그렇지 않으면 IN을 사용하는 것이 좋습니다.
        - EXISTS는 일치하는 항목이 발견되는 즉시 검색 프로세스를 종료하지만 IN은 모든 항목을 비교하기 때문입니다.
    8. ORDER BY 금지
        - RDBMS마다 다르지만 서브 쿼리(Sub Query)에서 Order By를 사용하는 경우 많은 비용이 발생합니다. 그러므로 서브 쿼리에서 Order By를 사용하지 않도록 합니다.
    9. WHERE문에 함수 사용 제한
        - COL1이라는 컬럼이 인덱스로 잡혀있는데 WHERE문에서 함수와 함께 사용되면 인덱스가 깨지므로 검색 속도가 느려집니다.
          인덱스로 잡혀있는 칼럼은 WHERE문 또는 JOIN에서 함수와 사용하는 것을 피해야 합니다.


- SQL 성능 향상 팁
    - index를 타는지 항상 체크하라.
    - select 쿼리문 작성시 필요한 칼럼(column)만 명시
    - where조건문의 왼쪽은 되도록 변형되지 않은 순수한 column만을 선언
    - JOIN을 사용하는 경우 INNER JOIN을 되도록 사용
    - 서브쿼리 사용시 불필요한 select 구문을 줄여라.

    -> 전반적인 성능향상을 꾀하려면 CPU, 메모리, I/O 의 밸런스를 맞추어야 한다. DB성능 튜닝은 이 세가지 자원에 걸리는 부하를 적절하게 분산시켜 비용대비 최적의 성능을 뽑아내는것이 핵심이다.

    * 일반적으로 대용량 테이블이라 하더라도 인덱스가 제대로 작동하고 있다면 검색 자체가 성능저하를 가져 오지는 않는다.
      다만, 복수의 JOIN과 같이 대량의 Nested Loop 가 발생한다면 엄청난 양의 I/O가 발생하고 이것이 RDB전체의 성능을 크게 저하시키는 원인이 되기도 한다.

    * HDD의 I/O 속도는 메모리에 비하여 많이 느리다. 10,000RPM HDD와 DDR3-2500 메모리의 성능 차이는 약 800배에 이른다.
      DBMS 같은 시스템에서는 효과적으로 버퍼(캐시)를 구현하여 I/O 발생을 최소화하도록 구현하고 있다. 그래서 히트(hit)율이 높을 때는,
      HDD에서 SSD로 교체해도 성능 향상 효과가 미미한 경우가 있다. 하지만 SSD를 사용하면 버퍼 크기를 작게 유지해도 되기 때문에 대용량의 메모리를 유지할 필요가 적어지기도 한다.


- 설정된 Index가 DML(Data Manipulation Language)에 미치는 영향
    Index는 주로 SELECT 쿼리에서는 성능이 잘 나온다. 하지만 INSERT/UPDATE/DELETE에서는 경우에 따라 다르다.

    UPDATE, DELETE
    인덱스로 설정된 컬럼에 대해 조건(WHERE)을 사용할 수도 있는 UPDATE, DELETE사용 시 조회에서는 성능이 크게 저하되지 않는다.
    ※ 여기서 수정/삭제할 데이터를 찾는 때의 속도가 빠르다는 것이지 수정이나 삭제 그 자체를 빠르게 처리한다는 뜻은 아니다.

    INSERT
    반면, INSERT의 경우에는 효율이 좋지 않다.
    새로운 데이터를 추가하면서 인덱스가 설정되어 있던 컬럼의 테이블이 수정되어야 하기 때문이다.


- Single Column Index와 Multi Column Index의 비교
    Multi Column Index의 장점
    ① 질의(SQL) 컬럼이 모두 조합 인덱스에 있는 경우, 물리적인 데이터 블록을 읽을 필요가 없다.
    (인덱스 테이블만 읽으면 된다.)

    Multi Column Index를 고려해야 하는 경우
    ① WHERE에 사용될 때 AND 연산자에 의해 자주 같이 질의되는 컬럼들인 경우.


- 트랜잭션 내에 외부 리소스 요청이 담기게 되면 어떤 문제가 발생할까?
    제어할 수 없는 영역인 외부 리소스에 대한 요청을 트랜잭션에서 분리하지 않으면 응답이 올 때까지 요청 스레드가 대기하게 된다.
    이때 요청에 데이터베이스 로직이 포함되면 커넥션도 함께 대기하게 된다.
    한정된 개수를 가진 커넥션을 빠르게 반납하지 않으면 병목 현상이 일어날 수 있다.
    이런 상황을 피하기 위해서는 트랜잭션이 활성화된 범위를 최소화해야한다. 이러한 개선 작업을 통해 불필요하게 낭비되는 서버 자원을 적절히 아낄 수 있다.


- [Database] 자연키(Natural key)와 대체키(Surrogate Key), PK(기본키)를 대체키로 설정해야 하는 이유
    https://mangkyu.tistory.com/287


- 디비에 insert,update 성능을 더 빠르게 개선하기 위해 어떤 방법이 있을까요

- DBMS / RDBMS

- 실행계획 보는법

- 왜 RDB를 선택한건지? nosql로 해도 되는거 아닌지?

- rdb랑 nosql의 차이점

- join의 종류에 대해 아는대로 말해주세요

- 파일시스템 vs db

- 힌트 사용 예제
    http://www.gurubee.net/lecture/2147

https://todayscoding.tistory.com/52