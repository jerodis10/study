- Deadlock
    - 발생 조건
        1. 상호배제
        2. 점유 대기
        3. 비선점
        4. 순환 대기
          => 네 가지 조건을 모두 만족하면 교착 상태가 발생

    - 해결 방법
        1. 교착 상태 예방
            - 위의 발생 중 하나 이상을 제거
            - 일반적으로 자원 사용 효율성이 떨어지고 비용이 많이 드는 방법

        2. 교착 상태 회피
            - 교착 상태 발생 가능성을 검사해서 발생 가능성이 있다면 사전에 회피하는 방식
                1. 자원 할당 그래프 알고리즘
                2. 은행원 알고리즘
            1. 프로세스가 자원 요청시, 자원을 할당한 후에도 안정 상태로 남아있는지 사전 검사
            2. 안정 상태라면 자원을 할당
            3. 불안정 상태라면 다른 프로세스가 자원을 해지할 때까지 대기
              => 자원을 요청할 때마다 시스템 상태를 검사하는 만큼 오버헤드가 큼. 은행원 알고리즘의 경우 전제 조건이 많음

        3. 교착 상태 탐지 및 회복
            - 교착 상태를 허용하지만 상태를 탐지하고 회복하는 방식
            - 알고리즘을 주기적으로 실행함으로써, 시스템에 발생한 Deadlock 을 체크하고 회복
                ex) 자원 할당 그래프 알고리즘의 경우 그래프 상에 교착 상태를 유발시키는 순환 사이클의 존재 유무를 체크
            - 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 회복
                1. 프로세스 종료
                    - 교착 상태의 프로세스를 모두 중지
                    - 교착 상태가 제거될 때까지 한 프로세스씩 중지
                2. 자원 선점
                    - 교착 상태가 제거될 때까지 프로세스가 점유한 자원을 선점해 다른 프로세스에게 할당

            - 회복 고려 사항
                - 희생자 선택
                - 후퇴 (Rollback)
                - 기아 상태 (Starvation)

        4. 교착 상태 무시
            - 교착 상태 자체를 무시하고, 특별한 조치를 취하지 않는 방법
            - 교착 상태의 발생 확률이 낮은 상황에서 주로 사용

- 데이터베이스 Lock
    - 데이터베이스 잠금이 왜 필요할까? - 동시성 제어
        - 동시성 제어
            - 트랜잭션들이 동시에 수행될 때, 일관성을 해치지 않도록 데이터 접근을 제어하는 DBMS 의 기능
              Lock 을 이용하여 동시성 제어

    - Lock 의 종류 - 낙관적, 비관적
        - 낙관적 잠금 (Optimistic Lock)
            - 데이터 경신 시 경합이 발생하지 않을 것이라고 보고 잠그는 기법
            - 데이터를 업데이트 시켜주기 전 버전을 다시 읽어온다. 처음에 읽어온 버전과 그 다음 읽어온 버전이 같다면 버전을 다시
              업데이트. 반면 다른 사용자는 뒤늦게 구매를 완료하고 버전을 다시 읽어온다. 이미 버전이 업데이트 되었으므로 버전이 달라서
              충돌이 발생하고 롤백을 시켜줌.
            - 동시 업데이트가 거의 없는 경우
        - 비관적 잠금 (Pessimistic Lock)
            - 동일한 데이터를 동시에 수정할 가능성이 높다고 보는 잠금
            - 데이터에 접근하기 전 Lock 을 걸어줌. 일련의 과정들을 거치고 Unlock 을 시켜줌. Lock 이 걸리고 Unlock 이 걸리는 동안
              다른 사용자는 무조건 대기해야함.
            - 동시 업데이트가 빈번한 경우, 롤백을 하기 힘든 외부 시스템과 연동한 경우

    - Pessimistic Lock 연산의 종류 - 공유, 베타
        - 공유 락 (shared lock)
            - read 연산 실행 가능, write 연산 실행 불가능
            - read 연산은 데이터에 영향을 안 미치므로 데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음
        - 베타 락 (exclusive lock)
            - read 연산과 write 연산을 모두 실행 가능
            - 베타 락 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 가짐

    - Lock 의 단위
        - 데이터베이스 / 파일 / 레코드 / 필드
        - 단위를 크게 가져간다면 구현이 단순하지만 병행성이 떨어지고, 단위를 작게 가져가면 구현이 복잡하지만 병행성이 높아짐
        - 락의 단위는 데이터베이스의 종류마다 다름

    - Lock 으로 발생할 수 있는 문제점 - 블로킹, 데드락
        - Blocking
            - Lock 들의 경합이 발생하여 특정세션이 작업을 진행하지 못하고 멈춰 선 상태
            - 데이터에 대해서 하나의 트랜잭션이 베타락을 걸면 다른 트랜잭션들은 어떠한 락도 걸지 못하고 대기해야하기 때문
            - 블로킹이 풀리는 시점은 트랜잭션이 커밋 혹은 롤백할 때
            - 해결 방안
                1. 트랜잭션을 짧게 정의
                2. 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절
        - DeadLock 교착 상태
            - 각 트랜잭션의 락들이 서로 맞물려 무한 대기하는 상태
            - 해결 방안
                1. 트랜잭션 진행 방향을 같은 방향으로 처리
                    -> 이렇게 하면 블로킹은 발생할 수 있지만, 데드락 발생 확률은 현저히 줄어듬.
                2. 트랜잭션 처리 속도를 최소화
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절

- 데이터베이스 INDEX
    - 인덱스란
        - 인덱스 기준이 하나도 잡혀 있지 않을 경우, 전체 데이터에서 순차적으로 확인하므로 매우 느리다.
          이를 인덱스를 통해 데이터를 빠르게 검색할 수 있도록 정렬해주는 것.
        - 인덱스가 적용된 대상을 where 절을 통해 검색. (where 절을 통해 검색하지 않으면 인덱스 사용 x)
        - 데이터베이스 테이블에 대한 검색 성능을 향상시키는 자료 구조이며 where 절 등을 통해 활용된다.
        - 인덱스 특징
            1. 인덱스는 항상 최신의 정렬 상태를 유지
            2. 인덱스도 하나의 데이터베이스 객체
            3. 데이터베이스 크기의 약 10% 정도의 저장공간 필요

    - 인덱스 알고리즘
        - 페이지: 데이터가 저장되는 단위 (16 Kbyte)
        - Full Table Scan
            - 순자척으로 접근
            - 접근 비용 감소
            - 사용
                1. 적용 가능한 인덱스가 없는 경우
                2. 인덱스 처리 범위가 넓은 경우
                3. 크기가 작은 테이블에 엑세스하는 경우
                -> 데이터베이스가 인덱스를 적용해도 성능상의 이점이 없다고 판단했을 때 Full Table Scan 적용
        - B-Tree (Balanced Tree)
            - Binary Search Tree
                - BST 는 이진탐색과 연결리스트의 장점이 합쳐져 만들어진 자료구조
                - 균형 있는 이진탐색트리 O(log n), 균형 없는 이진탐색트리 O(n)
            - Balanced Tree
                - 트리의 높이가 같음
                - 자식 노드를 2개 이상 가질 수 있음
                - 기본 데이터에비스 인덱스 구조
                https://www.youtube.com/watch?v=edpYzFgHbqs  5:13
    - 인덱스 종류
    - 인덱스 적용 기준
    - 실습
    - 인덱스 사용시 주의사항
