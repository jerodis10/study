- Deadlock
    - 발생 조건
        1. 상호배제
        2. 점유 대기
        3. 비선점
        4. 순환 대기
          => 네 가지 조건을 모두 만족하면 교착 상태가 발생

    - 해결 방법
        1. 교착 상태 예방
            - 위의 발생 중 하나 이상을 제거
            - 일반적으로 자원 사용 효율성이 떨어지고 비용이 많이 드는 방법

        2. 교착 상태 회피
            - 교착 상태 발생 가능성을 검사해서 발생 가능성이 있다면 사전에 회피하는 방식
                1. 자원 할당 그래프 알고리즘
                2. 은행원 알고리즘
            1. 프로세스가 자원 요청시, 자원을 할당한 후에도 안정 상태로 남아있는지 사전 검사
            2. 안정 상태라면 자원을 할당
            3. 불안정 상태라면 다른 프로세스가 자원을 해지할 때까지 대기
              => 자원을 요청할 때마다 시스템 상태를 검사하는 만큼 오버헤드가 큼. 은행원 알고리즘의 경우 전제 조건이 많음

        3. 교착 상태 탐지 및 회복
            - 교착 상태를 허용하지만 상태를 탐지하고 회복하는 방식
            - 알고리즘을 주기적으로 실행함으로써, 시스템에 발생한 Deadlock 을 체크하고 회복
                ex) 자원 할당 그래프 알고리즘의 경우 그래프 상에 교착 상태를 유발시키는 순환 사이클의 존재 유무를 체크
            - 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 회복
                1. 프로세스 종료
                    - 교착 상태의 프로세스를 모두 중지
                    - 교착 상태가 제거될 때까지 한 프로세스씩 중지
                2. 자원 선점
                    - 교착 상태가 제거될 때까지 프로세스가 점유한 자원을 선점해 다른 프로세스에게 할당

            - 회복 고려 사항
                - 희생자 선택
                - 후퇴 (Rollback)
                - 기아 상태 (Starvation)

        4. 교착 상태 무시
            - 교착 상태 자체를 무시하고, 특별한 조치를 취하지 않는 방법
            - 교착 상태의 발생 확률이 낮은 상황에서 주로 사용

- 데이터베이스 Lock
    - 데이터베이스 잠금이 왜 필요할까? - 동시성 제어
        - 동시성 제어
            - 트랜잭션들이 동시에 수행될 때, 일관성을 해치지 않도록 데이터 접근을 제어하는 DBMS 의 기능
              Lock 을 이용하여 동시성 제어

    - Lock 의 종류 - 낙관적, 비관적
        - 낙관적 잠금 (Optimistic Lock)
            - 데이터 경신 시 경합이 발생하지 않을 것이라고 보고 잠그는 기법
            - 데이터를 업데이트 시켜주기 전 버전을 다시 읽어온다. 처음에 읽어온 버전과 그 다음 읽어온 버전이 같다면 버전을 다시
              업데이트. 반면 다른 사용자는 뒤늦게 구매를 완료하고 버전을 다시 읽어온다. 이미 버전이 업데이트 되었으므로 버전이 달라서
              충돌이 발생하고 롤백을 시켜줌.
            - 동시 업데이트가 거의 없는 경우
        - 비관적 잠금 (Pessimistic Lock)
            - 동일한 데이터를 동시에 수정할 가능성이 높다고 보는 잠금
            - 데이터에 접근하기 전 Lock 을 걸어줌. 일련의 과정들을 거치고 Unlock 을 시켜줌. Lock 이 걸리고 Unlock 이 걸리는 동안
              다른 사용자는 무조건 대기해야함.
            - 동시 업데이트가 빈번한 경우, 롤백을 하기 힘든 외부 시스템과 연동한 경우

    - Pessimistic Lock 연산의 종류 - 공유, 베타
        - 공유 락 (shared lock)
            - read 연산 실행 가능, write 연산 실행 불가능
            - read 연산은 데이터에 영향을 안 미치므로 데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음
        - 베타 락 (exclusive lock)
            - read 연산과 write 연산을 모두 실행 가능
            - 베타 락 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 가짐

    - Lock 의 단위
        - 데이터베이스 / 파일 / 레코드 / 필드
        - 단위를 크게 가져간다면 구현이 단순하지만 병행성이 떨어지고, 단위를 작게 가져가면 구현이 복잡하지만 병행성이 높아짐
        - 락의 단위는 데이터베이스의 종류마다 다름

    - Lock 으로 발생할 수 있는 문제점 - 블로킹, 데드락
        - Blocking
            - Lock 들의 경합이 발생하여 특정세션이 작업을 진행하지 못하고 멈춰 선 상태
            - 데이터에 대해서 하나의 트랜잭션이 베타락을 걸면 다른 트랜잭션들은 어떠한 락도 걸지 못하고 대기해야하기 때문
            - 블로킹이 풀리는 시점은 트랜잭션이 커밋 혹은 롤백할 때
            - 해결 방안
                1. 트랜잭션을 짧게 정의
                2. 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절
        - DeadLock 교착 상태
            - 각 트랜잭션의 락들이 서로 맞물려 무한 대기하는 상태
            - 해결 방안
                1. 트랜잭션 진행 방향을 같은 방향으로 처리
                    -> 이렇게 하면 블로킹은 발생할 수 있지만, 데드락 발생 확률은 현저히 줄어듬.
                2. 트랜잭션 처리 속도를 최소화
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절

- 데이터베이스 INDEX
    - 인덱스란
        - 인덱스 기준이 하나도 잡혀 있지 않을 경우, 전체 데이터에서 순차적으로 확인하므로 매우 느리다.
          이를 인덱스를 통해 데이터를 빠르게 검색할 수 있도록 정렬해주는 것.
        - 인덱스가 적용된 대상을 where 절을 통해 검색. (where 절을 통해 검색하지 않으면 인덱스 사용 x)
        - 데이터베이스 테이블에 대한 검색 성능을 향상시키는 자료 구조이며 where 절 등을 통해 활용된다.
        - 인덱스 특징
            1. 인덱스는 항상 최신의 정렬 상태를 유지
            2. 인덱스도 하나의 데이터베이스 객체
            3. 데이터베이스 크기의 약 10% 정도의 저장공간 필요

    - 인덱스 알고리즘
        - 페이지: 데이터가 저장되는 단위 (16 Kbyte)
        - Full Table Scan
            - 순자척으로 접근
            - 접근 비용 감소
            - 사용
                1. 적용 가능한 인덱스가 없는 경우
                2. 인덱스 처리 범위가 넓은 경우
                3. 크기가 작은 테이블에 엑세스하는 경우
                -> 데이터베이스가 인덱스를 적용해도 성능상의 이점이 없다고 판단했을 때 Full Table Scan 적용
        - B-Tree (Balanced Tree)
            - Binary Search Tree
                - BST 는 이진탐색과 연결리스트의 장점이 합쳐져 만들어진 자료구조
                - 균형 있는 이진탐색트리 O(log n), 균형 없는 이진탐색트리 O(n)
            - Balanced Tree
                - 트리의 높이가 같음
                - 자식 노드를 2개 이상 가질 수 있음
                - 기본 데이터에비스 인덱스 구조
                - 루트 페이지: 자식 페에지 정보
                - 브랜치 페이지: 자식 페이지 정보
                - 리프 페이지
                    - 실제 데이터 페이지 (클러스터링 인덱스)
                    - 실제 데이터의 주소 페이지 (논-클러스터링 인덱스)
        - insert
            - 페이지 내부에서 작업될 경우 큰 부담은 없지만, 페이지가 꽉 찰 경우 데이터베이스는 비어 있는 페이지를 확보하고
              문제가 있는 페이지의 데이터를 공평하게 나누어 저장. 이는 데이터베이스에 부담이 되는 작업 (페이지 분할)
            - 페이지 분할
                - 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생
                - DB 가 느려지고 성능에 영향을 준다.
        - delete
            - 인덱스의 데이터를 실제로 지우지 않고 사용안함 표시를 한다.
        - update
            - delete (기존 값 사용안함 표시)
            - insert (변경된 값 삽입)
        -> update, delete 의 경우도 where 절을 사용할 때 빨라지지 않을까?
            - where 절로 처리할 대상을 찾기 위한 조회 성능은 향상된다.
            - 사용하지 않는 인덱스가 사용되었다면 불필요한 처리량 증가
            - 사용안함 표시로 페이지 낭비 및 인덱스 조각화 심해짐
            => 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다.

    - 인덱스 종류
        - 클러스터: 무리를 이루다.
        - 클러스터링 인덱스
            - 실제 데이터와 같은 무리의 인덱스
            - 실제 데이터가 정렬된 사전과 같은 역할
            - 특징
                1. 실제 데이터 자체가 정렬
                2. 테이블당 1개만 존재 가능
                3. 리프 페이지가 데이터 페이지
                4. 아래의 제약조건시 자동 생성
                    - primary key (우선 순위)
                    - unique + not null
        - 논-클러스터링 인덱스 (보조 인덱스, 세컨더리 인덱스)
            - 실제 데이터와 다른 무리의 별도의 인덱스
            - 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 같은 역할
            - 특징
                1. 실제 데이터 페이지는 그대로
                2. 별도의 인덱스 페이지 생성 -> 추가 공간 필요
                3. 테이블당 여러 개 존재
                4. 리프 페이지에 실제 데이터 페이지 주소를 담고 있음
                5. unique 제약조건 적용시 자동 생성
                6. 직접 index 생성시 논-클러스터링 인덱스 생성 (unique index, index)

        - 클러스터링 + 논-클러스터링 인덱스
            - 클러스터링 인덱스 페이지가 존재하고, 논-클러스터링 인덱스 페이지에는 데이터 페이지의 주소가 존재해서 데이터를 조회?
              하지만, 데이터 페이지의 주소값이 아닌 클러스터링 인덱스가 적용된 칼럼의 실제값이 들어있다.
            - name 인덱스 페이지에서 해당 name 을 찾고 그 값을 통해 id 인덱스 페이지에서 탐색
              (name 칼럼의 논-클러스터링 인덱스 페이지, id 칼럼의 클러스트렁 인덱스 페이지 구조 예시)
            - 만약 논-클러스터링 인덱스 페이지에 데이터 페이지의 주소값이 들어있게 되면, 데이터가 추가되거나 삭제될 때마다
              인덱스 페이지들의 주소들을 계속해서 변경해야 하는 영향을 주게 된다. 따라서 클러스터링 인덱스가 적용된 칼럼의 실제값이
              들어있으면 id 가 직접 변경되지 않는 한 인덱스 페이지에 영향을 주지 않도록 구성되어 있다.

    - 인덱스 적용 기준
        - 카디널리티: 그룹 내 요소의 개수
        - 어떤 칼럼에 인덱스를 적용해야 할까?
            1. 카디널리티가 높은 (중복도가 낮은) 칼럼
            2. where, join, order by 절에 자주 사용되는 칼럼
                - 인덱스는 추가 공간이 필요하다.
                - 조건 절이 없다면 인덱스가 사용되지 않는다.
            3. insert, update, delete 가 자주 발생하지 않는 칼럼 -> 성능 저하에 영향을 줄 수 있음
            4. 규모가 작지 않은 테이블

    - 인덱스 사용시 주의사항
        1. 잘 활용되지 않는 인덱스는 과감히 제거하자
            - where 절에 사용되더라도 자주 사용해야 가치가 있다.
            - 불필요한 인덱스로 성능저하가 발생할 수 있다.
        2. 데이터 중복도가 높은 칼럼은 인덱스 효과가 적다.
        3. 자주 사용되더라도 insert, update, delete 가 자주 일어나는지 고려해야 한다.
            - 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기 비율은 2:8 또는 1:9 이다.
            - 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법이다.
