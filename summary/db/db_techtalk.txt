- Deadlock
    - 발생 조건
        1. 상호배제
        2. 점유 대기
        3. 비선점
        4. 순환 대기
          => 네 가지 조건을 모두 만족하면 교착 상태가 발생

    - 해결 방법
        1. 교착 상태 예방
            - 위의 발생 중 하나 이상을 제거
            - 일반적으로 자원 사용 효율성이 떨어지고 비용이 많이 드는 방법

        2. 교착 상태 회피
            - 교착 상태 발생 가능성을 검사해서 발생 가능성이 있다면 사전에 회피하는 방식
                1. 자원 할당 그래프 알고리즘
                2. 은행원 알고리즘
            1. 프로세스가 자원 요청시, 자원을 할당한 후에도 안정 상태로 남아있는지 사전 검사
            2. 안정 상태라면 자원을 할당
            3. 불안정 상태라면 다른 프로세스가 자원을 해지할 때까지 대기
              => 자원을 요청할 때마다 시스템 상태를 검사하는 만큼 오버헤드가 큼. 은행원 알고리즘의 경우 전제 조건이 많음

        3. 교착 상태 탐지 및 회복
            - 교착 상태를 허용하지만 상태를 탐지하고 회복하는 방식
            - 알고리즘을 주기적으로 실행함으로써, 시스템에 발생한 Deadlock 을 체크하고 회복
                ex) 자원 할당 그래프 알고리즘의 경우 그래프 상에 교착 상태를 유발시키는 순환 사이클의 존재 유무를 체크
            - 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 회복
                1. 프로세스 종료
                    - 교착 상태의 프로세스를 모두 중지
                    - 교착 상태가 제거될 때까지 한 프로세스씩 중지
                2. 자원 선점
                    - 교착 상태가 제거될 때까지 프로세스가 점유한 자원을 선점해 다른 프로세스에게 할당

            - 회복 고려 사항
                - 희생자 선택
                - 후퇴 (Rollback)
                - 기아 상태 (Starvation)

        4. 교착 상태 무시
            - 교착 상태 자체를 무시하고, 특별한 조치를 취하지 않는 방법
            - 교착 상태의 발생 확률이 낮은 상황에서 주로 사용

- 데이터베이스 Lock
    - 데이터베이스 잠금이 왜 필요할까? - 동시성 제어
        - 동시성 제어
            - 트랜잭션들이 동시에 수행될 때, 일관성을 해치지 않도록 데이터 접근을 제어하는 DBMS 의 기능
              Lock 을 이용하여 동시성 제어
            - 트랜잭션이 시작되면 이용하고 있는 (ROW, TABLE)은 트랜잭션이 끝날 때까지 점유

    - Lock 의 종류 - 낙관적, 비관적
        - 낙관적 잠금 (Optimistic Lock)
            - 데이터 경신 시 경합이 발생하지 않을 것이라고 보고 잠그는 기법
            - 데이터를 업데이트 시켜주기 전 버전을 다시 읽어온다. 처음에 읽어온 버전과 그 다음 읽어온 버전이 같다면 버전을 다시
              업데이트. 반면 다른 사용자는 뒤늦게 구매를 완료하고 버전을 다시 읽어온다. 이미 버전이 업데이트 되었으므로 버전이 달라서
              충돌이 발생하고 롤백을 시켜줌.
            - 동시 업데이트가 거의 없는 경우
        - 비관적 잠금 (Pessimistic Lock)
            - 동일한 데이터를 동시에 수정할 가능성이 높다고 보는 잠금
            - 데이터에 접근하기 전 Lock 을 걸어줌. 일련의 과정들을 거치고 Unlock 을 시켜줌. Lock 이 걸리고 Unlock 이 걸리는 동안
              다른 사용자는 무조건 대기해야함.
            - 동시 업데이트가 빈번한 경우, 롤백을 하기 힘든 외부 시스템과 연동한 경우

    - Pessimistic Lock 연산의 종류 - 공유, 베타
        - 공유 락 (shared lock)
            - read 연산 실행 가능, write 연산 실행 불가능
            - read 연산은 데이터에 영향을 안 미치므로 데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음
        - 베타 락 (exclusive lock)
            - read 연산과 write 연산을 모두 실행 가능
            - 베타 락 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 가짐

    - Lock 의 단위
        - 데이터베이스 / 파일 / 레코드 / 필드
        - 단위를 크게 가져간다면 구현이 단순하지만 병행성이 떨어지고, 단위를 작게 가져가면 구현이 복잡하지만 병행성이 높아짐
        - 락의 단위는 데이터베이스의 종류마다 다름

    - Lock 으로 발생할 수 있는 문제점 - 블로킹, 데드락
        - Blocking
            - Lock 들의 경합이 발생하여 특정세션이 작업을 진행하지 못하고 멈춰 선 상태
            - 데이터에 대해서 하나의 트랜잭션이 베타락을 걸면 다른 트랜잭션들은 어떠한 락도 걸지 못하고 대기해야하기 때문
            - 블로킹이 풀리는 시점은 트랜잭션이 커밋 혹은 롤백할 때
            - 해결 방안
                1. 트랜잭션을 짧게 정의
                2. 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절
        - DeadLock 교착 상태
            - 각 트랜잭션의 락들이 서로 맞물려 무한 대기하는 상태
            - 해결 방안
                1. 트랜잭션 진행 방향을 같은 방향으로 처리
                    -> 이렇게 하면 블로킹은 발생할 수 있지만, 데드락 발생 확률은 현저히 줄어듬.
                2. 트랜잭션 처리 속도를 최소화
                3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절

- 데이터베이스 INDEX
    - 인덱스란
        - 인덱스 기준이 하나도 잡혀 있지 않을 경우, 전체 데이터에서 순차적으로 확인하므로 매우 느리다.
          이를 인덱스를 통해 데이터를 빠르게 검색할 수 있도록 정렬해주는 것.
        - 인덱스가 적용된 대상을 where 절을 통해 검색. (where 절을 통해 검색하지 않으면 인덱스 사용 x)
        - 데이터베이스 테이블에 대한 검색 성능을 향상시키는 자료 구조이며 where 절 등을 통해 활용된다.
        - 인덱스 특징
            1. 인덱스는 항상 최신의 정렬 상태를 유지
            2. 인덱스도 하나의 데이터베이스 객체
            3. 데이터베이스 크기의 약 10% 정도의 저장공간 필요

    - 인덱스 알고리즘
        - 페이지: 데이터가 저장되는 단위 (16 Kbyte)
        - Full Table Scan
            - 순자척으로 접근
            - 접근 비용 감소
            - 사용
                1. 적용 가능한 인덱스가 없는 경우
                2. 인덱스 처리 범위가 넓은 경우
                3. 크기가 작은 테이블에 엑세스하는 경우
                -> 데이터베이스가 인덱스를 적용해도 성능상의 이점이 없다고 판단했을 때 Full Table Scan 적용
        - B-Tree (Balanced Tree)
            - Binary Search Tree
                - BST 는 이진탐색과 연결리스트의 장점이 합쳐져 만들어진 자료구조
                - 균형 있는 이진탐색트리 O(log n), 균형 없는 이진탐색트리 O(n)

                - 트리의 노드가 한 방향으로 쏠리지 않게 재정렬을 통해, 각 노드 수의 밸런스를 유지하는 트리 형태의 자료구조이다.
                - 노드가 균형 있게 구성되어 있어서, 최악의 경우이더라도 일관된 탐색 시간(O(logN))을 가질 수 있다.
                - 재정렬을 해야 하는 작업으로 인해, 노드를 삽입 하거나 삭제 할 때 일반적인 트리보다 성능이 떨어진다.
            - Balanced Tree
                - 트리의 높이가 같음
                - 자식 노드를 2개 이상 가질 수 있음
                - 기본 데이터에비스 인덱스 구조
                - 루트 페이지: 자식 페에지 정보
                - 브랜치 페이지: 자식 페이지 정보
                - 리프 페이지
                    - 실제 데이터 페이지 (클러스터링 인덱스)
                    - 실제 데이터의 주소 페이지 (논-클러스터링 인덱스)
        - insert
            - 페이지 내부에서 작업될 경우 큰 부담은 없지만, 페이지가 꽉 찰 경우 데이터베이스는 비어 있는 페이지를 확보하고
              문제가 있는 페이지의 데이터를 공평하게 나누어 저장. 이는 데이터베이스에 부담이 되는 작업 (페이지 분할)
            - 페이지 분할
                - 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생
                - DB 가 느려지고 성능에 영향을 준다.
        - delete
            - 인덱스의 데이터를 실제로 지우지 않고 사용안함 표시를 한다.
        - update
            - delete (기존 값 사용안함 표시)
            - insert (변경된 값 삽입)
        -> update, delete 의 경우도 where 절을 사용할 때 빨라지지 않을까?
            - where 절로 처리할 대상을 찾기 위한 조회 성능은 향상된다.
            - 사용하지 않는 인덱스가 사용되었다면 불필요한 처리량 증가
            - 사용안함 표시로 페이지 낭비 및 인덱스 조각화 심해짐
            => 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다.

    - 인덱스 종류
        - 클러스터: 무리를 이루다.
        - 클러스터링 인덱스
            - 실제 데이터와 같은 무리의 인덱스
            - 실제 데이터가 정렬된 사전과 같은 역할
            - 특징
                1. 실제 데이터 자체가 정렬
                2. 테이블당 1개만 존재 가능
                3. 리프 페이지가 데이터 페이지
                4. 아래의 제약조건시 자동 생성
                    - primary key (우선 순위)
                    - unique + not null
        - 논-클러스터링 인덱스 (보조 인덱스, 세컨더리 인덱스)
            - 실제 데이터와 다른 무리의 별도의 인덱스
            - 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 같은 역할
            - 특징
                1. 실제 데이터 페이지는 그대로
                2. 별도의 인덱스 페이지 생성 -> 추가 공간 필요
                3. 테이블당 여러 개 존재
                4. 리프 페이지에 실제 데이터 페이지 주소를 담고 있음
                5. unique 제약조건 적용시 자동 생성
                6. 직접 index 생성시 논-클러스터링 인덱스 생성 (unique index, index)

        - 클러스터링 + 논-클러스터링 인덱스
            - 클러스터링 인덱스 페이지가 존재하고, 논-클러스터링 인덱스 페이지에는 데이터 페이지의 주소가 존재해서 데이터를 조회?
              하지만, 데이터 페이지의 주소값이 아닌 클러스터링 인덱스가 적용된 칼럼의 실제값이 들어있다.
            - name 인덱스 페이지에서 해당 name 을 찾고 그 값을 통해 id 인덱스 페이지에서 탐색
              (name 칼럼의 논-클러스터링 인덱스 페이지, id 칼럼의 클러스트렁 인덱스 페이지 구조 예시)
            - 만약 논-클러스터링 인덱스 페이지에 데이터 페이지의 주소값이 들어있게 되면, 데이터가 추가되거나 삭제될 때마다
              인덱스 페이지들의 주소들을 계속해서 변경해야 하는 영향을 주게 된다. 따라서 클러스터링 인덱스가 적용된 칼럼의 실제값이
              들어있으면 id 가 직접 변경되지 않는 한 인덱스 페이지에 영향을 주지 않도록 구성되어 있다.

    - 인덱스 적용 기준
        - 카디널리티: 그룹 내 요소의 개수
        - 어떤 칼럼에 인덱스를 적용해야 할까?
            1. 카디널리티가 높은 (중복도가 낮은) 칼럼
            2. where, join, order by 절에 자주 사용되는 칼럼
                - 인덱스는 추가 공간이 필요하다.
                - 조건 절이 없다면 인덱스가 사용되지 않는다.
            3. insert, update, delete 가 자주 발생하지 않는 칼럼 -> 성능 저하에 영향을 줄 수 있음
            4. 규모가 작지 않은 테이블

    - 인덱스 사용시 주의사항
        1. 잘 활용되지 않는 인덱스는 과감히 제거하자
            - where 절에 사용되더라도 자주 사용해야 가치가 있다.
            - 불필요한 인덱스로 성능저하가 발생할 수 있다.
        2. 데이터 중복도가 높은 칼럼은 인덱스 효과가 적다.
        3. 자주 사용되더라도 insert, update, delete 가 자주 일어나는지 고려해야 한다.
            - 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기 비율은 2:8 또는 1:9 이다.
            - 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법이다.

    - 인덱스 작동 원리
        - 일반적으로 B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고
          최종적으로 리프 노드까지 찾아 들어간다. 그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

    - 실제 데이터베이스에서 사용하는 B-Tree 구조 (https://steady-coding.tistory.com/546)
        - 루트 노드와 브랜치 노드는 자식 노드의 주소를 가리키지만, 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소값을 가리킨다.
          인덱스와 실제 데이터가 저장된 데이터는 따로 관리한다.
        - 테이블에 데이터를 삽입만 하면 정렬된 것처럼 보이지만, 중간에 삭제 과정이 일어난다면 빈 공간에 데이터를 삽입하므로 임의의 순서가 됨
        - 예외적으로 InnoDB 테이블에서 레코드는 PK 기준으로 정렬되어 저장된다.

    - B-Tree 인덱스 사용에 영향을 미치는 요소
        - 인덱스 키 값의 크기
            - 키 값이 클수록 디스크 IO 횟수가 많아져서 성능이 떨어진다. -> 인덱스의 키 값은 작을수록 유리
        - B-Tree 깊이
            - 인덱스 키 값의 크기가 클수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지므로 B-Tree 깊이가 깊어진다.
              깊이가 깊어진다는 것은 디스크 IO 횟수가 많아진다는 것.
        - 선택도 (기수성)
            - 인덱스 키 값 가운데 유니크한 값의 수를 의미
            - 전체 인덱스 키 값이 100개고, 유니크한 값의 수가 10개라면 기수성은 10이다.
            - 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
        -> 일반적으로 DBMS 의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도
           비용이 드는 작업. 즉, 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 사용하지 않고
           일반 테이블 검색하는 것이 좋다.

    - B-Tree 인덱스를 통한 데이터 읽기
        - 인덱스 레인지 스캔
            - 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
            - 검색하려는 값의 수나 검색 결과 레코드 건수와 관계 없이 레인지 스캔이라고 부른다.
            - 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
            - B-tree 인덱스에서 루트 노드와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로 인덱스를 읽어 나간다.
            - 리프 노드에서 저장된 레코드 주소로 데이터 파일의 레코드를 읽어 오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 발생한다.
            - 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%를 넘으면 순차 I/O를 사용한 테이블 풀 스캔이 낫다고 하는 것이다.
        - 인덱스 풀 스캔
            - 인덱스의 처음부터 끝까지 모두 읽는 방식
            - 쿼리의 조건절에 사용된 칼럼이 첫 번째 칼럼이 아닌 경우 사용된다.
              ex) 인덱스 (a,b,c) 칼럼의 순서로 만들어져 있지만, 쿼리의 조건절은 b 칼럼이나 c 칼럼으로 검색
            - 루트 노드의 첫 번째 인덱스 레코드와 이어진 브랜치 노드를 거쳐 리프 노드로 이동한다.
            - 해당 리프 노드의 첫 번째 페이지의 인덱스 레코드 방향부터 아래로 탐색한다.
            - 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 작은 경우가 많으므로 풀 테이블 스캔보다 적은 IO 로 쿼리를 처리할 수 있다.
        - 루스 인덱스 스캔
            - 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
            - 인덱스 레인지 스캔과 비슷하게 동작하지만 중간마다 필요하지 않은 키 값은 무시한다.
            - 일반적으로 group by 또는 max 등의 함수에 대해 최적화할 때 사용한다.
            ex) select dept_no, MIN(emp_no)
                from dept_emp
                where dept_no between 'doo2' and 'd004'
                group by dept_no;

                dept_emp 테이블은 dept_no와 emp_no 2개의 컬럼으로 인덱스를 구성하고 있다고 가정하며, 이 인덱스는 (dept_no, emp_no)를
                기준으로 정렬이 되어 있다. 즉 특정 dept_no 그룹 별로 처음에 있는 emp_no만 읽으면 된다. 즉, 인덱스에서 where 조건을
                만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있으므로 중간 중간 조건에 맞지 않으면 건너 뛴다.

    - 다중 컬럼 인덱스
        - 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라고 한다.
        - 다중 컬럼 인덱스에서 중요한 것은 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다는 것이다.
          즉, 두 번째 컬럼은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다.
        - 따라서 다중 컬럼 인덱스에서는 컬럼의 위치(순서)가 상당히 중요하며 신중하게 결정해야 한다.
        - = 조건과 같이 개수가 적은 데이터를 조회하는 컬럼을 다중 컬럼 인덱스 앞 쪽에 설정하고,
          범위 검색과 같이 개수가 많은 데이터를 조회하는 컬럼을 다중 컬럼 인덱스 뒤족에 설정해야 한다.
        - 단일 컬럼 인덱스보다 더 비효율적으로 Insert/Update/Delete 를 수행하므로 가급적 업데이트가 안 되는 값을 선정해서 사용하는 것이 좋다.
        - 데이터를 조회할 때 단일 인덱스를 여러 개를 사용해야 하는 경우가 많다면 다중 컬럼 인덱스를 고려해 본다.

        -> 데이터를 조회할 때 단일 인덱스를 여러 개를 사용해야 하는 경우가 많다면 다중 컬럼 인덱스를 고려해 본다.
          예를 들어 A, B 컬럼을 바탕으로 데이터 탐색을 자주 할 경우 A, B에 단일 인덱스에 걸려 있는 상태에서 조회하는 성능보다 A, B에
          다중 컬럼 인덱스가 걸려 있는 경우에 데이터 액세스가 줄어들어 성능이 더 좋기 때문이다.
        -> 다중 컬럼 인덱스에서 중요한 것은 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다는 것이다. 즉, 두 번째 컬럼은
          첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다. 그래서 컬럼의 순서를 신중하게 결정해야 한다. 가령, = 조건과 같이 개수가 적은
          데이터를 조회하는 컬럼을 다중 컬럼 인덱스 앞 쪽에 설정하고, 범위 검색과 같이 개수가 많은 데이터를 조회하는 컬럼을
          다중 컬럼 인덱스 뒤쪽에 설정하는 것이 좋다.
        -> 단일 컬럼 인덱스보다 더 비효율적으로 Insert/Update/Delete 를 수행하므로 가급적 업데이트가 안 되는 값을 선정해서 사용하는 것이 좋다.


- redis
    - redis 개요
        - Remote dictionary server
           외부    hashMap    서버
        - Database, Cache, Message broker
        - in-memory Data Structure Store
        - Supports rich data structure

    - Cache 개념
        - 나중의 요청에 대한 결과를 미리 저장했다가 빠르게 사용하는 것
        - Memory Hierarchy
            - CPU Register
            - CPU Cache
                ex) 12MB Cache memory(SRAM) - 빠르고 비싸고 용량이 작다
            - Main Memory (DRAM)
                ex) 16GB DRAM - 적당히 빠르고 적당히 비싸고 적당이 용량이 크다, 휘발성
            - Storage (SSD, HDD)
                ex) 512GB SSD - 비교적 느리고 저렴하고 용량이 엄청 크다, 비휘발성
        -> in-memory Database (Cache) - Database 보다 더 빠른 Memory 에 더 자주 접근하고 덜 자주 바뀌는 데이터를 저장하자

    - redis 자료구조
        - 서버가 여러대인 경우 Consistency 의 문제 발생
        - 멀티 스레드 환경에서 Race condition
            - Race condition 이란 여러 개의 스레드가 경합하는 것. 컨텍스트 스위칭에 따라 원하지 않는 결과가 발생할 수 있다.
            - 레디스는 기본적으로 싱글 스레드
            - 레디스 자료구조는 Atomic. Critical Section 에 대한 동기화를 제공
                (Critical Section -> 동시에 여러 프로세스가 접근하면 안되는 영역)
            - 서로 다른 Transaction Read/Write 를 동기화

        - 어디에 쓰이나
            - 여러 서버에서 같은 데이터를 공유할 때
            - Single Server 라면? Atomic 자료구조 & Cache

    - redis 주의사항
        - Single Thread 서버이므로 시간 복잡도를 고려해야한다.
            - 레디스는 네트워크로부터 요청을 받아서 명령어를 처리하는 데 이런 커맨드를 형성하고 처리하는 과정이 싱글 스레디 이기 때문에
              커맨드가 오랜 시간이 걸리는 경우 나머지 요청들이 더이상 받아지지 않고 서버가 다운되는 문제가 발생할 수 있다.
              그래서 싱글 스레드이기 때문에 처리가 빨라야 한다. 전체 데이터를 다루는 시간 복잡도를 가진
              O(N) 의 명령어는 주의해서 사용. (KEYS, Flush, GetAll 연산 등)
        - in-memory 특성상 메모리 파편화, 가상 메모리 등의 이해가 필요하다.
        - 레디스가 왜 Single Thread 로 동작하느냐?
            - Event Driven (비동기)
            - IO-bound Process
            - Context Switching 의 효율이 적다
            - Single Threaded
        - 메모리 관리
            - 메모리 파편화
            - 가상메모리 Swap
            - Replication - Fork

    - 그외..
        - 레디스를 저장소처럼 -> Redis Persistent, RDB, AOF
        - 레디스의 메모리는 제한되어 있기 때문에 주기적으로 Scale out, Back up 해야함 -> Redis Cluster
        - 부하 분산 -> Constant Hashing
        - Data Grid -> Spring Gemfire, Hazlecast
          (데이터베이스를 사용하지 않고 인메모리 db 만 사용하는 방식)

- 트랜잭션 매커니즘
    1. update accounts SET balance = balance - 10000 where user = '구매자' 쿼리 실행
    2. 업데이트에 필요한 데이터를 데이터 캐시에 요청하는데, 데이터 캐시에 해당 데이터가 없다.
    3. 데이터 파일에서 데이터를 가져와야 한다.
    4. 그리고 데이터 캐시에 필요한 데이터가 로드된다.
    5. 데이터가 로드된 후, 업데이트를 하면 되는데 그 전에 로그 캐시에 로그를 기록해야 한다.
    6. ReDo 로그와 UnDo 로그에 기록한다.
        - ReDo 로그: 변경 후의 값을 기록
        - UnDo 로그: 변경 전의 값을 기록
    7. 로그 기록 후 데이터 캐시에 있는 값을 변경하면 된다.
    8. update accounts set balance = balance + 10000 where user = '판매자' 쿼리 실행
    9. 판매자의 데이터가 없으므로 데이터 파일에서 데이터 캐시로 로드
    10. ReDo 로그와 UnDo 로그에 기록한다.
    11. 데이터 캐시의 데이터 업데이트
    12. 트랜잭션의 한 단위가 끝났다.

    - 데이터 롤백 시 UnDO 로그를 통해 롤백한다. UnDo 를 통해 역순으로 기록을 하게 되면 데이터가 이전 상태로 원복
    - 예상치 못한 오류 발생 시 ReDo 로그와 UnDO 로그를 통해 복구한다.
        - ReDo 로그를 순차적으로 실행해서 데이터들을 다시 일관성 있게 만들어줌.
          커밋된 것을 다시 실행
        - UnDo 로그를 역순으로 실행하여 다시 커밋되지 않은 것들을 다시 이전 상태로 돌려준다.
          트랜잭션은 시작瑩嗤 커밋되지 않은 연산을 취소

    - Transaction 관리를 위한 DBMS 전략
        - DBMS 구조
            - Query Processor(질의 처리기), Storage System(저장 시스템)
            - 입출력 단위: 고정 길이의 page 단위로 disk 에 읽거나 쓴다.
            - 저장 공간: 비휘발성 저장 장치인 disk 에 저장, 일부분을 Main Memory 에 저장

        - Buffer 관리 정책
            - DBMS 의 Storage System 에 속하는 모듈 중 하나로, Main Memory 에 유지하는 페이지를 관리하는 모듈
            - Buffer 관리 정책에 따라, UnDo 복구와 ReDo 복구가 요구되거나 그렇지 않게 되므로 transaction 관리에 매우 중요한 결정을 가져옴

        - UnDo
            - 수정된 페이지들이 Buffer 교체 알고리즘에 따라서 디스크에 출력될 수 있음.
              Buffer 교체는 transaction 과는 무관하게 buffer 의 상태에 따라서 결정됨
              따라서 정상적으로 종료되지 않은 transaction 이 변경한 페이지들은 원상 복구되어야 하는데 이 복구를 undo 라고 함

            - 2 개의 정책 (수정된 페이지를 디스크에 쓰는 시점으로 분류)
                - steal: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
                    - 대부분의 DBMS 가 채택하는 Buffer 관리 정책
                    - UnDo logging 과 복구를 필요로 함
                - no-steal: 수정된 페이지들을 EOT(End Of Transaction)까지는 버퍼에 유지하는 정책
                    - UnDo 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함

        - ReDo
            - 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업
            - Buffer 관리 정책에 영향을 받음 (트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지를 디스크에 쓸것인가 아닌가로 기준)
                - FORCE: 수정했던 모든 페이지를 트랜잭션 커밋 시점에 disk 에 반영
                    - 트랜잭션이 커밋되었을 때 수정된 페이지들이 disk 상에 반영되므로 redo 필요없음
                - no-FORCE: 커밋 시점에 반영하지 않는 정책
                    - 트랜잭션이 disk 상의 db 에 반영되지 않을 수 있기에 redo 복구가 필요 (대부분의 DBMS 정책)