- 인덱스를 이용한 소트 연산 생략
    - 인덱스 순으로 이미 정렬된 상태로 order by를 했다. 이것은 order by를 생략할 수 있다.
    - 만약 이렇게 인덱스가 구성되어있지 않다면 SORT ORDER BY 연산이 실행계획에 추가된다.
    - 조건절 뿐만 아니라 ORDER BY절이나 SELECT-LIST 에서 컬럼을 가공하여 인덱스를 정상적으로 못 사용하는 경우가 있다.
        - SELECT-LIST 에서 컬럼 가공
            select NVL(MAX(TO_NUMBER(변경순번)), 0)
            from 상태변경이력
            where 장비번호 = 'C'
                and 변경일자 = '20180316'

            위와 같이 ‘변경순번’의 값을 숫자로 바꾸면 인덱스를 사용할 수 없다.
            왜냐면 인덱스는 문자열 기준으로 정렬되어 있는데 숫자값으로 바꾸었기 때문이다.

        - 자동 형변환
            select * from 고객 where 생년월일 = 19920920

            -- 이걸 옵티마이저가 이렇게 바꿈
            select * from 고객 where TO_NUMBER(생년월일) = 19920920

            - DBMS마다 다른데 오라클은 자동 형변환 하는 방식을 채택한다.
            - 형변환 우선순위
                - 오라클에서 숫자형과 문자형이 만나면 숫자형이 이긴다.
                - 날짜형과 문자형이 만나면 날짜형이 이긴다.
                - 근데 LIKE가 출동하면 문자형이 이긴다.


- 인덱스를 리빌드하는 이유
    인덱스 파일은 생성 후 insert, update, delete 등을 반복하다보면 성능이 저하됩니다. 생성된 인덱스는
    트리구조를 가집니다. 삽입,수정,삭제등이 오랫동안 일어나다보면 트리의 한쪽이 무거워져 전체적으로 트리의 깊이가
    깊어집니다. 이러한 현상으로 인해 인덱스의 검색속도가 떨어지므로 주기적으로 리빌딩하는 작업을 거치는것이 좋습니다.

    SELECT I.TABLESPACE_NAME,I.TABLE_NAME,I.INDEX_NAME, I.BLEVEL,
           DECODE(SIGN(NVL(I.BLEVEL,99)-3),1,DECODE(NVL(I.BLEVEL,99),99,'?','Rebuild'),'Check') CNF
    FROM   USER_INDEXES I
    WHERE   I.BLEVEL > 4
    ORDER BY I.BLEVEL DESC

    해당쿼리는 index 트리의 깊이가 4이상인 index  를 조회하는 쿼리입니다.
    해당 쿼리문을 실행하여 검색되는 index 가 있다면 리빌딩을 하는것이 좋습니다.


- 인덱스(Index)를 남발하지 말아야 하는 이유
    개발을 진행할 때에 대개 개발서버와 운영서버를 나누어서 관리합니다. 대부분 개발서버에서 개발을 할때에는 적은량의
    데이터를 가지고 로직검사를 하며 로직검사에 통과한 코드들이 운영서버에 업데이트가 되죠. 하지만 개발서버에는 잘 동작하던
    로직들이 운영서버의 많은량의 데이터들을 처리하다보면 성능이슈가 많이 발생합니다. 그 성능이슈의 주요원인은
    바로 데이터베이스에 있습니다. 데이터베이스 관리자는 성능문제가 발생하면 가장 빨리 생각하는
    해결책이 인덱스 추가 생성입니다.

    하지만 문제를 그저 쉽게 해결하기 위해 쿼리 속도 문제가 날때마다 인덱스를 추가하는것은 바람직하지 못합니다.
    성능 이슈가 나서 인덱스를 만들고 또 다른 SQL 문에서 성능이슈가 발생하여 또 인덱스를 만들었다고 합시다.
    이렇게 문제가 발생할때마다 인덱스를 생성하면서 인덱스가 계속 추가되면 생성된 인덱스를 참조하는 하나의 쿼리문을
    빠르게는 만들 수 있지만 전체적인 데이터베이스의 성능 부하를 초래합니다. 그렇기에 인덱스를 생성하는것 보다는
    SQL 문을 좀 더 효율적으로 짜는 방향으로 나가야합니다. 인덱스 생성은 꼭 마지막 수단으로 강구해야 할 문제입니다.


- 인덱스 설계과정
    SQL별 접근경로조사 : 개발된 모든 SQL확인, 조건, 형변환등확인 표로정리
    테이블별 접근 경로 정리 : 테이블별 조인 조건 확인
    종합적인 인덱스 설계
    핵심 테이블 및 핵심 SQL 집중 설계
    인덱스 생성 및 모니터링 : 생성 후에 모니터링을 통한 개선 필요.


- B- 트리
    - B- 트리란?
        - B트리는 이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 벨런스를 맞추는 트리
        - 정렬된 순서를 보장
        - B-Tree 인덱스는 Root Block, Branch Block, Leaf Block 으로 나누어지며, 그림과 같이 Leaf block 은 양방향 링크를 가지고 있어서, 오름차순, 내림차순 검색이 가능하다.
        - 보통 B 트리라고 하면 B- 트리를 의미한다. B 트리는 트리 자료구조의 일종으로 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.
            - 노드에는 2개 이상의 데이터(key)가 들어갈 수 있으며, 항상 정렬된 상태로 저장된다.
            - 내부 노드는 M/2 ~ M개의 자식을 가질 수 있다. 최대 M개의 자식을 가질 수 있는 B 트리를 M차 B트리라고 한다.
            - 특정 노드의 데이터(key)가 K개라면, 자식 노드의 개수는 K+1개여야 한다.
            - 특정 노드의 왼쪽 서브 트리는 특정 노드의 key 보다 작은 값들로, 오른쪽 서브 트리는 큰 값들로 구성된다.
            - 노드 내에 데이터는 floor(M/2)-1개부터 최대 M-1개까지 포함될 수 있다
            - 모든 리프 노드들이 같은 레벨에 존재한다.

    - B-Tree 동작 방식
        1단계, 브랜치 블록의 가장 왼쪽 값이 찾고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동
        2단계, 찾고자 하는 값이 브랜치 블록의 값 사이에 존재하면 가운데 포인터로 이동
        3단계, 오른쪽에 있는 값보다 크면 오른쪽 포인터로 이동

    - B- 트리 탐색 과정
        - B- 트리는 루트 노드에서 탐색을 시작하여 하향식으로 탐색을 진행한다. 찾고자 하는 값이 K라면 다음과 같은 과정을 거친다.
            1. 루트 노드에서 탐색을 시작한다.
            2. K를 찾았다면 탐색을 종료한다.
            3. K와 노드의 key값을 비교해 알맞은 자식 노드로 내려간다.
            4. 해당 과정을 리프 노드에 도달할 때까지 반복한다.
            5. 리프 노드에서도 K를 찾지 못한다면 트리에 값이 존재하지 않는 것이다.

    - B- 트리 삽입 과정
        - 탐색과는 다르게 상향식으로 진행된다. B- 에서의 데이터 삽입은 항상 리프 노드에서 시작된다.
            1. 트리가 비어있다면 루트 노드를 할당하고 K를 삽입한다.
            2. 트리가 비어있지 않다면, 데이터를 넣을 적절한 리프 노드를 탐색한다.
            3. 리프 노드에 데이터를 넣고 리프 노드가 적절한 상태에 있다면 종료한다.
            4. 리프 노드가 부적절한 상태에 있다면 분리한다.

            이때, 적절한 상태란 해당 노드의 데이터 개수가 허용 범위 안에 있는 것이다. 반대로 부적절한 상태란 해당 노드의 데이터 개수가 허용 범위를 벗어나 너무 많은 상태를 뜻한다.

            - Case 1 : 분리가 일어나지 않는 경우
                1. 데이터를 삽입할 리프 노드를 탐색하고, 해당 노드에 데이터를 삽입한다.
                2. 해당 노드가 적절한 상태에 있다면, 삽입을 종료한다.

            - Case 2 : 분리가 일어나는 경우
                1. 데이터를 삽입할 리프 노드를 탐색하고, 해당 노드에 데이터를 삽입한다.
                 2-2. 해당 노드의 왼쪽 키들은 왼쪽 자식으로, 오른쪽 키들은 오른쪽 자식으로 분리된다.
                 2-3. 부모 노드를 검사해 부모 노드가 부적절한 상태에 있다면 위와 같은 분리를 반복한다.

    - B- 트리 삭제 과정
        - 노드를 삭제하는 과정 중 조건이 위반되면 조건에 맞도록 트리를 재구조화시켜야 한다.

        - Case 1. 리프 노드에서 삭제
            - Case 1-1) 리프 노드에서 값을 삭제하더라도 최소 유지 개수 조건을 만족하는 경우
                - 이 경우 바로 노드를 삭제해주면 된다.
            - Case 1-2) 리프 노드에서 값을 삭제할 때, 최소 유지 개수를 만족하지 못하지만 바로 옆 형제 노드들에게 값을 빌려올 수 있는 경우
                - K를 Parent와 바꿔준다. 이후 왼쪽 형제 노드에게서 값을 빌려올 수 있다면 Lmax와 Parent를, 오른쪽 형제에게서 값을 빌려올 수 있다면
                  Rmin과 Parent를 바꿔주면 된다. 둘 다 가능하면 하나를 선택하면 된다.
            - Case 1-3) 리프 노드에서 값을 삭제할 때, 최소 유지 개수를 만족하지 못하고 형제 노드들에게 값을 빌려올 수 없지만, 부모 노드를 분할할 수 있을 때
                - K를 삭제하고, Parent를 부모 노드에서 분할하여 형제 노드에 합친다. 이렇게 하면 부모 노드의 key가 하나 줄고, 자식 노드의 수도 하나 줄어들어 최소 유지 개수를 만족한다.
            - Case 1-4) 리프 노드에서 값을 삭제할 때, 최소 유지 개수를 만족하지 못하고, 형제 노드들에게 값을 빌려올 수 없고 부모 노드도 분할할 수 없을 때
                - 이 경우는 Case 2-2)의 경우와 동일

        - Case 2. 리프 노드가 아닌 내부 노드에서 삭제
            - Case 2-1) 내부 노드에서 값을 삭제할 때, 현재 노드 혹은 자식 노드의 최소 유지 개수의 최소보다 큰 경우
                - K의 Lmax 혹은 Rmin과 자리를 바꿔준다. 이후 리프 노드에서의 K 삭제와 과정이 동일
            - Case 2-2) 내부 노드에서 값을 삭제할 때, 현재 노드와 자식 노드 모두 key 개수가 최소인 경우
                - 트리의 재구조화가 필요