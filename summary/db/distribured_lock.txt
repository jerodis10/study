- Lock
    - 락이 필요한 이유
        - 격리수준은 connection 단위로만 적용 가능하다.
          트랜잭션 내에서 select 한 데이터에 대해 다른 트랜잭션을 동시성 제어하고 싶은 경우에 필요한 것이 데이터베이스의 lock 이다. ??

        - 격리 수준은 해당 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 볼 수 있는 기준을 정의
          락은 다른 트랜잭션에서 해당 데이터에 접근하는 것을 막는 기능을 수행.

    1. 낙관적 락(Optimistic Lock)
        - 낙관적 락 이란
            - 대부분의 트랜잭션이 충돌하지 않는다고 가정하는 방법
            - DB 의 lock 을 사용하지 않고 version 관리를 통해 어플리케이션 레벨에서 처리
            - 트랜잭션 커밋 전에는 트랜잭션 충돌을 알 수 없다.

        - JPA 의 낙관적 락(Optimistic Lock)을 사용하기 위해서는 @Version 을 사용해서 버전 관리 기능을 추가해야 한다.
            - @Version 을 적용할 수 있는 데이터 타입
                Long, long
                Integer, int
                Short, short
                Timestamp

        - 엔티티에 @Version 을 위한 필드를 추가하면, 엔티티를 수정할 때 마다 버전이 하나씩 자동으로 증가한다.
          그리고 엔티티를 수정할 때 조회 시점의 버전과, 수정 시점의 버전이 다르면 예외가 발생한다.
          이런 메커니즘 때문에 최초 커밋만 인정되는 방식을 구현할 수 있으므로, 두 번의 갱신 분실 문제를 방지할 수 있다.

        - 주의 사항
            - 임베디드 타입과 값 타입 컬렉션은 실제 DB 에서는 다른 테이블이지만, JPA 에서는 논리적인 개념해당 엔티티에 속한 값이므로 수정하면 엔티티의 버전이 증가한다.
            - 버전은 JPA 가 직접 관리하므로 개발자가 수정하면 안된다. 단 벌크연산시 JPA 가 관리하지 않으므로 이 때는 직접 버전을 관리해줘야 한다.

    2. 비관적 락(Pessimistic Lock)
        - 모든 트랜잭션은 충돌이 발생한다고 가정하고 우선 Lock 을 거는 방법이다.
        - 낙관적 락(Optimistic Lock)과는 달리 DB의 Lock 기능을 이용한다. 주로 select for update 구문을 사용하고, 버전 정보는 사용하지 않는다. (사용하도록 할 수도 있다.)
        - 엔티티가 아닌 스칼라 타입(int, String 같은 타입)을 조회할 때도 사용할 수 있다.
        - 트랜잭션 커밋하기 전에, 데이터를 수정하는 시점에 미리 트랜잭션 충돌을 감지할 수 있다.
        - Lock 을 획득할 때까지 트랜잭션은 대기하므로, Timeout 을 설정할 수 있다.

        - 갭 락?

        - 각 트랜잭션들이 순차적으로 작업을 마칠때까지 다른 트랜잭이 접근하지 못하므로 데드락을 방지할 수 있는 것이다.

        - 문제점
            - 성능 문제
                - 비관적 락은 모든 트랜잭션에 대해 락을 사용한다. 락이 필요하지 않은 상황에서도 락을 사용하기 때문에 트래픽이 많은 경우에는
                  O(N^2) 정도로 성능이 저하된다는 문제점이 있다. 즉 다른 요청들이 다 blocking 되서 타임아웃 날 수 있다.
            - 여전히 발생할 수 있는 데드락
                - 서로 다른 트랜잭션이 각자 자원을 점유하고, 상대방이 가진 자원을 얻기위해 무한히 대기하는 데드락이 발생한다.

            -> 예로 선착순 쿠폰 발급 시스템처럼 동시에 많은 트래픽이 몰리거나, 여러 테이블에 Lock 을 걸면서 데드락 이슈가 발생하는 경우에는 비관적 락으로는 해결할 수 없다.

        - 해결 방법
            Redis Sorted Set 활용
            Redis 의 Lua Script 활용
            Kafka 와 같은 메시징 큐 도입
            API Gateway 에서 처리율 제한 알고리즘 구현
            처리율 제한기 미들웨어 도입

        - 낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)은 싱글 DB 환경인 경우에만 적용 가능한 개념이다.
          샤딩 또는 Replication 등을 통해 DB가 분산되어있는 환경이라면 적용할 수 없다.

    3. 분산 락(Distributed Lock)
        - 자바 스프링 기반의 웹 애플리케이션은 기본적으로 멀티 쓰레드 환경에서 구동된다.
          따라서 여러 쓰레드가 함께 접근할 수 있는 공유자원에 대해 경쟁 상태(race condition)이 발생하지 않도록 별도의 처리가 필요하다.
          자바는 synchronized 라는 키워드를 언어 차원에서 제공해, 모니터 기반으로 상호 배제(mutual exclusion) 기능을 제공한다.
          하지만, 이 매커니즘은 같은 프로세스에서만 상호 배제를 보장한다.
          웹 애플리케이션 프로세스를 단 하나만 사용하는 서비스라면 상관 없지만, 일반적으로는 서버를 다중화하여 부하 분산하고 있을 것이다.
          이런 분산 환경에서 상호 배제를 구현하여 동시성 문제를 다루기 위해 등장한 방법이 바로 분산 락(distributed lock)이다.
          분산 락을 구현하기 위해 락에 대한 정보를 ‘어딘가’에 공통적으로 보관하고 있어야 한다.
          그리고 분산 환경에서 여러대의 서버들은 공통된 ‘어딘가’를 바라보며, 자신이 임계 영역(critical section)에 접근할 수 있는지 확인한다.
          이렇게 분산 환경에서 원자성(atomic)을 보장할 수 있게 된다.

        - DB가 분산되어있는 환경이라면, DB로 가는 요청을 단일진입점으로 만들고 순차적으로 요청을 처리할 때 사용할 수 있는 게 분산 락
        - Redis 의 분산 락은 일관성을 보장하지 못한다.??  (https://redis.io/docs/manual/patterns/distributed-locks/#disclaimer-about-consistency)

        - 분산 락(Distributed Lock)은 Lock 리소스 보안에 따라 크게 두 가지로 나눌 수 있다.
            1. 비동기 복제 기반 분산 시스템 ex) MySQL, Redis, Tair
            2. Paxos 기반 분산 합의 시스템 ex) ZooKeeper
            -> 1번 방법은 2번 방법에 비해 데이터 손실 위험이 있다. 그래서 TTL 메커니즘을 통해 세분화된 Lock 을 제공한다.
               Redis 의 Redisson 은 자체 TTL 메커니즘을 제공한다.
               2번 방법은 합의 프로토콜을 통해 여러 데이터 복사본을 보장하고 높은 데이터 보안성을 제공한다. 일반적으로 세션 메커니즘을 사용하고,
               오랜 기간 Lock 을 가지고 있으며 데이터 손실 위험이 비교적 적다.
        - 리소스에 Lock 을 가지고 있어도, 다른 DB의 같은 리소스에는 접근 가능하기 때문에, DB로 가는 요청을 단일 진입점으로 만들 수 있는 무언가가 필요하다.
          구현방식이 간단하고 성능이 가장 좋으면서, 참고할 레퍼런스가 많은 Redis 를 이용해서 분산 락(Distributed Lock)을 구현하고자 한다.

        - redis 자바 클라이언트
            - JAVA 용 레디스 클라이언트 라이브러리는 Jedis, Lettuce, Redisson 등이 있다.
                - Lettuce
                    - Lettuce 는 스핀락(Spin Lock)을 사용한다.
                    - 스핀락(Spin Lock)은 Lock 이 없는 프로세스는 Lock 을 획득하기 위해 무한루프를 돌게된다.
                    - 무한루프를 돌면서 CPU 를 쓸데없이 낭비하게 되기 때문에, 성능 저하로 이어질 수 있다.
                    - 그럼 이런 쓸데없는것을 왜 만들었나 싶겠지만, 코어가 여러개인 경우 유용하다.
                      Lock 을 얻기 위해 계속 무한루프를 돌다가, Lock 을 얻으면 컨텍스트 스위칭 필요없이 바로 실행될 수 있기 때문이다.

                - Redisson
                    - 스핀락(Spin Lock)을 사용하지 않고 pub-sub 기능을 사용한다.
                    - pub-sub 이란 마치 인터럽트처럼, Lock 획득을 기다리는 클라이언트에게 Lock 획득할 수 있다는 신호를 보내주는 것이다.
                    - 그래서 Lock 획득을 위해 무한루프를 돌 필요가 없다.

                    - Lettuce 와 비슷하게 Netty 를 사용하여 non-blocking I/O를 사용합니다.
                      Redisson 의 특이한 점은 직접 레디스의 명령어를 제공하지 않고,
                      Bucket 이나 Map 같은 자료구조나 Lock 같은 특정한 구현체의 형태로 제공한다는 것입니다.

                    - 장점
                        - Lock 에 타임아웃이 구현되어 있다.
                            - Redisson 은 tryLock 메소드에 타임아웃을 명시하도록 되어있습니다.

    -> 중요한 점은 Lock 을 정말로 사용해야 하는 상황인지 판단하는 것과 어떤 Lock 을 사용해서 해결해야 하는지 판단하는 능력인 것 같다.





** 참고 **

Redis로 분산 락을 구현해 동시성 이슈를 해결해보자!
https://hudi.blog/distributed-lock-with-redis/

락이란? 분산락, 스핀락의 개념
https://way-be-developer.tistory.com/m/274

Lock으로 이해하는 Transaction의 Isolation Level
https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/

[Database] 데이터베이스 락(Lock)의 종류와 역할
https://velog.io/@koo8624/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%9D%BDLock%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%97%AD%ED%95%A0

레디스와 분산 락(1/2) - 레디스를 활용한 분산 락과 안전하고 빠른 락의 구현
https://hyperconnect.github.io/2019/11/15/redis-distributed-lock-1.html

분산락을 이용하여 동시성 제어하기 (redis활용하기)
https://velog.io/@korea3611/Spring-boot-%EC%A2%8B%EC%95%84%EC%9A%94%EC%88%98-%EC%A6%9D%EA%B0%80-%EB%B6%84%EC%82%B0%EB%9D%BD%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0-redis%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0

redis 설치 및 redisson을 이용한 분산락 구현
https://it-hhhj2.tistory.com/102

[스프링] 재고 시스템으로 알아보는 동시성 문제 해결 방법
https://crazy-horse.tistory.com/entry/%EC%9E%AC%EA%B3%A0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95

[redis] redisson을 통한 분산 락
https://kkambi.tistory.com/196

동시성 문제 해결하기 V1, V2, V3
https://velog.io/@znftm97/%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-V2-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BDPessimistic-Lock

<Database> 공유락(Shared Lock) & 배타락(Exclusive Lock)
https://willbfine.tistory.com/578?category=1044057

분산락 테스트 코드
https://github.com/hgs-study/distributed-lock-practice

자바에서 동시성을 해결하는 다양한 방법과 Redis의 분산락   -> 다른 게시물 (락 이외) 참고
https://dkswnkk.tistory.com/681

락 종류
https://tecoble.techcourse.co.kr/post/2022-11-07-mysql-isolation/

JPA의 낙관적 락과 비관적 락을 통해 엔티티에 대한 동시성 제어하기
https://hudi.blog/jpa-concurrency-control-optimistic-lock-and-pessimistic-lock/

Distributed Locks with Redis (공식 레퍼런스)
https://redis.io/docs/manual/patterns/distributed-locks/

HikariCP Dead lock에서 벗어나기 (이론편)
https://techblog.woowahan.com/2664/

