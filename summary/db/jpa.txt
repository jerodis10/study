- fetch join
    https://jojoldu.tistory.com/457

- NoArgsConstructor 접근권한을 주지 않았었는데요. JPA에서는 프록시를 생성을 위해서 기본 생성자를 반드시 하나를 생성해야합니다.
  이때 접근 권한을 AccessLevel.PROTECTED로 설정하여 JPA에서의 Entity 클래스 생성만 허용해줍니다.

- [JPA] Querydsl 에서 Fetch Join 적용 안되는 이유
    https://elsboo.tistory.com/34

- 읽기 전용 쿼리 성능 최적화
    https://willseungh0.tistory.com/75

- querydsl pagination (커버링 인덱스)
    https://jaehoney.tistory.com/333

- Join, Fetch Join 차이점 요약
    - 일반 Join
        Fetch Join과 달리 연관 Entity에 Join을 걸어도 실제 쿼리에서 SELECT 하는 Entity는
        오직 JPQL에서 조회하는 주체가 되는 Entity만 조회하여 영속화
        조회의 주체가 되는 Entity만 SELECT 해서 영속화하기 때문에 데이터는 필요하지 않지만 연관 Entity가 검색조건에는 필요한 경우에 주로 사용됨
    - Fetch Join
        조회의 주체가 되는 Entity 이외에 Fetch Join이 걸린 연관 Entity도 함께 SELECT 하여 모두 영속화
        Fetch Join이 걸린 Entity 모두 영속화하기 때문에 FetchType이 Lazy인 Entity를 참조하더라도
        이미 영속성 컨텍스트에 들어있기 때문에 따로 쿼리가 실행되지 않은 채로 N+1문제가 해결됨

    * 페치 조인 미사용
      JPQL “SELECT m FROM Member m"로 호출 후 Member와 Team의 @ManyToOne FetchType.LAZY 설정을 통한 지연로딩 사용

    * 페치 조인의 특징과 한계
        - 페치 조인 대상에는 별칭을 줄 수 없다.(별칭 사용하지 않는게 관례)
            - 하이버네이트는 가능, 가급적 사용X
        - 둘 이상의 컬렉션은 페치 조인 할 수 없다.
        - 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
            - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
            - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)

    * 최적화가 필요한 곳은 페치 조인 적용
        N+1이 발생하는 곳은 Fetch 조인
        N+1이 발생하며, 페이징이 필요하다 @BatchSize 설정

    * 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
      여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적