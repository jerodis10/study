- JPA를 사용해야 하는 이유
    생산성
        자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다. SQL을 작성하고 JDBC API를 사용하는 반복 행위는 JPA가 대신해 준다.

    패러다임 불일치 해결
        JPA는 상속, 연관 관계, 객체 그래프 탐색, 비교 등 패러다임의 불일치를 해결해 준다.

    유지 보수
        엔티티에 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어 든다. 특히 이전에 작성하던 SQL과 JDBC API를 JPA가 대신 처리해 준다.

    성능
        JPA는 애플리케이션과 데이터베이스 사이에서 동작하므로 최적화 관점에서 시도해 볼 수 있는 것이 많다.

    데이터 접근 추상화와 벤더 독립성
        JPA는 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다.


- 엔티티
    데이터베이스의 테이블과 매핑되는 객체
    영속성을 가진 객체로 DB 테이블에 보관할 대상. 즉, 영속성 컨텍스트에 속한 객체.


- 엔티티 매니저(EntityManager)
    엔티티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할을 합니다.
    그리고 이런 엔티티 매니저를 만드는 곳이 엔티티 매니저 팩토리(entity manager factory)
    스프링 부트는 내부에서 엔티티 매니저 팩토리를 하나만 생성해서 관리하고
    @PersistenceContext 또는 @Autowired 애너테이션을 사용해서 엔티티 매니저를 사용합니다.

    - 정의
        - 엔티티 CRUD
        - 등록
        - 영속성 컨텍스트 참조
        - 영속화

        엔티티를 저장하고, 수정하고, 삭제하고 조회하는 등 엔티티와 관련된 모든 일을 처리.
        Spring Data JPA에서는 EntityManager를 자동으로 Bean이 등록되기 때문에 직접 사용하지는 않는다.
        JPA는 기본적으로 한 요청 당, 하나의 EntityManager를 사용
        각 EntityManager들은 정해진 영속성 컨텍스트를 참조하게 된다.
        그리고 이렇게 만들어진 EntityManager로 데이터를 다루려면 가장 먼저 Entity가 "영속화"되어 있어야 한다.

        영속성 컨텍스트를 통해 데이터의 상태 변화를 감지하고 필요한 쿼리를 자동으로 수행한다.

    - 엔티티 매니저 팩토리 / 엔티티 매니저
        엔티티 매니저 팩토리를 통해 생성되는데, 데이터베이스를 하나만 사용하는 애플리케이션은 일반적으로 엔티티 매니저 팩토리를 하나만 생성한다.
        EntityManagerFactory는 만드는 비용이 상당히 크다. 따라서 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다.
        한 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 안전하다.

        EntityManager는 만드는 비용이 거의 들지 않는다. 필요에 따라서 생성하고 사용하면 된다.
        하지만 주의할 점은 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.

    - 메서드
        - find() : 영속성 컨텍스트에서 엔티티를 검색하고 없을 경우 DB에서 데이터를 찾아 영속 컨텍스트에 저장
        - persist() : 엔티티를 영속성 컨텍스트에 저장 후 INSERT 쿼리를 실행
        - remove() : 엔티티 클래스를 영속성 컨텍스트에서 삭제 후 DELETE 쿼리를 실행


- 엔티티 생명주기
    - 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
              엔티티 객체를 생성만 하고 저장하지 않으면 순수한 객체 상태.
    - 영속 : 영속성 컨텍스트에 저장된 상태
            em.persist()
    - 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태. 개발자가 직접 준영속 상태로 만드는 경우는 극히 드물다.
              em.detach()
    - 삭제 : 삭제된 상태
            em.remove()


- 영속성 컨텍스트
    - 엔티티를 영구 저장하는 환경
    - 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

    - 장점
        - 1차 캐시
            엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환, 값이 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환
            이를 통해 캐시된 데이터를 조회할 때에는 데이터베이스를 거치치 않아도 되므로 매우 빠르게 데이터를 조회

            - 내부에 엔티티를 저장하는 캐시를 가지고 있는데 이것을 1차 캐시라고 한다.
            - 영속 상태의 엔티티는 데이터 베이스에 저장되기 전(트랜잭션 호출 전)까지 모두 이곳에 저장된다.
              엔티티 조회 시 1차 캐시에서 먼저 찾고 만약 존재하지 않으면 데이터베이스를 조회한다.

        - 트랜잭션을 지원하는 쓰기 지연
            트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미
            적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있습니다.

            - JPA 는 커밋하기 전까지 1차 캐시에 엔티티를 저장하고 관련 쿼리들을 쌓아 놓는다.
              그리고 트랜잭션을 커밋할 때 모아둔 쿼리들을 한 번에 db 에 보내는데 이것을 쓰기 지연
            - 쓰기 지연 기능을 활용하면 모아둔 등록 쿼리를 한번에 전달해서 sql batch 를 사용해 성능 최적화 가능

        - 변경감지
            - JPA 는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는 데 이것을 스냅샷.
              그리고 플러시 시점에 스냅샷과 현재 엔티티를 비교해서 변경된 부분을 찾는다.
              만약 변경된 데이터가 있다면 update 쿼리 문을 쓰기 지연 SQL 저장소에 저장해 두었다가 트랜잭션 커밋 시 db 에 반영

            - JPA 를 사용하기 전 SQL 을 사용하면 수정 쿼리를 일일이 작성해야 함.
              JPA 는 영속 상태의 엔티티의 변경사항을 db 에 자동으로 반영하는 데 이를 dirty checking 이라 함.
            - merge 는 새로운 엔티티를 만들어 기존 엔티티를 덮어 씌우는 방식이기 때문에 자칫 실수로 빈 필드도 같이 합쳐질 수 있어 사용x
            - JPA 의 기본 전략은 엔티티의 모든 필드를 업데이트하기 때문에, 변경 사항만 업데이트 하고 싶을 시 @DynamicUpdate 사용

        - 동일성 보장
            - 식별자가 같은 엔티티 인스턴스를 조회해서 비교했을 때, 영속성 컨텍스트는 1차 캐시에 있는 같은 인스턴스를 반환해주기 때문에 동일성 보장해줌

        - 지연 로딩
            - JPA 에서는 테이블 간 연관 관계는 객체의 참조를 통해 이루어짐. 실무에서는 서비스의 규모가 대부분 크기 때문에, 데이터의 양이 많은 것은
              물론이거니와 각각의 데이터들끼리 참조하고 있기에, 연관된 데이터들을 한번에 가져오는 행동은 부담이 크다.
              따라서 JPA 는 참조하는 객체들의 데이터를 가져오는 시점을 정할 수 있는데 이것을 Fetch Type - Eager, Lazy
            - 보편적으로 지연로딩을 사용. 즉시 로딩은 모든 객체들을 가져오기 때문에 불필요한 조인으로 인해 성능 저하

    - 특징
        - flush
            - 영속성 컨텍스트의 변경 내용을 db 에 반영. 플러시를 실행하면 변경 감지가 작동해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서
              수정된 엔티티를 찾고, 해당 사항에 맞는 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록 후 db 에 전송
            - 영속성 컨텍스트를 flush 하는 방법
                1. em.flush 직접 호출
                2. 트랜잭션 커밋 시 플러시가 자동 호출
                3. JPQL 쿼리 실행 시 플러시가 자동 호출

        - 영속성 컨텍스트와 식별자 값
            영속성 컨텍스트는 엔티티를 식별자 값(@Id)으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 한다.
            영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 기본 키 값이다.

        - 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
          (영속성 컨텍스트는 데이터베이스 트랜잭션이 READ COMMITTED 격리 수준이어도 애플리케이션 레벨에서 반복 가능한 읽기(REPEATABLE READ)를 제공한다.)


- Join, Fetch Join 차이점 요약
    - 일반 Join
        Fetch Join과 달리 연관 Entity에 Join을 걸어도 실제 쿼리에서 SELECT 하는 Entity는
        오직 JPQL에서 조회하는 주체가 되는 Entity만 조회하여 영속화
        조회의 주체가 되는 Entity만 SELECT 해서 영속화하기 때문에 데이터는 필요하지 않지만 연관 Entity가 검색조건에는 필요한 경우에 주로 사용됨
    - Fetch Join
        조회의 주체가 되는 Entity 이외에 Fetch Join이 걸린 연관 Entity도 함께 SELECT 하여 모두 영속화
        Fetch Join이 걸린 Entity 모두 영속화하기 때문에 FetchType이 Lazy인 Entity를 참조하더라도
        이미 영속성 컨텍스트에 들어있기 때문에 따로 쿼리가 실행되지 않은 채로 N+1문제가 해결됨

    * 페치 조인 미사용
      JPQL “SELECT m FROM Member m"로 호출 후 Member와 Team의 @ManyToOne FetchType.LAZY 설정을 통한 지연로딩 사용

    * 페치 조인의 특징과 한계
        - 페치 조인 대상에는 별칭을 줄 수 없다.(별칭 사용하지 않는게 관례)
            - 하이버네이트는 가능, 가급적 사용X
        - 둘 이상의 컬렉션은 페치 조인 할 수 없다. ??
        - 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
            - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
            - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)

    * 최적화가 필요한 곳은 페치 조인 적용
        N+1이 발생하는 곳은 Fetch 조인
        N+1이 발생하며, 페이징이 필요하다 @BatchSize 설정 ??

    * 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
      여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적


- (JPA) Readonly 트랜잭션은 Dirty Checking을 하지 않는다
    - @Transaction(readOnly = true)로 설정하면 select 할 당시 엔티티의 스냅샷을 만들지 않는다.
    - (JPA) Readonly 트랜잭션은 트랜잭션을 시작하지만 flush를 하지 않는다에서 봤다 싶이 트랜잭션이 커밋될 때 flush를 하지 않는다.
    - flush를 할 필요가 없기 때문에 Dirty Checking을 할 필요가 없고, 그에 따라서 엔티티의 스냅샷도 만들지 않는 것이다. -> 성능 최적화
    - 데이터베이스가 master와 slave로 나누어져 있다면, readOnly = true 설정을 주었을 때 읽기 전용인 slave를 호출하게 된다.
      즉, 상황에 따라 데이터베이스 서버 부하를 줄일 수 있다.


- NoArgsConstructor 접근권한을 주지 않았었는데요. JPA에서는 프록시를 생성을 위해서 기본 생성자를 반드시 하나를 생성해야합니다.
  이 때 접근 권한을 AccessLevel.PROTECTED로 설정하여 JPA에서의 Entity 클래스 생성만 허용해줍니다. ??


- 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
    hibernate.jdbc.batch_size 속성의 값을 50으로 주면 최대 50건씩 모아서 SQL 배치를 실행한다. 이때 같은 SQL일 때만 유효하고, 만약 중간에 다른 처리가 들어가면 SQL 배치를 다시 시작한다.
    트랜잭션을 지원하는 쓰기 지연과 변경 감지 기능은 성능과 개발의 편의성 및 데이터베이스 row에 락이 걸리는 시간을 최소화한다.
        트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지 데이터베이스에 데이터를 등록, 수정, 삭제하지 않는다.
        따라서 커밋 직전까지 데이터베이스 row에 락을 걸지 않는다.
        만약 JPA를 사용하지 않고 SQL을 직접 다루면 update() 메소드를 호출할 때, 즉시 UPDATE SQL을 실행하여 데이터베이스 테이블 row에 락을 걸게 된다.


- SQL을 직접 다룰 때 발생하는 문제점
    진정한 의미의 계층 분할이 아니다.
        개발자는 수정 사항이나 버그가 생겼을 경우 DAO를 열어서 어떤 SQL이 실행되고 어떤 객체들이 함께 조회되는지 일일이 확인해야 한다. 가령, 도메인 객체의 변화가 생겼음에도 불구하고 DAO를 확인할 수 밖에 없으므로 진정한 의미의 계층 분할이라고 할 수 없다.

    SQL에 의존적인 개발을 피하기 어렵다.
        물리적으로 SQL과 JDBC API를 데이터 접근 계층 (DAO)에 숨기는 데 성공했을지라도 논리적으로는 엔티티와 아주 강한 의존 관계를 지니고 있다. 이런 강한 의존 관계때문에 회원을 조회할 때는 물론이고 회원 객체에 필드를 하나 추가할 때도 DAO의 CRUD와 SQL 대부분을 변경해야 한다. 이것은 SOLID 원칙 중에 개방 폐쇄 원칙을 위반하는 사례다.
        아래에서 자세히 이야기하겠지만, JPA는 위의 문제를 해결할 수 있다. JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 SQL을 작성하지 않고 JPA가 제공하는 API를 사용한다. 그러면 JPA가 개발자 대신에 적절한 SQL을 생성해서 데이터베이스에 전달한다.

    패러다임의 불일치
        객체 지향과 달리 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 그리고 객체 지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다. 두 개념이 지향하는 목적이 다르므로 둘의 기능과 표현이 다르고, 여기서 패러다임 불일치가 발생한다.

        JDBC API를 이용해서 코드를 작성하려면 부모 객체에서 부모 데이터를 꺼내고, 자식 객체에서 자식 데이터를 꺼내서 따로 SQL을 작성해야하므로 작성해야 할 코드가 많다.
        JPA는 이와 달리 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해 준다. 개발자는 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다.

        JPA는 객체 그래프를 마음껏 탐색한다. JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL문을 실행하며, 이를 lazy loading이라고 한다.


- JPA Hibernate 프록시 제대로 알고 쓰기
    https://tecoble.techcourse.co.kr/post/2022-10-17-jpa-hibernate-proxy/

- [JPA] Spring JPA 환경에서 bulk insert를 효율적으로 해보자 - JPA의 한계와 JDBC 활용
    https://sabarada.tistory.com/220


- 엔티티 매니저가뭐냐

- 1차캐시가뭐냐

- 영속성컨텍스트가뭐냐

- 영속상태?  라이프사이클?에대해말해라



- Join, Fetch Join 차이점 요약 ??

- JPA 연관관계 외래키 매핑시 주의점
    https://kim-solshar.tistory.com/70

- 영속성 컨텍스트
    https://kim-solshar.tistory.com/67

- [JPA] JPA Entity 왜 단일키가 좋은가?
    https://jwkim96.tistory.com/166