- 엔티티 생명주기
    - 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
              엔티티 객체를 생성만 하고 저장하지 않으면 순수한 객체 상태.
    - 영속 : 영속성 컨텍스트에 저장된 상태
            em.persist()
    - 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태. 개발자가 직접 준영속 상태로 만드는 경우는 극히 드물다.
              em.detach()
    - 삭제 : 삭제된 상태
            em.remove()

- 영속성 컨텍스트   -> REPEATABLE READ ??
    - 엔티티를 영구 저장하는 환경
    - 엔티티를 DB 에 저장하는 것이 아닌 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장.
    - 영속성 컨텍스트는 엔티티 매니저를 생성할 때 자동으로 하나 만들어짐.
    - 엔티티를 식별자(@Id 로 테이블의 기본키와 매핑한 값)으로 구분.
      따라서 영속 상태의 엔티티는 식별자 값이 반드시 있어야 한다.
    - persist() 단계에서 DB 에 저장되는 것이 아니라 영속성 컨텍스트에 저장되며, 트랜잭션을 커밋하는 순간 DB 에 반영. 이것을 flush

    - 장점
        - 1차 캐시
            - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것이 1차 캐시.
            - find() 를 통해 회원을 조회할 때 해당 객체가 영속 상태여서 1차 캐시에 엔티티가 있다면 db 를 조회하지 않고 메모리에 있는 엔티티 바로 반환
              만약 영속 상태가 아니라면 db 조회 후 조회한 엔티티를 1차 캐시에 저장하고 1차 캐시에서 엔티티를 가져온다.

        - 동일성 보장
            - 식별자가 같은 엔티티 인스턴스를 조회해서 비교했을 때, 영속성 컨텍스트는 1차 캐시에 있는 같은 인스턴스를 반환해주기 때문에 동일성 보장해줌

        - 트랜잭션을 지원하는 쓰기 지연
            - JPA 는 커밋하기 전까지 1차 캐시에 엔티티를 저장하고 관련 쿼리들을 쌓아 놓는다.
              그리고 트랜잭션을 커밋할 때 모아둔 쿼리들을 한 번에 db 에 보내는데 이것을 쓰기 지연
            - 쓰기 지연 기능을 활용하면 모아둔 등록 쿼리를 한번에 전달해서 sql batch 를 사용해 성능 최적화 가능

        - 변경감지
            - JPA 를 사용하기 전 SQL 을 사용하면 수정 쿼리를 일일이 작성해야 함.
              JPA 는 영속 상태의 엔티티의 변경사항을 db 에 자동으로 반영하는 데 이를 dirty checking 이라 함.
            - JPA 는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는 데 이것을 스냅샷.
              그리고 플러시 시점에 스냅샷과 현재 엔티티를 비교해서 변경된 부분을 찾는다.
              만약 변경된 데이터가 있다면 update 쿼리 문을 쓰기 지연 SQL 저장소에 저장해 두었다가 트랜잭션 커밋 시 db 에 반영
            - merge 는 새로운 엔티티를 만들어 기존 엔티티를 덮어 씌우는 방식이기 때문에 자칫 실수로 빈 필드도 같이 합쳐질 수 있어 사용x
            - JPA 의 기본 전략은 엔티티의 모든 필드를 업데이트하기 때문에, 변경 사항만 업데이트 하고 싶을 시 @DynamicUpdate 사용

    - flush
        - 영속성 컨텍스트의 변경 내용을 db 에 반영. 플러시를 실행하면 변경 감지가 작동해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서
          수정된 엔티티를 찾고, 해당 사항에 맞는 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록 후 db 에 전송
        - 영속성 컨텍스트를 flush 하는 방법
            1. em.flush 직접 호출
            2. 트랜잭션 커밋 시 플러시가 자동 호출
            3. JPQL 쿼리 실행 시 플러시가 자동 호출

    - 지연 로딩
        - JPA 에서는 테이블 간 연관 관계는 객체의 참조를 통해 이루어짐. 실무에서는 서비스의 규모가 대부분 크기 때문에, 데이터의 양이 많은 것은
          물론이거니와 각각의 데이터들끼리 참조하고 있기에, 연관된 데이터들을 한번에 가져오는 행동은 부담이 크다.
          따라서 JPA 는 참조하는 객체들의 데이터를 가져오는 시점을 정할 수 있는데 이것을 Fetch Type - Eager, Lazy
        - 보편적으로 지연로딩을 사용. 즉시 로딩은 모든 객체들을 가져오기 때문에 불필요한 조인으로 인해 성능 저하

    - Fetch Join vs 일반 Join with DTO
        - Fetch Join : 두 엔티티의 영속화가 필요로 할 때
        - Join with DTO : 영속화 없이 데이터 조회만 할 수 있을 경우


- NoArgsConstructor 접근권한을 주지 않았었는데요. JPA에서는 프록시를 생성을 위해서 기본 생성자를 반드시 하나를 생성해야합니다.
  이때 접근 권한을 AccessLevel.PROTECTED로 설정하여 JPA에서의 Entity 클래스 생성만 허용해줍니다. ??


- Join, Fetch Join 차이점 요약 ??
    - 일반 Join
        Fetch Join과 달리 연관 Entity에 Join을 걸어도 실제 쿼리에서 SELECT 하는 Entity는
        오직 JPQL에서 조회하는 주체가 되는 Entity만 조회하여 영속화
        조회의 주체가 되는 Entity만 SELECT 해서 영속화하기 때문에 데이터는 필요하지 않지만 연관 Entity가 검색조건에는 필요한 경우에 주로 사용됨
    - Fetch Join
        조회의 주체가 되는 Entity 이외에 Fetch Join이 걸린 연관 Entity도 함께 SELECT 하여 모두 영속화
        Fetch Join이 걸린 Entity 모두 영속화하기 때문에 FetchType이 Lazy인 Entity를 참조하더라도
        이미 영속성 컨텍스트에 들어있기 때문에 따로 쿼리가 실행되지 않은 채로 N+1문제가 해결됨

    * 페치 조인 미사용
      JPQL “SELECT m FROM Member m"로 호출 후 Member와 Team의 @ManyToOne FetchType.LAZY 설정을 통한 지연로딩 사용

    * 페치 조인의 특징과 한계
        - 페치 조인 대상에는 별칭을 줄 수 없다.(별칭 사용하지 않는게 관례)
            - 하이버네이트는 가능, 가급적 사용X
        - 둘 이상의 컬렉션은 페치 조인 할 수 없다. ??
        - 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
            - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
            - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)

    * 최적화가 필요한 곳은 페치 조인 적용
        N+1이 발생하는 곳은 Fetch 조인
        N+1이 발생하며, 페이징이 필요하다 @BatchSize 설정 ??

    * 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
      여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적


- (JPA) Readonly 트랜잭션은 Dirty Checking을 하지 않는다
    - @Transaction(readOnly = true)로 설정하면 select 할 당시 엔티티의 스냅샷을 만들지 않는다.
    - (JPA) Readonly 트랜잭션은 트랜잭션을 시작하지만 flush를 하지 않는다에서 봤다 싶이 트랜잭션이 커밋될 때 flush를 하지 않는다.
    - flush를 할 필요가 없기 때문에 Dirty Checking을 할 필요가 없고, 그에 따라서 엔티티의 스냅샷도 만들지 않는 것이다. -> 성능 최적화
    - 데이터베이스가 master와 slave로 나누어져 있다면, readOnly = true 설정을 주었을 때 읽기 전용인 slave를 호출하게 된다. 즉, 상황에 따라 데이터베이스 서버 부하를 줄일 수 있다.

