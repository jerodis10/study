- 인덱스(Index)란?
    이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.
    인덱스도 하나의 데이터베이스 객체
    데이터베이스 크기의 약 10% 정도의 저장공간 필요


- 인덱스(Index)를 사용하는 이유
    - 조건 검색 Where 절의 효율성
        테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다.
        이렇게 되면 Where 절에 특정 조건에 맞는 데이터들을 찾아낼 때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과
        맞는지 비교해야 합니다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 하지만 인덱스 테이블은 데이터들이
        정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠.
        이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다.

    - 정렬 Order by 절의 효율성
        인덱스(Index)를 사용하면 Order by에 의한 Sort 과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이
        걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면
        디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다.
        이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.

    - MIN, MAX 의 효율적인 처리가 가능하다.
        - 이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점입니다. MIN 값과 MAX 값을 레코드의 시작값과 끝 값 한건씩만
          가져오면 되기에 FULL TABLE SCAN 으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.


- 인덱스 자료구조 (B * Tree 인덱스)
    인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다.
    그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.
    B * Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다.


- Clustered Index
    - 항상 정렬된 상태를 유지하고 노드 내에서도 정렬되어 있음
    - 데이터페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
    - 데이터페이지는 리프 레벨
    - 클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 된다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있다.
    - 테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
    - 물리적으로 행을 재배열 (실제 DB의 데이터파일에 정렬이 되어 있는 상태로 디스크에 저장)

    - 실제 데이터 자체가 정렬
    - 리프 페이지 -> 실제 데이터 페이지


- Non Clustered Index
    - 인덱스 페이지는 로그 파일에 저장됨
    - 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됨
    - 기본키는 아니지만 성능 향상을 위해 임의의 컬럼을 지정해서 만든 인덱스
    - 3% 이내에서 사용해야 좋은 선택도를 가진다.

    - 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 같은 역할
    - 별도의 인덱스 페이지 생성 -> 추가 공간 필요

    - 직접 index 생성시 논-클러스터링 인덱스 생성 (unique index, index)