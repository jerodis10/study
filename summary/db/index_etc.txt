- 인덱스(Index)란?
    이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.
    인덱스도 하나의 데이터베이스 객체
    데이터베이스 크기의 약 10% 정도의 저장공간 필요


- 인덱스(Index)를 사용하는 이유
    - 조건 검색 Where 절의 효율성
        테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다.
        이렇게 되면 Where 절에 특정 조건에 맞는 데이터들을 찾아낼 때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과
        맞는지 비교해야 합니다. 이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 하지만 인덱스 테이블은 데이터들이
        정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠.
        이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다.

    - 정렬 Order by 절의 효율성
        인덱스(Index)를 사용하면 Order by에 의한 Sort 과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이
        걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면
        디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다.
        이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.

    - MIN, MAX 의 효율적인 처리가 가능하다.
        - 이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점입니다. MIN 값과 MAX 값을 레코드의 시작값과 끝 값 한건씩만
          가져오면 되기에 FULL TABLE SCAN 으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.


- 인덱스 자료구조 (B * Tree 인덱스)
    인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다.
    그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.
    B * Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다.


- Clustered Index
    - 항상 정렬된 상태를 유지하고 노드 내에서도 정렬되어 있음
    - 데이터페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
    - 데이터페이지는 리프 레벨
    - 클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 된다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있다.
    - 테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
    - 물리적으로 행을 재배열 (실제 DB의 데이터파일에 정렬이 되어 있는 상태로 디스크에 저장)

    - 실제 데이터 자체가 정렬
    - 리프 페이지 -> 실제 데이터 페이지

    - Clustered Key
        (1) PK
        (2) PK가 없을 땐, Unique Key
        (3) PK가 없고 Unique Key도 없을 땐, 6 bytes의 Hidden Key 생성


- Non Clustered Index
    - 인덱스 페이지는 로그 파일에 저장됨
    - 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됨
    - 기본키는 아니지만 성능 향상을 위해 임의의 컬럼을 지정해서 만든 인덱스
    - 3% 이내에서 사용해야 좋은 선택도를 가진다.

    - 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 같은 역할
    - 별도의 인덱스 페이지 생성 -> 추가 공간 필요

    - 직접 index 생성시 논-클러스터링 인덱스 생성 (unique index, index)


- 클러스터링 + 논-클러스터링 인덱스
    - 클러스터링 인덱스 페이지가 존재하고, 논-클러스터링 인덱스 페이지에는 데이터 페이지의 주소가 존재해서 데이터를 조회
      하지만, 데이터 페이지의 주소값이 아닌 클러스터링 인덱스가 적용된 칼럼의 실제값이 들어있다.
    - name 인덱스 페이지에서 해당 name 을 찾고 그 값을 통해 id 인덱스 페이지에서 탐색
      (name 칼럼의 논-클러스터링 인덱스 페이지, id 칼럼의 클러스트렁 인덱스 페이지 구조 예시)
    - 만약 논-클러스터링 인덱스 페이지에 데이터 페이지의 주소값이 들어있게 되면, 데이터가 추가되거나 삭제될 때마다
      인덱스 페이지들의 주소들을 계속해서 변경해야 하는 영향을 주게 된다. 따라서 클러스터링 인덱스가 적용된 칼럼의 실제값이
      들어있으면 id 가 직접 변경되지 않는 한 인덱스 페이지에 영향을 주지 않도록 구성되어 있다.


- 흐름   https://tecoble.techcourse.co.kr/post/2021-10-12-covering-index/
    현재 age와 PK에 인덱스가 걸려있다. 따라서 Non-clustered Key는 age에, Clustered Key는 PK에 인덱스가 있다.
    그리고 Non-clustered Key는 age 순으로, Clustered Key는 PK 순으로 정렬된다.
    Non-clustered Key에는 인덱스 컬럼(age)의 값들과 PK의 값들이 있고, Clustered Key는 테이블의 실제 레코드 위치를 알고 있다.
    MySQL에서는 Non-clustered Key에 Clustered Key가 항상 포함되어 있다. Non-clustered Key엔 데이터 블록의 위치가 없기 때문이다.
    그러므로 인덱스 조건에 부합하는 WHERE가 있더라도, SELECT 문에 인덱스에 포함되어 있는 컬럼 외의 다른 컬럼 값이 필요할 때는
    Non-clustered Key에 있는 Clustered Key 값으로 데이터 블록을 찾는 과정이 필요하다.
    그렇지만, PK를 사용하는 경우에는 테이블 액세스 시간이 없어져서 필요로 하는 데이터에 더 빠르게 접근할 수 있다.
    결국 커버링 인덱스는 이미지의 2. 실제 데이터 접근 과정 없이, 인덱스에 존재하는 컬럼 값으로만 쿼리를 완성하는 것을 얘기한다.


- 인덱스(Index)의 관리
    앞서 설명했듯이 인덱스는 항상 최신의 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다.
    그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE 가 수행된다면 계속 정렬을 해주어야 하고 그에
    따른 부하가 발생합니다. 이런 부하를 최소화하기 위해 인덱스는 데이터 삭제라는 개념에서 인덱스를 사용하지 않는다
    라는 작업으로 이를 대신합니다.
    INSERT: 새로운 데이터에 대한 인덱스를 추가합니다.
    DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행합니다.
    UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가합니다.


- 인덱스를 타지 않는 경우
    1. 인덱스 컬럼의 변형
        - 수식이나 함수 등으로 인덱스 컬럼 절을 변형하였을 경우 인덱스를 타지 않는다.
        - 반드시 함수나 수식을 사용해야하는 경우에는 인덱스 컬럼에 적용하지 말고, 대입되는 컬럼이나 상수에 적용해야 한다.
        - 기존에 저장된 데이터 기준으로 소트하여 인덱스를 만들어 놓았는데 칼럼이 변형되면 인덱스 스캔 시작점을 찾을 수 없다.
          따라서 table full scan 하게 된다.

    3. IN 연산자 사용
        - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.
          하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

    4. LIKE문을 사용할 때 전체 범위를 설정할 시
        - 정규표현식 REGEXP 을 사용해도 인덱스를 더치지 않고 풀 스캔이 일어난다.
        - 가능하면 INSTR 을 사용하는 것도 나쁘지 않다. INSTR('비교할 대상', '비교하고자 하는 값', 비교를 시작할 위치, 검색된 결과의 순번)
          select * from table where INSTR(column_name, value) > 0

    5. 복합인덱스에서 첫 인덱스가 첫 조건으로 적용하지 않았을 경우
        - select * from table where name = 'word' or idx = 5 ??
        - name과 idx가 둘다 인덱스가 걸려있는 경우라해도, DBMS가 최적의 OR 조건을 뽑기 힘들어, FULL SCAN 하는 경우가 많다. (내용이 안맞음)

    6. NULL 조건의 사용
        - NULL 인 값이 많지 않아 인덱스를 통해 엑세스를 하고자 한다면 데이터 생성 시 디폴트로 0과 같이 데이터를 만들어주 는 것이 좋다.
        - 만약, NOT NULL 이 분석 대상이라면 해당 컬럼을 NULL 허용 컬럼으로 두는 것이 좋다.


- 인덱스 기본 사용법
    - Range Scan을 못 쓰는 경우
        - 인덱스 가공
            - 인덱스 스캔 시작점을 찾을 수 없기 때문이다. 일정 범위를 스캔하려면 ‘시작지점’과 ‘끝지점’이 있어야 한다.

        - Like 문을 사용
            ex) where 업체명 like '%대한%'
            - LIKE로 검색해도 위와 같이 ‘대한’이라는 글자를 가진 인덱스를 중간 글씨에서 찾아야 하기 때문에, Range Scan이 불가능하다.

        - OR 조건
            - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
            - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능 ??

        - IN 조건
            - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다. ??


- 루스 인덱스 스캔 ??
    - 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
    - 인덱스 레인지 스캔과 비슷하게 동작하지만 중간마다 필요하지 않은 키 값은 무시한다.
    - 일반적으로 group by 또는 max 등의 함수에 대해 최적화할 때 사용한다.
    ex) select dept_no, MIN(emp_no)
        from dept_emp
        where dept_no between 'doo2' and 'd004'
        group by dept_no;

        dept_emp 테이블은 dept_no와 emp_no 2개의 컬럼으로 인덱스를 구성하고 있다고 가정하며, 이 인덱스는 (dept_no, emp_no)를
        기준으로 정렬이 되어 있다. 즉 특정 dept_no 그룹 별로 처음에 있는 emp_no만 읽으면 된다. 즉, 인덱스에서 where 조건을
        만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있으므로 중간 중간 조건에 맞지 않으면 건너 뛴다.


- 결합 인덱스의 효율성이 떨어지는 경우
    결합 인덱스도 일반적인 인덱스와 마찬가지로 데이터들이 정렬되어 보관되기 때문에 소수의 데이터를 빠르게 찾는 것에는
    유리하지만 아래와 같이 스캔이 많이 생기게 된다면 효율성이 떨어지게 됩니다.

    아래의 예시들은 emp_pay_idx 인덱스를 사용하기는 하지만 스캔이 많이 생기는 경우로 인덱스의 효율성이
    떨어지는 경우들의 예시입니다.

    select * from emp_pay where 급여년월 LIKE '2021%' and 급여코드 = '정기급여';
    위 조건절의 경우 결합 인덱스의 첫 번째 컬럼인 급여년월의 조건이 있더라도 Equal(=)이 아닌 범위 연산자인
    LIKE '2021%' 조건을 사용했으므로, 세개의 칼럼이 모두 필요한 emp_pay_idx 인덱스를 찾을 때 두번째 칼럼인
    급여코드에 대한 조건을 B*Tree 에서 쉽게 찾을수가 없게 됩니다. 이는 결합 인덱스가 각 칼럼별로 정렬이 되어 있는
    것이 아니라 첫번째, 두번째, 세번째 칼럼이 결합이 되어 정렬이 되어있기 때문입니다. 이때 급여코드에 대한 조건은
    인덱스를 찾아가는 검색조건이 아니라 인덱스 값이 조건에 맞는지 여부를 검증하는 체크 조건이 됩니다.

    select * from emp_pay where 급여년월 = '202107' and 사원번호 = '20210401';
    위 조건절의 경우는 결합 인덱스의 첫번째 칼럼인 급여년월의 조건이 equal(=)이더라도 두번째 컬럼인 급여코드에
    대한 조건이 없으므로 세번째 칼럼인 사원번호 조건을 검색 조건이 아닌 체크 조건으로 밖에 사용할 수 없게 됩니다.
    즉 결합 인덱스에서 급여년월인 모든 데이터를 찾아서 사원번호 조건에 맞는지 일일이 확인하는
    풀 테이블 스캔이 일어나고 있는 셈입니다.


- 다중 인덱스 사용 시 주의사항
    - 다중 인덱스를 사용할 때 범위 조건은 인덱스를 타지만 이후 컬럼들은 인덱스를 타지 않음
        WHERE 컬럼1 = ?
        AND   컬럼2 = ?
        AND   컬럼3 BETWEEN ? AND ? -- 결합인덱스에서 '='이 아닌 연산자를 사용하는 첫 번째
        AND   컬럼4 = ?

        컬럼3에서 BETWEEN을 사용했기에 컬럼3 까지만 인덱스를 타고 후행컬럼인 컬럼4는 인덱스를 타지 않고 필터만 한다.
        그래서 결합인덱스 = 컬럼1 + 컬럼2 + 컬럼4 + 컬럼3으로 순서를 바꿔줘야한다.


- 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기
    1. 프라이머리 키(PK, Primary Key)와 클러스터링 테이블
        - 프라이머리 키(PK, Primary Key)의 특성
            데이터베이스, 특히 MySQL에서 프라이머리 키(PK, Primary Key)는 상당히 신중하게 결정되어야 한다.
            그 이유는 PK가 레코드의 저장 위치를 결정하기 때문이다. 그래서 PK는 NOT NULL, 유니크 등의 특성을 갖는다.
            MySQL은 PK를 기준으로 유사한 값들이 함께 조회되는 경우가 많다는 점에서 착안하여, PK가 유사한 레코드들끼리 묶어서 저장한다.
            유사한 것들을 묶는 것을 클러스터링이라고 하는데, 그래서 일반적으로 PK는 클러스터 인덱스(Clustered Index)라고도 불리며, 그 외의 일반적인 인덱스는 논클러스터 인덱스로 불린다.
            그리고 이러한 클러스터링 특성 때문에 레코드의 저장이나 PK의 변경은 처리 속도가 느리다.
            왜냐하면 우선 레코드를 추가하기 위해 PK 기반으로 레코드의 저장 위치를 탐색해야 하기 때문이다. 그리고 PK를 변경하는 것은 레코드가 저장된 물리적인 위치를 변경하는 작업이 수반되기 때문이다.
            하지만 그럼에도 불구하고 이러한 특성을 갖는 이유는 쓰기 작업을 희생해서라도 빠르게 읽기 작업을 처리하기 위함이다. 읽기 작업이 더욱 우선시 되는 이유는 일반적인 온라인 환경에서 읽기와 쓰기의 비율이 8:2, 9:1 정도이기 때문이다.

        - 클러스터링 테이블의 저장 방식
            클러스터링 테이블이란 클러스터 인덱스를 갖는 테이블이다. MySQL에서는 기본적으로 PK가 클러스터 인덱스이며,
            PK가 없으면 내부적으로 PK를 만들어내므로 모든 테이블이 클러스터링 테이블이라고 볼 수 있다.
            PK는 인덱스와 마찬가지로 별도의 자료구조에서 관리가 된다. PK와 테이블의 저장 방식을 살펴보면 다음과 같은데,
            이는 리프 노드에 실제 레코드의 모든 컬럼 값이 저장되어 있다는 점을 제외하면 일반적인 인덱스와 동일하다.

        - PK와 인덱스의 관계
            PK가 레코드의 물리적인 저장 위치를 결정하기 때문에, 인덱스는 PK에 의존한다.
            그래야 인덱스를 타고 들어와서 PK를 통해 저장된 위치에서 레코드를 읽어올 수 있기 때문이다.

        - 클러스터 인덱스의 장점과 단점
            - 장점
                - PK로 검색할 때 처리가 매우 빠름
                - 연속되는 PK로 조회할 경우 랜덤 I/O가 아닌 순차 I/O를 사용하여 처리 속도가 더욱 빠름
                - 인덱스가 PK값을 가지므로 인덱스로 PK 값만 조회하는 경우 효율적으로 처리될 수 있음(=커버링 인덱스)
            - 단점
                - 모든 인덱스가 PK에 의존하므로 PK 값이 클 경우 전체적으로 인덱스의 크기가 커지고, 페이지 양이 많아짐
                - 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림
                - INSERT 시에 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
                - PK를 변경할 때 레코드를 DELETE 및 INSERT 해야 하므로 처리 성능이 느림

            먼저 PK는 물리적인 저장 위치를 저장한다.
            그래서 PK로 검색 시에 처리가 매우 빠르며, 특히 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데, 랜덤 I/O는 임의의 장소에서 데이터를 가져오지만
            순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다. 그 외에도 인덱스가 PK 값을 가지므로,
            인덱스를 통해 PK만 조회하는 경우라면 내부 테이블까지 조회하지 않아도 되므로 효율적으로 처리된다.

            하지만 단점 역시 적지않다. 먼저 PK가 물리적인 저장 위치를 결정하므로 인덱스를 관리할 때 PK를 같이 저장한다. 데이터의 작업 단위는 페이지인데,
            PK가 클수록 다른 인덱스 구조도 커지면서 페이지가 많이 쪼개져 디스크 I/O 횟수가 증가하는 문제가 있다.
            또한 인덱스에 PK가 의존하여 저장되므로 인덱스로 조회 시에 인덱스로 PK를 찾고, PK로 레코드를 찾아야 한다.
            그 외에도 레코드를 INSERT 하거나 PK를 UPDATE 하는 등의 경우에 레코드의 저장 위치를 탐색해야 하므로 추가적인 성능 문제가 생길 수 있다.
            이러한 단점들에도 불구하고 일반적인 온라인 환경에서는 읽기 비중이 훨씬 높다. 그렇기 때문에 쓰기 성능을 희생해서라도 읽기 성능을 확보하는 것이다.

    2. 프라이머리 키(PK, Primary Key)의 동작 방식
        - PK가 없는 경우
            MySQL에서 테이블은 PK 기반으로 저장되기 때문에 PK가 필수적이다. PK가 없다면 데이터베이스(구체적으로는 스토리지 엔진)에서 별도의 처리를 통해 PK를 설정하는데, 다음과 같은 순서를 따른다.
                1. 기본적으로 PK를 클러스터링 키로 선택함
                2. PK가 없다면 NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택함
                3. 후보군이 없다면 내부적으로 자동 증가 유니크 컬럼을 추가한 후 클러스터링 키로 선택함

            3번으로 생성되는 내부 PK는 사용자에게 노출되지 않으며, 쿼리에서 사용할 수도 없다. 클러스터 인덱스는 테이블 당 하나만 가질 수 있는 엄청난 혜택이므로 반드시 생성해주는 것이 좋다.

        - PK를 변경하는 경우
            PK는 레코드의 저장 위치를 결정한다. 이 말은 PK가 변경되는 경우에 레코드가 저장된 물리적인 위치도 변경되어야 함을 의미
            PK는 물리적인 레코드의 저장 위치를 결정하기 때문에 단순히 값만 변경해서는 안되고, 레코드를 DELETE 한 후에 INSERT 해주어야 한다.
            따라서 2번의 디스크 I/O 작업이 필요하고, 인덱스 쪽에도 추가 작업을 유발할 수 있어서 비용이 상당히 크므로 PK는 변하지 않는 값으로 설정하는 것이 중요하다.