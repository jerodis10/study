- analyze table
    - ANALYZE 는 인덱스, 테이블, 클러스터의 통계정보를 생성 한다.
    - ANALYZE 가 생성한 통계정보들은 비용기준(Cost-based)의 옵티마이저가 가장 효율적인 실행계획을 수립하기 위해 최소비용을 계산할 때 사용된다.
    - 각 오브젝트의 구조를 확인하는 것과 체인(Chain) 생성 여부를 확인할 수 있으므로 시스템의 저장공간 관리를 도와준다.
    - ANALYZE 는 다음과 같은 통계정보를 생성하여 데이터 사전에 저장 한다.
        - 테이블 : 총 로우의수, 총 블럭의 수, 비어있는 블럭에 쓰여질 수 있는 빈 공간의 평군, 체인이 발생된 로우의 수, 로우의 평균 길이
        - 인덱스 : 인덱스의 깊이(Depth), Leaf block 의 개수, Distinct Key 의 수, Leaf Blocks/Key 의 평균,
                  Data blocks/key 의 평균, Clustering Factor, 가장 큰 key 값, 가장 작은 key 값
        - 컬럼 : Distinct 한 값의 수, 히스토그램 정보
        - 클러스터 : Cluster Key 당 길이의 평균

    - 주기적인 ANALYZE 작업을 수행 시켜 주어야 한다.
      테이블을 재생성 하거나, 새로 클러스터링을 한 경우, 인덱스를 추가하거나 재생성한 경우, 다량의 데이터를 SQL 이나
      배치 애플리케이션을 통해 작업한 경우 ANALYZE 를 수행 시켜 주는 것이 좋다.
      사용자는 USER_TABLES, USER_COLUMNS, USER_INDEXS, USER_CLUSTER 등의 자료사전 뷰를 통해 정보를 확인할 수 있다
      테이블을 ANALYZE 시킨다면 거기에 따르는 인덱스들도 같이 실시하는 것이 좋다.


- Index Fast Full Scan을 활용한 튜닝 사례
    select * from 공급업체
    where 업체명 like '%네트웍스%'
    - TABLE ACCESS Full
    - 실행시간 5초 이상 소요
    - 결과 건수 21
    =>
    select /*+ ordered use_nl(b) no_merge(b) rowid(b) */ b.*
    from (select /*+ index_ffs(공급업체 공급업체_X01) */ rowid rid
           from 공급업체
          where instr(업체명, '네트웍스') > 0) a, 공급업체 b
    where b.rowid = a.rid
    - 업체명 컬럼의 인덱스를 Fast Full Scan 해서 얻은 rowid를 이용해 테이블을 다시 억세스.
    - like 연산자보다 빠른 instr 함수 사용.
    - 최종 결과 건수가 많아지더라도 부분범위 처리가 가능한 애플리케이션 환경이면 유리.
    - 11g라면 결과 건수가 많더라도 인라인 뷰에 'order by rowid'를 추가함으로써 큰 효과를 얻을 수 있다(5절 (5)항에서 설명)
    - 데이터 건수가 많다면 parallel_index 힌트를 이용해 병렬쿼리도 가능.


- like '% ...' 성능 튜닝
    SELECT /*+ ordered use_nl(B) no_merge(B) rowid(B) */ B.*

      FROM ( SELECT /*+ index_ffs(공급업체 공급업체_X01) */ ROWID RID

                    FROM 공급업체

      WHERE INSTR(업체명, '네트웍스') > 0 ) A, 공급업체 B

    WHERE B.ROWID = A.RID;

    -- Index Fast Full Scan은 모든 컬럼이 인덱스에 포함돼 있을 때만 사용 가능

    -- 일단 해당 레코드의 ROWID만 Index Fast Full Scan으로 빠르게 get

    -- 인덱스로부터 얻은 ROWID로 테이블 액세스


- 인덱스(Index)란?
    인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
    특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
    이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면
    옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.
    인덱스에서 내가 원하는 데이터를 먼저 찾고 저장되어 있는 물리적 주소로 찾아갑니다.

    인덱스는 데이터베이스 테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스 객체이며 일종의 색인기술입니다.
    테이블에 index 를 생성하게 되면 index Table 을 생성해 관리합니다.
    가장 일반적인 B-tree 인덱스는 인덱스 키(인덱스로 만들 테이블의 컬럼 값)와 이 키에 해당하는 컬럼 값을 가진
    테이블의 로우가 저장된 주소 값으로 구성됩니다.

    인덱스를 설정하면 특정 컬럼들을 키 값으로 메모리 영역에 트리 구조로 저장해둡니다.
    그리고 디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
    인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.
    이를 위해 데이터가 추가/삭제 될 때마다 자료구조를 정렬하기 때문에 인덱스는 SELECT 성능을 향상시키는 대신 INSERT, UPDATE, DELETE 의 성능이 떨어지게 됩니다.


- InnoDB Adaptive Hash Index
    - MySQL 은 기본으로 InnoDB 를 사용하고 InnoDB 는 B-Tree 를 사용합니다.
    - PK 가 아닌 컬럼으로 인덱스를 지정하면 Non Clustered Index 가 생성됩니다.
    - 그래서 인덱스로 컬럼을 조회하면 Secondary 인덱스를 기반으로 PK 를 찾은 뒤 다시 Primary Index 로 데이터를 찾아냅니다.
    - 인덱스를 두번 타기 때문에 2 * O(log n) 비용이 듭니다.
    - 그래서 자주 사용되는 컬럼을 해시로 정의해서 B-Tree 를 타지 않고 바로 데이터에 접근할 수 있게 하는 걸 Adaptive Hash Index
    - 미리 캐싱한 해시값으로 조회하기 때문애 O(1) 의 속도를 보여주지만 어떤 값을 해싱할지는 옵티마이저가 판단하기 때문에 제어할 수 없다는 약점이 있습니다.


- 인덱스  https://bcp0109.tistory.com/365
    - 인덱스 란
        - 인덱스를 설정하면 특정 컬럼들을 키 값으로 메모리 영역에 트리 구조로 저장해둡니다.
          그리고 디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
          인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.
          이를 위해 데이터가 추가/삭제 될 때마다 자료구조를 정렬하기 때문에 인덱스는 SELECT 성능을 향상시키는 대신 INSERT, UPDATE, DELETE 의 성능이 떨어지게 됩니다.

    - 인덱스 종류
        - Clustered Index vs Non-Clustered Index
            - Clustered Index
                - 이름 그대로 인접한 데이터들을 한곳으로 모았다는 뜻
                - PK 설정 시 자동으로 클러스터드 인덱스로 만들어짐
                - 테이블당 1개씩만 허용
                - 물리적인 데이터를 갖고 있음
                - 항상 정렬된 상태를 유지하고 노드 내에서도 정렬되어 있음
                - Non Clustered 인덱스에 비해 조회 속도가 빠르지만 삽입/수정/삭제는 더 느림

            - Non Clustered Index
                - UNIQUE 로 설정된 컬럼에 자동으로 생성됨
                - 인덱스 페이지는 로그 파일에 저장됨
                - 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됨
                - 기본키는 아니지만 성능 향상을 위해 임의의 컬럼을 지정해서 만든 인덱스

    - 인덱스 자료구조
        - B-Tree 인덱스
            - Balanced Tree 의 약자로서 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적으로 사용되는 알고리즘
            - B-Tree 인덱스는 컬럼의 값을 변경시키지 않고 구조체 내에서 항상 정렬된 상태를 유지
            - B-Tree 는 최상위에 루트 (Root) 노드가 존재하고 하위에 브랜치 (Branch) 노드, 마지막에 리프 (Leaf) 노드로 되어 있습니다.
            - 부모 노드를 기준으로 왼쪽 자식 노드는 더 작은 값 오른쪽 자식 노드는 더 큰값을 갖고 있습니다.

        - 왜 B-Tree 인가?
            - 인덱스로 사용할 수 있는 자료구조는 여러 개가 있을 겁니다.
            - Tree 구조의 Worst 시간복잡도는 한쪽으로 모든 자식 노드가 쏠려있는 형태인 O(n) 입니다.
            - 그래서 우리는 자식 노드가 양쪽에 골고루 퍼져있는 Balanced Tree 를 사용합니다.
            - Balanced Tree 중에는 RedBlack Tree 도 있는데 왜 사용하지 않을까요? 해시 테이블은 O(1) 인데 왜 사용하지 않을까요?

        - 다른 트리 구조를 사용하지 않는 이유
            - RedBlack Tree 는 B-Tree 와 마찬가지로 정렬된 상태와 밸런스를 유지
            - B-Tree 와 차이가 없을 것 같은데 왜 사용하지 않을까요?
            - 가장 큰 차이점은 B-Tree 는 노드 하나에 여러 개의 데이터를 저장할 수 있다
            - 노드에서 배열 형태로 여러 데이터를 저장할 수 있기 때문에 트리 포인터를 참조해서 계속 depth 를 타고 들어가는 것보다 효율적이고 이는 데이터가 많아질수록 차이가 두드러집니다.

        - Hash 테이블을 사용하지 않는 이유
            - 해시 테이블은 Hash 함수를 사용해서 키 값을 해싱한 후에 테이블에 저장합니다.
            - 해시 테이블은 분명 한 가지 키에 대한 탐색은 효율적입니다.
            - 하지만 데이터가 정렬되어 있지 않기 때문에 부등호 (<, >) 를 사용하지 못한다는 단점이 있습니다.

        - B-Tree 인덱스의 쿼리별 특징
            - SELECT
                - 특정 키 값을 찾기 위해 자식 노드를 계속 타고 들어가는 방식
                - 마지막 리프 노드에는 레코드의 주소가 존재하고 이 값으로 테이블 레코드를 찾을 수 있음

                - B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
                  그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

            - INSERT
                - B-Tree 에 새로운 키값을 저장할 때는 우선 적절한 위치를 찾아야함
                - 새로운 키값과 레코드 정보는 리프 노드에 저장
                - 만약 리프 노드가 꽉찼다면 트리를 재구성하여 리프 노드를 분리
                - 분리 과정에서 해당 리프 노드의 부모 노드까지 영향이 갈 수 있음
                - 이러한 이유로 INSERT 작업은 상대적으로 비용이 많이 듬
                - 인덱스가 많으면 많을수록 이런 비용이 추가로 들기 때문에 너무 많은 인덱스를 추가하는 건 성능에 영향을 줌

            - DELETE
                - B-Tree 에서 키 값 삭제는 간단
                - 해당 키를 찾아서 삭제 마크만 하면 작업이 완료
                - 삭제 마킹된 인덱스 키 공간은 그대로 두거나 재활용 가능

            - UPDATE
                - 인덱스는 항상 정렬된 상태로 유지됨
                - 단순히 인덱스 키 값을 수정한다면 트리의 전체 구조를 바꿔야 할 수도 있음
                - 그래서 B-Tree 에선 키 변경이 아닌 기존 키 삭제 (DELETE) 후 새로운 키 추가 (INSERT) 방식을 사용
                - 따라서 키 값의 잦은 수정은 성능에 큰 영향을 미침

    - 인덱스 설정 시 고려사항
        - 인덱스의 갯수
            - 인덱스의 갯수는 3 ~ 4 개가 적당
            - 인덱스의 갯수가 너무 많으면 다음과 같은 이슈가 존재
                - 데이터 삽입/수정/삭제 시마다 인덱스도 같이 추가하거나 수정/삭제 해주어야 해서 성능상 이슈가 존재
                - 데이터 삽입시마다 인덱스도 같이 추가하기 때문에 인덱스가 늘어날수록 더 많은 메모리를 차지함
                - 인덱스가 많아지면 옵티마이저가 잘못된 인덱스를 선택할 확률이 높아짐 (인덱스 힌트로 원하는 인덱스를 지정할 순 있음)

        - 인덱스를 걸기에 적절한 컬럼
            - 인덱스의 갯수에 한계가 있다면 적절한 인덱스 컬럼을 정하는 것도 중요
            - 인덱스는 카디널리티 (Cardinality) 가 높은 컬럼에 지정하는 게 좋습니다.
            - 카디널리티가 높다는 말은 데이터의 중복이 적다는 뜻인데 대표적으로 ID, 주민번호 등이 있습니다.
            - 반대로 성별 같은 중복된 데이터가 많은 경우 카디널리티가 낮다고 표현
            - 성별에 인덱스를 거는 경우 인덱스를 타더라도 남/녀 두가지만 존재하기 때문에 결국 나머지 조건에 맞는 데이터는 직접 풀스캔을 해서 찾아야 합니다.
            - 하지만 ID 같이 중복된 값이 없는 경우 해당하는 데이터를 빠르게 찾을 수 있습니다.

        - 읽어야 하는 레코드 갯수
            - 인덱스는 일반적으로 단 하나의 데이터를 구할 때 가장 효율적
            - 여러 개의 데이터를 구한다면 인덱스를 통해 레코드의 주소를 찾아 데이터의 레코드를 읽는 작업을 반복해야 합니다.
            - 그래서 만약 많은 레코드를 한번에 조회한다면 오히려 인덱스를 사용하지 않고 직접 테이블을 읽는 것이 더 효율적일 수 있습니다.
            - 일반적으로 DBMS 의 옵티마이저는 인덱스를 사용해 레코드 1건을 읽는 것이 테이블에서 직접 읽는 것보다 4 ~ 5배 정도 비용이 더 많이 든다고 예측
            - 그러므로 인덱스를 통해 읽어야 할 레코드가 전체 테이블의 20 ~ 25% 이상이라면 직접 테이블을 읽는 것이 효율적

        - 복합 인덱스를 구성할 때
            - 인덱스는 여러 개의 컬럼을 동시에 지정할 수도 있는데 어떤 순서로 구성하느냐에 따라 성능이 달라집니다.
            - 인덱스는 트리 구조로 되어있다고 했는데, 여러 개의 컬럼을 함께 키 값으로 지정하는 경우 먼저 첫 번재 컬럼을 기준으로 정렬된 뒤에 두번째 컬럼이 정렬되어 있습니다.
            - 이 말은 즉 첫 번째 컬럼 없이 두 번째 컬럼만 갖고 인덱스를 조회하면 제대로 된 위치를 찾을 수 없다는 뜻
            - 그러므로 복합 인덱스를 구성했다면 조회할 때 앞 순서의 조건을 반드시 포함해야 인덱스를 태울 수 있습니다.
            - 여러 개의 컬럼이 있다면 카디널리티가 높은 순에서 낮은 순으로 지정하는게 인덱스의 효율을 이끌어낼 수 있습니다.
            - 과거에는 인덱스의 컬럼 순서와 조회 컬럼 순서를 맞춰야 인덱스를 탔지만 최근에는 옵티마이저가 알아서 인덱스 순서에 맞춰주기 때문에 거의 차이가 없습니다.
            - 그래도 재배열하는 과정을 생략하기 위해 최대한 맞추는게 좋다.

    - 인덱스 사용 시 주의사항
        - 다중 인덱스를 사용할 때 범위 조건은 인덱스를 타지만 이후 컬럼들은 인덱스를 타지 않음
            WHERE 컬럼1 = ?
            AND   컬럼2 = ?
            AND   컬럼3 BETWEEN ? AND ? -- 결합인덱스에서 '='이 아닌 연산자를 사용하는 첫 번째
            AND   컬럼4 = ?

            컬럼3에서 BETWEEN을 사용했기에 컬럼3 까지만 인덱스를 타고 후행컬럼인 컬럼4는 인덱스를 타지 않고 필터만 한다.
            그래서 결합인덱스 = 컬럼1 + 컬럼2 + 컬럼4 + 컬럼3으로 순서를 바꿔줘야한다.

        - 인덱스를 타지 않는 경우
            1. 인덱스 컬럼의 변형
                - 인덱스에 변형을 가하게 되면, DBMS가 인덱스를 이용하지 않는다.
                - 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 range scan 가능
                  인덱스 칼럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문
                  그래서 인덱스 칼럼을 가공하면 index full scan 을 하게 된다.
            2. 부정형의 사용
                - NOT일 경우 무조건 인덱스를 안타는 것이 아니라 일반적으로 NOT에 사용된 값이 아닌 데이터 비율이 높은 경우가 많기 때문에 인덱스를 타지 않는다.
            3. IN 연산자 사용
                - IN일 경우에도, IN에 포함된 데이터들의 비율이 매우 높다면 FULL SCAN을 하는 것이 낫다고 DBMS가 판단하면 인덱스를 타지 않는다.
                - Mysql에서는 range_optimizer_max_mem_size 설정의 용량을 In절의 파라미터가 넘어서면 FullScan을 한다.
                  다른 DB의 경우도 파라미터가 많아지면 옵티마이저가 FullScan을 할 수 있다.
                - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.
                  하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능
            4. LIKE문을 사용할 때 전체 범위를 설정할 시
                - 문자열로 이루어진 값을 인덱스로 잡았을 때, %가 앞쪽에 사용되면 정렬 순서를 사용할 수 없으므로 테이블 FULL SCAN이 이루어진다.
                  select * from table  where name like 'word%'; -> 쿼리가 이런 경우 인덱스를 탄다. 문자열 정렬 순서를 그대로 이용할 수 있기 때문이다. (Index Range Scan 이 가능)
                  인덱스를 걸면 해당 컬럼은 정렬이 됩니다. 정렬된 문자열 앞부분부터 검색해야 하는데, LIKE절이 '%'로 시작하면 앞 문자열을 모르니 인덱스를 사용할 수 없게 됩니다.

                - 정규표현식 REGEXP 을 사용해도 인덱스를 더치지 않고 풀 스캔이 일어난다.
                - 가능하면 INSTR 을 사용하는 것도 나쁘지 않다. INSTR('비교할 대상', '비교하고자 하는 값', 비교를 시작할 위치, 검색된 결과의 순번)
                  select * from table where INSTR(column_name, value) > 0  ???
            5. 복합인덱스에서 첫인덱스가 첫조건으로 적용하지 않았을경우
                - select * from table where name = 'word' or idx = 5
                - name과 idx가 둘다 인덱스가 걸려있는 경우라해도, DBMS가 최적의 OR 조건을 뽑기 힘들어, FULL SCAN 하는 경우가 많다.
            6. NULL 조건의 사용
            7. 인덱스 컬럼의 내부적인 데이터 변환
                - 문자값 데이터타입을 갖는 컬럼에 ‘값’ → 값 을 하지 말고 정확한 데이터 타입을 넣어야 인덱스를 탈 수 있다.
            8. OR 조건 사용
                - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

    - InnoDB Adaptive Hash Index
        - MySQL 은 기본으로 InnoDB 를 사용하고 InnoDB 는 B-Tree 를 사용합니다.
        - PK 가 아닌 컬럼으로 인덱스를 지정하면 Non Clustered Index 가 생성됩니다.
        - 그래서 인덱스로 컬럼을 조회하면 Secondary 인덱스를 기반으로 PK 를 찾은 뒤 다시 Primary Index 로 데이터를 찾아냅니다.
        - 인덱스를 두번 타기 때문에 2 * O(log n) 비용이 듭니다.
        - 그래서 자주 사용되는 컬럼을 해시로 정의해서 B-Tree 를 타지 않고 바로 데이터에 접근할 수 있게 하는 걸 Adaptive Hash Index
        - 미리 캐싱한 해시값으로 조회하기 때문애 O(1) 의 속도를 보여주지만 어떤 값을 해싱할지는 옵티마이저가 판단하기 때문에 제어할 수 없다는 약점이 있습니다.

    - Covering Index
        - 인덱스를 사용하면 특정 컬럼 값을 키로 하여 데이터의 주소값을 구한 뒤 해당 주소값으로 다시 테이블에 접근해서 최종 데이터를 구합니다.
        - 커버링 인덱스란 인덱스에 이미 필요한 데이터가 전부 존재해서 테이블에 접근할 필요가 없는 인덱스를 의미
        - 인덱스는 기본적으로 Non Clustered Index 에서 먼저 값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.
        - 여기서 커버링 인덱스가 사용되었다는건 Clustered Index 까지 통하지 않고 Non Clustered Index 만으로도 데이터를 구할 수 있다는 뜻
        - 커버링 인덱스가 적용되면 EXPLAIN 실행 시 Extra 필드에 Using index 라고 표시

    - 인덱스 스캔 방식  https://jungmina.com/720
        - Index Range Scan
            - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식(수직적 탐색 후 필요한 범위만 수평적 탐색)
            - 항상 빠른 속도를 보장하진 않음
            - 인덱스 스캔 범위를 얼만큼 줄일 수 있느냐, 테이블 액세스 횟수를 얼만큼 줄일 수 있느냐가 관건
                 => 인덱스 설계와 SQL 튜닝의 핵심 원리
            - 인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 함
            - where 조건에서 =, >, <, like 'abc%' 같은 경우에 선택됨

        - Index Full Scan
            - 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
            - 최적의 인덱스가 없을 때 차선책(인덱스 선두 컬럼이 조건절에 없을 경우)
            - 최종 결과값이 적을때 Table Full Scan보다 Index Full Scan이 훨씬 효율적

        - Index Unique Scan
            - 수직적 탐색만으로 데이터를 찾는 스캔 방식
            - Unique Index를 통해 '=' 조건으로 탐색하는 경우
            * Unique Index를 이용했지만 Index Range Scan이 나타나는 경우
                - Unique Index를 통해 범위 조건(between, 부등호, like)으로 검색하는 경우
                - 결합 형태인 Unique Index의 일부 컬럼만으로(선두 컬럼 포함) 검색하는 경우

        - Index Skip Scan
            - 인덱스가 세 개의 컬럼으로 구성되어 있는데 중간 컬럼에 대한 조건절만 누락된 경우나 Distinct Value가 적은 두 개의 선두 컬럼이 모두 누락된 경우
            - 선두 컬럼이 범위 조건(between, 부등호, like) 검색인 경우
            - 조회 조건에 인덱스 선두 컬럼이 없는데 선두 컬럼의 Distinct Value 개수가 적은 경우

        - Index Fast Full Scan
            - Index Full Scan보다 빠름
            - Index를 논리적 구조 순으로 읽지 않고 물리적으로 디스크에 저장된 순서대로 읽음(Segment 전체를 Scan)
            - Multiblock I/O
            - 결과 집합이 Sorting된 상태가 아닐 수 있음
            - 쿼리에 사용되는 모든 컬럼이 인덱스 컬럼에 포함돼 있을 때만 사용 가능
            - 병렬스캔 가능


- SORT MERGE JOIN (정렬 병합 조인)
    - SORT MERGE JOIN 이란?
        조회의 범위가 많을 때 주로 사용하는 조인 방법론이며 양쪽 테이블을 각각 Access 하여 그 결과를 정렬하고
        그 정렬한 결과를 차례로 Scan 해 나가면서 연결고리의 조건으로 Merge 를 하는 방식
        주로 조인 조건 칼럼에 인덱스가 없거나, 출력해야 할 결과 값이 많을 때 사용
        조회의 범위가 좁을 때 유리한 Nested Loop Join 의 조인 방식과 장단점이 서로 바뀌어있다고 생각하시면 이해하기 쉽습니다.

    - SORT MERGE JOIN 의 사용처
        1. 연결 고리에 인덱스가 전혀 없는 경우
        2. 대용량의 자료를 조인할때 유리한 경우
        3. 조인 조건으로 <, >, <=, >=와 같은 범위 비교 연산자가 사용된 경우
        4. 인덱스 사용에 따른 랜덤 액세스의 오버헤드가 많은 경우

    - SORT MERGE JOIN 의 동작 방식
        1. 각 테이블에 대해 동시에 독립적으로 데이터를 먼저 읽어 들인다.
        2. 읽혀진 각 테이블의 데이터를 조인을 위한 연결고리에 대하여 정렬을 수행한다.
        3. 정렬이 모두 끝난 후에 조인 작업이 수행한다.

    - SORT MERGE JOIN 의 성능 개선 포인트
        - ACCESS 하는 속도를 향상 시킨다.
            SORT MERGE JOIN 은 가장 먼저 양쪽 테이블을 Access 하는 과정을 거쳐야 합니다. 이 속도를 빠르게 해 준다면
            속도 향상에 도움이 되겠죠. 테이블을 Access 할 때 FULL TABLE SCAN 이냐 INDEX RANGE SCAN 이냐 하는 등
            테이블을 Access 하는 방법을 다양한 방법을 통해 최적화시킨다면 SORT MERGE JOIN 의 속도도
            자연스럽게 최적화할 수 있습니다.

        - 정렬 속도의 향상
            SORT MERGE JOIN 은 양쪽 테이블에서 조회한 데이터들을 정렬시켜야 합니다. 이때 조인 조건 컬럼이
            이미 정렬되어 있다면 정렬을 하는 작업을 단축시켜 검색 속도 향상에 도움이 될 것입니다.

        - 양쪽의 정렬까지 완료되는 속도를 맞추어줌
            SORT MERGE JOIN 은 양쪽 테이블을 ACCESS 하고 조회한 데이터들을 정렬할때 어느 한쪽이라도 정렬 작업이
            종료되지 않으면 한쪽이 대기 상태가 되고 다른 한쪽의 정렬이 완전히 끝날 때까지 조인이 시작될 수 없습니다.
            그렇기에 두 테이블 ACCESS 속도와 정렬 속도를 최대한 비슷하게 맞추어주는 것이 좋습니다.
            비교해야 할 두 테이블의 데이터 양이나 정렬 속도를 고려하여 최대한 맞춰주는 것이 효율성 측면에서 좋습니다.

        - SORT_AREA_SIZE 최적화
            SORT MERGE JOIN 은 두 테이블 간의 비교가 이루어지기 전에 수행하는 정렬 작업을 위해 별도의 정렬 공간이 필요하며
            이 공간은 SORT_AREA_SIZE 크기만큼 메모리를 할당받아 사용하게 되고, 메모리가 부족하다면
            Temporary Table Space 를 이용하여 정렬을 수행하게 됩니다. 이때 Temporary Table Space 를 사용하면
            딜레이가 생기므로 SORT_AREA_SIZE 를 적당한 크기로 설정해두는 것이 속도 향상에 도움이 됩니다.


- HASH JOIN (해시 조인)
    - HASH JOIN 이란?
        HASH 조인은 조인될 두 테이블 중 하나를 해시 테이블로 선정하여 조인될 테이블의 조인 키 값을 해시 알고리즘으로
        비교하여 매치되는 결과값을 얻는 방식
        HASH JOIN 은 비용 기반 옵티마이저를 사용할 때만 사용될 수 있는 조인 방식이며 '=' 비교를 통한 조인에서만
        사용될 수 있습니다. 주로 많은 양의 데이터를 조인해야 하는 경우에 주로 사용

    - HASH JOIN 의 사용처
        1. JOIN 컬럼에 적당한 인덱스가 없어 NL JOIN 이 비효율적일 때
        2. JOIN Access 량이 많아 Random Access 부하가 심하여 NL JOIN 이 비효율적일 때
        3. Sort Merge Join 을 하기에는 두 테이블이 너무 커 Sort 부하가 심할 때
        4. 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 JOIN 할 때

    - HASH JOIN 의 동작 방식
        1. 둘 중 작은 집합(Build Input)을 읽어 Hash Area 에 해시 테이블을 생성한다.
            (해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인에 엔트리를 연결)
        2. 반대쪽 큰 집합(Probe Input)을 읽어 해시 테이블을 탐색하면서 JOIN 한다.
        3. 해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인을 스캔하면서 데이터를 찾는다.

    - HASH JOIN 의 성능 개선 포인트
        - HASH TABLE 을 만드는 과정을 효율화 한다.
            HASH JOIN 은 해시 테이블을 생성하는 비용이 수반되므로 이 과정을 효율화하는 것이 성능 개선에 있어 가장 중요합니다.
            그렇기에 HASH TABLE 로 만들 Build Input 이 Hash Area 에 담길 정도로 충분히 작아야 하며
            Build Input 해시 키 칼럼에 중복 값이 거의 없어야 효율적인 동작을 기대할 수 있습니다.

        - CPU 의 성능을 향상한다.
            HASH BUCKET 이 조인 집합에 구성되어 해시 함수 결과를 저장해야 하는데 기본적으로 HASH_AREA_SIZE 에
            지정된 크기만큼의 메모리가 할당되어 사용됩니다. 이러한 처리에는 많은 메모리와 CPU 자원을 소모하게 됩니다.
            그렇기에 CPU 의 자원이 넉넉하다면 다른 조인에 비해 보다 좋은 효율을 내지만 부족한 상황에서는 다른 조인 방법보다
            느려질 수도 있습니다. 그러므로 CPU 의 성능을 향상한다면 HASH JOIN 의 성능을 향상할 수 있습니다.

        - 충분한 PGA 메모리 확보
            Hash Area 는 PGA 메모리에 할당되는데 Build Input 이 HASH_AREA_SIZE 를 초과하게 되면 가장 큰 순서대로
            Hash Bucket 이 Temporary Table Space 로 내려가서 구성됩니다. 디스크로 내려간 Hash Bucket 에
            변경이 일어날 때마다 디스크 I/O가 발생하게 되어 성능이 현저하게 저하됩니다.

        * HASH_AREA_SIZE
          HASH JOIN 에 사용되는 최대 메모리 SIZE 를 지정하는 설정값입니다. Hash Join 에서 사용되는
          해쉬 메모리 크기(HASH_AREA_SIZE)의 기본 값은 SORT_AREA_SIZE 의 2배입니다. 9i 이상에서 값을 지정하는 것을
          권장하지 않고, PGA_AGGREGATE_TARGET parameter 사용을 권장합니다.

    - 사용법
        /*+leading(a c) use_hash(c)*/
        아마 힌트를 주지 않아도 옵티마이저가 알아서 hash 조인을 하는 경우도 있지만, 이러한 힌트를 명시해주는 것이 바람직


- 조인 방법
    - 중첩 루프 조인(Nested Loop Join, NLJ)
        - where 절에 있는 조건에 따라 두 테이블에서 하나의 테이블을 기준으로 삼아 다른 하나의 테이블에 있는 데이터를 읽는 방식으로 조인을 수행.
        - 기준이 되는 테이블을 드라이빙 테이블/아우터 테이블 이라고 하며, 나머지 테이블을 이너 테이블 이라고 한다.
        - 프로그래밍의 for 이중루프랑 같다.
        - NLJ는 메모리가 필요없는 조인 방법으로 추가적인 메모리 비용이 들지 않는다.
        - 어떤 테이블을 드라이빙 테이블로 선택하느냐가 중요하다. 왜냐면 드라이빙 테이블의 로우를 가지고 이너를 검색하기 때문

    - 정렬 병합 조인(Sorted Merge Join, SMJ)
        - 두 테이블을 각각 정렬한 다음 조인조건에 맞는 건을 찾아 합치는 방식이다.
        - 드라이빙 테이블이 별도로 존재하지 않으며, 모두 독립적으로 동등한 레벨에 있다.
        - 정렬 작업을 위해 추가적인 메모리를 사용한다. 디스크 I/O가 발생한다.
        - NJL보다 많은 양의 데이터를 처리할 때 유리하며, 메모리만 사용해서 정렬 작업을 수행한다면 넓은 범위의 값을 검색하는데 유용하다.
        - 두 테이블의 데이터를 각각 정렬하는 작업이 전체 성능에 영향을 많이 끼치게 된다. 해서 select 리스트에서 불필요한 칼럼은 제거해서
          정렬 작업 수행 시 부하를 적게 줘야 한다.
        - 일반적으로 >, >=, <, <= 와 같은 비동등 연산자가 사용될 때 쓰인다.

    - 해쉬 조인(HJ)
        - 두 테이블 중 where 조건에 의해 필터링된 로우 수가 적은 테이블을 대상으로 해쉬 테이블을 만든 후에 조인 조건에 따라 다른 하나의 테이블의 데이터를 검색하는 방법이다.
        - HJ 방법은 해시 테이블이 드라이빙 테이블이 되어 NLJ를 수행한다고 보면 된다.
        - 해시 테이블은 HASH_AREA_SIZE에 지정된 메모리 값 내에서 해시 테이블을 만들게 되므로 대상 테이블의 크기가 이 값 내에 있을 경우 유용한 조인
        - 보통 HASH_AREA_SIZE 값은 SORT_AREA_SIZE 값의 2배로 설정한다.
        - 해시 조인은 조인 조건에서 동등조건이 사용되었을 때만 가능하다.
        - 보통 반환되는 로우수가 적은 테이블(이 테이블을 대상으로 해시 테이블을 만든다.)과 이에 반해 반환되는 로우수가 상당히 많은 테이블을 조인 시에 유리하다.

* 주의사항 :
  /*+ 다음에 스페이스를 반드시 줘야 함.
  테이블 알리아스를 사용해야 한다. 테이블의 물리명을 사용하면 안됨.

   SINGLE TABLE QUERY에서는 HINT 절에 table 명을 주는 것이 원칙이다.

  * Hint 내의 table_name은 alias를 사용하였을 경우에는 반드시 table alias name으로 지정하여야 한다.

  * 그 이유는 다음과 같이 SQL이 사용될 경우도 있기 때문니다.

  (SELF-JOIN)

  select /*+ index_desc(a a_pk) */
  *
  from t1 a, t1 b
  where a.key1 = 'a'
  and a.key1 = b.prev_c1(+)
  and a.seq = b.pseq_no(+)
  and rownum = 1

  위와 같이 동일한 TABLE이 FROM 절 뒤에 복수로 나오는 경우 (Recursive 관계)가 있을 수 있는데 이 때 Hint 절의 table 명을
  유일하게 줄 수가 없으므로 반드시 table alias name을 주어야  원하는 답이 나온다.


- 인덱스가 무엇인가요?
    - RDB에서 테이블의 검색성능을 높여주는 방법중 하나입니다. 사전의 목차처럼 인덱스를 이용하여 원하는 데이터에 빠르게 접근할 수 있습니다.
      특정 컬럼을 서치키로 설정하여 인덱스를 생성하면 그 값으로 정렬하여 별도 파일에 저장합니다. 인덱스는 보통 테이블의 10% 정도 저장공간을 차지하는 데
      이유는 서치키와 포인터만 저장하기 때문입니다. 여러가지 자료구조로 인덱스를 구현할 수 있지만 대부분 B+트리를 이용하여 인덱스의 구조를 이룹니다.


- 인덱스의 종류가 있나요?
    1) 클러스터형 인덱스 : 보통 PK를 기준으로 정렬하여 데이터를 저장합니다. 그렇게 되면 테이블 자체가 하나의 인덱스가 되고 이를 클러스터형 인덱스라고 합니다.
    2) 보조 인덱스 : 별도 공간에 생성되는 인덱스를 의미합니다. PK 외에 원하는 컬럼에 대해서 인덱스를 생성할 수 있습니다. secondary index 라고도 합니다.


- 인덱스를 많이 쓰면 되나요?
    - 안됩니다. 검색성능은 향상될 수 있으나 추가 저장공간도 필요하고 변경작업이 많아지면 인덱스 재구성에 필요한 비용이 커집니다.
      예를 들어, 어떤 테이블의 인덱스가 5개 있다고 한다면 데이터의 변경이 일어나는 경우 5개의 인덱스 자료구조의 재구성이 필요합니다.


- 어떤 컬럼에 인덱스를 써야하나요?
    - 인덱스는 where 에서 자주 사용되고 수정빈도가 낮으며 카디널리티가 높은 컬럼을 선택하는 것이 좋습니다. 카디널리티가 높다는 것은 중복된 데이터가 적다는 뜻입니다.


- NoSQL
    - 정의
        - NoSQL은 RDBMS의 형태가 아닌 일관성 모델(비관계형 모델)을 이용하는 데이터 저장을 말하는 것
        - 단순 검색 및 추가작업에 있어서 매우 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에 있어서 매우 뛰어난 성능

    - 대표적인 NoSQL (NoSQL은 다양한 모델을 기반으로 데이터베이스를 설계할 수 있는데, 크게 4가지로 분류할 수 있다.)
        - key-value Database
            - 기본적인 패턴으로 KEY-VALUE 하나의 묶음(Unique)으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장시 용이
            ex) Riak, Redis, Voldmort
        - Document Database
            - 테이블의 스키마가 유동적, 즉 레코드마다 각각 다른 스키마를 가질 수 있다.
            - 보통 XML, JSON과 같은 DOCUMENT를 이용해 레코드를 저장
            - 트리형 구조로 레코드를 저장하거나 검색하는 데 효율적
            ex) MongoDB, CouchDB
        - BigTable Database
            ex) Hbase, Casandra
        - Graph Database
            - 데이터를 노드로(그림에서 파란, 녹색 원) 표현하며 노드 사이의 관계를 엣지(그림에서 화살표)로 표현
            - 일반적으로 RDBMS보다 성능이 좋고 유연하며 유지보수에 용이
            ex) Sones, AllegroGraph

    - 장점
        - RDBMS에 비해 저렴한 비용으로 분산 처리와 병렬 처리가 가능
        - 비정형 데이터 구조 설계로 설계 비용이 감소
        - 관계형 데이터베이스의 relation과 join 구조를 linking과 embedded로 구현하여 성능이 빠름
        - Big Data 처리에 효과적
            - Scale out 구조를 채댁하여 서버 확장에 용이하며 더 많은 데이터를 저장
        - 가변적인 구조로 데이터 저장이 가능
        - Document based(Schema-less) 구조로 데이터 모델의 유연한 변화가 가능
        - json 구조로 RDBMS 테이블 구조에 비해 데이터를 직관적으로 파악
        - Auto Sharding을 지원

        * sharding이란
            - 단일의 논리적 데이터셋을 다수의 데이터베이스에 쪼개고 나누는 방법
            - 샤딩은 데이터셋이 단일 데이터베이스에서 저장하기에 너무 클 때 필수적으로 사용된다.

    - 단점
        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 복잡한 join은 어려움(다양하고 복잡한 데이터 쿼리), document based이기 때문
        - NoSQL은 sharding 방식을 사용해서 큰 테이블을 여러 서버에 나누어 저장한다.
          어떤 데이터가 update 되었을 때, NoSQL은 중복 저장된 서버들에 해당 update가 적용되기까지는 시간이 걸린다.
        - RDBMS는 모든 서버를 update 되기전까지는 해당 데이터 또는 테이블에 lock을 걸어 읽기 금지를 한다. 따라서 데이터에 대한 일관성이 보장된다.
          하지만 NoSQL에서는 lock을 하게 될 경우 느려지므로 RDBMS와 같은 lock을 하지 않는다.
        - 데이터 일관성이 항상 보장되지 않는다.


- Clustered Index vs Non-Clustered Index
    - Clustered Index
        - 정의
            - 데이터페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
            - 데이터페이지는 리프 레벨
            - 클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 된다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있다.
        - 특징
            - 테이블 당 1개만 허용
            - 기본 키 설정시 자동으로 만들어짐
            - 테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
            - 데이터 입력, 수정, 삭제 시 항상 정렬을 유지함
            - 물리적으로 행을 재배열 (실제 DB의 데이터파일에 정렬이 되어 있는 상태로 디스크에 저장)

    - Non-Clustered Index
        - 정의
            - 데이터 페이지를 건들지 않고, 별도의 장소에 인덱스 페이지를 생성
            - 우선 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬하고 데이터 위치 포인터를 생성한다.
            - 데이터 위치 포인터는 데이터가 위치한 고유한 값이 된다.
        - 특징
            - 인덱스 페이지를 별도로 저장
            - 테이블 자체는 되지 않고, 인덱스 페이지에만 정렬


- 인덱스 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어진다.
    - 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다.
      UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해준다.
      만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어,
      SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.


- Index를 사용하면 좋은 경우
    - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
    - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
    - 데이터의 중복도가 낮은 컬럼
    - 필드에 저장된 값을 찾는 작업이 예상되는 경우
    - 필드의 값을 정렬하는 작업이 예상되는 경우


- 왜 Index를 생성하는데 b-tree를 사용하는가
    - 인덱스도 크기가 커져 보조 기억 장치에 저장되게 되는데 이 또한 디스크 I/O가 발생하게 되는 것이다.
      따라서 B-Tree의 깊이를 줄여야 디스크 I/O를 줄일 수 있기 때문에 B-Tree를 사용한다.

- 프로시저
    - 장점
        - 하나의 요청으로 여러 SQL문을 실행시킬 수 있습니다. (네트워크 부하를 줄일 수 있음)
        - 네트워크 소요 시간을 줄여 성능을 개선할 수 있습니다.
        - 여러 어플리케이션과 공유가 가능합니다. (API처럼 제공가능)
        - 기능 변경이 편합니다. (특정 기능을 변경할 때 프로시저만 변경하면 됨)

    - 단점
        - 문자나 숫자열 연산에 사용하면 오히려 C,Java보다 느린 성능을 보일 수 있습니다.
        - 유지보수가 어렵습니다.(프로시져가 앱의 어디에 사용되는지 확인이 어려움)


- 저장 프로시저(Stored PROCEDURE)
    - 정의
        - 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
        - 원하는 결과물을 얻기 위해 사용할 여러줄의 쿼리문을 한 번의 요청으로 실행
          인자 값만 상황에 따라 바뀌고 동일한 로직의 복잡한 쿼리문을 필요할 때마다 작성한다면 비효율적. 이럴 때 사용할 수 있는 것이 바로 프로시저다.

    - 장점
        1. 최적화 & 캐시
            프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다.
            만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.

        2. 유지 보수
            작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다. (But, 장점이 단점이 될 수도 있는 부분이기도.. )

        3. 트래픽 감소
            클라이언트가 직접 SQL문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 된다. 즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서버 간 네트워크 상 트래픽이 감소된다.

        4. 보안
            프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.

    - 단점
        1. 호환성
            구문 규칙이 SQL / PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁘다.

        2. 성능
            문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느리다.

        3. 디버깅
            에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.


- 친절한 SQL 튜닝
    - 인덱스 기본
        - 인덱스 튜닝
            1) 인덱스 스캔 효율화 튜닝
                - 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것
                - 인덱스 엑세스 조건(수직적 탐색 ,수평적 탐색)

            2) 랜덤엑세스 최소화 튜닝 (테이블의 엑세스 횟수를 줄이는 것)
                - 인덱스 스캔 후 테이블 레코드를 엑세스 할 때 랜덤 I/O 방식으로 사용하므로 이를 랜덤 액세스 최소화 튜닝이라고함.

        - 인덱스 구조
            - 범위 스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문
            - 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있음
                - 인덱스 수직적 탐색(인덱스 스캔 시작지점을 찾는 과정)
                    정렬된 인덱스 레코드 중 조건을 만족하는 첫번째 레코드를 찾는 과정이다. 즉 인덱스 스캔 시작 지점을 찾는 과정
                - 인덱스 수평적 탐색(데이터를 찾는 과정)
                    수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔함
                    인덱스를 수평적으로 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾기위해  Rowid를 얻기 위해

        - 인덱스 기본 사용법
            - Range Scan을 못 쓰는 경우
                - 인덱스 가공
                    - 인덱스 스캔 시작점을 찾을 수 없기 때문이다. 일정 범위를 스캔하려면 ‘시작지점’과 ‘끝지점’이 있어야 한다.

                - Like 문을 사용
                    ex) where 업체명 like '%대한%'
                    - LIKE로 검색해도 위와 같이 ‘대한’이라는 글자를 가진 인덱스를 중간 글씨에서 찾아야 하기 때문에, Range Scan이 불가능하다.

                - OR 조건
                    - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                    - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

                - IN 조건
                    - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.

        - 인덱스 사용조건
            - range scan을 하기 위해선 가장 첫번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다.
              반대로 말하면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 range scan이 무조건 가능하다.

        - 인덱스를 이용한 소트 연산 생략
            - 인덱스 순으로 이미 정렬된 상태로 order by를 했다. 이것은 order by를 생략할 수 있다.
            - 만약 이렇게 인덱스가 구성되어있지 않다면 SORT ORDER BY 연산이 실행계획에 추가된다.
            - 조건절 뿐만 아니라 ORDER BY절이나 SELECT-LIST 에서 컬럼을 가공하여 인덱스를 정상적으로 못 사용하는 경우가 있다.
                - SELECT-LIST 에서 컬럼 가공
                    select NVL(MAX(TO_NUMBER(변경순번)), 0)
                    from 상태변경이력
                    where 장비번호 = 'C'
                        and 변경일자 = '20180316'

                    위와 같이 ‘변경순번’의 값을 숫자로 바꾸면 인덱스를 사용할 수 없다.
                    왜냐면 인덱스는 문자열 기준으로 정렬되어 있는데 숫자값으로 바꾸었기 때문이다.

                - 자동 형변환
                    select * from 고객 where 생년월일 = 19920920

                    -- 이걸 옵티마이저가 이렇게 바꿈
                    select * from 고객 where TO_NUMBER(생년월일) = 19920920

                    - DBMS마다 다른데 오라클은 자동 형변환 하는 방식을 채택한다.
                    - 형변환 우선순위
                        - 오라클에서 숫자형과 문자형이 만나면 숫자형이 이긴다.
                        - 날짜형과 문자형이 만나면 날짜형이 이긴다.
                        - 근데 LIKE가 출동하면 문자형이 이긴다.

        - 인덱스 확장기능 사용법
            - Index Range Scan
                - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 엑세스 방식
                - 수직적 탐색 후 필요함 범위(Range)만 수평적 탐색
                - 인덱스 스캔 범위와 테이블 액세스 횟수를 줄이는 것이 성능 향상의 길

                - 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
                - B-tree 인덱스에서 루트 노드와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로 인덱스를 읽어 나간다.
                - 리프 노드에서 저장된 레코드 주소로 데이터 파일의 레코드를 읽어 오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 발생한다.
                - 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%를 넘으면 순차 I/O를 사용한 테이블 풀 스캔이 낫다고 하는 것이다.

            - Index Full Scan
                - 수직적 탐색 없이 오직 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
                - 최적의 인덱스가 없을때, 차선으로 선택된다.

                - 선두 컬럼이 조건절에 없으면 옵티마이저가 Index Full Scan을 고려한다.
                - 만약 테이블이 고용량이면 인덱스 활용을 고려하지 않을 수 있다.
                - 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면, 면적이 큰 테이블보다 인덱스를 스캔하는 쪽이 유리하다.

                - 인덱스의 처음부터 끝까지 모두 읽는 방식
                - 쿼리의 조건절에 사용된 칼럼이 첫 번째 칼럼이 아닌 경우 사용된다.
                    ex) 인덱스 (a,b,c) 칼럼의 순서로 만들어져 있지만, 쿼리의 조건절은 b 칼럼이나 c 칼럼으로 검색
                - 루트 노드의 첫 번째 인덱스 레코드와 이어진 브랜치 노드를 거쳐 리프 노드로 이동한다.
                - 해당 리프 노드의 첫 번째 페이지의 인덱스 레코드 방향부터 아래로 탐색한다.
                - 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 작은 경우가 많으므로 풀 테이블 스캔보다 적은 IO 로 쿼리를 처리할 수 있다.

            - Index Unique Scan
                - 수직적 탐색으로만 데이터를 찾는 방식으로, Unique 인덱스를 = (equal) 조건으로 탐색하는 경우
                - Unique 인덱스가 존재하는 컬럼은 중복값 없이 입력되지 않게 DBMS가 정합성 관리해준다. 그래서 데이터를 = 조건으로 찾은 후 더이상 탐색이 필요없다.
                    - Unique 인덱스가 존재해도 Between, Like 등 범위 조건으로 검색하면 Index Range Scan을 한다.
                    - Unique 결합 인덱스도 검색 할 때, Index Range Scan을 사용한다.

            - Index Skip Scan
                - 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 Index Skip Scan을 사용한다.
                - Index Skip Scan은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 갯수가 많을때 유용하다.
                - 선두 컬럼이 조건절에 있고, 중간 컬럼이 조건절에 없어도 Index Skip Scan을 사용할 수 있다.
                - Distinct Value 개수가 적은 두 개의 선두컬럼이 다 조건절에 없어도 Index Skip Scan 사용할 수 있다.
                - 선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위 검색 조건일때도 Index Skip Scan 사용할 수 있다.
                - 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 한다.
                  만약 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때, 이들 스캔 방식을 차선책으로 활용하는 전략이 바람직하다.

                - 루스 인덱스 스캔 ??
                    - 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
                    - 인덱스 레인지 스캔과 비슷하게 동작하지만 중간마다 필요하지 않은 키 값은 무시한다.
                    - 일반적으로 group by 또는 max 등의 함수에 대해 최적화할 때 사용한다.
                    ex) select dept_no, MIN(emp_no)
                        from dept_emp
                        where dept_no between 'doo2' and 'd004'
                        group by dept_no;

                        dept_emp 테이블은 dept_no와 emp_no 2개의 컬럼으로 인덱스를 구성하고 있다고 가정하며, 이 인덱스는 (dept_no, emp_no)를
                        기준으로 정렬이 되어 있다. 즉 특정 dept_no 그룹 별로 처음에 있는 emp_no만 읽으면 된다. 즉, 인덱스에서 where 조건을
                        만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있으므로 중간 중간 조건에 맞지 않으면 건너 뛴다.

            - Index Fast Full Scan
                - Index Fast Full Scan은 Index Full Scan보다 빠르다.
                - 그 이유는, 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문이다.
                - Index Fast Full Scan은 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다.
                - 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과 발휘한다.
                - 인덱스 키 순서대로 정렬되지 않다. (연결 리스트 구조를 무시해서 결과집합이 인덱스 키 순서대로 정렬되지 않음)
                - 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때 사용 가능함.
                - 병렬스캔 가능

            - Index Range Scan Descending
                - Index Range Scan과 기본적으로 동일 스캔방식이나, 인덱스를 뒤에서 앞으로 스캔하기 때문에 내림차순으로 결과집합을 얻는다.


1-1 해당 쿼리가 왜 인덱스 타지 않았는지? (인덱스를 저장하는 구조를 활용하여)
    - 양방향 like 검색
1-2 양방향 LIKE 검색 경우 인덱스를 타지 않는데 힌트만 줘서는 인덱스가 타도록 유도가 안되는데 구체적으로 어떻게 해결한건지?
    - 문자열 % like 검색 으로 바꿈
1-3 여러가지 인덱스가 있을텐데 어떤 인덱스를 타고 있기 때문에 다른 인덱스를 타도록 유도하기 위해서 힌트를 사용했을텐데 그 과정
    - 결합인덱스의 선행 칼럼 조건이 입력되지 않아 INDEX FAST FULL SCAN 이던걸 INDEX_SS 를 통해 INDEX SKIP SCAN 유도


- 슬로우 쿼리에 대처하기
    https://hyperconnect.github.io/2020/08/31/improve-slow-query.html

- SQL 튜닝
    - Join, Indexing, SQL Execution Plan