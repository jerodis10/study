- analyze table
    - ANALYZE 는 인덱스, 테이블, 클러스터의 통계정보를 생성 한다.
    - ANALYZE 가 생성한 통계정보들은 비용기준(Cost-based)의 옵티마이저가 가장 효율적인 실행계획을 수립하기 위해 최소비용을 계산할 때 사용된다.
    - 각 오브젝트의 구조를 확인하는 것과 체인(Chain) 생성 여부를 확인할 수 있으므로 시스템의 저장공간 관리를 도와준다.
    - ANALYZE 는 다음과 같은 통계정보를 생성하여 데이터 사전에 저장 한다.
        - 테이블 : 총 로우의수, 총 블럭의 수, 비어있는 블럭에 쓰여질 수 있는 빈 공간의 평군, 체인이 발생된 로우의 수, 로우의 평균 길이
        - 인덱스 : 인덱스의 깊이(Depth), Leaf block 의 개수, Distinct Key 의 수, Leaf Blocks/Key 의 평균,
                  Data blocks/key 의 평균, Clustering Factor, 가장 큰 key 값, 가장 작은 key 값
        - 컬럼 : Distinct 한 값의 수, 히스토그램 정보
        - 클러스터 : Cluster Key 당 길이의 평균

    - 주기적인 ANALYZE 작업을 수행 시켜 주어야 한다.
      테이블을 재생성 하거나, 새로 클러스터링을 한 경우, 인덱스를 추가하거나 재생성한 경우, 다량의 데이터를 SQL 이나
      배치 애플리케이션을 통해 작업한 경우 ANALYZE 를 수행 시켜 주는 것이 좋다.
      사용자는 USER_TABLES, USER_COLUMNS, USER_INDEXS, USER_CLUSTER 등의 자료사전 뷰를 통해 정보를 확인할 수 있다
      테이블을 ANALYZE 시킨다면 거기에 따르는 인덱스들도 같이 실시하는 것이 좋다.


- Index Fast Full Scan을 활용한 튜닝 사례
    select * from 공급업체
    where 업체명 like '%네트웍스%'
    - TABLE ACCESS Full
    - 실행시간 5초 이상 소요
    - 결과 건수 21
    =>
    select /*+ ordered use_nl(b) no_merge(b) rowid(b) */ b.*
    from (select /*+ index_ffs(공급업체 공급업체_X01) */ rowid rid
           from 공급업체
          where instr(업체명, '네트웍스') > 0) a, 공급업체 b
    where b.rowid = a.rid
    - 업체명 컬럼의 인덱스를 Fast Full Scan 해서 얻은 rowid를 이용해 테이블을 다시 억세스.
    - like 연산자보다 빠른 instr 함수 사용.
    - 최종 결과 건수가 많아지더라도 부분범위 처리가 가능한 애플리케이션 환경이면 유리.
    - 11g라면 결과 건수가 많더라도 인라인 뷰에 'order by rowid'를 추가함으로써 큰 효과를 얻을 수 있다(5절 (5)항에서 설명)
    - 데이터 건수가 많다면 parallel_index 힌트를 이용해 병렬쿼리도 가능.


- like '% ...' 성능 튜닝
    SELECT /*+ ordered use_nl(B) no_merge(B) rowid(B) */ B.*

      FROM ( SELECT /*+ index_ffs(공급업체 공급업체_X01) */ ROWID RID

                    FROM 공급업체

      WHERE INSTR(업체명, '네트웍스') > 0 ) A, 공급업체 B

    WHERE B.ROWID = A.RID;

    -- Index Fast Full Scan은 모든 컬럼이 인덱스에 포함돼 있을 때만 사용 가능

    -- 일단 해당 레코드의 ROWID만 Index Fast Full Scan으로 빠르게 get

    -- 인덱스로부터 얻은 ROWID로 테이블 액세스


- 인덱스(Index)란?
    인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
    특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
    이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면
    옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.
    인덱스에서 내가 원하는 데이터를 먼저 찾고 저장되어 있는 물리적 주소로 찾아갑니다.

    인덱스는 데이터베이스 테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스 객체이며 일종의 색인기술입니다.
    테이블에 index 를 생성하게 되면 index Table 을 생성해 관리합니다.
    가장 일반적인 B-tree 인덱스는 인덱스 키(인덱스로 만들 테이블의 컬럼 값)와 이 키에 해당하는 컬럼 값을 가진
    테이블의 로우가 저장된 주소 값으로 구성됩니다.

    인덱스를 설정하면 특정 컬럼들을 키 값으로 메모리 영역에 트리 구조로 저장해둡니다.
    그리고 디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
    인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.
    이를 위해 데이터가 추가/삭제 될 때마다 자료구조를 정렬하기 때문에 인덱스는 SELECT 성능을 향상시키는 대신 INSERT, UPDATE, DELETE 의 성능이 떨어지게 됩니다.


- InnoDB Adaptive Hash Index
    - MySQL 은 기본으로 InnoDB 를 사용하고 InnoDB 는 B-Tree 를 사용합니다.
    - PK 가 아닌 컬럼으로 인덱스를 지정하면 Non Clustered Index 가 생성됩니다.
    - 그래서 인덱스로 컬럼을 조회하면 Secondary 인덱스를 기반으로 PK 를 찾은 뒤 다시 Primary Index 로 데이터를 찾아냅니다.
    - 인덱스를 두번 타기 때문에 2 * O(log n) 비용이 듭니다.
    - 그래서 자주 사용되는 컬럼을 해시로 정의해서 B-Tree 를 타지 않고 바로 데이터에 접근할 수 있게 하는 걸 Adaptive Hash Index
    - 미리 캐싱한 해시값으로 조회하기 때문애 O(1) 의 속도를 보여주지만 어떤 값을 해싱할지는 옵티마이저가 판단하기 때문에 제어할 수 없다는 약점이 있습니다.


- 인덱스  https://bcp0109.tistory.com/365
    - 인덱스 란
        - 인덱스를 설정하면 특정 컬럼들을 키 값으로 메모리 영역에 트리 구조로 저장해둡니다.
          그리고 디스크 저장소에 바로 접근하는 대신 메모리 저장소에 있는 인덱스를 먼저 조회해서 빠르게 데이터를 가져올 수 있습니다.
          인덱스가 데이터를 빠르게 가져올 수 있는 이유는 항상 정렬된 상태를 유지하기 때문입니다.
          이를 위해 데이터가 추가/삭제 될 때마다 자료구조를 정렬하기 때문에 인덱스는 SELECT 성능을 향상시키는 대신 INSERT, UPDATE, DELETE 의 성능이 떨어지게 됩니다.

    - 인덱스 종류
        - Clustered Index vs Non-Clustered Index
            - Clustered Index
                - 이름 그대로 인접한 데이터들을 한곳으로 모았다는 뜻
                - PK 설정 시 자동으로 클러스터드 인덱스로 만들어짐
                - 테이블당 1개씩만 허용
                - 물리적인 데이터를 갖고 있음
                - 항상 정렬된 상태를 유지하고 노드 내에서도 정렬되어 있음
                - Non Clustered 인덱스에 비해 조회 속도가 빠르지만 삽입/수정/삭제는 더 느림

            - Non Clustered Index
                - UNIQUE 로 설정된 컬럼에 자동으로 생성됨
                - 인덱스 페이지는 로그 파일에 저장됨
                - 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됨
                - 기본키는 아니지만 성능 향상을 위해 임의의 컬럼을 지정해서 만든 인덱스

    - 인덱스 자료구조
        - B-Tree 인덱스
            - Balanced Tree 의 약자로서 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적으로 사용되는 알고리즘
            - B-Tree 인덱스는 컬럼의 값을 변경시키지 않고 구조체 내에서 항상 정렬된 상태를 유지
            - B-Tree 는 최상위에 루트 (Root) 노드가 존재하고 하위에 브랜치 (Branch) 노드, 마지막에 리프 (Leaf) 노드로 되어 있습니다.
            - 부모 노드를 기준으로 왼쪽 자식 노드는 더 작은 값 오른쪽 자식 노드는 더 큰값을 갖고 있습니다.

        - 왜 B-Tree 인가?
            - 인덱스로 사용할 수 있는 자료구조는 여러 개가 있을 겁니다.
            - Tree 구조의 Worst 시간복잡도는 한쪽으로 모든 자식 노드가 쏠려있는 형태인 O(n) 입니다.
            - 그래서 우리는 자식 노드가 양쪽에 골고루 퍼져있는 Balanced Tree 를 사용합니다.
            - Balanced Tree 중에는 RedBlack Tree 도 있는데 왜 사용하지 않을까요? 해시 테이블은 O(1) 인데 왜 사용하지 않을까요?

        - 다른 트리 구조를 사용하지 않는 이유
            - RedBlack Tree 는 B-Tree 와 마찬가지로 정렬된 상태와 밸런스를 유지
            - B-Tree 와 차이가 없을 것 같은데 왜 사용하지 않을까요?
            - 가장 큰 차이점은 B-Tree 는 노드 하나에 여러 개의 데이터를 저장할 수 있다
            - 노드에서 배열 형태로 여러 데이터를 저장할 수 있기 때문에 트리 포인터를 참조해서 계속 depth 를 타고 들어가는 것보다 효율적이고 이는 데이터가 많아질수록 차이가 두드러집니다.

        - Hash 테이블을 사용하지 않는 이유
            - 해시 테이블은 Hash 함수를 사용해서 키 값을 해싱한 후에 테이블에 저장합니다.
            - 해시 테이블은 분명 한 가지 키에 대한 탐색은 효율적입니다.
            - 하지만 데이터가 정렬되어 있지 않기 때문에 부등호 (<, >) 를 사용하지 못한다는 단점이 있습니다.

        - B-Tree 인덱스의 쿼리별 특징
            - SELECT
                - 특정 키 값을 찾기 위해 자식 노드를 계속 타고 들어가는 방식
                - 마지막 리프 노드에는 레코드의 주소가 존재하고 이 값으로 테이블 레코드를 찾을 수 있음

                - B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다.
                  그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

            - INSERT
                - B-Tree 에 새로운 키값을 저장할 때는 우선 적절한 위치를 찾아야함
                - 새로운 키값과 레코드 정보는 리프 노드에 저장
                - 만약 리프 노드가 꽉찼다면 트리를 재구성하여 리프 노드를 분리
                - 분리 과정에서 해당 리프 노드의 부모 노드까지 영향이 갈 수 있음
                - 이러한 이유로 INSERT 작업은 상대적으로 비용이 많이 듬
                - 인덱스가 많으면 많을수록 이런 비용이 추가로 들기 때문에 너무 많은 인덱스를 추가하는 건 성능에 영향을 줌

            - DELETE
                - B-Tree 에서 키 값 삭제는 간단
                - 해당 키를 찾아서 삭제 마크만 하면 작업이 완료
                - 삭제 마킹된 인덱스 키 공간은 그대로 두거나 재활용 가능

            - UPDATE
                - 인덱스는 항상 정렬된 상태로 유지됨
                - 단순히 인덱스 키 값을 수정한다면 트리의 전체 구조를 바꿔야 할 수도 있음
                - 그래서 B-Tree 에선 키 변경이 아닌 기존 키 삭제 (DELETE) 후 새로운 키 추가 (INSERT) 방식을 사용
                - 따라서 키 값의 잦은 수정은 성능에 큰 영향을 미침

    - 인덱스 설정 시 고려사항
        - 인덱스의 갯수
            - 인덱스의 갯수는 3 ~ 4 개가 적당
            - 인덱스의 갯수가 너무 많으면 다음과 같은 이슈가 존재
                - 데이터 삽입/수정/삭제 시마다 인덱스도 같이 추가하거나 수정/삭제 해주어야 해서 성능상 이슈가 존재
                - 데이터 삽입시마다 인덱스도 같이 추가하기 때문에 인덱스가 늘어날수록 더 많은 메모리를 차지함
                - 인덱스가 많아지면 옵티마이저가 잘못된 인덱스를 선택할 확률이 높아짐 (인덱스 힌트로 원하는 인덱스를 지정할 순 있음)

        - 인덱스를 걸기에 적절한 컬럼
            - 인덱스의 갯수에 한계가 있다면 적절한 인덱스 컬럼을 정하는 것도 중요
            - 인덱스는 카디널리티 (Cardinality) 가 높은 컬럼에 지정하는 게 좋습니다.
            - 카디널리티가 높다는 말은 데이터의 중복이 적다는 뜻인데 대표적으로 ID, 주민번호 등이 있습니다.
            - 반대로 성별 같은 중복된 데이터가 많은 경우 카디널리티가 낮다고 표현
            - 성별에 인덱스를 거는 경우 인덱스를 타더라도 남/녀 두가지만 존재하기 때문에 결국 나머지 조건에 맞는 데이터는 직접 풀스캔을 해서 찾아야 합니다.
            - 하지만 ID 같이 중복된 값이 없는 경우 해당하는 데이터를 빠르게 찾을 수 있습니다.

        - 읽어야 하는 레코드 갯수
            - 인덱스는 일반적으로 단 하나의 데이터를 구할 때 가장 효율적
            - 여러 개의 데이터를 구한다면 인덱스를 통해 레코드의 주소를 찾아 데이터의 레코드를 읽는 작업을 반복해야 합니다.
            - 그래서 만약 많은 레코드를 한번에 조회한다면 오히려 인덱스를 사용하지 않고 직접 테이블을 읽는 것이 더 효율적일 수 있습니다.
            - 일반적으로 DBMS 의 옵티마이저는 인덱스를 사용해 레코드 1건을 읽는 것이 테이블에서 직접 읽는 것보다 4 ~ 5배 정도 비용이 더 많이 든다고 예측
            - 그러므로 인덱스를 통해 읽어야 할 레코드가 전체 테이블의 20 ~ 25% 이상이라면 직접 테이블을 읽는 것이 효율적

        - 복합 인덱스를 구성할 때
            - 인덱스는 여러 개의 컬럼을 동시에 지정할 수도 있는데 어떤 순서로 구성하느냐에 따라 성능이 달라집니다.
            - 인덱스는 트리 구조로 되어있다고 했는데, 여러 개의 컬럼을 함께 키 값으로 지정하는 경우 먼저 첫 번재 컬럼을 기준으로 정렬된 뒤에 두번째 컬럼이 정렬되어 있습니다.
            - 이 말은 즉 첫 번째 컬럼 없이 두 번째 컬럼만 갖고 인덱스를 조회하면 제대로 된 위치를 찾을 수 없다는 뜻
            - 그러므로 복합 인덱스를 구성했다면 조회할 때 앞 순서의 조건을 반드시 포함해야 인덱스를 태울 수 있습니다.
            - 여러 개의 컬럼이 있다면 카디널리티가 높은 순에서 낮은 순으로 지정하는게 인덱스의 효율을 이끌어낼 수 있습니다.
            - 과거에는 인덱스의 컬럼 순서와 조회 컬럼 순서를 맞춰야 인덱스를 탔지만 최근에는 옵티마이저가 알아서 인덱스 순서에 맞춰주기 때문에 거의 차이가 없습니다.
            - 그래도 재배열하는 과정을 생략하기 위해 최대한 맞추는게 좋다.

    - 인덱스 사용 시 주의사항
        - 다중 인덱스를 사용할 때 범위 조건은 인덱스를 타지만 이후 컬럼들은 인덱스를 타지 않음
            WHERE 컬럼1 = ?
            AND   컬럼2 = ?
            AND   컬럼3 BETWEEN ? AND ? -- 결합인덱스에서 '='이 아닌 연산자를 사용하는 첫 번째
            AND   컬럼4 = ?

            컬럼3에서 BETWEEN을 사용했기에 컬럼3 까지만 인덱스를 타고 후행컬럼인 컬럼4는 인덱스를 타지 않고 필터만 한다.
            그래서 결합인덱스 = 컬럼1 + 컬럼2 + 컬럼4 + 컬럼3으로 순서를 바꿔줘야한다.

        - 인덱스를 타지 않는 경우
            1. 인덱스 컬럼의 변형
                - 인덱스에 변형을 가하게 되면, DBMS가 인덱스를 이용하지 않는다.
                - 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 range scan 가능
                  인덱스 칼럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문
                  그래서 인덱스 칼럼을 가공하면 index full scan 을 하게 된다.
            2. 부정형의 사용
                - NOT일 경우 무조건 인덱스를 안타는 것이 아니라 일반적으로 NOT에 사용된 값이 아닌 데이터 비율이 높은 경우가 많기 때문에 인덱스를 타지 않는다.
            3. IN 연산자 사용
                - IN일 경우에도, IN에 포함된 데이터들의 비율이 매우 높다면 FULL SCAN을 하는 것이 낫다고 DBMS가 판단하면 인덱스를 타지 않는다.
                - Mysql에서는 range_optimizer_max_mem_size 설정의 용량을 In절의 파라미터가 넘어서면 FullScan을 한다.
                  다른 DB의 경우도 파라미터가 많아지면 옵티마이저가 FullScan을 할 수 있다.
                - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.
                  하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능
            4. LIKE문을 사용할 때 전체 범위를 설정할 시
                - 문자열로 이루어진 값을 인덱스로 잡았을 때, %가 앞쪽에 사용되면 정렬 순서를 사용할 수 없으므로 테이블 FULL SCAN이 이루어진다.
                  select * from table  where name like 'word%'; -> 쿼리가 이런 경우 인덱스를 탄다. 문자열 정렬 순서를 그대로 이용할 수 있기 때문이다. (Index Range Scan 이 가능)
                  인덱스를 걸면 해당 컬럼은 정렬이 됩니다. 정렬된 문자열 앞부분부터 검색해야 하는데, LIKE절이 '%'로 시작하면 앞 문자열을 모르니 인덱스를 사용할 수 없게 됩니다.

                - 정규표현식 REGEXP 을 사용해도 인덱스를 더치지 않고 풀 스캔이 일어난다.
                - 가능하면 INSTR 을 사용하는 것도 나쁘지 않다. INSTR('비교할 대상', '비교하고자 하는 값', 비교를 시작할 위치, 검색된 결과의 순번)
                  select * from table where INSTR(column_name, value) > 0  ???
            5. 복합인덱스에서 첫인덱스가 첫조건으로 적용하지 않았을경우
                - select * from table where name = 'word' or idx = 5
                - name과 idx가 둘다 인덱스가 걸려있는 경우라해도, DBMS가 최적의 OR 조건을 뽑기 힘들어, FULL SCAN 하는 경우가 많다.
            6. NULL 조건의 사용
            7. 인덱스 컬럼의 내부적인 데이터 변환
                - 문자값 데이터타입을 갖는 컬럼에 ‘값’ → 값 을 하지 말고 정확한 데이터 타입을 넣어야 인덱스를 탈 수 있다.
            8. OR 조건 사용
                - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

    - InnoDB Adaptive Hash Index
        - MySQL 은 기본으로 InnoDB 를 사용하고 InnoDB 는 B-Tree 를 사용합니다.
        - PK 가 아닌 컬럼으로 인덱스를 지정하면 Non Clustered Index 가 생성됩니다.
        - 그래서 인덱스로 컬럼을 조회하면 Secondary 인덱스를 기반으로 PK 를 찾은 뒤 다시 Primary Index 로 데이터를 찾아냅니다.
        - 인덱스를 두번 타기 때문에 2 * O(log n) 비용이 듭니다.
        - 그래서 자주 사용되는 컬럼을 해시로 정의해서 B-Tree 를 타지 않고 바로 데이터에 접근할 수 있게 하는 걸 Adaptive Hash Index
        - 미리 캐싱한 해시값으로 조회하기 때문애 O(1) 의 속도를 보여주지만 어떤 값을 해싱할지는 옵티마이저가 판단하기 때문에 제어할 수 없다는 약점이 있습니다.

    - Covering Index
        - 인덱스를 사용하면 특정 컬럼 값을 키로 하여 데이터의 주소값을 구한 뒤 해당 주소값으로 다시 테이블에 접근해서 최종 데이터를 구합니다.
        - 커버링 인덱스란 인덱스에 이미 필요한 데이터가 전부 존재해서 테이블에 접근할 필요가 없는 인덱스를 의미
        - 인덱스는 기본적으로 Non Clustered Index 에서 먼저 값을 구하고 Clustered Index 에서 다시 데이터를 구합니다.
        - 여기서 커버링 인덱스가 사용되었다는건 Clustered Index 까지 통하지 않고 Non Clustered Index 만으로도 데이터를 구할 수 있다는 뜻
        - 커버링 인덱스가 적용되면 EXPLAIN 실행 시 Extra 필드에 Using index 라고 표시

    - 인덱스 스캔 방식  https://jungmina.com/720
        - Index Range Scan
            - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식(수직적 탐색 후 필요한 범위만 수평적 탐색)
            - 항상 빠른 속도를 보장하진 않음
            - 인덱스 스캔 범위를 얼만큼 줄일 수 있느냐, 테이블 액세스 횟수를 얼만큼 줄일 수 있느냐가 관건
                 => 인덱스 설계와 SQL 튜닝의 핵심 원리
            - 인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 함
            - where 조건에서 =, >, <, like 'abc%' 같은 경우에 선택됨

        - Index Full Scan
            - 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
            - 최적의 인덱스가 없을 때 차선책(인덱스 선두 컬럼이 조건절에 없을 경우)
            - 최종 결과값이 적을때 Table Full Scan보다 Index Full Scan이 훨씬 효율적

        - Index Unique Scan
            - 수직적 탐색만으로 데이터를 찾는 스캔 방식
            - Unique Index를 통해 '=' 조건으로 탐색하는 경우
            * Unique Index를 이용했지만 Index Range Scan이 나타나는 경우
                - Unique Index를 통해 범위 조건(between, 부등호, like)으로 검색하는 경우
                - 결합 형태인 Unique Index의 일부 컬럼만으로(선두 컬럼 포함) 검색하는 경우

        - Index Skip Scan
            - 인덱스가 세 개의 컬럼으로 구성되어 있는데 중간 컬럼에 대한 조건절만 누락된 경우나 Distinct Value가 적은 두 개의 선두 컬럼이 모두 누락된 경우
            - 선두 컬럼이 범위 조건(between, 부등호, like) 검색인 경우
            - 조회 조건에 인덱스 선두 컬럼이 없는데 선두 컬럼의 Distinct Value 개수가 적은 경우

        - Index Fast Full Scan
            - Index Full Scan보다 빠름
            - Index를 논리적 구조 순으로 읽지 않고 물리적으로 디스크에 저장된 순서대로 읽음(Segment 전체를 Scan)
            - Multiblock I/O
            - 결과 집합이 Sorting된 상태가 아닐 수 있음
            - 쿼리에 사용되는 모든 컬럼이 인덱스 컬럼에 포함돼 있을 때만 사용 가능
            - 병렬스캔 가능


- SORT MERGE JOIN (정렬 병합 조인)
    - SORT MERGE JOIN 이란?
        조회의 범위가 많을 때 주로 사용하는 조인 방법론이며 양쪽 테이블을 각각 Access 하여 그 결과를 정렬하고
        그 정렬한 결과를 차례로 Scan 해 나가면서 연결고리의 조건으로 Merge 를 하는 방식
        주로 조인 조건 칼럼에 인덱스가 없거나, 출력해야 할 결과 값이 많을 때 사용
        조회의 범위가 좁을 때 유리한 Nested Loop Join 의 조인 방식과 장단점이 서로 바뀌어있다고 생각하시면 이해하기 쉽습니다.

    - SORT MERGE JOIN 의 사용처
        1. 연결 고리에 인덱스가 전혀 없는 경우
        2. 대용량의 자료를 조인할때 유리한 경우
        3. 조인 조건으로 <, >, <=, >=와 같은 범위 비교 연산자가 사용된 경우
        4. 인덱스 사용에 따른 랜덤 액세스의 오버헤드가 많은 경우

    - SORT MERGE JOIN 의 동작 방식
        1. 각 테이블에 대해 동시에 독립적으로 데이터를 먼저 읽어 들인다.
        2. 읽혀진 각 테이블의 데이터를 조인을 위한 연결고리에 대하여 정렬을 수행한다.
        3. 정렬이 모두 끝난 후에 조인 작업이 수행한다.

    - SORT MERGE JOIN 의 성능 개선 포인트
        - ACCESS 하는 속도를 향상 시킨다.
            SORT MERGE JOIN 은 가장 먼저 양쪽 테이블을 Access 하는 과정을 거쳐야 합니다. 이 속도를 빠르게 해 준다면
            속도 향상에 도움이 되겠죠. 테이블을 Access 할 때 FULL TABLE SCAN 이냐 INDEX RANGE SCAN 이냐 하는 등
            테이블을 Access 하는 방법을 다양한 방법을 통해 최적화시킨다면 SORT MERGE JOIN 의 속도도
            자연스럽게 최적화할 수 있습니다.

        - 정렬 속도의 향상
            SORT MERGE JOIN 은 양쪽 테이블에서 조회한 데이터들을 정렬시켜야 합니다. 이때 조인 조건 컬럼이
            이미 정렬되어 있다면 정렬을 하는 작업을 단축시켜 검색 속도 향상에 도움이 될 것입니다.

        - 양쪽의 정렬까지 완료되는 속도를 맞추어줌
            SORT MERGE JOIN 은 양쪽 테이블을 ACCESS 하고 조회한 데이터들을 정렬할때 어느 한쪽이라도 정렬 작업이
            종료되지 않으면 한쪽이 대기 상태가 되고 다른 한쪽의 정렬이 완전히 끝날 때까지 조인이 시작될 수 없습니다.
            그렇기에 두 테이블 ACCESS 속도와 정렬 속도를 최대한 비슷하게 맞추어주는 것이 좋습니다.
            비교해야 할 두 테이블의 데이터 양이나 정렬 속도를 고려하여 최대한 맞춰주는 것이 효율성 측면에서 좋습니다.

        - SORT_AREA_SIZE 최적화
            SORT MERGE JOIN 은 두 테이블 간의 비교가 이루어지기 전에 수행하는 정렬 작업을 위해 별도의 정렬 공간이 필요하며
            이 공간은 SORT_AREA_SIZE 크기만큼 메모리를 할당받아 사용하게 되고, 메모리가 부족하다면
            Temporary Table Space 를 이용하여 정렬을 수행하게 됩니다. 이때 Temporary Table Space 를 사용하면
            딜레이가 생기므로 SORT_AREA_SIZE 를 적당한 크기로 설정해두는 것이 속도 향상에 도움이 됩니다.


- HASH JOIN (해시 조인)
    - HASH JOIN 이란?
        HASH 조인은 조인될 두 테이블 중 하나를 해시 테이블로 선정하여 조인될 테이블의 조인 키 값을 해시 알고리즘으로
        비교하여 매치되는 결과값을 얻는 방식
        HASH JOIN 은 비용 기반 옵티마이저를 사용할 때만 사용될 수 있는 조인 방식이며 '=' 비교를 통한 조인에서만
        사용될 수 있습니다. 주로 많은 양의 데이터를 조인해야 하는 경우에 주로 사용

    - HASH JOIN 의 사용처
        1. JOIN 컬럼에 적당한 인덱스가 없어 NL JOIN 이 비효율적일 때
        2. JOIN Access 량이 많아 Random Access 부하가 심하여 NL JOIN 이 비효율적일 때
        3. Sort Merge Join 을 하기에는 두 테이블이 너무 커 Sort 부하가 심할 때
        4. 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 JOIN 할 때

    - HASH JOIN 의 동작 방식
        1. 둘 중 작은 집합(Build Input)을 읽어 Hash Area 에 해시 테이블을 생성한다.
            (해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인에 엔트리를 연결)
        2. 반대쪽 큰 집합(Probe Input)을 읽어 해시 테이블을 탐색하면서 JOIN 한다.
        3. 해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인을 스캔하면서 데이터를 찾는다.

    - HASH JOIN 의 성능 개선 포인트
        - HASH TABLE 을 만드는 과정을 효율화 한다.
            HASH JOIN 은 해시 테이블을 생성하는 비용이 수반되므로 이 과정을 효율화하는 것이 성능 개선에 있어 가장 중요합니다.
            그렇기에 HASH TABLE 로 만들 Build Input 이 Hash Area 에 담길 정도로 충분히 작아야 하며
            Build Input 해시 키 칼럼에 중복 값이 거의 없어야 효율적인 동작을 기대할 수 있습니다.

        - CPU 의 성능을 향상한다.
            HASH BUCKET 이 조인 집합에 구성되어 해시 함수 결과를 저장해야 하는데 기본적으로 HASH_AREA_SIZE 에
            지정된 크기만큼의 메모리가 할당되어 사용됩니다. 이러한 처리에는 많은 메모리와 CPU 자원을 소모하게 됩니다.
            그렇기에 CPU 의 자원이 넉넉하다면 다른 조인에 비해 보다 좋은 효율을 내지만 부족한 상황에서는 다른 조인 방법보다
            느려질 수도 있습니다. 그러므로 CPU 의 성능을 향상한다면 HASH JOIN 의 성능을 향상할 수 있습니다.

        - 충분한 PGA 메모리 확보
            Hash Area 는 PGA 메모리에 할당되는데 Build Input 이 HASH_AREA_SIZE 를 초과하게 되면 가장 큰 순서대로
            Hash Bucket 이 Temporary Table Space 로 내려가서 구성됩니다. 디스크로 내려간 Hash Bucket 에
            변경이 일어날 때마다 디스크 I/O가 발생하게 되어 성능이 현저하게 저하됩니다.

        * HASH_AREA_SIZE
          HASH JOIN 에 사용되는 최대 메모리 SIZE 를 지정하는 설정값입니다. Hash Join 에서 사용되는
          해쉬 메모리 크기(HASH_AREA_SIZE)의 기본 값은 SORT_AREA_SIZE 의 2배입니다. 9i 이상에서 값을 지정하는 것을
          권장하지 않고, PGA_AGGREGATE_TARGET parameter 사용을 권장합니다.

    - 사용법
        /*+leading(a c) use_hash(c)*/
        아마 힌트를 주지 않아도 옵티마이저가 알아서 hash 조인을 하는 경우도 있지만, 이러한 힌트를 명시해주는 것이 바람직


- 조인 방법
    - 중첩 루프 조인(Nested Loop Join, NLJ)
        - where 절에 있는 조건에 따라 두 테이블에서 하나의 테이블을 기준으로 삼아 다른 하나의 테이블에 있는 데이터를 읽는 방식으로 조인을 수행.
        - 기준이 되는 테이블을 드라이빙 테이블/아우터 테이블 이라고 하며, 나머지 테이블을 이너 테이블 이라고 한다.
        - 프로그래밍의 for 이중루프랑 같다.
        - NLJ는 메모리가 필요없는 조인 방법으로 추가적인 메모리 비용이 들지 않는다.
        - 어떤 테이블을 드라이빙 테이블로 선택하느냐가 중요하다. 왜냐면 드라이빙 테이블의 로우를 가지고 이너를 검색하기 때문

    - 정렬 병합 조인(Sorted Merge Join, SMJ)
        - 두 테이블을 각각 정렬한 다음 조인조건에 맞는 건을 찾아 합치는 방식이다.
        - 드라이빙 테이블이 별도로 존재하지 않으며, 모두 독립적으로 동등한 레벨에 있다.
        - 정렬 작업을 위해 추가적인 메모리를 사용한다. 디스크 I/O가 발생한다.
        - NJL보다 많은 양의 데이터를 처리할 때 유리하며, 메모리만 사용해서 정렬 작업을 수행한다면 넓은 범위의 값을 검색하는데 유용하다.
        - 두 테이블의 데이터를 각각 정렬하는 작업이 전체 성능에 영향을 많이 끼치게 된다. 해서 select 리스트에서 불필요한 칼럼은 제거해서
          정렬 작업 수행 시 부하를 적게 줘야 한다.
        - 일반적으로 >, >=, <, <= 와 같은 비동등 연산자가 사용될 때 쓰인다.

    - 해쉬 조인(HJ)
        - 두 테이블 중 where 조건에 의해 필터링된 로우 수가 적은 테이블을 대상으로 해쉬 테이블을 만든 후에 조인 조건에 따라 다른 하나의 테이블의 데이터를 검색하는 방법이다.
        - HJ 방법은 해시 테이블이 드라이빙 테이블이 되어 NLJ를 수행한다고 보면 된다.
        - 해시 테이블은 HASH_AREA_SIZE에 지정된 메모리 값 내에서 해시 테이블을 만들게 되므로 대상 테이블의 크기가 이 값 내에 있을 경우 유용한 조인
        - 보통 HASH_AREA_SIZE 값은 SORT_AREA_SIZE 값의 2배로 설정한다.
        - 해시 조인은 조인 조건에서 동등조건이 사용되었을 때만 가능하다.
        - 보통 반환되는 로우수가 적은 테이블(이 테이블을 대상으로 해시 테이블을 만든다.)과 이에 반해 반환되는 로우수가 상당히 많은 테이블을 조인 시에 유리하다.

* 주의사항 :
  /*+ 다음에 스페이스를 반드시 줘야 함.
  테이블 알리아스를 사용해야 한다. 테이블의 물리명을 사용하면 안됨.

   SINGLE TABLE QUERY에서는 HINT 절에 table 명을 주는 것이 원칙이다.

  * Hint 내의 table_name은 alias를 사용하였을 경우에는 반드시 table alias name으로 지정하여야 한다.

  * 그 이유는 다음과 같이 SQL이 사용될 경우도 있기 때문니다.

  (SELF-JOIN)

  select /*+ index_desc(a a_pk) */
  *
  from t1 a, t1 b
  where a.key1 = 'a'
  and a.key1 = b.prev_c1(+)
  and a.seq = b.pseq_no(+)
  and rownum = 1

  위와 같이 동일한 TABLE이 FROM 절 뒤에 복수로 나오는 경우 (Recursive 관계)가 있을 수 있는데 이 때 Hint 절의 table 명을
  유일하게 줄 수가 없으므로 반드시 table alias name을 주어야  원하는 답이 나온다.


- 인덱스가 무엇인가요?
    - RDB에서 테이블의 검색성능을 높여주는 방법중 하나입니다. 사전의 목차처럼 인덱스를 이용하여 원하는 데이터에 빠르게 접근할 수 있습니다.
      특정 컬럼을 서치키로 설정하여 인덱스를 생성하면 그 값으로 정렬하여 별도 파일에 저장합니다. 인덱스는 보통 테이블의 10% 정도 저장공간을 차지하는 데
      이유는 서치키와 포인터만 저장하기 때문입니다. 여러가지 자료구조로 인덱스를 구현할 수 있지만 대부분 B+트리를 이용하여 인덱스의 구조를 이룹니다.


- 인덱스의 종류가 있나요?
    1) 클러스터형 인덱스 : 보통 PK를 기준으로 정렬하여 데이터를 저장합니다. 그렇게 되면 테이블 자체가 하나의 인덱스가 되고 이를 클러스터형 인덱스라고 합니다.
    2) 보조 인덱스 : 별도 공간에 생성되는 인덱스를 의미합니다. PK 외에 원하는 컬럼에 대해서 인덱스를 생성할 수 있습니다. secondary index 라고도 합니다.


- 인덱스를 많이 쓰면 되나요?
    - 안됩니다. 검색성능은 향상될 수 있으나 추가 저장공간도 필요하고 변경작업이 많아지면 인덱스 재구성에 필요한 비용이 커집니다.
      예를 들어, 어떤 테이블의 인덱스가 5개 있다고 한다면 데이터의 변경이 일어나는 경우 5개의 인덱스 자료구조의 재구성이 필요합니다.


- 어떤 컬럼에 인덱스를 써야하나요?
    - 인덱스는 where 에서 자주 사용되고 수정빈도가 낮으며 카디널리티가 높은 컬럼을 선택하는 것이 좋습니다. 카디널리티가 높다는 것은 중복된 데이터가 적다는 뜻입니다.


- NoSQL
    - 정의
        - NoSQL은 RDBMS의 형태가 아닌 일관성 모델(비관계형 모델)을 이용하는 데이터 저장을 말하는 것
        - 단순 검색 및 추가작업에 있어서 매우 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에 있어서 매우 뛰어난 성능

    - 대표적인 NoSQL (NoSQL은 다양한 모델을 기반으로 데이터베이스를 설계할 수 있는데, 크게 4가지로 분류할 수 있다.)
        - key-value Database
            - 기본적인 패턴으로 KEY-VALUE 하나의 묶음(Unique)으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장시 용이
            ex) Riak, Redis, Voldmort
        - Document Database
            - 테이블의 스키마가 유동적, 즉 레코드마다 각각 다른 스키마를 가질 수 있다.
            - 보통 XML, JSON과 같은 DOCUMENT를 이용해 레코드를 저장
            - 트리형 구조로 레코드를 저장하거나 검색하는 데 효율적
            ex) MongoDB, CouchDB
        - BigTable Database
            ex) Hbase, Casandra
        - Graph Database
            - 데이터를 노드로(그림에서 파란, 녹색 원) 표현하며 노드 사이의 관계를 엣지(그림에서 화살표)로 표현
            - 일반적으로 RDBMS보다 성능이 좋고 유연하며 유지보수에 용이
            ex) Sones, AllegroGraph

    - 장점
        - RDBMS에 비해 저렴한 비용으로 분산 처리와 병렬 처리가 가능
        - 비정형 데이터 구조 설계로 설계 비용이 감소
        - 관계형 데이터베이스의 relation과 join 구조를 linking과 embedded로 구현하여 성능이 빠름
        - Big Data 처리에 효과적
            - Scale out 구조를 채댁하여 서버 확장에 용이하며 더 많은 데이터를 저장
        - 가변적인 구조로 데이터 저장이 가능
        - Document based(Schema-less) 구조로 데이터 모델의 유연한 변화가 가능
        - json 구조로 RDBMS 테이블 구조에 비해 데이터를 직관적으로 파악
        - Auto Sharding을 지원

        * sharding이란
            - 단일의 논리적 데이터셋을 다수의 데이터베이스에 쪼개고 나누는 방법
            - 샤딩은 데이터셋이 단일 데이터베이스에서 저장하기에 너무 클 때 필수적으로 사용된다.

    - 단점
        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 복잡한 join은 어려움(다양하고 복잡한 데이터 쿼리), document based이기 때문
        - NoSQL은 sharding 방식을 사용해서 큰 테이블을 여러 서버에 나누어 저장한다.
          어떤 데이터가 update 되었을 때, NoSQL은 중복 저장된 서버들에 해당 update가 적용되기까지는 시간이 걸린다.
        - RDBMS는 모든 서버를 update 되기전까지는 해당 데이터 또는 테이블에 lock을 걸어 읽기 금지를 한다. 따라서 데이터에 대한 일관성이 보장된다.
          하지만 NoSQL에서는 lock을 하게 될 경우 느려지므로 RDBMS와 같은 lock을 하지 않는다.
        - 데이터 일관성이 항상 보장되지 않는다.


- Clustered Index vs Non-Clustered Index
    - Clustered Index
        - 정의
            - 데이터페이지 자체가 인덱스 키 값에 의해 물리적으로 정렬
            - 데이터페이지는 리프 레벨
            - 클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 된다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있다.
        - 특징
            - 테이블 당 1개만 허용
            - 기본 키 설정시 자동으로 만들어짐
            - 테이블 자체가 인덱스 (클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
            - 데이터 입력, 수정, 삭제 시 항상 정렬을 유지함
            - 물리적으로 행을 재배열 (실제 DB의 데이터파일에 정렬이 되어 있는 상태로 디스크에 저장)

    - Non-Clustered Index
        - 정의
            - 데이터 페이지를 건들지 않고, 별도의 장소에 인덱스 페이지를 생성
            - 우선 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬하고 데이터 위치 포인터를 생성한다.
            - 데이터 위치 포인터는 데이터가 위치한 고유한 값이 된다.
        - 특징
            - 인덱스 페이지를 별도로 저장
            - 테이블 자체는 되지 않고, 인덱스 페이지에만 정렬


- 인덱스 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어진다.
    - 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다.
      UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’ 처리를 해준다.
      만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어,
      SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.


- Index를 사용하면 좋은 경우
    - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
    - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
    - 데이터의 중복도가 낮은 컬럼
    - 필드에 저장된 값을 찾는 작업이 예상되는 경우
    - 필드의 값을 정렬하는 작업이 예상되는 경우


- 왜 Index를 생성하는데 b-tree를 사용하는가
    - 인덱스도 크기가 커져 보조 기억 장치에 저장되게 되는데 이 또한 디스크 I/O가 발생하게 되는 것이다.
      따라서 B-Tree의 깊이를 줄여야 디스크 I/O를 줄일 수 있기 때문에 B-Tree를 사용한다.

- 프로시저
    - 장점
        - 하나의 요청으로 여러 SQL문을 실행시킬 수 있습니다. (네트워크 부하를 줄일 수 있음)
        - 네트워크 소요 시간을 줄여 성능을 개선할 수 있습니다.
        - 여러 어플리케이션과 공유가 가능합니다. (API처럼 제공가능)
        - 기능 변경이 편합니다. (특정 기능을 변경할 때 프로시저만 변경하면 됨)

    - 단점
        - 문자나 숫자열 연산에 사용하면 오히려 C,Java보다 느린 성능을 보일 수 있습니다.
        - 유지보수가 어렵습니다.(프로시져가 앱의 어디에 사용되는지 확인이 어려움)


- 저장 프로시저(Stored PROCEDURE)
    - 정의
        - 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
        - 원하는 결과물을 얻기 위해 사용할 여러줄의 쿼리문을 한 번의 요청으로 실행
          인자 값만 상황에 따라 바뀌고 동일한 로직의 복잡한 쿼리문을 필요할 때마다 작성한다면 비효율적. 이럴 때 사용할 수 있는 것이 바로 프로시저다.

    - 장점
        1. 최적화 & 캐시
            프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다.
            만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.

        2. 유지 보수
            작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다. (But, 장점이 단점이 될 수도 있는 부분이기도.. )

        3. 트래픽 감소
            클라이언트가 직접 SQL문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 된다. 즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서버 간 네트워크 상 트래픽이 감소된다.

        4. 보안
            프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.

    - 단점
        1. 호환성
            구문 규칙이 SQL / PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁘다.

        2. 성능
            문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느리다.

        3. 디버깅
            에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.


- 친절한 SQL 튜닝
    - 인덱스 기본
        - 인덱스 튜닝
            1) 인덱스 스캔 효율화 튜닝
                - 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것
                - 인덱스 엑세스 조건(수직적 탐색 ,수평적 탐색)

            2) 랜덤엑세스 최소화 튜닝 (테이블의 엑세스 횟수를 줄이는 것)
                - 인덱스 스캔 후 테이블 레코드를 엑세스 할 때 랜덤 I/O 방식으로 사용하므로 이를 랜덤 액세스 최소화 튜닝이라고함.

        - 인덱스 구조
            - 범위 스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문
            - 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있음
                - 인덱스 수직적 탐색(인덱스 스캔 시작지점을 찾는 과정)
                    정렬된 인덱스 레코드 중 조건을 만족하는 첫번째 레코드를 찾는 과정이다. 즉 인덱스 스캔 시작 지점을 찾는 과정
                - 인덱스 수평적 탐색(데이터를 찾는 과정)
                    수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔함
                    인덱스를 수평적으로 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾기위해  Rowid를 얻기 위해

        - 인덱스 기본 사용법
            - Range Scan을 못 쓰는 경우
                - 인덱스 가공
                    - 인덱스 스캔 시작점을 찾을 수 없기 때문이다. 일정 범위를 스캔하려면 ‘시작지점’과 ‘끝지점’이 있어야 한다.

                - Like 문을 사용
                    ex) where 업체명 like '%대한%'
                    - LIKE로 검색해도 위와 같이 ‘대한’이라는 글자를 가진 인덱스를 중간 글씨에서 찾아야 하기 때문에, Range Scan이 불가능하다.

                - OR 조건
                    - OR 조건으로 검색할떄, 수직적 탐색을 통해 전화번호 ‘01012345678’이거나 고객명이 ‘홍길동’인 시작지점을 찾을 수 없다.
                    - 하지만 union all을 사용하면 각 쿼리당 다른 브랜치 블록을 타기 때문에, Index Range Scan 가능

                - IN 조건
                    - IN조건 또한 OR의 다른 표현이기 때문에, OR과 마찬가지로 Index Range Scan이 안된다.

        - 인덱스 사용조건
            - range scan을 하기 위해선 가장 첫번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다.
              반대로 말하면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 range scan이 무조건 가능하다.

        - 인덱스를 이용한 소트 연산 생략
            - 인덱스 순으로 이미 정렬된 상태로 order by를 했다. 이것은 order by를 생략할 수 있다.
            - 만약 이렇게 인덱스가 구성되어있지 않다면 SORT ORDER BY 연산이 실행계획에 추가된다.
            - 조건절 뿐만 아니라 ORDER BY절이나 SELECT-LIST 에서 컬럼을 가공하여 인덱스를 정상적으로 못 사용하는 경우가 있다.
                - SELECT-LIST 에서 컬럼 가공
                    select NVL(MAX(TO_NUMBER(변경순번)), 0)
                    from 상태변경이력
                    where 장비번호 = 'C'
                        and 변경일자 = '20180316'

                    위와 같이 ‘변경순번’의 값을 숫자로 바꾸면 인덱스를 사용할 수 없다.
                    왜냐면 인덱스는 문자열 기준으로 정렬되어 있는데 숫자값으로 바꾸었기 때문이다.

                - 자동 형변환
                    select * from 고객 where 생년월일 = 19920920

                    -- 이걸 옵티마이저가 이렇게 바꿈
                    select * from 고객 where TO_NUMBER(생년월일) = 19920920

                    - DBMS마다 다른데 오라클은 자동 형변환 하는 방식을 채택한다.
                    - 형변환 우선순위
                        - 오라클에서 숫자형과 문자형이 만나면 숫자형이 이긴다.
                        - 날짜형과 문자형이 만나면 날짜형이 이긴다.
                        - 근데 LIKE가 출동하면 문자형이 이긴다.

        - 인덱스 확장기능 사용법
            - Index Range Scan
                - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 엑세스 방식
                - 수직적 탐색 후 필요함 범위(Range)만 수평적 탐색
                - 인덱스 스캔 범위와 테이블 액세스 횟수를 줄이는 것이 성능 향상의 길

                - 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
                - B-tree 인덱스에서 루트 노드와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로 인덱스를 읽어 나간다.
                - 리프 노드에서 저장된 레코드 주소로 데이터 파일의 레코드를 읽어 오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 발생한다.
                - 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%를 넘으면 순차 I/O를 사용한 테이블 풀 스캔이 낫다고 하는 것이다.

            - Index Full Scan
                - 수직적 탐색 없이 오직 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
                - 최적의 인덱스가 없을때, 차선으로 선택된다.

                - 선두 컬럼이 조건절에 없으면 옵티마이저가 Index Full Scan을 고려한다.
                - 만약 테이블이 고용량이면 인덱스 활용을 고려하지 않을 수 있다.
                - 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면, 면적이 큰 테이블보다 인덱스를 스캔하는 쪽이 유리하다.

                - 인덱스의 처음부터 끝까지 모두 읽는 방식
                - 쿼리의 조건절에 사용된 칼럼이 첫 번째 칼럼이 아닌 경우 사용된다.
                    ex) 인덱스 (a,b,c) 칼럼의 순서로 만들어져 있지만, 쿼리의 조건절은 b 칼럼이나 c 칼럼으로 검색
                - 루트 노드의 첫 번째 인덱스 레코드와 이어진 브랜치 노드를 거쳐 리프 노드로 이동한다.
                - 해당 리프 노드의 첫 번째 페이지의 인덱스 레코드 방향부터 아래로 탐색한다.
                - 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 작은 경우가 많으므로 풀 테이블 스캔보다 적은 IO 로 쿼리를 처리할 수 있다.

            - Index Unique Scan
                - 수직적 탐색으로만 데이터를 찾는 방식으로, Unique 인덱스를 = (equal) 조건으로 탐색하는 경우
                - Unique 인덱스가 존재하는 컬럼은 중복값 없이 입력되지 않게 DBMS가 정합성 관리해준다. 그래서 데이터를 = 조건으로 찾은 후 더이상 탐색이 필요없다.
                    - Unique 인덱스가 존재해도 Between, Like 등 범위 조건으로 검색하면 Index Range Scan을 한다.
                    - Unique 결합 인덱스도 검색 할 때, Index Range Scan을 사용한다.

            - Index Skip Scan
                - 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 Index Skip Scan을 사용한다.
                - Index Skip Scan은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 갯수가 많을때 유용하다.
                - 선두 컬럼이 조건절에 있고, 중간 컬럼이 조건절에 없어도 Index Skip Scan을 사용할 수 있다.
                - Distinct Value 개수가 적은 두 개의 선두컬럼이 다 조건절에 없어도 Index Skip Scan 사용할 수 있다.
                - 선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위 검색 조건일때도 Index Skip Scan 사용할 수 있다.
                - 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 한다.
                  만약 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때, 이들 스캔 방식을 차선책으로 활용하는 전략이 바람직하다.

                - 루스 인덱스 스캔 ??
                    - 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
                    - 인덱스 레인지 스캔과 비슷하게 동작하지만 중간마다 필요하지 않은 키 값은 무시한다.
                    - 일반적으로 group by 또는 max 등의 함수에 대해 최적화할 때 사용한다.
                    ex) select dept_no, MIN(emp_no)
                        from dept_emp
                        where dept_no between 'doo2' and 'd004'
                        group by dept_no;

                        dept_emp 테이블은 dept_no와 emp_no 2개의 컬럼으로 인덱스를 구성하고 있다고 가정하며, 이 인덱스는 (dept_no, emp_no)를
                        기준으로 정렬이 되어 있다. 즉 특정 dept_no 그룹 별로 처음에 있는 emp_no만 읽으면 된다. 즉, 인덱스에서 where 조건을
                        만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있으므로 중간 중간 조건에 맞지 않으면 건너 뛴다.

            - Index Fast Full Scan
                - Index Fast Full Scan은 Index Full Scan보다 빠르다.
                - 그 이유는, 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문이다.
                - Index Fast Full Scan은 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다.
                - 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과 발휘한다.
                - 인덱스 키 순서대로 정렬되지 않다. (연결 리스트 구조를 무시해서 결과집합이 인덱스 키 순서대로 정렬되지 않음)
                - 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때 사용 가능함.
                - 병렬스캔 가능

            - Index Range Scan Descending
                - Index Range Scan과 기본적으로 동일 스캔방식이나, 인덱스를 뒤에서 앞으로 스캔하기 때문에 내림차순으로 결과집합을 얻는다.


1-1 해당 쿼리가 왜 인덱스 타지 않았는지? (인덱스를 저장하는 구조를 활용하여)
    - 양방향 like 검색
1-2 양방향 LIKE 검색 경우 인덱스를 타지 않는데 힌트만 줘서는 인덱스가 타도록 유도가 안되는데 구체적으로 어떻게 해결한건지?
    - 문자열 % like 검색 으로 바꿈
1-3 여러가지 인덱스가 있을텐데 어떤 인덱스를 타고 있기 때문에 다른 인덱스를 타도록 유도하기 위해서 힌트를 사용했을텐데 그 과정
    - 결합인덱스의 선행 칼럼 조건이 입력되지 않아 INDEX FAST FULL SCAN 이던걸 INDEX_SS 를 통해 INDEX SKIP SCAN 유도


- 슬로우 쿼리에 대처하기
    https://hyperconnect.github.io/2020/08/31/improve-slow-query.html

- SQL 튜닝
    - Join, Indexing, SQL Execution Plan

- 옵티마이저
    - 가장 효율적인 방법으로 SQL 을 수행할 최적의 처리 경로를 생성해주는 DBMS 의 핵심 엔진
    - 컴퓨터의 두뇌가 CPU 인 것처럼 DBMS 의 두뇌는 옵티마이저
    - SQL 을 작성하고 실행하면 소프트웨어 실행파일처럼 즉시 실행되는 것이 아니라 옵티마이저(Optimizer)라는 곳에서 "이 쿼리문을
      어떻게 실행시키겠다!"라는 여러 가지 실행계획을 세우게 됩니다. 이렇게 실행계획을 세운 뒤 시스템 통계정보를 활용하여
      각 실행계획의 예상 비용을 산정한 후 각 실행계획을 비교해서 최고의 효율을 가지고 있는 실행계획을 판별한 후 그 실행계획에
      따라 쿼리를 수행하게 되는 것입니다.

    - 종류
        항목	        규칙 기반 옵티마이저	                    비용 기반 옵티마이저
        개념	        사전에 정의된 규칙 기반	                    최소비용 계산 실행계획 수립
        기준	        실행우선 순위(Ranking)	                액세스 비용(Cost)
        인덱스	    인덱스 존재 시 가장 우선시 사용	            Cost 에 의한 결정
        성능	        사용자 SQL 작성 숙련도	                    옵티마이저 예측 성능
        장점	        판단이 매우 규칙적 실행 예상 가능	            통계 정보를 통한 현실 요소 적용
        단점	        예측 통계정보 요소 무시	                    최소 성능 보장 계획의 예측 제어 어려움
        사례	        AND 중심 양쪽 ‘=’ 시 Index Merge 사용	    AND 중심 양쪽 ‘=’ 시 분포도별 Index 선택

    - 동작 방식
        Parser : SQL 문장을 분석하여 문법 검사와 구성요소를 파악하고 이를 파싱 해서 파싱 트리를 만듭니다.
        Query Transformer : 파싱된 SQL 을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL 로 변환이
                            가능한지를 판단하여 변환 작업을 수행합니다.
        Estimator : 시스템 통계정보를 딕셔너리로부터 수집하여 SQL 을 실행할 때 소요되는 총비용을 계산합니다.
        Plan Generator : Estimator 를 통해 계산된 값들을 토대로 후보군이 되는 실행계획을 도출합니다.
        Row-Source Generator : 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는
                               코드나 프로시저 형태로 포맷팅 합니다.
        SQL Engine : SQL 을 실행합니다.


- NESTED LOOP JOIN 이란?
    where 절에 있는 조건에 따라 두 테이블에서 하나의 테이블을 기준으로 삼아 다른 하나의 테이블에 있는 데이터를 읽는 방식으로 조인을 수행.
    어떤 테이블을 드라이빙 테이블로 선택하느냐가 중요하다. 왜냐면 드라이빙 테이블의 로우를 가지고 이너를 검색하기 때문

    NL JOIN 이라고도 불리는 NESTED LOOP JOIN 은 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row 를
    결합하여 원하는 결과를 조합하는 조인 방식


- RDBMS에서 트랜잭션이 무엇인가요?
    - 데이터베이스의 무결성을 유지하면서 데이터베이스의 상태를 변화시키는 작업을 수행합니다.
    - 데이터베이스는 하나 이상의 쿼리를 포함하고 있으며 ACID 규칙을 만족합니다.
    - 트랜잭션은 작업의 완전성을 보장해줍니다.


- 트랜잭션 격리 수준
    - 정의
        - 트랜잭션들끼리 얼마나 고립되어 있는지(잠금수준)를 나타내는 것


- SQL 쿼리를 짤 때 주의해야 하는 것들
    1. where 조건절 걸 때, index 순서에 맞게 거는게 좋다.
    2. SQL 쿼리에서 풀스캔이 있는지 없는지 확인한다.
        - SQL 실행 속도를 현저하게 비효율적으로 만드는 것이 풀스캔이다. 데이터가 많은 경우 out of memory가 발생하거나 DB 서버가 죽어버린다.
    3. Driving Table 을 정한 후에 사용해야 한다.
        - 데이터 수가 적은 테이블을 Driving Table 로 선정
    4  같은 내용의 조건이라면, GROUP BY 연산 시에는 가급적 HAVING보다는 WHERE 절을 사용하는 것이 좋습니다.
    5. SELECT DISTINCT, UNION DISTINCT와 같이 중복 값을 제거하는 연산은 최대한 사용하지 않아야 합니다.
    6. 3개 이상의 테이블을 INNER JOIN 할 때는, 크기가 가장 큰 테이블을 FROM 절에 배치하고, INNER JOIN 절에는 남은 테이블을 작은 순서대로 배치하는 것이 좋습니다
    7. IN 대신 EXISTS 사용
        - 서브 쿼리의 결과가 많으면 EXISTS가 나은 성능을 제공하며 그렇지 않으면 IN을 사용하는 것이 좋습니다.
        - EXISTS는 일치하는 항목이 발견되는 즉시 검색 프로세스를 종료하지만 IN은 모든 항목을 비교하기 때문입니다.
    8. ORDER BY 금지
        - RDBMS마다 다르지만 서브 쿼리(Sub Query)에서 Order By를 사용하는 경우 많은 비용이 발생합니다. 그러므로 서브 쿼리에서 Order By를 사용하지 않도록 합니다.
    9. WHERE문에 함수 사용 제한
        - COL1이라는 컬럼이 인덱스로 잡혀있는데 WHERE문에서 함수와 함께 사용되면 인덱스가 깨지므로 검색 속도가 느려집니다.
          인덱스로 잡혀있는 칼럼은 WHERE문 또는 JOIN에서 함수와 사용하는 것을 피해야 합니다.


- SQL 성능 향상 팁
    - index를 타는지 항상 체크하라.
    - select 쿼리문 작성시 필요한 칼럼(column)만 명시
    - where조건문의 왼쪽은 되도록 변형되지 않은 순수한 column만을 선언
    - JOIN을 사용하는 경우 INNER JOIN을 되도록 사용
    - 서브쿼리 사용시 불필요한 select 구문을 줄여라.

    -> 전반적인 성능향상을 꾀하려면 CPU, 메모리, I/O 의 밸런스를 맞추어야 한다. DB성능 튜닝은 이 세가지 자원에 걸리는 부하를 적절하게 분산시켜 비용대비 최적의 성능을 뽑아내는것이 핵심이다.

    * 일반적으로 대용량 테이블이라 하더라도 인덱스가 제대로 작동하고 있다면 검색 자체가 성능저하를 가져 오지는 않는다.
      다만, 복수의 JOIN과 같이 대량의 Nested Loop 가 발생한다면 엄청난 양의 I/O가 발생하고 이것이 RDB전체의 성능을 크게 저하시키는 원인이 되기도 한다.

    * HDD의 I/O 속도는 메모리에 비하여 많이 느리다. 10,000RPM HDD와 DDR3-2500 메모리의 성능 차이는 약 800배에 이른다.
      DBMS 같은 시스템에서는 효과적으로 버퍼(캐시)를 구현하여 I/O 발생을 최소화하도록 구현하고 있다. 그래서 히트(hit)율이 높을 때는,
      HDD에서 SSD로 교체해도 성능 향상 효과가 미미한 경우가 있다. 하지만 SSD를 사용하면 버퍼 크기를 작게 유지해도 되기 때문에 대용량의 메모리를 유지할 필요가 적어지기도 한다.


- LOCK의 부작용이 있을까요?
    - LOCK의 제어를 잘 못하면 데드락이 걸릴 수 있습니다.

    1) 트랜잭션 1이 A 를 읽기 위해 LOCK을 검
    2) 트랜잭션 2가 B를 읽기 위해 LOCK을 검
    3) 트랜잭션 1이 B를 읽어 오려고 했으나 LOCK이 걸려 대기
    4) 트랜잭션 2가 A를 읽어 오려고 했으나 LOCK이 걸려 대기


- Transaction 관리를 위한 DBMS 전략
    - DBMS 구조
        - Query Processor(질의 처리기), Storage System(저장 시스템)
        - 입출력 단위: 고정 길이의 page 단위로 disk 에 읽거나 쓴다.
        - 저장 공간: 비휘발성 저장 장치인 disk 에 저장, 일부분을 Main Memory 에 저장

    - Buffer 관리 정책
        - DBMS 의 Storage System 에 속하는 모듈 중 하나로, Main Memory 에 유지하는 페이지를 관리하는 모듈
        - Buffer 관리 정책에 따라, UnDo 복구와 ReDo 복구가 요구되거나 그렇지 않게 되므로 transaction 관리에 매우 중요한 결정을 가져옴

    - UnDo
        - 수정된 페이지들이 Buffer 교체 알고리즘에 따라서 디스크에 출력될 수 있음.
          Buffer 교체는 transaction 과는 무관하게 buffer 의 상태에 따라서 결정됨
          따라서 정상적으로 종료되지 않은 transaction 이 변경한 페이지들은 원상 복구되어야 하는데 이 복구를 undo 라고 함

        - 2 개의 정책 (수정된 페이지를 디스크에 쓰는 시점으로 분류)
            - steal: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
                - 대부분의 DBMS 가 채택하는 Buffer 관리 정책
                - UnDo logging 과 복구를 필요로 함
            - no-steal: 수정된 페이지들을 EOT(End Of Transaction)까지는 버퍼에 유지하는 정책
                - UnDo 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함

    - ReDo
        - 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업
        - Buffer 관리 정책에 영향을 받음 (트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지를 디스크에 쓸것인가 아닌가로 기준)
            - FORCE: 수정했던 모든 페이지를 트랜잭션 커밋 시점에 disk 에 반영
                - 트랜잭션이 커밋되었을 때 수정된 페이지들이 disk 상에 반영되므로 redo 필요없음
            - no-FORCE: 커밋 시점에 반영하지 않는 정책
                - 트랜잭션이 disk 상의 db 에 반영되지 않을 수 있기에 redo 복구가 필요 (대부분의 DBMS 정책)

- 데드락(교착상태)
    - 발생 조건
        1. 상호배제
        2. 점유 대기
        3. 비선점
        4. 순환 대기
        => 네 가지 조건을 모두 만족하면 교착 상태가 발생

    - 해결 방법
        1. 교착 상태 예방
            - 위의 발생 중 하나 이상을 제거
        2. 교착 상태 회피
            - 교착 상태 발생 가능성을 검사해서 발생 가능성이 있다면 사전에 회피하는 방식
        3. 교착 상태 탐지 및 회복
            - 교착 상태를 허용하지만 상태를 탐지하고 회복하는 방식
        4. 교착 상태 무시
            - 교착 상태 자체를 무시하고, 특별한 조치를 취하지 않는 방법

    - 해결 방법
        1) 트랜잭션 진행 방향을 같은 방향으로 처리
            - 업데이트시 begintran로 인하여 블록킹이 될 수는 있으나 데드락이 발생할 확률이 줄어지게 됩니다.

        2)트랜잭션 처리 속도를 최소화
            - 트랜잭션 속도가 빨라 commit 처리가 되면 다른 트랜잭션에서 테이블이 잠길 일이 없습니다.

        3) SET LOCK_TIMEOUT문을 이용하여 잠금해제 시간을 조절
            - 데드락이 발생했을때 잠금 시간을 해제 해주면 무기한 대기하지 않고 만료가 되어 다음 작업을 진행할수 있습니다.
            - -1(기본값)은 제한시간없이 무기한대기

        - 데드락 발생시 DBMS는 둘 중 한 트랜잭션에 에러를 발생시킴으로써 문제를 해결.


- Lock 으로 발생할 수 있는 문제점 - 블로킹, 데드락
    - Blocking
        - Lock 들의 경합이 발생하여 특정세션이 작업을 진행하지 못하고 멈춰 선 상태
        - 데이터에 대해서 하나의 트랜잭션이 베타락을 걸면 다른 트랜잭션들은 어떠한 락도 걸지 못하고 대기해야하기 때문
        - 블로킹이 풀리는 시점은 트랜잭션이 커밋 혹은 롤백할 때
        - 해결 방안
            1. 트랜잭션을 짧게 정의
            2. 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계
            3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절

    - DeadLock 교착 상태
        - 각 트랜잭션의 락들이 서로 맞물려 무한 대기하는 상태
        - 해결 방안
            1. 트랜잭션 진행 방향을 같은 방향으로 처리
                -> 이렇게 하면 블로킹은 발생할 수 있지만, 데드락 발생 확률은 현저히 줄어듬.
            2. 트랜잭션 처리 속도를 최소화
            3. LOCK TIMEOUT 을 이용하여 잠금해제 시간을 조절


- 정규화란
    - 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정

    - 비정규형
        - 하나의 튜플에서 속성을 입력되는 도메인 값으로 여러 개의 값이 들어와서 원자성(Atomic)을 가지지 못한 경우
    - 제1정규형 (원자값이 아닌 도메인을 분해)
        - 원자값이 아닌 도메인을 분해하여 어떤 릴레이션 R에 속한 모든 도메인이 원자값으로만 되어 있도록 설계
    - 제2정규형 (부분 함수 종속 제거)
        - 어떤 릴레이션 R이 제1정규화에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수적 종속이면 충족하는 정규화
    - 제3정규형 (이행 함수 종속 제거)
        - 어떤 릴레이션 R이 제2정규화에 있으며 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아닌 상태의 관계
    - 보이스 코드 정규형 (결정자가 후보키가 아닌 함수 종속 제거)
        - 릴레이션 R의 모든 결정자가 후보키이면 릴레이션 R은 Boyce-Codd 정규형에 속하는 상태.
    - 제4정규형 (다중치 종속 제거)
    - 제5정규형 (후보키를 통하지 않은 조인 종속 제거)


- noSQL
    - NoSQL 정의
        - Not Only SQL
        - NoSQL 은 비관계형 데이터베이스를 지칭한다. 즉, 관계형 데이터 모델을 지양 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며
          스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.
        - NoSQL 은 기존 RDBMS 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며,
          관계형 데이터베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태이다.

    - NoSQL 의 특징
        - RDBMS 와 달리 데이터 간의 관계를 정의하지 않는다.
            - RDBMS 는 데이터 관계를 외래키 등으로 정의하고 JOIN 연산을 수행할 수 있지만, NoSQL 은 JOIN 연산이 불가능하다.
        - RDBMS 에 비해 대용량의 데이터를 저장할 수 있다.
            - 페타바이트 급의 대용량 데이터를 저장할 수 있다.
        - 분산형 구조이다.
            - 여러 곳의 서버에 데이터를 분산 저장해 특정 서버에 장애가 발생했을 때도 데이터 유실 혹은 서비스 중지가 발생하지 않도록 한다.
        - 고정되지 않은 테이블 스키마를 갖는다.
            - RDBMS 와 달리 테이블의 스키마가 유동적이다. 데이터를 저장하는 칼럼이 각기 다른 이름과 다른 데이터 타입을 갖는 것이 허용된다.

    - NoSQL 의 장점
        - RDBMS 에 비해 저렴한 비용으로 분산처리와 병렬 처리 가능
        - 비정형 데이터 구조 설계로 설계 비용 감소
        - Big Data 처리에 효과적
        - 가변적인 구조로 데이터 저장이 가능
        - 데이터 모델의 유연한 변화가 가능

        - RDBMS에 비해 저렴한 비용으로 분산 처리와 병렬 처리가 가능
        - 비정형 데이터 구조 설계로 설계 비용이 감소
        - 관계형 데이터베이스의 relation과 join 구조를 linking과 embedded로 구현하여 성능이 빠름
        - Big Data 처리에 효과적
            - Scale out 구조를 채댁하여 서버 확장에 용이하며 더 많은 데이터를 저장
        - 가변적인 구조로 데이터 저장이 가능
        - Document based(Schema-less) 구조로 데이터 모델의 유연한 변화가 가능
        - json 구조로 RDBMS 테이블 구조에 비해 데이터를 직관적으로 파악
        - Auto Sharding을 지원

        * sharding이란
            - 단일의 논리적 데이터셋을 다수의 데이터베이스에 쪼개고 나누는 방법
            - 샤딩은 데이터셋이 단일 데이터베이스에서 저장하기에 너무 클 때 필수적으로 사용된다.

    - NoSQL 의 단점
        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 데이터 일관성이 항상 보장되지 않음

        - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
        - 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
        - 복잡한 join은 어려움(다양하고 복잡한 데이터 쿼리), document based이기 때문
        - NoSQL은 sharding 방식을 사용해서 큰 테이블을 여러 서버에 나누어 저장한다.
          어떤 데이터가 update 되었을 때, NoSQL은 중복 저장된 서버들에 해당 update가 적용되기까지는 시간이 걸린다.
        - RDBMS는 모든 서버를 update 되기전까지는 해당 데이터 또는 테이블에 lock을 걸어 읽기 금지를 한다. 따라서 데이터에 대한 일관성이 보장된다.
          하지만 NoSQL에서는 lock을 하게 될 경우 느려지므로 RDBMS와 같은 lock을 하지 않는다.
        - 데이터 일관성이 항상 보장되지 않는다.

    - NoSQL 의 종류
        - Key-Value Database
            - 기본적인 패턴으로 KEY-VALUE 하나의 묶음(Unique)으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장 시 용이하다.
            - Key 안에 (COLUMN, VALUE) 형태로 된 여러 개의 필드, 즉 COLUMN FAMILIES 갖는다.
              주로 SERVER CONFIG, SESSION CLUSTERING 등에 사용되고 엑세스 속도는 빠르지만, SCAN 에는 용이하지 않다.
            Ex) Redis, Oracle NoSQL Database, VoldeMorte

        - Document Database
            - 테이블의 스키마가 유동적, 즉 레코드마다 각각 다른 스키마를 가질 수 있다.
              보통 XML, JSON 과 같은 DOCUMENT 를 이용해 레코드를 저장한다.
              트리형 구조로 레코드를 저장하거나 검색하는 데 효과적이다.
            Ex) MongoDB, CouchDB, Azure Cosmos DB

        - Wide-Column Database
            - 행마다 키와 해당 값을 저장할 때마다 각각 다른값의 다른 수의 스키마를 가질 수 있다.
              위 그림을 참고하면 사용자의 이름(key)에 해당하는 값에 스키마들이 각각 다름을 볼 수 있다.
              이러한 구조를 갖는 WIDE COLUMN DATABASE 는 대량의 데이터의 압축, 분산처리, 집계 쿼리 (SUM, COUNT, AVG 등)및
              쿼리 동작 속도 그리고 확장성이 뛰어난 것이 그 대표적 특징이라 할 수 있다.
            EX) Hbase, GoogleBigTable, Vertica

        - Graph Database
            - 데이터를 노드로(그림에서 파란, 녹색 원) 표현하며 노드 사이의 관계를 엣지(그림에서 화살표)로 표현
              일반적으로 RDBMS 보다 성능이 좋고 유연하며 유지보수에 용이한 것이 특징.
              Social networks, Network diagrams 등에 사용할 수 있다.
            Ex) Neo4j, BlazeGraph, OrientDB


- RDBMS와 NoSQL의 차이에 대해 설명해주세요.
    - RDBMS는 모든 데이터를 2차원 테이블 형태로 표현합니다.
        장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
        단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)

    - NoSQL(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.
        장점 : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
              데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만 아닌 scale-out 또한 가능하다.
        단점 : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
              스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.


- 그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?
    - RDBMS
        - 데이터 구조가 명확하고, 변경될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다.
        - 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합

    - NoSQL
        - 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다.
        - 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋다.
        - Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합


- NoSQL
    - 관계형 데이터베이스와 반대되는 방식을 사용하여 스키마와 관계라는 개념이 없다.
    - RDBMS에서는 스키마에 맞추어 데이터를 관리하여야 하지만 NOSQL은 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있다.
    - NOSQL에서 테이블과 같은 개념으로 컬렉션이라는 형태로 데이터를 관리한다.

    - 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋다.


- Replication
    - 2개 이상의 DBMS를 Master와 Slave로 나누어 동일한 데이터를 저장한다.
    - Master DB는 Insert, Update, Delete의 기능을 수행하고, Slave DB에 실제 데이터를 복사한다.
    - Slave DB 시간이 오래걸리는 Select문의 기능을 수행하여 전체적인 Select문 성능을 향상시킨다.

    - DB 이중화
        - master db에서는 insert , update ,delete 작업 , slave db에서는 read용으로 사용
        - mysql replication을 통해 데이터 복제

    - replication 장점
        - DB 서버 부하 분산
        - master db 장애시 slave db로 대체 가능

    - replication 단점
        - Master-Slave pair 관리:서버들이 많아질 경우, Master와 Slave의 짝을 관리하는 것이 쉽지 않다.
        - 실패 상황에서의 복구 : Master가 실패시 Master와 Slave의 교체, 혹은 Slave의 데이터를 Master로 복사하는 등의 작업을 수동으로 진행하여야 한다.
          Slave의 실패인 경우도 마찬가지이다.
        - binary log의 관리: Master 에 쌓이는 binary log에 대한 관리 또한 수동으로 처리하여야 한다.(cron등을 이용하여 정기적인 삭제 필요)
        - replication 지연발생: Master의 처리량이 많은 경우 Slave는 지연시간이 발생하게 되고 그 시간동안의 데이터는 일치하지 않는 문제가 있다.


- 샤딩
    - 데이터가 많아서 검색이 느린데 더 빠르게 할 수 있는 방법은 없을까?
        - 샤딩은 수평 분할(Horizontal Partitioning)과 동일하며, 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위한 것이다.
        - 수평 분할(Horizontal Partitioning)이란 스키마(schema)가 같은 데이터를 두 개 이상의 테이블에 나누어 저장하는 디자인을 말한다.
        - 가령 같은 주민 데이터를 처리하기 위해 스키마가 같은 '서현동주민 테이블'과 '정자동주민 테이블'을 사용하는 것을 말한다.
        - 데이터베이스를 샤딩하게 되면 기존에 하나로 구성될 스키마를 다수의 복제본으로 구성하고 각각의 샤드에 어떤 데이터가 저장될지를 샤드키를 기준으로 분리한다.

    - 프로그래밍, 운영적인 복잡도는 더 높아지는 단점이 있습니다.
        - 가능하면 Sharding을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선되어야 합니다.

    - Scale-in
        - Hardware Spec이 더 좋은 컴퓨터를 사용합니다.

    - Read 부하가 크다면?
        - Cache나 Database의 Replication을 적용하는 것도 하나의 방법입니다.

    - Table의 일부 컬럼만 자주 사용한다면?
        - Vertically Partition도 하나의 방법입니다. Data를 Hot, Warm, Cold Data로 분리하는 것입니다.

    - 기본개념을 넘어 좀더 자세히 알자보자면!!
        - 분산된 DB에서 어떻게 Data를 읽어오기 위해 Shard Key에 대한 방식을 선택해야 한다.

    - Algorithm Sharding
        - Database id를 단순하게 나누어 샤딩하는 방식
        - Sharding Key는 hash(key) % NUM_DB 같은 방식

        - 장점 같은 값을 가지는 key-value 데이터베이스에 적합하다.
        - 단점 Cluster를 포함하는 Node 갯수가 변하게 되면 Resharding이 필요하다. Hash Key로 분산되기 때문에 공간에 대한 효율이 부족하다.

    - Dynamic Sharding
        - 클라이언트는 Locator Service에 접근하여 Shard Key를 얻는다.
        - 장점 Cluster가 포함하는 Node 갯수가 변하면 Shard Key를 추가하기만 하면 된다.
            - 확장에 유연하게 대처가능하다.
        - 단점 Data Relocation시에는 Locator Service의 Shard key Table도 일치시켜야 한다.
            - Locator에 의존할 수 밖에 없는 구조이다.

    - Entity Group
        - Database id를 단순하게 나누어 샤딩하는 방식
        - Sharding Key는 hash(key) % NUM_DB 같은 방식

        - 장점 같은 값을 가지는 key-value 데이터베이스에 적합하다.
        - 단점 Cluster를 포함하는 Node 갯수가 변하게 되면 Resharding이 필요하다. Hash Key로 분산되기 때문에 공간에 대한 효율이 부족하다.


- 파티셔닝
    - VLDB(Very large DBMS)
    - 전체 DB가 하나의 DBMS시스템에 다 들어가기 힘들어지는 경우, 테이블들을 여러 개의 군으로 나눠 분산 저장
    - 하나의 테이블이 방대한 경우에는 사전방식과 같이 나눠 저장
    - 파티셔닝 DBMS 레벨 분할
      샤딩 DBMS 외부에서 분할 / 응용레벨에서 구별해야 함

    - 파티셔닝 방식
        - 범위(range) a-m/n-r/s-z
        - 해시(hash) 해시함수 파티션별로 크기를 비슷하게 나눔
        - 리스트(list) 특정한 컬럼을 기준
        ex) Card 테이블에 연도 (CreationTime) 컬럼을 추가하고 파티셔닝하시오.


- mybatis 캐시
    - Local cache
        - MyBatis에는 Local cache라는게 있는데 이녀석은 끌 수없고 항상 활성화
        - SESSION과 STATEMENT라는 설정 범위를 갖고있고 SESSION이 기본값
        - STATEMENT와 SESSION의 차이는 캐시데이터의 생존범위

        - 따로 설정이 없다면 기본설정인 SESSION과 범위로 되어 있습니다.

    - SESSION
        SESSION을 적용했을때 cache의 정보의 생존범위는 session이 유지되는 순간까지 이다.
        즉 Transaction이 끝나거나(commit이나 rollback) 아니면 insert, update, delete 가 실행되면
        Local cache가 보유하고 있던 cache 정보는 폐기된다.

    - STATEMENT
        mapper에 정의된 액션( .. , ..) 하나까지 유지
        사실상 cache를 거의 사용하지 않는 것과 같은 효과이다.

    - Second level cache
        - Second level cache 는 Local cache 와는 다르게 비활성화 활성화가 가능
        - Second level cache를 활성화 하고 싶다면 mapper.xml에서 설정을 해줘야한다.

        - eviction: 캐시 알고리즘 속성으로 기본은 LRU(사용빈도가 낮은것)이고 그 외에 3가지가 있음. FIFO(선입선출).
        - flushInterval: 캐시 유지 설정1분 뒤 캐시 비움.(단, 특정 시각을 정하지는 못함)
        - size: 디폴트 값은 1024이며, 메모리 여부를 확인 후 사용해야 할 듯.
        - readOnly: 캐시 데이터를 읽기만 가능하게 할지 설정. (읽기/쓰기 모두 가능한 경우에는 반환된 캐시 데이터에 대한 변경이 가능하며, 캐시 복사본을 반환한다고 함)

        - 위에 선언을 해주고 사용할 statement에 select 안에 useCache 옵션을 True로 설정해주면 해당 Statement의 결과가 캐시된다.
            - Second level cache는 Session 범위 밖에서의 캐시사용 여부를 조정한다.
            - Local cache는 Statement 실행후 Commit이 되면 캐시를 지우는데 반해 Second level cache는 commit을 해도 캐시데이터가 살아있다.

        - mybatis cache는 이와같고 mybatis cache는 잘사용하지 않으며 DAO단의 캐시보단는 ehcache ,redis를 이용한 service단의 캐시를 고려하는게 좋은거 같다.


- db 부하를 줄이기 위한 마이바티스 캐시 설정
    https://yunamom.tistory.com/40
    https://blog.opendocs.co.kr/?p=199
    https://techblog.lotteon.com/%EC%96%B4%EB%9E%8F-%EC%97%AC%EA%B8%B0%EC%97%90%EC%84%9C-oom-%EB%B0%9C%EC%83%9D%ED%95%A0-%EC%A4%84%EC%9D%B4%EC%95%BC-503ddf286fd

    MyBatis에는 2가지 내장 Cache가 존재
        local session cache
        second level cache

        local session cache는 임의로 켜거나 끌 수 없고, 무조건 활성화됩니다. 저장 범위가 session 또는 statement이며, 디폴트는 session이다. 기본적으로 작동하며, 해제가 불가하다.
        반면 second level cache는 mapper namespace 단위로 동작하여 개발자가 켜거나 끌 수 있습니다.
        second level cache는 mapper namespace 단위로 동작합니다. 이 Cache를 켜기 위해서는 mapper.xml 파일 안에 <cache />를 입력하면 됩니다.
        Mapper에 <cache /> 설정을 안해주면 해당 Mapper에서 정의된 Statement는 캐싱이 되지 않습니다.


- mybatis # $ 차이점
    - #
        - 쿼리문을 작성할 때 #{}을 사용하는 경우 PreparedStatement를 생성하게 되는데 위의 ?에 파라미터가 바인딩되어 수행된다.
        - 파싱된 쿼리문은 재활용(캐싱)되기 때문에 효율적이다
        - 변수에 작은 따옴표(‘)가 자동으로 붙여 쿼리가 수행되기 때문에 '#{id}'와 같은 식으로 쿼리문을 작성하지 않아도 된다
        - 쿼리 주입을 예방 할 수 있어 보안상 유리하다.

    - $
        - 값이 넣어진 채로 쿼리문이 수행된다. 그렇기 때문에 파라미터의 값이 바뀔 때마다 항상 쿼리문 파싱을 진행해야 한다.
        - 성능상의 단점이 존재한다.
        - 쿼리 주입 예방이 되지 않아 보안상 좋지 않다.
        - 테이블,칼럼명을 파라미터로 전달 할 때 사용한다.


- SQL Injection이 무엇인지 설명해주세요.
    - SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다.
    - SQL Injection을 방어 및 방지하기 위한 방법
        1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값) 인지 검증합니다.
        2. 저장 프로시저를 사용합니다.
            ※ 저장 프로시저란 사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상한다.


- PreparedStatement vs Statement
    PreparedStatement
        PreparedStatement 는 동일하거나 비슷한 SQL 문을 효율적으로 처리하기 위한 기능을 뜻합니다.
        동작 방식
            준비 —> 컴파일 —> 변수 바인딩 —> 실행 단계입니다.
            준비 단계에서는 ? 를 사용하여 쿼리 작성 insert into xxx (xxx) values(?,?).
            컴파일 후, 실행 단계에서는 값을 바인딩 한 후, SQL 실행합니다.

    Statement
        Statement 는 위 PreparedStatement 1~4단계를 계속해서 반복해서 사용합니다.

    차이점
        PreparedStatement 는 처음 한 번만 1~3단계를 거친 후, 캐시에 담아 재사용합니다.
        동일 쿼리를 반복적으로 수행한다면 PreparedStatement 가 성능에 좋습니다.