- 추상클래스/인터페이스
    1. Java 8 이후의 Interface 의 특징
    2. Interface 를 써야 하는 이유
    3. Skeletal Implementation 이란
    4. Interface 사용시 주의점


    1. Java 8 이후의 Interface 의 특징
        - 인스턴스를 생성할 수 없고 상수만 가질 수 있다.
        - 메서드 body 가 없는 추상 메서드를 가진다.
        - 디폴트 메소드, static 메서드만 가질 수 있다. (JDK 1.8 이상)
            - 디폴트 메서드
                - 인터페이스에서 메서드 body 를 가지는 메서드.
                - 반드시 override 할 필요는 없음. 접근 제어자는 public
                - 이미 작성된 인터페이스에서 기능을 추가하려고 할 때 디폴트 메서드 없이는 구현체 클래스들이 전부 override 를 해야하지만,
                  디폴트 메서드가 있다면 그런 작업 없이 하위호환이 가능

    2. Interface 를 써야 하는 이유
        - 다중 상속이 가능하다.
          ex) singer -> songWriter -> singerSongWriter 로 구현하면 다중 상속 필요 없지 않나?
              singer -> songWriter 상속 관계 때문에 songWriter 생성 시 불필요한 singer 의 메서드나 필드가 상속된다.
              즉, 독자적인 songWriter 를 생성할 수 없다.
              따라서, singer 와 songWriter 에서 가져오고 싶은 속성을 singerSongWriter 에 가져와야 한다.
              => 추상클래스만으로 표현하다보면 조합적 폭발이 발생
          * 다이아몬드 문제: 다중 상속 시, 부모 클래스에 같은 시그니처의 메서드가 있을 때 어떤 메서드를 상속받아야 하는지 판별할 수 없는 문제
                          그러나, 추상메서드는 구체적인 선언부가 없기 때문에 모호함이 발생하지 않는다.

        - 공통의 조상을 갖지 않는 두 클래스에 관계를 맺을 수 있다.
        - 사용자 입장에서는 내부적 구조에 대한 이해 없이 약속된 행위가 보장된다.
        - 추상 클래스도 이런 다형성 구현이 가능하지만, 상속관계에 있는 클래스끼리만 가능. 따라서, 인터페이스가 좀 더 유연하게 다형성 적용 가능

        - 추상 클래스 써야 할 때
            1. 굉장히 밀접하게 관련된 클래스끼리 코드를 공유해야 할 때
            2. 추상 클래스의 하위 구현체 클래스들이 공통된 필드나 메서드를 많이 공유하고, 접근제어자가 public 이 아닌 경우
            3. Non-static 혹은 non-final 의 필드로 객체의 상태를 바꿔야 하는 경우

        - 인퍼페이스 써야 할 때
            1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
            2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
            3. 다중 상속이 필요한 때

    3. Skeletal Implementation 이란
        ex) Java Collection 의 AbstractList, AbstractMap 등

        - 추상 골격 클래스는 private, protected 가 가능하므로 override 한 메서드의 내부 메서드들을 클라이언트가 접근하지 못하도록
          막을 수 있다. 그러나, 직접 interface 를 구현하게 되면 접근 제어자가 모두 public 이기 때문에 이와 같은 은닉이 힘들다.
          또한 디폴트 메서드에서는 하위 구현체 클래스에 대한 상태, 즉 필드에 대한 참조가 이루어질 수 없다.

        - 디폴트 메서드의 도입 원인을 생각하면, 이미 존재하는 인터페이스의 하위 호환성을 위해서이다.
          따라서, 새로 인터페이스를 만드는 시점에서 디폴트 메서드를 쓴다면 디폴트 메서드 도입 취지와는 맞지 않다.

    4. Interface 사용시 주의점
        ex) Java 8에서 Collection 에 추가된 removeIf 디폴트 메서드
        - 멀티 쓰레드 환경인 SynchronizedCollection 에서는?
            - 런타임 에러 -> removeIf 를 override 하자 (lock 을 설정하여)
                        -> 원래의 디폴트 메서드를 목적에 맞게 재정의해서 해결

        - 디폴트 메서드 override 시 다이아몬드 문제가 일어나지 않나?
            - 디폴트 메서드 다중 상속 시, 약간의 우선순위로 해결
                1. 구현하는 클래스나 슈퍼클래스
                2. 상속받는 인터페이스
                3. 명시적 사용

        => 디폴트 메서드는 런타임 에러를 일으킬 수 있다.
           이미 구현된 인터페이스에 디폴트 메서드를 추가하는 것은 신중히 해야 한다.
           디폴트 메서드를 추가하려면 릴리즈 전에 반드시 테스트를 거쳐야 한다.

- stream vs for
    - for 문
        - java 1부터 지원
        - for (초기화; 조건; 후처리)

    - 향상된 for 문
        - java 5부터 지원
        - 가독성 up, 안정성 up

    - stream
        - java 8부터 지원
        - stream 생성 -> 중간 연산 -> 최종 연산

    - 둘 다 다량의 데이터 처리 작업에 사용

    - 차이점
        - 함수 객체 vs 코드 블럭
            - for 문은 코드 블록으로 표현
            - 스트림 파이프라인은 함수 객체로 표현 (람다 or 메서드 참조)
            -> 람다식에는 final 변수만 읽을 수 있기 때문에 지역 변수를 수정할 수 없다.
            -> for 문에서는 할 수 있는 continue, break 로직은 stream 에서는 할 수 없다.

        - 외부 반복 (how) vs 내부 반복 (what)
            - 외부 반복: for 문, 구체적인 구현 로직이 외부에 노출
            - 내부 반복: stream, 로직이 노출되지 x

        - 가독성
            ex) for 문의 경우 if 문의 중첩으로 인해 indent depth 가 깊어져 가독성이 떨어질 수 있으나
                stream 의 경우, 조건들을 filter 의 체이닝 형식을 통해 표현할 수 있기 때문에 보다 간결한 표현 가능

            ex) if 문의 중첩 만 있을 경우, 메서드 추출을 통해서 충분히 indent depth 를 줄여 가독성을 높일 수 있었음.
                하지만, for 문으로 요소를 순회하면서 return 을 하는 경우에는 메서드 추출을 통해 indent depth 를
                줄이는 것이 어려움.
                이런 경우, stream 을 이용하면 depth 를 줄여 가독성을 높일 수 있음.

            - 상황에 따라 stream 이 더 가독성이 안 좋을 수도 있음.

        - 디버깅
            - stream 은 많은 내부 수행 작업과 지연 연산으로 인해 디버깅이 다소 어려울 수 있다.
            - for 문은 예외가 발생하는 stack trace 가 간결하게 출력되서 디버깅에 유리할 수 있다.

        - 병렬 처리
            - for 문의 경우, Runnable 등을 활용해 병렬 처리를 위한 코드를 일일이 작성해야 함.
              로직이 복잡해질 경우 직접 구현하기도 까다롭고 신경쓸 것도 많아짐
              데이터들을 몇 개로 어떻게 나눌 것인지, 혹은 발생할 수 있는 동시성 문제가 있는지를 고려해야 한다.
            - stream 을 이용하면 위의 내용들을 stream 이 내부적으로 처리해 주기 때문에 보다 쉽게 병렬 처리 표현 가능

        - 성능
            - int 배열에서 for 문이 stream 보다 빠른 이유
                - for 는 나온지 오래된 만큼 stream 에 비해 JVM 에서 최적화가 충분히 이루어졌다.

                - stream 을 사용하려면 stream 객체를 생성해야 한다.
                  이 생성 과정에서 여러 작업들이 이루어지고 stream 에서 필요한 다른 객체를 생성하는데 오버헤드가 발생
                - for 는 추가적인 객체 생성 없이 인덱스를 통해서 메모리에 직접 접근을 하기 때문에
                  stream 에 비해 오베헤드가 발생하지 않는다.

            - 향상된 for 문에서는 원시타입 배열에 어떻게 접근 할까?
                - 향상된 for 문에서는 컬렉션을 순회할 때와 마찬가지로 iterator 를 이용할 것이라고 예상할 수 있지만
                  원시타입 배열이 들어온 경우에는 iterator 가 아닌 전통 for 문의 형식으로 바꾸어서 순회.
                  따라서 int 배열에 대한 작업에서는 전통 for 문과 향상된 for 문이 비슷한 성능을 보임

            - List 에서 성능 차이가 미미한 이유
                - int 배열은 요소들이 원시타입인 반면 컬렉션은 Wrapper 타입이 들어오게 된다.
                  그래서 박싱 및 언박싱에 대한 오버헤드가 발생한다. 이 오버헤드는 충분히 크기 때문에
                  컬렉션에 대한 성능은 이 오버헤드에 지배되면서 큰 성능 차이를 보이지 못함.

            => 하지만, 오늘날의 하드웨어는 충분히 빠르기 때문에 소프트웨어에서는 성능보다는 다른 점들을 더욱 신경쓰는 추세.
               유지보수, 가독성 등을 고려하는 것이 더욱 좋을 수 있음.

    - 결론
        - 가독성
            - 추상화된 api 를 제공하고, 보다 What 중심의 코드를 작성할 수 있어 가독성이 더 좋을 수 있다. (개인 차이 존재)

        - 디버깅
            - for 문에 비해 stream 이 디버깅이 어렵다.

        - 병렬 처리
            - 비교적 stream 을 이용한 병렬 처리가 간단하다.

        - 성능
            - for 문이 성능이 더 좋을 수 있다.

        - 스트림을 적용하기 좋은 조건
            - 원소들의 시퀀스를 일관되게 변환한다.
            - 원소들의 시퀀스를 필터링 한다.
            - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.
            - 원소들의 시퀀스를 컬렉션에 모은다.
            - 원소들의 시퀀스를 특정 조건을 만족하는 원소를 찾는다.

        => 어느 하나가 절대적으로 좋은 것이 아닌 각각의 장단점이 있다.
           따라서, 차이를 인지하고 이를 적절히 사용하는 것이 바람직하다.

- GC
    - GC 가 왜 필요하지?
        - 프로그램이 동적으로 할당했던 메모리 영역 중 필요 없게 된 영역을 알아서 해제하는 기법
        - 여기서 동적으로 할당했던 메모리 영역은 프로그램 런타임에 사용되는 Heap 영역 메모리
          필요없게된 영역은 어떤 변수도 가리키지 않게 된 영역
        - C 나 C++ 의 경우 Heap 영역의 메모리를 관리하기 위해 코드 레벨에서 할당 받고 해제해야함.
          만약 할당 받은 메모리를 제대로 해제하지 않으면 Memory Leak 이 발생하기도 함

        - 장점
            - 메모리 누수 방지
            - 해제된 메모리에 접근 x
            - 해제한 메모리에 재접근하는 이중 해제 x
        - 단점
            - GC 작업 (어떠한 메모리 영역이 해제의 대상이 될지 검사하고 해제하는 일)은 순수 오버헤드
            - 개발자는 언제 GC 가 메모리를 해재하는지 모름
              실시간성이 매우 강조되는 프로그램의 경우 GC 에게 메모리 관리를 맡기는 것이 알맞지 않을 수 있다.

    - GC 알고리즘
        - GC 는 어떻게 해제할 동적 메모리 영역들을 알아서 판단할까?
        - Reference Counting 과 Mark And Sweep GC 알고리즘
            - Reference Counting
                Heap 영역에 선언된 객체들이 각각 reference count 라는 별도 숫자를 가지고 있다.
                reference count 는 몇 가지 방법으로 해당 객체에 접근할 수 있는지를 뜻함.
                해당 객체에 접근할 수 있는 방법이 하나도 없다면 즉, reference count 가 0에 다다르면 가비지 컬렉션의 대상이 됨
                Heap Space 내부에서 순환 참조 하고 있을 경우 Memory leak 이 발생
            - Mark And Sweep
                Reference Counting 의 순환 참조 문제를 해결할 수 있다.
                루트에서부터 해당 객체에 접근 가능한지를 해제의 기준으로 삼는다.
                루트부터 그래프 순회를 통해 연결된 객체들을 찾아내고 연결이 끊어진 객체들은 지우는 방식
                메모리 파편화를 막는 Compaction. Mark And Sweep 에서 Compaction 은 필수는 아님.
                자바와 자바스크립트가 Mark And Sweep 방식으로 메모리 관리를 한다.
                의도적으로 GC 를 실행시켜야 한다.
                어플리케이션 실행과 GC 실행이 병행된다.

    - JVM 의 GC
        - Class Loader: 바이트 코드를 읽고, 클래스 정보를 메모리에 Heap/Method Area 에 저장
        - JVM Memory: 실행 중인 프로그램의 정보가 올라가 있는 메모리
        - Execution Engine: 바이트 코드를 네이티브 코드로 변환시켜주고, GC 를 실행

        - JVM Memory 구조
            - JVM 은 OS 로부터 메모리를 할당 받은 후, 해당 메모리를 용도에 따라 여러 영역으로 나누어서 관리
            - 모든 쓰레드가 공유하는 영역으로 Method Area, Heap 영역
              각 쓰레드마다 고유하게 생성하며, 쓰레드 종료 시 소멸되는 stack, PC Register, Native Method Stack 영역
                - Method Area 는 프로그램의 클래스 구조를 메타데이터처럼 가지며, 메서드의 코드들을 저장
                - Heap 은 어플리케이션 실행 중에 생성되는 객체 인스턴스를 저장. Garbage Collector 에 의해 관리되는 영역
                - stack 은 메서드 호출을 스택 프레임이라는 블록으로 쌓으며 로컬 변수, 중간 연산 결과들이 저장
                - PC Register 는 쓰레드가 현재 실행할 스택 프레임의 주소를 저장
                - Native Method Stack C/C++ 등의 Low level 코드를 실행하는 스택
            - JVM GC 의 Root Space 는 Stack 의 로컬 변수, Method Area 의 Static 변수, Native Method Stack 의 JNI 참조

        - Heap 영역 (GC 의 실행 타이밍을 알 수 있음)
            - Young Generation 과 Old Generation 으로 나뉨.
            - Young Generation 에서 발생하는 GC 는 minor gc, Old Generation 에서 발생하는 GC 는 major gc
            - Young Generation 은 Eden / Survival 0 / Survival 1 세 영역으로 나뉜다.
                - Eden 은 새롭게 생성된 객체들이 할당되는 영역
                - Survival 영역은 minor gc 로부터 살아남은 객체들이 존재하는 영역
                - Survival 0 혹은 Survival 1 둘 중 하나는 꼭 비어 있어야 한다.
                - 새로운 객체가 계속 생성되다 보면 Eden 영역이 꽉 차게 되는 순간이 옴. 이 떄 minor gc 가 일어남.
                  Mark And Sweep 이 진행된다. 루트로부터 Reachable 이라 판단된 객체는 Survival 0 영역으로 옮겨진다.
                  Survival 0 으로 옮겨진 객체들의 age-bit 가 증가함. minor gc 에서 살아남을 때마다 1씩 증가한다.
                  시간이 흘러 Eden 영역이 또 꽉차면 또 다시 minor gc 가 발생한다. 이번에는 Reachable 이라고 판단된 객체들이
                  Survival 1 영역으로 이동된다. 시간이 흘러 Eden 영역이 또 꽉차면 minor gc 가 발생한다. 이번에 살아남은 객체들은
                  Survival 0 영역으로 이동된다. Survival 0 영역으로 넘어온 객체 중 하나가 오래 살아남아 age-bit 3 이 됨.
                  JVM GC 에서는 일정 수준의 age-bit 를 넘어가면 오래도록 참조될 객체라고 판단하여 해당 객체를
                  Old Generation 에 넘겨줌. 이 과정을 Promotion 이라고 함. Java 8 에서는 Parallel GC 사용 기준 age-bit 가
                  15가 되면 Promotion 이 진행된다. 시간이 아주 많이 지나면 Old Generation 도 다 채워짐. 이 때 major gc 가
                  발생하면서 Mark And Sweep 방식을 통해 필요 없는 메모리를 비워준다.
                  이 major gc 는 minor gc 보다 오래 걸린다.
                - GC 설계자들이 어플리케이션을 분석해보니 대부분의 객체가 수명이 짧은 것을 발견. GC 도 결국 비용인데, 메모리의
                  특정 부분만을 탐색하며 해제하면 더 효율적. 어차피 대다수의 객체가 금방 사라지니 Young Generation 안에서 최대한
                  처리되도록 함.

        - Stop The World
            - GC 를 실행하기 위해 JVM 이 어플리케이션 실행을 멈추는 것.
            - 어플리케이션의 사용성을 유지하면서 효율적으로 GC 를 실행하는 것이 어려운 최적화 작업.
              Stop The World 시간을 최소화하는 것이 어려운 최적화 작업

        - GC 방식 살펴보기
            - Serial GC
                - 하나의 쓰레드로 GC 를 실행하는 방식
                - Stop The World 시간이 긺
                - 싱글 쓰레드 환경 및 Heap 이 매우 작을 때 사용
            - Parallel GC
                - 여러 개의 쓰레드로 GC 를 실행. 이에 따라 Serial GC 보다 Stop The World 시간이 더 짧음
                - 멀티코어 환경에서 어플리케이션 처리 속도를 향상하기 위해 사용
                - Java 8 의 default GC 방식
            - CMS GC
                - CMS (Concurrent-Mark-Sweep)
                - GC 작업을 어플리케이션과 동시에 실행하여 Stop The World 최소화
                - 메모리와 CPU 를 많이 사용하고 Mark And Sweep 과정 이후 메모리 파편화를 해결하는
                  Compaction 이 기본적으로 제공되지 않다는 단점이 있음
                - G1 GC 등장에 따라 Deprecated
            - G1 GC
                - G1 (가비지 퍼스트)
                - Heap 을 일정 크기의 Region 으로 잘게 나누어 어떤 영역은 Young Generation, 어떤 영역은 Old Generation 으로 활용
                - 런타임에 G1 GC 가 필요에 따라 영역별 Region 개수를 튜닝함. 그에 따라 Stop the world 를 최소화할 수 있음
                - Java 9 부터 default GC 방식

    - JVM GC 튜닝 맛보기
        - GC 튜닝은 성능 개선의 최종 단계. 객체 생성 자체를 줄이려는 코드 레벨에서의 개선이 선행되어야 한다.
        - JVM GC 튜닝의 목표
            - Old Generation 으로 넘어가는 객체 최소화하기
            - Major GC 시간을 짧게 유지하기
            -> Major GC 를 적게 발생시키거나 빠른 시간 내에 끝내는 것이 목표
        - 한정된 Heap 영역에 Young Generation 과 Old Generation 을 각각 얼마만큼 할당하는 것이 적당한지를 판단해야 한다.
          메모리가 너무 크다면 GC 가 가끔 일어나겠지만 오래 걸릴 것이고, 메모리가 너무 작다면 GC 는 자주 일어나겠지만 금방 끝날 것.
          어플리케이션의 구조 및 특성에 따라 판단해야 함.
        - GC 튜닝 과정
            - 현재 GC 상태 모니터링하기
            - 어플리케이션 성격에 알맞은 GC 방식과 메모리 크기 설정
            - 적용하기

        - JVM 메모리 모니터링
            - JDK 설치 시 기본으로 제공되는 jstat 이라는 툴 활용 가능
            - jstat gcutil 명령어로 현재 실행중인 프로세스에 대해 gc 와 관련된 정보 확인 가능
                ex) jstat -gcutil -t 8844 1000 10
            - jstat gccapacity 명령을 통해 프로세스가 heap 영역을 얼마나 사용 중인지 정확한 수치 확인 가능
                ex) jstat -gccapacity -t 8844 1000 10