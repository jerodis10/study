- 추상클래스/인터페이스
    1. Java 8 이후의 Interface 의 특징
    2. Interface 를 써야 하는 이유
    3. Skeletal Implementation 이란
    4. Interface 사용시 주의점


    1. Java 8 이후의 Interface 의 특징
        - 인스턴스를 생성할 수 없고 상수만 가질 수 있다.
        - 메서드 body 가 없는 추상 메서드를 가진다.
        - 디폴트 메소드, static 메서드만 가질 수 있다. (JDK 1.8 이상)
            - 디폴트 메서드
                - 인터페이스에서 메서드 body 를 가지는 메서드.
                - 반드시 override 할 필요는 없음. 접근 제어자는 public
                - 이미 작성된 인터페이스에서 기능을 추가하려고 할 때 디폴트 메서드 없이는 구현체 클래스들이 전부 override 를 해야하지만,
                  디폴트 메서드가 있다면 그런 작업 없이 하위호환이 가능

    2. Interface 를 써야 하는 이유
        - 다중 상속이 가능하다.
          ex) singer -> songWriter -> singerSongWriter 로 구현하면 다중 상속 필요 없지 않나?
              singer -> songWriter 상속 관계 때문에 songWriter 생성 시 불필요한 singer 의 메서드나 필드가 상속된다.
              즉, 독자적인 songWriter 를 생성할 수 없다.
              따라서, singer 와 songWriter 에서 가져오고 싶은 속성을 singerSongWriter 에 가져와야 한다.
              => 추상클래스만으로 표현하다보면 조합적 폭발이 발생
          * 다이아몬드 문제: 다중 상속 시, 부모 클래스에 같은 시그니처의 메서드가 있을 때 어떤 메서드를 상속받아야 하는지 판별할 수 없는 문제
                          그러나, 추상메서드는 구체적인 선언부가 없기 때문에 모호함이 발생하지 않는다.

        - 공통의 조상을 갖지 않는 두 클래스에 관계를 맺을 수 있다.
        - 사용자 입장에서는 내부적 구조에 대한 이해 없이 약속된 행위가 보장된다.
        - 추상 클래스도 이런 다형성 구현이 가능하지만, 상속관계에 있는 클래스끼리만 가능. 따라서, 인터페이스가 좀 더 유연하게 다형성 적용 가능

        - 추상 클래스 써야 할 때
            1. 굉장히 밀접하게 관련된 클래스끼리 코드를 공유해야 할 때
            2. 추상 클래스의 하위 구현체 클래스들이 공통된 필드나 메서드를 많이 공유하고, 접근제어자가 public 이 아닌 경우
            3. Non-static 혹은 non-final 의 필드로 객체의 상태를 바꿔야 하는 경우

        - 인퍼페이스 써야 할 때
            1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
            2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
            3. 다중 상속이 필요한 때

    3. Skeletal Implementation 이란
        ex) Java Collection 의 AbstractList, AbstractMap 등

        - 추상 골격 클래스는 private, protected 가 가능하므로 override 한 메서드의 내부 메서드들을 클라이언트가 접근하지 못하도록
          막을 수 있다. 그러나, 직접 interface 를 구현하게 되면 접근 제어자가 모두 public 이기 때문에 이와 같은 은닉이 힘들다.
          또한 디폴트 메서드에서는 하위 구현체 클래스에 대한 상태, 즉 필드에 대한 참조가 이루어질 수 없다.

        - 디폴트 메서드의 도입 원인을 생각하면, 이미 존재하는 인터페이스의 하위 호환성을 위해서이다.
          따라서, 새로 인터페이스를 만드는 시점에서 디폴트 메서드를 쓴다면 디폴트 메서드 도입 취지와는 맞지 않다.

    4. Interface 사용시 주의점
        ex) Java 8에서 Collection 에 추가된 removeIf 디폴트 메서드
        - 멀티 쓰레드 환경인 SynchronizedCollection 에서는?
            - 런타임 에러 -> removeIf 를 override 하자 (lock 을 설정하여)
                        -> 원래의 디폴트 메서드를 목적에 맞게 재정의해서 해결

        - 디폴트 메서드 override 시 다이아몬드 문제가 일어나지 않나?
            - 디폴트 메서드 다중 상속 시, 약간의 우선순위로 해결
                1. 구현하는 클래스나 슈퍼클래스
                2. 상속받는 인터페이스
                3. 명시적 사용

        => 디폴트 메서드는 런타임 에러를 일으킬 수 있다.
           이미 구현된 인터페이스에 디폴트 메서드를 추가하는 것은 신중히 해야 한다.
           디폴트 메서드를 추가하려면 릴리즈 전에 반드시 테스트를 거쳐야 한다.


    - 인터페이스나 추상클래스나 둘 다 똑같이 추상 메소드를 통해 상속/구현을 통한 메서드 강제 구현 규칙을 가지는 추상화 클래스

    - 추상클래스는 추상화를 사용하면서 중복되는 클래스 멤버들을 통합/확장 즉, 클래스간의 연관 관계를 구축하는 것에 초점
      인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점
      인터페이스는 다중 구현 및 다중 상속 가능

    - 인터페이스의 필드는 상수만 가능하여 중복된 필드가 있을 경우 인터페이스로 해결이 어렵고, 추상클래스를 남용하면 단일 상속만 되는 제한 때문에 클래스 의존성이 커진다.
      이러한 서로간의 제약들을 극복하기 위해 인터페이스-추상클래스-클래스 구현 디자인 패턴이 나왔고 여러 디자인 패턴들의 근간이 된다.


    - 인터페이스는 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌
      추상클래스는 자신의 기능들을 하위 클래스로 확장 시키는 느낌

    - 추상클래스는 클라이언트에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌
      인터페이스는 반대로 먼저든 나중이든 그때 그때 필요에 따라 구현해서 자유롭게 붙였다 땟다하는 느낌

- stream vs for
    - for 문
        - java 1부터 지원
        - for (초기화; 조건; 후처리)

    - 향상된 for 문
        - java 5부터 지원
        - 가독성 up, 안정성 up

    - stream
        - java 8부터 지원
        - stream 생성 -> 중간 연산 -> 최종 연산

    - 둘 다 다량의 데이터 처리 작업에 사용

    - 차이점
        - 함수 객체 vs 코드 블럭
            - for 문은 코드 블록으로 표현
            - 스트림 파이프라인은 함수 객체로 표현 (람다 or 메서드 참조)
            -> 람다식에는 final 변수만 읽을 수 있기 때문에 지역 변수를 수정할 수 없다.
            -> for 문에서는 할 수 있는 continue, break 로직은 stream 에서는 할 수 없다.

        - 외부 반복 (how) vs 내부 반복 (what)
            - 외부 반복: for 문, 구체적인 구현 로직이 외부에 노출
            - 내부 반복: stream, 로직이 노출되지 x

        - 가독성
            ex) for 문의 경우 if 문의 중첩으로 인해 indent depth 가 깊어져 가독성이 떨어질 수 있으나
                stream 의 경우, 조건들을 filter 의 체이닝 형식을 통해 표현할 수 있기 때문에 보다 간결한 표현 가능

            ex) if 문의 중첩 만 있을 경우, 메서드 추출을 통해서 충분히 indent depth 를 줄여 가독성을 높일 수 있었음.
                하지만, for 문으로 요소를 순회하면서 return 을 하는 경우에는 메서드 추출을 통해 indent depth 를
                줄이는 것이 어려움.
                이런 경우, stream 을 이용하면 depth 를 줄여 가독성을 높일 수 있음.

            - 상황에 따라 stream 이 더 가독성이 안 좋을 수도 있음.

        - 디버깅
            - stream 은 많은 내부 수행 작업과 지연 연산으로 인해 디버깅이 다소 어려울 수 있다.
            - for 문은 예외가 발생하는 stack trace 가 간결하게 출력되서 디버깅에 유리할 수 있다.

        - 병렬 처리
            - for 문의 경우, Runnable 등을 활용해 병렬 처리를 위한 코드를 일일이 작성해야 함.
              로직이 복잡해질 경우 직접 구현하기도 까다롭고 신경쓸 것도 많아짐
              데이터들을 몇 개로 어떻게 나눌 것인지, 혹은 발생할 수 있는 동시성 문제가 있는지를 고려해야 한다.
            - stream 을 이용하면 위의 내용들을 stream 이 내부적으로 처리해 주기 때문에 보다 쉽게 병렬 처리 표현 가능

        - 성능
            - int 배열에서 for 문이 stream 보다 빠른 이유
                - for 는 나온지 오래된 만큼 stream 에 비해 JVM 에서 최적화가 충분히 이루어졌다.

                - stream 을 사용하려면 stream 객체를 생성해야 한다.
                  이 생성 과정에서 여러 작업들이 이루어지고 stream 에서 필요한 다른 객체를 생성하는데 오버헤드가 발생
                - for 는 추가적인 객체 생성 없이 인덱스를 통해서 메모리에 직접 접근을 하기 때문에
                  stream 에 비해 오베헤드가 발생하지 않는다.

            - 향상된 for 문에서는 원시타입 배열에 어떻게 접근 할까?
                - 향상된 for 문에서는 컬렉션을 순회할 때와 마찬가지로 iterator 를 이용할 것이라고 예상할 수 있지만
                  원시타입 배열이 들어온 경우에는 iterator 가 아닌 전통 for 문의 형식으로 바꾸어서 순회.
                  따라서 int 배열에 대한 작업에서는 전통 for 문과 향상된 for 문이 비슷한 성능을 보임

            - List 에서 성능 차이가 미미한 이유
                - int 배열은 요소들이 원시타입인 반면 컬렉션은 Wrapper 타입이 들어오게 된다.
                  그래서 박싱 및 언박싱에 대한 오버헤드가 발생한다. 이 오버헤드는 충분히 크기 때문에
                  컬렉션에 대한 성능은 이 오버헤드에 지배되면서 큰 성능 차이를 보이지 못함.

            => 하지만, 오늘날의 하드웨어는 충분히 빠르기 때문에 소프트웨어에서는 성능보다는 다른 점들을 더욱 신경쓰는 추세.
               유지보수, 가독성 등을 고려하는 것이 더욱 좋을 수 있음.

    - 결론
        - 가독성
            - 추상화된 api 를 제공하고, 보다 What 중심의 코드를 작성할 수 있어 가독성이 더 좋을 수 있다. (개인 차이 존재)

        - 디버깅
            - for 문에 비해 stream 이 디버깅이 어렵다.

        - 병렬 처리
            - 비교적 stream 을 이용한 병렬 처리가 간단하다.

        - 성능
            - for 문이 성능이 더 좋을 수 있다.

        - 스트림을 적용하기 좋은 조건
            - 원소들의 시퀀스를 일관되게 변환한다.
            - 원소들의 시퀀스를 필터링 한다.
            - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.
            - 원소들의 시퀀스를 컬렉션에 모은다.
            - 원소들의 시퀀스를 특정 조건을 만족하는 원소를 찾는다.

        => 어느 하나가 절대적으로 좋은 것이 아닌 각각의 장단점이 있다.
           따라서, 차이를 인지하고 이를 적절히 사용하는 것이 바람직하다.

- GC
    - GC 가 왜 필요하지?
        - 프로그램이 동적으로 할당했던 메모리 영역 중 필요 없게 된 영역을 알아서 해제하는 기법
        - 여기서 동적으로 할당했던 메모리 영역은 프로그램 런타임에 사용되는 Heap 영역 메모리
          필요없게된 영역은 어떤 변수도 가리키지 않게 된 영역
        - C 나 C++ 의 경우 Heap 영역의 메모리를 관리하기 위해 코드 레벨에서 할당 받고 해제해야함.
          만약 할당 받은 메모리를 제대로 해제하지 않으면 Memory Leak 이 발생하기도 함

        - 장점
            - 메모리 누수 방지
            - 해제된 메모리에 접근 x
            - 해제한 메모리에 재접근하는 이중 해제 x
        - 단점
            - GC 작업 (어떠한 메모리 영역이 해제의 대상이 될지 검사하고 해제하는 일)은 순수 오버헤드
            - 개발자는 언제 GC 가 메모리를 해재하는지 모름
              실시간성이 매우 강조되는 프로그램의 경우 GC 에게 메모리 관리를 맡기는 것이 알맞지 않을 수 있다.

    - GC 알고리즘
        - GC 는 어떻게 해제할 동적 메모리 영역들을 알아서 판단할까?
        - Reference Counting 과 Mark And Sweep GC 알고리즘
            - Reference Counting
                Heap 영역에 선언된 객체들이 각각 reference count 라는 별도 숫자를 가지고 있다.
                reference count 는 몇 가지 방법으로 해당 객체에 접근할 수 있는지를 뜻함.
                해당 객체에 접근할 수 있는 방법이 하나도 없다면 즉, reference count 가 0에 다다르면 가비지 컬렉션의 대상이 됨
                Heap Space 내부에서 순환 참조 하고 있을 경우 Memory leak 이 발생
            - Mark And Sweep
                Reference Counting 의 순환 참조 문제를 해결할 수 있다.
                루트에서부터 해당 객체에 접근 가능한지를 해제의 기준으로 삼는다.
                루트부터 그래프 순회를 통해 연결된 객체들을 찾아내고 연결이 끊어진 객체들은 지우는 방식
                메모리 파편화를 막는 Compaction. Mark And Sweep 에서 Compaction 은 필수는 아님.
                자바와 자바스크립트가 Mark And Sweep 방식으로 메모리 관리를 한다.
                의도적으로 GC 를 실행시켜야 한다.
                어플리케이션 실행과 GC 실행이 병행된다.

    - JVM 의 GC
        - Class Loader: 바이트 코드를 읽고, 클래스 정보를 메모리에 Heap/Method Area 에 저장
        - JVM Memory: 실행 중인 프로그램의 정보가 올라가 있는 메모리
        - Execution Engine: 바이트 코드를 네이티브 코드로 변환시켜주고, GC 를 실행

        - JVM Memory 구조
            - JVM 은 OS 로부터 메모리를 할당 받은 후, 해당 메모리를 용도에 따라 여러 영역으로 나누어서 관리
            - 모든 쓰레드가 공유하는 영역으로 Method Area, Heap 영역
              각 쓰레드마다 고유하게 생성하며, 쓰레드 종료 시 소멸되는 stack, PC Register, Native Method Stack 영역
                - Method Area 는 프로그램의 클래스 구조를 메타데이터처럼 가지며, 메서드의 코드들을 저장
                - Heap 은 어플리케이션 실행 중에 생성되는 객체 인스턴스를 저장. Garbage Collector 에 의해 관리되는 영역
                - stack 은 메서드 호출을 스택 프레임이라는 블록으로 쌓으며 로컬 변수, 중간 연산 결과들이 저장
                - PC Register 는 쓰레드가 현재 실행할 스택 프레임의 주소를 저장
                - Native Method Stack C/C++ 등의 Low level 코드를 실행하는 스택
            - JVM GC 의 Root Space 는 Stack 의 로컬 변수, Method Area 의 Static 변수, Native Method Stack 의 JNI 참조

        - Heap 영역 (GC 의 실행 타이밍을 알 수 있음)
            - Young Generation 과 Old Generation 으로 나뉨.
            - Young Generation 에서 발생하는 GC 는 minor gc, Old Generation 에서 발생하는 GC 는 major gc
            - Young Generation 은 Eden / Survival 0 / Survival 1 세 영역으로 나뉜다.
                - Eden 은 새롭게 생성된 객체들이 할당되는 영역
                - Survival 영역은 minor gc 로부터 살아남은 객체들이 존재하는 영역
                - Survival 0 혹은 Survival 1 둘 중 하나는 꼭 비어 있어야 한다.
                - 새로운 객체가 계속 생성되다 보면 Eden 영역이 꽉 차게 되는 순간이 옴. 이  minor gc 가 일어남.
                  Mark And Sweep 이 진행된다. 루트로부터 Reachable 이라 판단된 객체는 Survival 0 영역으로 옮겨진다.
                  Survival 0 으로 옮겨진 객체들의 age-bit 가 증가함. minor gc 에서 살아남을 때마다 1씩 증가한다.
                  시간이 흘러 Eden 영역이 또 꽉차면 또 다시 minor gc 가 발생한다. 이번에는 Reachable 이라고 판단된 객체들이
                  Survival 1 영역으로 이동된다. 시간이 흘러 Eden 영역이 또 꽉차면 minor gc 가 발생한다. 이번에 살아남은 객체들은
                  Survival 0 영역으로 이동된다. Survival 0 영역으로 넘어온 객체 중 하나가 오래 살아남아 age-bit 3 이 됨.
                  JVM GC 에서는 일정 수준의 age-bit 를 넘어가면 오래도록 참조될 객체라고 판단하여 해당 객체를
                  Old Generation 에 넘겨줌. 이 과정을 Promotion 이라고 함. Java 8 에서는 Parallel GC 사용 기준 age-bit 가
                  15가 되면 Promotion 이 진행된다. 시간이 아주 많이 지나면 Old Generation 도 다 채워짐. 이 때 major gc 가
                  발생하면서 Mark And Sweep 방식을 통해 필요 없는 메모리를 비워준다.
                  이 major gc 는 minor gc 보다 오래 걸린다.
                - GC 설계자들이 어플리케이션을 분석해보니 대부분의 객체가 수명이 짧은 것을 발견. GC 도 결국 비용인데, 메모리의
                  특정 부분만을 탐색하며 해제하면 더 효율적. 어차피 대다수의 객체가 금방 사라지니 Young Generation 안에서 최대한
                  처리되도록 함.

                  1. Eden 영역에 새로운 객체가 할당
                  2. Eden 영역이 가득 차면 Minor GC가 발생
                  3. 참조가 있는 객체는 첫번째 Survivor로 이동
                  ※ 이동되면서 age bit가 1씩 증가
                  4. Eden 영역이 가득 차면 Minor GC가 발생
                  5. 참조가 살아있는 객체들은 두번째 Survivor로 이동
                  ※ 이동되면서 age bit가 1씩 증가
                  6. Minor GC 후에 특정 Age 임계치에 도달한 객체들은 Old Generation 으로 Promotion(이동)
                  (Java 8에서는 Parallel GC 방식 기준으로 age bit가 15가 되면 Promotion이 진행)
                  7. 때문에 Minor GC 가 계속되면 Old Generation 에 객체들이 계속 Promotion 된다. Old Generation 이 가득차게 되면 객체를 삭제하고 압축하기 위해 Majro GC 가 수행

        - Stop The World
            - GC 를 실행하기 위해 JVM 이 어플리케이션 실행을 멈추는 것.
            - 어플리케이션의 사용성을 유지하면서 효율적으로 GC 를 실행하는 것이 어려운 최적화 작업.
              Stop The World 시간을 최소화하는 것이 어려운 최적화 작업

        - GC 방식 살펴보기
            - Serial GC
                - 하나의 쓰레드로 GC 를 실행하는 방식
                - Stop The World 시간이 긺
                - 싱글 쓰레드 환경 및 Heap 이 매우 작을 때 사용
            - Parallel GC
                - 여러 개의 쓰레드로 GC 를 실행. 이에 따라 Serial GC 보다 Stop The World 시간이 더 짧음
                - 멀티코어 환경에서 어플리케이션 처리 속도를 향상하기 위해 사용
                - Java 8 의 default GC 방식
            - CMS GC
                - CMS (Concurrent-Mark-Sweep)
                - GC 작업을 어플리케이션과 동시에 실행하여 Stop The World 최소화
                - 메모리와 CPU 를 많이 사용하고 Mark And Sweep 과정 이후 메모리 파편화를 해결하는
                  Compaction 이 기본적으로 제공되지 않다는 단점이 있음
                - G1 GC 등장에 따라 Deprecated
            - G1 GC
                - G1 (가비지 퍼스트)
                - Heap 을 일정 크기의 Region 으로 잘게 나누어 어떤 영역은 Young Generation, 어떤 영역은 Old Generation 으로 활용
                - 런타임에 G1 GC 가 필요에 따라 영역별 Region 개수를 튜닝함. 그에 따라 Stop the world 를 최소화할 수 있음
                - Java 9 부터 default GC 방식

    - JVM GC 튜닝 맛보기
        - GC 튜닝은 성능 개선의 최종 단계. 객체 생성 자체를 줄이려는 코드 레벨에서의 개선이 선행되어야 한다.
        - JVM GC 튜닝의 목표
            - Old Generation 으로 넘어가는 객체 최소화하기
            - Major GC 시간을 짧게 유지하기
            -> Major GC 를 적게 발생시키거나 빠른 시간 내에 끝내는 것이 목표
        - 한정된 Heap 영역에 Young Generation 과 Old Generation 을 각각 얼마만큼 할당하는 것이 적당한지를 판단해야 한다.
          메모리가 너무 크다면 GC 가 가끔 일어나겠지만 오래 걸릴 것이고, 메모리가 너무 작다면 GC 는 자주 일어나겠지만 금방 끝날 것.
          어플리케이션의 구조 및 특성에 따라 판단해야 함.
        - GC 튜닝 과정
            - 현재 GC 상태 모니터링하기
            - 어플리케이션 성격에 알맞은 GC 방식과 메모리 크기 설정
            - 적용하기

        - JVM 메모리 모니터링
            - JDK 설치 시 기본으로 제공되는 jstat 이라는 툴 활용 가능
            - jstat gcutil 명령어로 현재 실행중인 프로세스에 대해 gc 와 관련된 정보 확인 가능
                ex) jstat -gcutil -t 8844 1000 10
            - jstat gccapacity 명령을 통해 프로세스가 heap 영역을 얼마나 사용 중인지 정확한 수치 확인 가능
                ex) jstat -gccapacity -t 8844 1000 10

- DFS/BFS
    - 탐색 알고리즘의 개념과 필요성
         - 탐색 알고리즘: 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘
         - 그래프: 정점과 간선으로 구성된, 한정된 자료구조를 의미. 각각의 지점을 정점, 정점과 정점의 연결을 간선
         - 각 정점이 서로 연결되어 있는지, 정해진 시간 내에 효율적으로 할 수 있는가? 를 확인하는 알고리즘

    - DFS
        - 현재 정점과 연결된 정점들을 하나씩 갈 수 있는지 검사하고, 특정 정점으로 갈 수 있다면 그 정점에 가서 같은 행위를 반복
          시작점에서 한 갈래로 더 이상 갈 수 없을 때까지 탐색하고, 더 갈 곳이 없다면 이전의 경로로 되돌아간다.
          같은 정점을 다시 방문하지 않도록 정점에 방문했다는 것을 표시.
          재귀 함수를 통해 구현
        - 장점
            - 코드가 직관적이고 구현하기 쉽다.
        - 단점
            - 재귀 함수를 이용하기 문에 함수 호출 비용이 추가로 들어감
            - 재귀 깊이가 지나치게 깊어지면 메모리 비용을 예측하기 어려움
            - 최단 경로를 알 수 없다.

    - BFS
        - 시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘
        - 큐를 이용하여 구현
            - 먼저 출발점을 큐에 넣는다.
            - 큐에 저장된 정점 하나를 Dequeue 한다.
            - Dequeue 된 정점과 연결된 모든 정점을 큐에 넣는다.
            - 큐가 비어있다면 반복을 종료
        - 장점
            - 효율적인 운영이 가능하고, 시간/공간 복잡도 면에서 안정적이다.
            - 간선의 비용이 모두 같을 경우, 최단 경로를 구할 수 있다.
        - 단점
            - DFS 에 비해 코드 구현이 어렵다.
            - 모든 지점을 탐색할 경우를 대비해, 큐의 메모리가 미리 준비되어 있어야 한다.

- 람다
    - Java 8 에서는 많은 새로운 기능들이 도입 되었고, 그 중에는 람다와 stream 도입을 통한
      함수형 프로그래밍도 있다. 람다를 통해 함수를 파라미터로 넘길 수 있고 변수에 할당할 수 있으며
      반환 값으로 반환할 수 있는 일급 시민으로써 사용할 수 있게 됨.
      이를 통해 코드 양도 줄이면서도 코드의 재사용성을 크게 높일 수 있다.

    - 동작 파라미터화
        - 함수 또는 코드 블록을 파라미터로 넘길 수 있게 하는 것

    - 람다를 사용하기 위한 조건 -> 함수형 인터페이스
      함수형 인터페이스는 하나의 추상메서드가 존재해야 한다.
      @FunctionalInterface 는 함수형 인터페이스로 사용 명시, 해당 인터페이스가 함수형 인터페이스의 조건을
      충족하지 못할 경우 에러를 띄우는 역할

    - 표준 라이브러리에 존재하는 함수형 인터페이스
        ex) Predicate, Consumer...

    - 익명 클래스는 단순히 편의를 위해서 클래스 내부에서 사용을 할뿐 컴파일이 되면
      별도의 클래스로 분리되어 나온다.
    - 하지만 람다의 경우 컴파일 해도 별도의 클래스 파일이 생성되지 않으며 람다는 그대로 존재

    - 람다 동작 과정
        - 람다를 정의를 한 파일의 바이트코드를 보면 람다가 정의된 곳은 INVOKEDYNAMIC 으로 대체가 되고 클래스 내부에
          새로운 메서드 하나가 생성됨. INVOKEDYNAMIC 은 Java 7 에서 도입되었으며 클래스에 생성을 런타임까지 지연시키는 역할.
          이 때문에 람다는 컴파일 단계에서 생성되지 않고 런타임까지 지연됨.
          람다의 정의로 인해서 생성되는 메서드들은 'lambda' 라는 prefix 가 오고 두 개의 '$' 가 옴

    - 람다를 사용하면 안되는 경우
        - this 를 사용할 경우
            - 만약 내부에서 this 를 사용해야 하면 람다 대신 익명 클래스 사용해야 함
        - 섀도우 변수 (shadow variable) 를 사용할 경우
            - shadow variable 는 inner scope 내부에 outer scope 에 정의한 똑같은 변수가 있을 경우 shadow 된다.
            - 람다는 변수 shadowing 을 잡아내지 못하고 에러를 띄우므로 익명 클래스 사용해야 함
        - 콘텍스트 오버로딩이 존재할 때
            - 람다는 파라미터나 반환 값 등을 통해서 해당 람다가 어느 익명 메서드의 구현인지를 내부적으로 추론하는데
              모든 요소가 같은 추상 메서드가 2개 이상 존재한다면 에러가 띄우므로 익명 클래스 사용해야 함
        - 람다 코드가 3줄을 넘어갈 때
            - 동작을 파악하는데 시간이 오래 걸리고 복잡한 코드가 나올수 있으므로 지양

    - 람다 표현식의 한계
        - 코드 자체로 동작이 명확하게 설명되지 않거나 람다가 길거나 읽기 어렵다면, 쓰지 않는 방향으로 리팩토링하는 것을 고려
        - 람다식은 기본적으로 익명 구현 객체 기반이기 때문에, 익명 객체 특성상 디버깅 할때 콜 스택(call stack) 추적이 매우 어려운 단점을 가지고 있다.
        - stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다.
        - 람다식을 통해 재귀 함수를 구축하면 실행 조차 안되는 컴파일 에러가 나타난다.

- 제네릭   https://mangkyu.tistory.com/241
    - 제네릭이란?
        - 컴파일 타임에 타입을 체크함으로써 코드의 안전성을 높여주는 기능
        - List<T> 에서 T 가 타입 매개 변수
        - List<String> 에서 String 이 매개 변수화된 타입

        - 제네릭을 사용하는 이유
            1. 컴파일 타임에 강력한 타입 검사
            2. 캐스팅 (타입 변환) 제거

        - 배열 vs 제네릭 타입
            - 배열
                Object[] objectArray = new Integer[1]
                Integer 가 Object 의 하위 타입이면 Integer 배열도 Object 배열의 하위 타입이 성립함
                공변
            - 제네릭
                List<Object> objectList = new ArrayList<Integer>(); // Compile Error
                List<Object> 와 ArrayList<Integer> 는 서로 다른 타입 매개 변수이므로 컴파일 에러를 띄운다.
                무공변

        - 변성 (variance)
            - 무공변(Invariance) - <T>
                타입 B 가 타입 A 의 하위 타입일 때, Category<B> 가 Category<A> 의 하위 타입이 아닌 경우.
            - 공변(Covariance) - <? extends T>
                타입 B 가 타입 A 의 하위 타입일 때, Category<B> 가 Category<A> 의 하위 타입인 경우
            - 반공변(Contravariance) - <? super T>
                타입 B 가 타입 A 의 하위 타입일 때, Category<B> 가 Category<A 의 상위 타입인 경우

    - 제네릭 타입과 메서드
        - 제네릭 타입: 타입을 파라미터로 가지는 클래스와 인터페이스
        - 제네릭 메서드: 선언부에 제네릭 타입이 선언된 형식
        - 제한된 제네릭 타입
            ex) <T extends Noodle> : Noodle 과 Noodle 의 하위 타입만 가능

    - 와일드 카드
        1. <?> Unbounded Wildcards
            모든 타입 가능
        2. <? extends Noodle> Upper Bounded Wildcards
            Noodle 과 Noodle 의 하위 타입 (상한 경계) -> 공변
        3. <? super Noodle> Lower Bounded Wildcards
            Noodle 과 Noodle 의 상위 타입 (하한 경계) -> 반공변

        ex)
        class CategoryHelper {
            public void popNoodle(Category<? extends Noodle> category)  {
                Noodle noodle = category.get() // 꺼내는건 OK
                category.set(new Noodle()); // 저장은 NO -> 하위 타입에 상위 타입을 대입할 위험이 있기 때문에 컴파일 오류
            }

            public void pushNoodle(Category<? super Noodle> category)  {
                category.set(new Noodle()); // 저장은 NO
                Noodle noodle = category.get() // 꺼내는건 NO -> 하위 타입에 상위 타입을 대입할 위험이 있기 때문에 컴파일 오류
            }
        }

        - 제네릭 타입을 언제 써야 할까? -> PECS
            - producer - extends, consumer - super -> 생성을 하는 곳에서는 extends, 소비를 하는 곳에서는 super

    - 제네릭 타입 소거
        - 제네릭은 컴파일 타임에 타입을 검사하고 런타임에는 타입을 소거해서 해당 정보를 알 수 없다. -> Java 5
          기존의 코드들도 돌아갈 수 있도록 하기 위해 타입 소거 도입

        1. 타입 매개변수의 경계가 없는 경우에는 Object 로, 경계가 있는 경우에는 경계 타입으로 타입 파라미터를 변경
        2. 타입 안정성을 유지하기 위해, 필요한 경우 타입 변환 추가
        3. 제네릭 타입을 상속받은 클래스의 다형성을 유지하기 위해 Bridge method 생성

- 쓰레드 풀
    - 프로그램: 어떤 목적을 달성하기 위해서 컴퓨터의 동작을 하나로 모아 놓은 것
    - 프로세스: 컴퓨터가 현재 실행중인 프로그램

    - 단순히 스레드만 사용해서 동시에 여러 작업을 실행시킬 수 있는 프로그램을 만들 수 있을까?
        - 문제
            - 스레드 생성비용이 크기 때문에 요청에 대한 응답시간이 늘어난다.
                1. Java 는 One-to-One Threading-model 로 Thread 생성한다.
                2. User Thread(Process 의 스레드) 생성시 OS Thread(OS 레벨의 스레드) 와 연결해야 한다.
                    - User Thread 는 OS Thread 에 대한 User Program 계층에서의 추상화
                3. 새로운 Thread 를 생성할 때 마다 OS Kernel 의 작업이 필요하다.
                4. Thread 는 생성 비용이 많이 든다.
                5. 작업 요청이 들어올 때마다 Thread 를 생성하면 최종적인 요청 처리 시간이 증가한다.

            - Thread 가 너무 많으면 여러가지 문제를 발생시킨다.
                1. Process 의 처리 속도보다 빠르게 요청이 쏟아져 들어오면
                2. 새로운 Thread 가 무제한적으로 계속 생성된다.
                3. Thread 가 많아 질수록 메모리를 차지하고 Context-Switching 이 더 자주 발생한다.
                4. 메모리 문제가 발생할 수 있고, CPU 오버헤드가 증가한다.

    - 그래서 나온 게 Thread Pool
        - Thread 를 허용된 개수 안에서 사용하도록 제한하는 시스템
        - Thread, 작업 큐로 이루어짐.
            1. 스레드풀에 작업 처리 요청
            2. 작업 큐에 작업들이 쌓이게 됨.
            3. 각 스레드로 작업을 보내고, 스레드는 작업을 처리함.
            4. 결과 전달

        - 해결
            - 미리 만들어 놓은 스레드를 재사용할 수 있기 때문에 새로운 스레드를 생성하는 비용을 줄일 수 있다.
            - 사용할 스레드 개수를 제한하기 때문에 무제한적으로 스레드가 생성되는 것을 방지

        => 여러 개의 작업을 동시에 처리하면서도 안정적으로 처리하고 싶을 때 Thread Pool 은 효과적

    - Java 의 Thread Pool
        - ThreadPoolExecutor 클래스르 이용해 스레드풀을 구현

        - maximumPoolSize
        - corePoolSize
        - keepAliveTime
            -> 항상 maximumPoolSize 만큼 유지하고 있지는 않음. 요청이 적을 때는 많은 양의 스레드를 계속 가지고 있을 이유가 없다.
               만약 작업이 없는데 스레드 개수가 최대이고, keepAliveTime 이후로도 계속 작업 요청이 없다면 스레드는 없어짐.
               무한히 없어지는게 아니라 corePoolSize 만큼 없어짐.
               따라서 최대 maximumPoolSize, 최소 corePoolSize 만큼 스레드를 가진다.

    - Tomcat 의 Thread Pool
        - Tomcat
            - SpringBoot 의 내장 Servlet Container 중 하나
            - Java 기반의 WAS
            - Java 의 스레드풀 클래스와 매우 유사한 자체 스레드풀 구현체를 가지고 있다.

        - Java 의 스레드풀과 다른점
            - Max-Connections
                - 톰캣이 최대로 동시에 처리할 수 있는 Connection 의 개수
                - Web 요청이 들어오면 톰캣의 Connector 가 Connection 을 생성하면서 요청된 작업을 스레드풀의 스레드에 연결한다.
            - Accept-Count
                - Max-Connections 이상의 요청이 들어왔을 때 사용하는 대기열 큐의 사이즈
                - Max-Connections 와 Accept-Count 이상의 요청이 들어왔을 때 추가적으로 들어오는 요청은 거절될 수 있다.

    - 어떻게 하면 스레드풀을 잘 설정해서 Server Application 을 효과적으로 구현할 수 있을까?
        - SpringBoot 설정을 통한 Tomcat Thread Pool 설정
            - server.tomcat.threads.max
                - 스레드풀에서 사용할 최대 스레드 개수, 기본 값은 200
                - 서버 어플리케이션이 동시에 처리할 수 있는 요청 개수와 관련있다.
                - 요청에 비해 너무 많게 설정 -> 놀고 있는 스레드가 많아져서 비효율 발생
                - 너무 적게 설정 -> 동시 처리 요청 수가 줄어든다. 평균응답시간, TPS 감소
                -> 기본적으로 스레드가 많아지면 CPU 오버헤드와 메모리에서 문제가 생길 수 있다.

            - server.tomcat.threads.min-spare
                - 스레드풀에서 최소한으로 유지할 스레드 개수, 기본값은 10
                - 너무 많이 설정 -> 스레드풀이 항상 유지해야 할 스레드 수가 너무 많아진다.
                - 적절하게 설정 -> 적은 수의 요청에서 새로운 스레드를 만들 필요없이 요청을 효과적을 처리할 수 있다.
                -> 잘못 설정했을 때 사용하지 않는 스레드가 메모리를 차지하면서 비효율을 발생시킨다.

            - server.tomcat.max-connections
                - 동시에 처리할 수 있는 최대 Connection 의 개수, 기본 값은 8192
                - 사실상 서버의 실질적인 동시 요청 처리 개수
                    - 톰캣의 커넥터 컴포넌트의 방식에 따라서 개수 설정
                        - Blocking IO: 1 Connection 1 Thread
                        - Non-Blocking IO: N Connection 1 Thread
                    - tomcat 8 버전 이후부터는 Non-Blocking IO 방식 사용
                - Non-Blocking IO 에서는 스레드풀을 최대 스레드 개수보다 많은 양의 Connection 을 유지할 수 있다.
                - Non-Blocking IO 에서는 최대 스레드 개수보다 적거나 같은 수의 max-connections 를 설정하는 것은 비효율적인
                  설정이 될 수 있다.

            - server.tomcat.accept-count
                - max-connections 이상의 요청이 들어왔을 때 사용하는 요청 대기열 큐의 사이즈, 기본 값은 100
                - 너무 크게 설정 -> 대기열이 커지면서 메모리 문제 유발
                - 너무 작게 설정 -> 요청이 몰렸을 때 들어오는 요청들을 거절해 버릴 수 있다.
                -> 이 설정을 하는 이유 중 하나는 부적절하거나 잘못된 요청이 한번에 너무 많이 들어와
                   서버에 장애를 발생시키는 것을 방지하기 위함도 있다.

    => 스레드풀을 설정해야 하는 이유
        - 스레드풀은 응답시간과 TPS 에 영향을 주는 하나의 요소이다.
        - 잘 조정된 스레드풀은 시스템의 성능을 끌어내고 안정적인 어플리케이션 운용을 가능하게 한다.
        - 부적절하게 설정된 스레드풀은 병목 현상, CPU 오버헤드, 메모리 문제를 유발할 수 있다.

- Blocking vs Non-Blocking, Sync vs Async
    - Blocking vs Non-Blocking
        - Blocking: 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것
        - Non-Blocking: 다른 주체의 작업에 관련없이 자신의 작업을 하는 것
        -> 다른 주체가 작업을 할 때 자신의 제어권이 있는지 없는지로 볼 수 있다.

    - Synchronous vs Asynchronous
        - Synchronous: 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작함을 의미
        - Asynchronous: 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음을 의미
        -> 결과를 돌려주었을 때, 순서와 결과에 관심이 있는지 아닌지로 판단할 수 있다.

    - Blocking/Sync
        ex) 자바에서 입력요청을 할 때

    - Non-Blocking/Sync
        - Blocking/Sync 와 큰 차이가 없다.

    - Blocking/Async
        - 보통 Non-Blocking/Async 로 하려다가 개발자의 실수로 혹은 기타 이유로 이와 같이 동작

    - Non-Blocking/Async
        ex) 자바스크립트에서 API 요청을 하고 다른 작업을 하다가 콜백을 통해서 추가적인 작업을 처리할 때

- 멀티스레드와 동기화
    - 공유자원과 임계영역
        - 공유자원: 여러 스레드가 동시에 접근할 수 있는 자원
        - 임계영역: 공유자원들 중 여러 스레드가 동시에 접근했을 때 문제가 생길 수 있는 부분

    - 경쟁상태
        - 둘 이상의 스레드가 공유자원을 병행적으로 읽거나 쓰는 동작을 할 때 타이밍이나 접근 순서에 따라 실행 결과가 달라지는 상황
        - Read - Modify - Write, Check - then - act 라는 두 가지 패턴 존재
            - Read - Modify - Write
              경쟁 상태가 발생하는 연산의 패턴 중 가장 유명한 패턴
              메모리에 값을 읽어오고 수정하고 덮어쓰는 세 가지 연산으로 분리가 되는 것
            - Check - then - act
              if 분기문을 통과하기 전에는 조건에 부합했지만, if 분기문을 통과한 후에는 조건에 부합x

    - 원자성과 가시성
        - 원자성
            - 공유 자원에 대한 작업의 단위가 더이상 쪼갤 수 없는 하나의 연산인 것처럼 동작하는 것
            - Read - Modify - Write
                1. 메모리에서 값을 읽어옴 (read)
                2. 읽어온 값을 수정 (modify)
                3. 수정한 값을 다시 메모리에 덮어씀 (write)
                -> 1 2 번 사이에 시간 텀이 생기게 되므로 한 쓰레드가 연산을 할 때 다른 쓰레드의 연산이 개입할 수 있다.
                   이런 경쟁 상태를 발생시키지 않기 위해서는 분리된 명령어들을 하나로 모아주는 과정이 필요한데 이걸 원자성이라 한다.
            - Check - then - act
                1. 분기문 비교 (read)
                2. 로직 (act)
        - 가시성
            - 쓰레드를 실행하는 건 CPU 가 실행을 하는데 쓰레드를 CPU 가 실행할 때 메인 메모리에서 변수 값을 읽어와서 쓰레드를 실행.
              그런데 메인 메모리와 CPU 간의 거리가 멀어서 CPU 캐시 사용. CPU 는 이 쓰레드를 실행할 때 필요한 값을 메인 메모리에서 읽어와서
              CPU 캐시에 담아두고 CPU 캐시의 모든 연산을 반영한 다음 그 값을 메인 메모리에 덮어쓰는 방식으로 동작
            - 메인 메모리에 있는 진짜 값을 보지 못해서 가시성 이라고 함
            - volatile 변수를 선언하면 이 변수는 메인 메모리에서만 값을 읽고 쓰고 CPU 캐시를 사용하지 않는 변수가 된다.

    - 동기화
        - 블로킹
            - 특정 스레드가 작업을 수행하는 동안 다른 작업은 진행하지 않고 대기하는 방식
              ex) Monitor, Synchronized 키워드
            - 모니터
                - 자바에서 동기화를 하기 위한 도구
                - 배타동기큐는 synchronized, 조건동기큐는 wait(), notify(), notifyAll()
                - 임계영역에는 한번에 한 스레드만 락을 가지고 들어가도록 설계되어 있음.
                  만약에 임계영역에 접근하는 여러 스레드가 있다면 그 중에 한 스레드가 먼저 임계영역에 들어갈 수 있고 작업을 수행하다가
                  wait() 라는 연산을 만나면 이 스레드는 슬립 상태가 되면서 조건동기큐로 들어가게 된다. 배타동기큐에 있던 다른 스레드들이
                  임계영역이 비어있기 때문에 임계영역에 락을 가지고 들어올 수 있다. 다른 스레드가 임계영역에서 작업을 수행하다가
                  notify()나 notifyAll()이라는 메서드를 호출하게 되면 조건동기큐에서 자고 있던 스레드가 깨어나면서 임계영역이 비어 있을 때
                  다시 임계영역으로 돌아와서 작업을 수행하도록 하는 걸 모니터 메커니즘이라고 함.
            - Synchronized
                - 배타동기를 선언하는 키워드
                - 연산결과가 메모리에 써질때까지 다른 스레드는 임계영역에 들어오지 못하고 대기
                - 동작 방식
                    임계영역에 한 개의 스레드만 들어올 수 있기 때문에 이 스레드가 들어오고 나서 자기가 연산할 것을 다 연산하고 메인 메모리에
                    반영시킨 이후에 임계영역에서 나가게 된다. 그리고 나서 다른 스레드가 임계영역에 들어오게 되고 들어올 때는 메인 메모리에서
                    이미 동기화된 값을 읽어오기 때문에 문제가 발생하지 않음. 이렇게 순차적으로 접근하는 방식 때문에 원자성과 가시성을
                    모두 만족
                - 단점
                    - 하나의 쓰레드만 임계영역에서 작업을 수행할 수 있기 때문에 나머지 대기하는 스레드들이 발생하고 성능저하로 이어질 수 있음
                    - 임계영역에 들어갈 때 락을 획득하고 들어가기 때문에 데드락이 발생할 수 있다.
                        - 계속 자기가 잡고 있는 자원을 놓지 않고 상대방이 가지고 있는 자원을 놓기를 계속 기다리고 있는 상태가 데드락 상태

        - 논블로킹
            - 다른 스레드의 작업여부와 상관없이 자신의 작업을 수행하는 방식
              ex) Atomic 타입
            - CAS 알고리즘 (Compare and Set)
                - 연산을 할 때 자원 값을 가져오는 데 가져올 때 자원 값이랑 똑같은 값에 기대 값이라는 걸 만든다.
                  이 기대값을 기반으로 연산을 진행해서 새로운 값을 도출. 이 새로운 값을 자원 값에다 덮어쓰기 하기 직전에 내가 이전에
                  만들었던 기대값과 현재의 자원값이 같은지를 확인하는 로직이 있다. 같으면 기존 자원값을 새로운 값으로 수정하고 true, 다르면
                  수정하지 않고 false. 이렇게 자원값과 기대값을 비교하는 과정에서 CAS 를 통해서 원자성을 보장.
                - false 를 반환했을 때 이후에 동작은 어떻게 할 것인지는 개발자의 요구사항에 따라 달라짐.
                  while 문을 계속 돌면서 이 조건이 true 가 나올 때까지 계속 재시도 하는 방법이 있고 아니면 몇 번 시도하다가 exception 을
                  터뜨리고 끝내는 방법도 있다.
            - Atomic 타입
                - 동시성을 보장하기 위해서 자바에서 제공하는 래퍼 클래스
                - CAS 와 Volatile 을 활용해서 원자성과 가시성을 보장
                - AtomicReference
                    - 보통 일반적인 스레드에서는 값을 연산하고자 할 때 연산하는 값을 끌어올 때는 JVM 과 CPU 사이에 있는 캐시값에서 변수를
                      끌어옴. 근데 아토믹 레퍼런스를 설정하게 되면 내부에 volatile 이 박혀있어서 JVM 메모리에서 바로 스레드로 값을
                      당겨올 수 있다. 바로 값을 당겨와서 연산을 진행하게 되는데 연산을 할 때는 compareAndSet() 이라는 메소드가 호출된다.
                      CAS 알고리즘을 녹인 메소드인데 이걸 실행하면 현재 메모리에 저장된 값과 스레드 내부에 이미 만들어 놨던 기대값을
                      비교해서 일치하면 true, 아니면 false 를 반환하는 식으로 동작. 그래서 아토믹 레퍼런스가 volatile 을 통해서 가시성을
                      CAS 를 통해서 원자성을 보장.

    - 스레드 안전한 객체 설계 방법
        - 여러 스레드가 동시에 클래스를 사용하려 하는 상황에서 클래스 내부의 값을 안정적인 상태로 유지할 수 있는 것을 스레드 세이프.
        - 여러 방법들이 있는데 전략에 따라서 선택을 달리 해야하고 구현에 따라서 장단점도 다르다.
        - 가장 확실하고 안전하고 간단한 방법 -> 공유변수 최소화 + 캡슐화 + 문서화
          공유변수 최소화가 가장 스레드 안전한 객체를 설계하는 방법이고 불가피하게 공유 변수를 써야 한다면
          내가 관리해야 될 포인트를 한 곳에 모아서 한 객체에서 캡슐화를 해서 그 객체만 관리할 수 있게끔 하는게 차선.
          공유 변수를 사용하게 되면 동기화 정책을 많이 적용하게 되는데 그런 동기화 정책이 코드에 들어가면 코드 파악이 어려워지므로 문서화 필요

- 함수형 프로그래밍
    - 값을 가지고 수학적 함수를 적용해 계산을 진행하는 패러다임의 한 종류
    - 특징
        1. 불변
            - 그 대상이 변경되지 않는 걸 의미
              ex) Optional
        2. 선언적
            - 선언적이라는 건 '무엇' 을 의미
              ex) stream

    - 함수형 언어 조건
        - 함수가 1급 객체
            - 함수 리터럴이 존재 (1급 객체이려면 해야 한다.)
              ex) 람다식
            - 함수를 인수로 제공하고 반환할 수 있어야 함
              ex) 함수형 인터페이스
            - 함수를 런타임시점에 생성 가능해야 함
                - 프로그램이 실행하는 과정 중에 함수가 생성될 수 있다는 의미
                  ex) 함수 합성

    - 값은 함수와 대상을 포함하는 개념
    - 수학적 함수는 순수 함수
    - 계산을 진행한다는 건 함수들의 조합과 합성을 통해 프로그램을 만들 수 있다는 의미

- OOP
    - 객체지향 프로그래밍 이란?
        - 프로그래밍 방법론
        - 사람이 현실을 바라보는 방법을 개발을 접목
            - 직관적으로 이해하기 쉽다.
            - 유지보수를 용이하게 만든다.

    - 키워드로 알아보는 객체지향
        - 객체
            - 객체는 현실의 무언가에 추상적으로 표현한 것
            - 클래스는 객체를 표현하는 하나의 수단
        - 협력과 책임, 역할
            - 다른 객체와 협력하는 역할을 맡고 있는 대상
            - 역할을 맡으면 임무를 수행할 책임이 생긴다.
            - 책임을 다하기 위한 데이터와 프로세스를 가지고 있다.
            - 협력: 시스템 목표를 달성하기 위해 여러 객체가 참여하여 행동하는 것
                   ex) 치킨을 튀겨서 손님에게 배달해야 한다.
            - 책임: 협력 속에서 본인이 수행해야 할 임무의 내용을 알고, 수행하는 것
                   ex) 치킨을 튀길 객체는 치킨을 맛있게 조리할 책임을 갖는다
            - 역할: 동일한 목적을 가진 책임의 묶음
                   ex) 치킨은 조리할 책임을 가지는 역할은 요리사이다
        - 메시지
            - 객체는 메시지를 통해 다른 객체에 책임을 다하라고 요구한다.
            - 메시지를 보내는 객체는 무엇을 할지만 요구하고, 어떻게 하는지는 신경쓰지 않아도 된다.
            - 객체는 책임을 수행하라고 요구받지만, 어떻게 처리할지는 자율에 맡긴다.
            - 책임을 수행하는 방법은 메시지를 보내는 것(메서드 통해서)
        - 자율성 (의인화)
            - 객체 지향과 현실 세계의 차이점
                - 현실 세계의 치킨 가게는 건물에 불과
                - 객체지향 세계의 치킨 가게는 스스로 치킨을 튀기고, 치킨을 건네어 준다.
            - 즉, 객체지향에선 객체가 자율적으로, 능동적으로 행동할 수 있다고 의인화해야 한다.
            - 자율적으로 메시지를 처리하기 위해서 자신의 책임을 수행하는데 필요한 데이터와 프로세스를 가지고 있다.
        - 다형성
            - 다형성을 활용하는 목적은 서로 다른 유형의 객체가 동일한 메시지에 대해 다르게 반응하기 위해서이다.
            - 동일한 메시지를 처리한다 == 같은 역할을 수행한다.
            - 다르게 반응한다 == 메시지 처리 방법은 자율적이다.

    - 정리
        - 객체는 현실의 개념을 추상화한 것이다.
        - 객체들은 서로 협력하고, 역할을 맡아 책임을 수행하여 문제 상황을 해결한다.
        - 하지만 현실의 사물과 달리 객체는 능동적이고 자율적인 존재이다.

    - 빠지기 쉬운 함정
        - 현실 세계를 반영하기 위한 설계를 시작하면 자칫 데이터 중심의 설계를 하기 쉽다.
        - 데이터 중심의 설계의 문제점
            1. getter, setter 가 과도하게 추가되어 결합도가 높아진다. (서로 알고 있는 객체가 많아진다.)
            2. 데이터를 처리하는 작업과 데이터가 분리되어 응집도가 낮아진다.
        - 책임 주도 개발
            1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임(협력)을 파악한다.
                ex) 치킨 주문을 받아 손님에게 배달해야 한다.
            2. 시스템 책임을 더 작은 책임으로 분할
                ex) 메시지 생성 (치킨 주문을 받는다 / 치킨을 요리한다 / 치킨을 손님에게 배달한다)
            3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
            4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
            5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

    -> grasp 패턴

- 빌드와 배포
    - 컴파일
        - 소스 코드를 기계가 읽을 수 있는 바이너리 코드로 변경하는 과정
        - 소스 코드 분석 및 문법 오류 분석이 이루어진다.
        - JVM: Java Byte Code 를 OS 에 맞게 실행. 자바의 높은 이식성에 큰 영향을 주게 됨.
          결과물로 .class

    - 빌드
        - 소스 코드를 실행 가능한 독립적인 소프트웨어 산출물로 만드는 과정

        1. 컴파일: 소스코드를 바이너리 코드로
        2. 링크: 클래스 파일들끼리 연결 (외부 라이브러리 포함)
        3. 패키징: 연결된 클래스 및 리소스 파일 묶어주기
        4. 테스트: 기능 테스트
        -> 독립적인 소프트웨어 산출물로 묶어줌 (JAR, WAR)
            - JAR (Java Archive): 자바에서 사용되는 압축 양식, 클래스 + 리소스 파일로 구성
            - WAR (Web Archive): 웹 어플리케이션을 압축하고 배포하는데 사용되는 파일 형태
                                 JAR 에 비해 자바 서블릿, XML 파일, 정적 파일 등 필요한 자원이 더 많다.

    - 빌드 툴
        - Ant
            - XML 형식으로 작성
            - 자유도가 높음
            - 절차적으로 작성이 됨
            - 스크립트 직접적으로 명시, 다양한 Task 가능
            - 스크립트 재사용 불가능
            - 복잡해질수록 구조 및 스크립트 파악이 힘듬
        - Maven
            - pom.xml 형식으로 작성
            - 전체적인 프로젝트 관리 가능
            - 편리한 의존성 관리 및 다운로드 가능
            - 표준화된 빌드 스크립트
            - Lib 가 존재하여 빌드 속도가 빨라짐
            - 지원하지 않는 복잡한 빌드 과정 추가 시에 난이도 상승
            - pom.xml 관리가 까다로워짐
            - Repository 관리 불편함
        - Gradle
            - Ant 의 장점과 Maven 의 장점을 모아 Gradle 이 만들어짐
            - JVM 위에서 동작하는 Groovy 기반으로 작성
            - 자바 문법과 유사하여 익히기가 쉬움
            - Maven 의 세팅 및 중앙 저장소를 활용 가능
            - 프로젝트를 설정 주입식으로 정의, 재사용이 용이
            - Wrapper 를 활용하여 Gradle 이 설치되어 있지 않아도 사용 가능
            - Maven 에 비해 커뮤니티 크기가 작음

            - src: 자바 소스 파일
            - .gradle: gradle 버전 및 설정 파일
            - settings.gradle: 프로젝트 정보 설정
                - 프로젝트 빌드 정보 설정은 보통 하나지만, 멀티 프로젝트 빌드 시에 프로젝트 정의 가능. 하위 프로젝트들이 어떻게 구성되어 있는지를 기록
            - build.gradle: 프로젝트 빌드에 대한 정의
            - gradlew, gradlew.bat: 작동될 gradle 명령 파일들
                - gradle wrapper 의 약자로, gradle 이 설치되어 있지 않아도, 빌드할 수 있게 하는 역할
                  자바의 특성은 다양한 운영체제에서 작동하는 것인데, gradle 도 동일

    - 배포
        - 사용자가 사용할 수 있도록 소프트웨어를 제공하는 과정

    - CI/CD
        - 협업 시 문제점
            - 마지막에 프로젝트 합칠 시에 Integration Hell 발생
            - 중간 중간 프로젝트 합칠 시에 지속적으로 시간 소모 (빌드, 테스트)
        -> 이런 문제들을 해결하기 위해서 만든 것이 CI

        - CI (Continuous Integration)
            - 지속적 통합이라고도 하며, 코드 변경사항마다 빌드, 테스트까지 자동으로 진행하고 결과물을 보고 받고
              리포지토리에 자동 통합되는 프로세스

            - 변경 사항이 클래스, 기능 더 나아가 전체 어플리케이션에서의 테스트를 수월하게 수행
            - 신규 코드와 기존 코드의 충돌을 빠르게 수정 가능
            - 협업 시에 어플리케이션이 최신 상태로 유지됨을 믿을 수 있음

            - CI Tools
                - Travis
                    - Github 와 연계가 매우 좋다
                    - 클라우드 기반으로 서버 없이 작동 가능
                    - yml 형식을 통하여 쉽게 설정 가능
                    - 모든 작업들이 독립적
                    - 유료 서비스
                    - 상대적으로 부조간 플러그인
                - Jenkins
                    - 다양한 IDE 를 지원
                    - 호스팅을 직접 하기 때문에 커스터마이징 가능
                    - 가장 커뮤니티가 크기 문에 문서가 다양
                    - 중구난방 플러그인 때문에 파편화된 세팅
                    - 규모가 작아도 서버를 운영해야 함
                    - 서버 운영 비용 발생

        - CD (Continuous Deployment)
            - 개발자들이 코드에 변경 사항을 줄 경우, 파이프 라인을 통해 이동하여 프로적션 단계까지 자동으로 배포되는 프로세슨

            - 어플리케이션을 프로덕션으로 빠르고 쉽게 배포
            - 소비자들의 요구를 빠르게 만족시키는 서비스 출시가 가능
            - 개발팀과 운영팀의 간극을 메워줄 생산성 향상

        -> 운영, 모니터링 그리고 문제점이나 새로운 기능들을 다음 기능 기획에 반영? => DevOps
        - DevOps
            - Development 와 Operation 을 결합한 단어
            - 개발과 운영이 연계하여 협력하여 서비스를 이끌어 나가는 방법론

- api/라이브러리/프레임워크
    - api (Application Programming Interface)
        - 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
        - 구현과 독립적으로 사양만 정의되어 있다.
        - API 에 따라 접근 권한이 필요할 수 있다.
        - 구현과는 독립적으로 다양한 컴포넌트 간에 정보를 주고 받기 위한 규약
        ex) Java API, 여러 기업들의 오픈 API

    - Library
        - 응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어
        - 독립성을 가진다.
        - 응용 프로그램이 능동적으로 라이브러리를 사용한다.
        - 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임. 개발자가 응용 프로그램 흐름의 제어권을 가짐
        ex) Apache Commons, Guava, Lombok, jQuery

    - Framework
        - 응용 프로그램이나 소프트웨어의 솔류션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경
        - 상호협력하는 클래스와 인터페이스의 집합
        - 응용 프로그램이 수동적으로 프레임워크에 의해 사용된다. (프레임워크가 응용 프로그램 흐름의 제어권을 가짐)
        ex) Spring Framework, Junit, Ruby on Rails

    -> Library 와 API 의 차이점은 구현 로직의 유무이다.
       Library 와 Framework 의 차이점은 응용 프로그램의 흐름 주도권을 누가 가지고 있느냐 이다.

- CSR/SSR
    - SPA: Single Page Application, 하나의 페이지로 구성된 웹 어플리케이션
      웹 어플리케이션에 필요한 정적 리소스를 초반 한 번에 모두 다운로드 하고 그 이후 새로운 페이지 요청이 있을 때 페이지 갱신에 필요한
      데이터만 전달받아서 클라이언트에서 페이지를 갱신하기 때문에 자연스럽게 렌더링 방식으로 CSR 을 사용
    - MPA: Multi Page Application, 탭을 이동할 때마다 서버로부터 새로운 html 을 받아와서 페이지 전체를 새로 렌더링
      새로운 요청이 있을 때마다 서버에서 이미 렌더링된 정적 리소스를 받아오기 때문에 렌더링 방식으로 SSR 을 사용
    - SPA -> CSR,  MPA -> SSR

    - CSR: Client Side Rendering
    - SSR: Server Side Rendering
    - SSG: Static Site Generation (Static Rendering)
        - 서버에서 html 을 보내준다는 측면에서 SSR 과 비슷하지만 언제 만들어 주느냐에 차이
        - SSR 은 요청 시 서버에서 즉시 html 을 만들어서 응답하기 때문에 데이터가 달라지거나 자주 바뀌어서 미리 만들어 두기 어려운 페이지에 적합
        - SSG 는 페이지들을 서버에 모두 만들어둔 뒤에 요청시에 해당 페이지를 응답하는 것이므로 바뀔 일이 거의 없는 캐싱 해두면 좋은 페이지에 적합


    - CSR 의 동작 과정과 특징
        - 동작 과정
            - 유저가 웹사이트에 방문하면 브라우저가 서버에 콘텐츠를 요청하고 서버는 빈 뼈대만 있는 html 을 응답으로 보내준다.
              브라우저가 연결된 JS 링크를 통해 서버로부터 다시 JS 파일을 다운로드 받고 JS 를 이용해 동적 페이지를 만들어서 브라우저에 띄어줌
        - 특징
            - CSR 은 브라우저가 JS 파일을 다운로드 받고 동적으로 DOM 을 생성하는 시간을 기다려야 하기 때문에 초기 로딩 속도가 느리다.
              하지만 초기 로딩 이후에 페이지 일부를 변경할 때는 서버에 해당 데이터만 요청하면 되기 때문에 이후 구동 속도는 빠르다.
            - 서버가 빈 뼈대만 있는 html 을 넘겨주는 역할만 수행하면 되기 때문에 서버측에 부하가 적다.
              클라이언트측에서 연산, 라우팅 등을 모두 직접 처리하기 때문에 반응 속도가 빠르고 UX 도 우수하다.
            - 브라우저들이 가지는 웹 크롤러는 html 을 읽어서 검색 가능한 색인을 만들어냄. 웹 크롤러 봇 입장에서 본 html 은 텅텅 비어있다.
              검색엔진이 색인을 할만한 콘텐츠가 존재하지 않는다. -> 검색엔진 최적화에 불리하다는 치명적인 단점 존재
               (구글의 크롤러 봇은 자바스크립트를 실행할 줄 안다. CSR 웹 크롤링도 가능)
            - 화면 깜빡임이 없고 서버 부하가 클라이언트로 분산된다.

    - SSR 의 동작 과정과 특징
        - 동작 과정
            - 유저가 웹사이트에 방문하면 브라우저에서 서버로 콘텐츠를 요청한다. 서버에서는 즉시 페이지에 필요한 데이터를 얻어와 모두 삽입하고
              css 까지 모두 적용해서 렌더링 준비를 마친 html 과 JS 코드를 브라우저에 응답으로 전달.
              브라우저에서는 바로 전달 받은 페이지를 띄운다. 이어 브라우저가 JS 코드를 다운로드하고 html 에 JS 로직을 연결한다.
        - 특징
            - 모든 데이터가 이미 html 에 담겨진채로 브라우저에 전달되기 때문에 검색엔진 최적화에 유리하다. JS 를 실행할 줄 모르는
              크롤러 봇도 무리없이 html 을 읽을 수 있다.
            - 자바스크립트 코드를 다운로드 받고 실행하기 전에 사용자가 화면을 볼 수 있다. JS 다운로드를 기다려야 했던 CSR 보다
              초기 구동 속도가 빠르다. 하지만 이 시점에는 사용자가 버튼을 클릭하거나 이동하려고 해도 아무런 반응이 없을 수 있다.
              인터랙션 가능한 페이지처럼 보이지만 그저 내용과 스타일이 입혀진 껍데기에 불과하고 실제로 클라이언트 측 JS 가 실행되고
              이벤트 핸들러가 첨부되어서 JS 로직이 모두 연결될 때까지 사용자 입력에 응답할 수 없기 때문이다.
              -> TTV(Time To View) 와 TTI(Time To Interact) 간에 시간 간격이 존재한다는 단점 존재
              -> 반면 CSR 은 JS 가 동적으로 DOM 을 생성하기 때문에 html 은 JS 로직이 모두 완전히 연결된 상태라 사용자가 보는 시점과
                 이용할 수 있느 시점이 동일하다.
            - 화면 깜빡임이 있고 매 페이지 로딩시마다 서버에 요청하므로 서버 부하가 있다.

    - CSR 단점 보완
        - 초기 로딩 속도 보완
            - code splitting, tree-shaking, chunk 분리 -> JS 번들 크기를 줄여서 초기 DOM 생성 속도를 줄이는 것
        - SEO 개선
            - pre-rendering -> 라이브러리나 웹팩 플러그인을 통해 각 페이지에 대한 html 파일을 미리 생성해둔 뒤 서버에서 요청하는 자가
              만약 크롤러라면 사전에 렌더링된 html 버전 페이지를 보여주는 방식을 통해 개선

        - SSR, SSG 도입
            - with 프레임워크
                - CSR 에 비해 코드 복잡도가 올라가고, 직접 제어할 수 없는 블랙박스 영역 존재
                ex) next.js, gatsby, nuxt.js, 앵귤러 유니버셜

        - CSR + SSR
            - 초기 렌더링 벙식으로 SSR 을 사용하고 그 이후에는 CSR 을 사용하는 앱이나 그 렌더링 방식
            - Isomorphic App: 서버와 클라이언트에서 동일한 코드가 동작하는 어플리케이션. 서버와 클라이언트가 모두 같은 코드로
              돌아가기 때문에 예상과는 다른 결과를 마주할 가능성도 있지만, 초기 로딩 속도와 SEO 를 해결하면서도 CSR 의 장점을
              그대로 가져갈 수 있는 좋은 대안이기 때문에 최근 많이 사용되고 있는 추세.
            - Universal Rendering

    - 무엇을 써야할까?
        - CSR
            사용자와의 상호 작용이 많고 대부분 페이지가 고객의 개인정보 데이터를 기준으로 구성되는 서비스라면 검색포털 상위 노출 되는 것보다
            오히려 고객의 데이터를 보호하는 것이 더 중요.
        - SSR
            만약 회사 홈페이지이기 때문에 상위 노출되어야 하고 누구에거나 동일한 내용을 노출하고 있다면, 그 페이지 데이터가 자주 바뀐다면
        - SSG
            만약 회사 홈페이지이기 때문에 상위 노출되어야 하고 누구에거나 동일한 내용을 노출하고 있다면, 내용을 업데이트 하는 일이 거의 없다면
        - CSR + SSR -> 유니버셜 렌더링
            만약 사용자에 따라 페이지 내용도 달라지고 빠른 인터랙션도 중요하고 검색엔진 최적화도 포기할 수 없다면

- 정렬 알고리즘
    - 정렬
        - 정렬이란? -> 데이터를 기준에 맞게 순서대로 배열하는 작업
        - 정렬을 하는 이유 -> 탐색에 용이하기 위해서

    - insertion Sort
    - Merge Sort
    - Quick Sort
    - java 에서의 Sort
        - Dual Pivot Quick Sort
            1. primitive 타입을 정렬할 때, Dual Pivot Quick Sort 를 사용
            2. 피봇을 하나만 쓰는 것보다 일반적으로 빠름
        - Tim Sort
            1. Object 타입을 정렬할 때, Tim Sort 를 사용
            2. 앞에서 봤던 Insertion Sort 와 Merge Sort 의 하이브리드한 형태
            3. Binary Insertion Sort 를 사용
            4. Merge Sort 와 같이 분할을 진행하다가 특정한 기준보다 작은 사이즈가 되면 분할을 멈춘 후, Binary Insertion Sort 를 이용
            5. 특정 병합 조건에 맞게 병합

- 선형 자료구조 (Linear Data Structure)
    - 연속된 데이터를 저장하기 위한 자료구조

    - 동적 배열
        - 새로운 연속된 공간에 데이터를 복사해서 생성하는 것
        - 중간에 데이터 삽입, 삭제 시 비효율
    - 연결 리스트
        - 연속된 공간에 데이터를 저장하지 않는 것
        - 조회가 느리다.
        - 중간에 추가, 삭제하는 동작도 그 지점까지 타고 가는 비용이 있다.
        - 다음 노드를 기억하는데 추가 메모리를 사용
        - 메모리가 퍼져 있으므로 캐시의 효과를 누리지 못한다.
        - 잦은 추가와 삭제가 이루어지는 경우 사용
        - 다른 자료 구조를 공부하는 기반 지식이 된다.
    - 큐
    - 스택
    - 덱

- 싱글턴과 정적 클래스
    - 싱글턴
        - 싱글턴의 개념
            - 클래스의 인스턴스를 하나만 생성하고, 어디서든 그 인스턴스를 참조할 수 있도록 하는 패턴
            - 생성자가 여러 번 호출되더라도 실제로 생성되는 객체는 하나
        - 싱글턴을 쓰는 이유
            - 고정된 메모리 영역을 가지고 하나의 인스턴스만 사용하기 때문에 메모리 낭비 방지
            - 싱글턴 클래스의 인스턴스는 전역이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움
            - DBCP 처럼 공통괸 객체를 여러 개 생성해야 하는 상황에 많이 사용
        - 싱글턴 구현
            1. Eager initialization
                - static 을 로딩하면서 바로 메모리를 가진다. 래서 클라이언트에서 사용하지 않더라도 인스턴스가 항상 생성됨.
                - 예외 처리를 할 수 있는 방법이 없음
            2. Static block initialization
                - Eager initialization 과 유사
                - 인스턴스가 static block 내에서 생성됨
                - 예외 처리 가능
            3. Lazy initialization
                - getInstance() 호출 이외에는 인스턴스를 생성하지 않음
                - Eager initialization 의 단점 보완
                - 스레드 세이프 하지 않음
            4. Thread safe initialization
                - Synchronized 를 이용해서 하나의 스레드만 접근 가능하도록 설정
                - 성능 저하를 야기하는 비효율적인 방법
            5. Double-Checked Locking
                - null 체크를 Synchronized 블록 밖에서 한 번, 안에서 한 번 총 두 번 실행
                - 밖에서 하는 체크는 인스턴스가 있는 경우 빠르게 리턴하기 위해서,
                  안쪽에서 하는 체크는 인스턴스가 생성되지 않은 경우 하나의 인스턴스만 생성하기 위해서
            6. Bill Pugh Solution
                - Double-Checked 에 비해 구현이 간단
                - Lazy Loading 이 가능
                - Thread safe

    - 정적 클래스
        - 정적 클래스의 개념
            - 모든 메서드가 static 인 클래스 지칭, 또는 inner static class 를 뜻하기도 함
        - 정적 클래스 쓰는 이유
            - 상태를 가지고 있지 않고 global access 를 제공할 때 유용
            - static 은 컴파일 때 static binding 으로 싱글턴보다 좀 더 빠르다
            - 클래스 자체에 static 을 붙여 사용할 수 없다. (inner class 일 때만 가능)
        - 정적 클래스의 구현
            - static variable
                - 메모리에 고정적으로 할당되어, 프로그램이 종료될 때 해제되는 변수
            - static method
                - 객체 생성 없이 메소드 바로 호출 가능
                - 객체 생성 없이 접근하는 메서드이므로, static 이 아는 변수는 사용 불가능
            - static class
                - static nested class 라고 한다.
                - 외부클래스의 자원 중 static 이 붙은 것만 사용 가능
                - inner 클래스에 static 을 붙이지 않으면 inner 클래스에서 outer 클래스에 있는 필드 등에 참조할 수 있고
                  inner 클래스의 역할이 끝나도 gc 가 지우지 못해 메모리 낭비가 생긴다.

    - 싱글턴 vs 정적 클래스
        - 싱글턴
            - 하나의 인스턴스를 생성하여 재사용
            - 인터페이스 구현 가능
            - override 가능 (상속)
            - 필요에 따라 lazy 가능
            - OOP
        - 정적 클래스
            - 인스턴스 생성 x
            - 인터페이스 구현 불가능
            - override 불가능
            - static binding 으로 빠르게 로딩
            - OOP x

- Java final 과 불변 객체
    - 자바 final
        - 한 번만 할당 가능하다는 선언
        - 재할당하려고 하면 컴파일 오류가 발생
        - 버그 발생 가능성이 줄어들고, 버그를 찾는 시점이 빨라져 서비스 안정성이 높아짐
    - 불변 객체란
        - 한 번 생성되면 상태를 수정할 수 없는 객체 -> 생성이 된 불변 객체는 신뢰할 수 있다.
    - 불변 객체를 사용해야 하는 이유
        - 스레드 동기화 문제 방지

- 자바 직렬화
    - 자바 직렬화의 흐름
        - 직렬화
            - 객체의 상태를 영속화하는 메커니즘
            - 객체를 다른 환경에 저장했다가 나중에 재구성 할 수 있게 만드는 과정
            - 객체의 상태를 영속해야 할 필요가 있을 때 사용
            - 다른 VM 에게 객체의 정보를 바이트 스트림으로 변환해서 전송해야 할 때 사용
        - 직렬화/역직렬화 흐름
            - 객체는 writeObject 를 거쳐 직렬화 되어 어딘가(DB, File, Memory)에 보관되었다가 readObject 에 의해 역직렬화 되면서
              객체로 재생성
    - 자바 직렬화의 위험성
        - 보안
            - 보이지 않는 생성자, readObject
            -> 해결: 커스텀 직렬화
                    직렬화 대상 클래스에 readObject 메서드를 새롭게 정의해주면 된다.
        - 유지보수성
        - 테스트
        - 그 외 다수 (싱글톤 문제, 역직렬화 폭탄 등)
            - 싱글톤 문제
                - 싱글톤 객체를 직렬화 했다가 역직렬화하여 사용하면 싱글톤의 성격을 잃어버린다.
                -> 해결: readResolve 를 정의해주면 된다.
                        readObject 가 불린 이후에 readResolve 가 불리게 되면서 역직렬화하여 생성한 객체는 사용하지 않고
                        readResolve 에서 반환하는 객체를 사용.
                        만약 클래스의 인스턴스 변수가 존재하는 경우 전부 transient 예약어를 이용해서 직렬화-역직렬화 대상이 되지 않도록
                        해주어야 한다. 그렇지 않으면 참조필드의 영역값을 훔쳐오는 행위가 가능해짐.

- java version
    - java version
        - java 8
            - 큰 변화가 생김. 빅데이터가 떠오르면서 병렬 처리에 대한 관심이 높아짐에 따라 병렬 환경을 쉽게 관리할 수 있는 방향으로 가고자
              Stream API 가 추가됨.
        - java 9
            - 버전이 올라가면서 JDK 의 규모가 커지게 되고 일부 패키지만 필요로 하는 작은 환경에서 사용하지 않는 패키지들도 런타임에
              실행되어야 했다. 개발자가 라이브러리와 대규모 응용 프로그램을 쉽게 구성하고 관리할 수 있도록 모듈화 지원
    - java 9
        - Modules
            - 패키지가 클래스들의 묶음이라면 모듈은 패키지의 묶음
            - 기존 패키지 방식은 여러 패키지에서 공용으로 사용되는 클래스를 외부에 숨길 수 없었다. 이렇게 되면 라이브러리 내부 뿐만 아니라
              외부에서도 클래스 접근이 가능하게 된다. 그리고 런타임 시 사용하지 않는 클래스들도 모두 포함해야 했다.
            - 모듈화를 통해 패키지를 캡슐화하고 위 문제들을 해결
        - private methods in interfaces
            - private 메서드를 사용해서 메서드를 분리할 수 있고 중복되는 코드 재사용 가능
            - private static 도 사용 가능하게 됨
        - 불변 컬렉션 생성
            - List.of(), Set.of(), Map.of()
        - Compact String
            - 자바는 내부적으로 UTF-16 을 사용하기 때문에 모든 문자가 2byte 로 구성되고 1byte 로 표현될 수 있는 영어도 빈 공간을
              사용해야 했다.
            - java 6 버전에서 VM 옵션을 활성화해서 문자열을 char 배열 대신에 byte 배열로 저장할 수 있었다.
              하지만 성능 문제로 7 버전에서 삭제되고 9 버전에 Compact String 으로 돌아옴.
            - 자바 9 버전 이상의 String 클래스를 보면 인스턴스 변수가 byte 배열로 되어 있어 1byte 로도 저장이 가능해짐
        - try-with-resource 향상
            - 자원을 try 문 밖에서 할당하게 된다면 그 변수를 try 문 안에서 바로 사용할 수가 없었다.
              자바 9 버전에서는 밖에서 할당한 변수도 try 문 안에서 바로 사용 가능
        - Optional API 추가
    - java 10
        - Local variable type interface (로컬 변수 타입 추론)
            - 하위호환성을 중요시 하는 java 는 기존의 변수명을 var 로 사용했을 것을 염두하여 키워드로 만들지 않음
              따라서 var 를 변수나 메서드명으로 사용 가능
            - var 는 인스턴스 변수로 사용이 불가능하고 반드시 초기화해야 함
            - var 형식의 지역 변수에 익명 클래스를 할당하면 부모가 아닌 익명 클래스 형식을 유추
        - Optional.orElseThrow()
            - 인자 없이 사용 가능해짐.
            - 인자 없이 사용해서 객체가 비어 있을 경우에는 NoSuchElementException 발생
        - Unmodifiable Collections
            - copyOf() -> List.copyOf(), Set.copyOf(), Map.copyOf()
            - toUnmodifiable -> toUnmodifiableList(), toUnmodifiableMap, toUnmodifiableSet()
    - java 11
        - Local-Variable Syntax for Lambda
            - var 를 람다 표현식의 매개변수로 사용할 수 있게 확장됨
            - var 를 매개변수로 사용하게 된다면 @NotNull 같은 어노테이션을 사용할 수 있게 된다.
        - String API Additions
            - repeat(int): 문자열 반복
            - lines(): 라인 단위로 분할하여 스트림으로 반환
            - strip(): 문자열 앞 뒤 공백 제거
            - stripLeading(): 문자열 앞 공백 제거
            - stripTrailing(): 문자열 뒤 공백 제거
            - isBlank(): 문자열이 비어 있거나 공백만 있는 경우 true 반환
            * trim() 과 차이점은 유니코드의 공백 문자를 인식
        - New File Methods
            - writeString()
            - readString()
            - toArray
