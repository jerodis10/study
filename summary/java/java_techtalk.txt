- 추상클래스/인터페이스
    1. Java 8 이후의 Interface 의 특징
    2. Interface 를 써야 하는 이유
    3. Skeletal Implementation 이란
    4. Interface 사용시 주의점


    1. Java 8 이후의 Interface 의 특징
        - 인스턴스를 생성할 수 없고 상수만 가질 수 있다.
        - 메서드 body 가 없는 추상 메서드를 가진다.
        - 디폴트 메소드, static 메서드만 가질 수 있다. (JDK 1.8 이상)
            - 디폴트 메서드
                - 인터페이스에서 메서드 body 를 가지는 메서드.
                - 반드시 override 할 필요는 없음. 접근 제어자는 public
                - 이미 작성된 인터페이스에서 기능을 추가하려고 할 때 디폴트 메서드 없이는 구현체 클래스들이 전부 override 를 해야하지만,
                  디폴트 메서드가 있다면 그런 작업 없이 하위호환이 가능

    2. Interface 를 써야 하는 이유
        - 다중 상속이 가능하다.
          ex) singer -> songWriter -> singerSongWriter 로 구현하면 다중 상속 필요 없지 않나?
              singer -> songWriter 상속 관계 때문에 songWriter 생성 시 불필요한 singer 의 메서드나 필드가 상속된다.
              즉, 독자적인 songWriter 를 생성할 수 없다.
              따라서, singer 와 songWriter 에서 가져오고 싶은 속성을 singerSongWriter 에 가져와야 한다.
              => 추상클래스만으로 표현하다보면 조합적 폭발이 발생
          * 다이아몬드 문제: 다중 상속 시, 부모 클래스에 같은 시그니처의 메서드가 있을 때 어떤 메서드를 상속받아야 하는지 판별할 수 없는 문제
                          그러나, 추상메서드는 구체적인 선언부가 없기 때문에 모호함이 발생하지 않는다.

        - 공통의 조상을 갖지 않는 두 클래스에 관계를 맺을 수 있다.
        - 사용자 입장에서는 내부적 구조에 대한 이해 없이 약속된 행위가 보장된다.
        - 추상 클래스도 이런 다형성 구현이 가능하지만, 상속관계에 있는 클래스끼리만 가능. 따라서, 인터페이스가 좀 더 유연하게 다형성 적용 가능

        - 추상 클래스 써야 할 때
            1. 굉장히 밀접하게 관련된 클래스끼리 코드를 공유해야 할 때
            2. 추상 클래스의 하위 구현체 클래스들이 공통된 필드나 메서드를 많이 공유하고, 접근제어자가 public 이 아닌 경우
            3. Non-static 혹은 non-final 의 필드로 객체의 상태를 바꿔야 하는 경우

        - 인퍼페이스 써야 할 때
            1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
            2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
            3. 다중 상속이 필요한 때

    3. Skeletal Implementation 이란
        ex) Java Collection 의 AbstractList, AbstractMap 등

        - 추상 골격 클래스는 private, protected 가 가능하므로 override 한 메서드의 내부 메서드들을 클라이언트가 접근하지 못하도록
          막을 수 있다. 그러나, 직접 interface 를 구현하게 되면 접근 제어자가 모두 public 이기 때문에 이와 같은 은닉이 힘들다.
          또한 디폴트 메서드에서는 하위 구현체 클래스에 대한 상태, 즉 필드에 대한 참조가 이루어질 수 없다.

        - 디폴트 메서드의 도입 원인을 생각하면, 이미 존재하는 인터페이스의 하위 호환성을 위해서이다.
          따라서, 새로 인터페이스를 만드는 시점에서 디폴트 메서드를 쓴다면 디폴트 메서드 도입 취지와는 맞지 않다.

    4. Interface 사용시 주의점
        ex) Java 8에서 Collection 에 추가된 removeIf 디폴트 메서드
        - 멀티 쓰레드 환경인 SynchronizedCollection 에서는?
            - 런타임 에러 -> removeIf 를 override 하자 (lock 을 설정하여)
                        -> 원래의 디폴트 메서드를 목적에 맞게 재정의해서 해결

        - 디폴트 메서드 override 시 다이아몬드 문제가 일어나지 않나?
            - 디폴트 메서드 다중 상속 시, 약간의 우선순위로 해결
                1. 구현하는 클래스나 슈퍼클래스
                2. 상속받는 인터페이스
                3. 명시적 사용

        => 디폴트 메서드는 런타임 에러를 일으킬 수 있다.
           이미 구현된 인터페이스에 디폴트 메서드를 추가하는 것은 신중히 해야 한다.
           디폴트 메서드를 추가하려면 릴리즈 전에 반드시 테스트를 거쳐야 한다.


    - 인터페이스나 추상클래스나 둘 다 똑같이 추상 메소드를 통해 상속/구현을 통한 메서드 강제 구현 규칙을 가지는 추상화 클래스

    - 추상클래스는 추상화를 사용하면서 중복되는 클래스 멤버들을 통합/확장 즉, 클래스간의 연관 관계를 구축하는 것에 초점
      인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점
      인터페이스는 다중 구현 및 다중 상속 가능

    - 인터페이스의 필드는 상수만 가능하여 중복된 필드가 있을 경우 인터페이스로 해결이 어렵고, 추상클래스를 남용하면 단일 상속만 되는 제한 때문에 클래스 의존성이 커진다.
      이러한 서로간의 제약들을 극복하기 위해 인터페이스-추상클래스-클래스 구현 디자인 패턴이 나왔고 여러 디자인 패턴들의 근간이 된다.


    - 인터페이스는 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌
      추상클래스는 자신의 기능들을 하위 클래스로 확장 시키는 느낌

    - 추상클래스는 클라이언트에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌
      인터페이스는 반대로 먼저든 나중이든 그때 그때 필요에 따라 구현해서 자유롭게 붙였다 땟다하는 느낌

- stream vs for
    - for 문
        - java 1부터 지원
        - for (초기화; 조건; 후처리)

    - 향상된 for 문
        - java 5부터 지원
        - 가독성 up, 안정성 up

    - stream
        - java 8부터 지원
        - stream 생성 -> 중간 연산 -> 최종 연산

    - 둘 다 다량의 데이터 처리 작업에 사용

    - 차이점
        - 함수 객체 vs 코드 블럭
            - for 문은 코드 블록으로 표현
            - 스트림 파이프라인은 함수 객체로 표현 (람다 or 메서드 참조)
            -> 람다식에는 final 변수만 읽을 수 있기 때문에 지역 변수를 수정할 수 없다.
            -> for 문에서는 할 수 있는 continue, break 로직은 stream 에서는 할 수 없다.

        - 외부 반복 (how) vs 내부 반복 (what)
            - 외부 반복: for 문, 구체적인 구현 로직이 외부에 노출
            - 내부 반복: stream, 로직이 노출되지 x

        - 가독성
            ex) for 문의 경우 if 문의 중첩으로 인해 indent depth 가 깊어져 가독성이 떨어질 수 있으나
                stream 의 경우, 조건들을 filter 의 체이닝 형식을 통해 표현할 수 있기 때문에 보다 간결한 표현 가능

            ex) if 문의 중첩 만 있을 경우, 메서드 추출을 통해서 충분히 indent depth 를 줄여 가독성을 높일 수 있었음.
                하지만, for 문으로 요소를 순회하면서 return 을 하는 경우에는 메서드 추출을 통해 indent depth 를
                줄이는 것이 어려움.
                이런 경우, stream 을 이용하면 depth 를 줄여 가독성을 높일 수 있음.

            - 상황에 따라 stream 이 더 가독성이 안 좋을 수도 있음.

        - 디버깅
            - stream 은 많은 내부 수행 작업과 지연 연산으로 인해 디버깅이 다소 어려울 수 있다.
            - for 문은 예외가 발생하는 stack trace 가 간결하게 출력되서 디버깅에 유리할 수 있다.

        - 병렬 처리
            - for 문의 경우, Runnable 등을 활용해 병렬 처리를 위한 코드를 일일이 작성해야 함.
              로직이 복잡해질 경우 직접 구현하기도 까다롭고 신경쓸 것도 많아짐
              데이터들을 몇 개로 어떻게 나눌 것인지, 혹은 발생할 수 있는 동시성 문제가 있는지를 고려해야 한다.
            - stream 을 이용하면 위의 내용들을 stream 이 내부적으로 처리해 주기 때문에 보다 쉽게 병렬 처리 표현 가능

        - 성능
            - int 배열에서 for 문이 stream 보다 빠른 이유
                - for 는 나온지 오래된 만큼 stream 에 비해 JVM 에서 최적화가 충분히 이루어졌다.

                - stream 을 사용하려면 stream 객체를 생성해야 한다.
                  이 생성 과정에서 여러 작업들이 이루어지고 stream 에서 필요한 다른 객체를 생성하는데 오버헤드가 발생
                - for 는 추가적인 객체 생성 없이 인덱스를 통해서 메모리에 직접 접근을 하기 때문에
                  stream 에 비해 오베헤드가 발생하지 않는다.

            - 향상된 for 문에서는 원시타입 배열에 어떻게 접근 할까?
                - 향상된 for 문에서는 컬렉션을 순회할 때와 마찬가지로 iterator 를 이용할 것이라고 예상할 수 있지만
                  원시타입 배열이 들어온 경우에는 iterator 가 아닌 전통 for 문의 형식으로 바꾸어서 순회.
                  따라서 int 배열에 대한 작업에서는 전통 for 문과 향상된 for 문이 비슷한 성능을 보임

            - List 에서 성능 차이가 미미한 이유
                - int 배열은 요소들이 원시타입인 반면 컬렉션은 Wrapper 타입이 들어오게 된다.
                  그래서 박싱 및 언박싱에 대한 오버헤드가 발생한다. 이 오버헤드는 충분히 크기 때문에
                  컬렉션에 대한 성능은 이 오버헤드에 지배되면서 큰 성능 차이를 보이지 못함.

            => 하지만, 오늘날의 하드웨어는 충분히 빠르기 때문에 소프트웨어에서는 성능보다는 다른 점들을 더욱 신경쓰는 추세.
               유지보수, 가독성 등을 고려하는 것이 더욱 좋을 수 있음.

    - 결론
        - 가독성
            - 추상화된 api 를 제공하고, 보다 What 중심의 코드를 작성할 수 있어 가독성이 더 좋을 수 있다. (개인 차이 존재)

        - 디버깅
            - for 문에 비해 stream 이 디버깅이 어렵다.

        - 병렬 처리
            - 비교적 stream 을 이용한 병렬 처리가 간단하다.

        - 성능
            - for 문이 성능이 더 좋을 수 있다.

        - 스트림을 적용하기 좋은 조건
            - 원소들의 시퀀스를 일관되게 변환한다.
            - 원소들의 시퀀스를 필터링 한다.
            - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.
            - 원소들의 시퀀스를 컬렉션에 모은다.
            - 원소들의 시퀀스를 특정 조건을 만족하는 원소를 찾는다.

        => 어느 하나가 절대적으로 좋은 것이 아닌 각각의 장단점이 있다.
           따라서, 차이를 인지하고 이를 적절히 사용하는 것이 바람직하다.

- GC
    - GC 가 왜 필요하지?
        - 프로그램이 동적으로 할당했던 메모리 영역 중 필요 없게 된 영역을 알아서 해제하는 기법
        - 여기서 동적으로 할당했던 메모리 영역은 프로그램 런타임에 사용되는 Heap 영역 메모리
          필요없게된 영역은 어떤 변수도 가리키지 않게 된 영역
        - C 나 C++ 의 경우 Heap 영역의 메모리를 관리하기 위해 코드 레벨에서 할당 받고 해제해야함.
          만약 할당 받은 메모리를 제대로 해제하지 않으면 Memory Leak 이 발생하기도 함

        - 장점
            - 메모리 누수 방지
            - 해제된 메모리에 접근 x
            - 해제한 메모리에 재접근하는 이중 해제 x
        - 단점
            - GC 작업 (어떠한 메모리 영역이 해제의 대상이 될지 검사하고 해제하는 일)은 순수 오버헤드
            - 개발자는 언제 GC 가 메모리를 해재하는지 모름
              실시간성이 매우 강조되는 프로그램의 경우 GC 에게 메모리 관리를 맡기는 것이 알맞지 않을 수 있다.

    - GC 알고리즘
        - GC 는 어떻게 해제할 동적 메모리 영역들을 알아서 판단할까?
        - Reference Counting 과 Mark And Sweep GC 알고리즘
            - Reference Counting
                Heap 영역에 선언된 객체들이 각각 reference count 라는 별도 숫자를 가지고 있다.
                reference count 는 몇 가지 방법으로 해당 객체에 접근할 수 있는지를 뜻함.
                해당 객체에 접근할 수 있는 방법이 하나도 없다면 즉, reference count 가 0에 다다르면 가비지 컬렉션의 대상이 됨
                Heap Space 내부에서 순환 참조 하고 있을 경우 Memory leak 이 발생
            - Mark And Sweep
                Reference Counting 의 순환 참조 문제를 해결할 수 있다.
                루트에서부터 해당 객체에 접근 가능한지를 해제의 기준으로 삼는다.
                루트부터 그래프 순회를 통해 연결된 객체들을 찾아내고 연결이 끊어진 객체들은 지우는 방식
                메모리 파편화를 막는 Compaction. Mark And Sweep 에서 Compaction 은 필수는 아님.
                자바와 자바스크립트가 Mark And Sweep 방식으로 메모리 관리를 한다.
                의도적으로 GC 를 실행시켜야 한다.
                어플리케이션 실행과 GC 실행이 병행된다.

    - JVM 의 GC
        - Class Loader: 바이트 코드를 읽고, 클래스 정보를 메모리에 Heap/Method Area 에 저장
        - JVM Memory: 실행 중인 프로그램의 정보가 올라가 있는 메모리
        - Execution Engine: 바이트 코드를 네이티브 코드로 변환시켜주고, GC 를 실행

        - JVM Memory 구조
            - JVM 은 OS 로부터 메모리를 할당 받은 후, 해당 메모리를 용도에 따라 여러 영역으로 나누어서 관리
            - 모든 쓰레드가 공유하는 영역으로 Method Area, Heap 영역
              각 쓰레드마다 고유하게 생성하며, 쓰레드 종료 시 소멸되는 stack, PC Register, Native Method Stack 영역
                - Method Area 는 프로그램의 클래스 구조를 메타데이터처럼 가지며, 메서드의 코드들을 저장
                - Heap 은 어플리케이션 실행 중에 생성되는 객체 인스턴스를 저장. Garbage Collector 에 의해 관리되는 영역
                - stack 은 메서드 호출을 스택 프레임이라는 블록으로 쌓으며 로컬 변수, 중간 연산 결과들이 저장
                - PC Register 는 쓰레드가 현재 실행할 스택 프레임의 주소를 저장
                - Native Method Stack C/C++ 등의 Low level 코드를 실행하는 스택
            - JVM GC 의 Root Space 는 Stack 의 로컬 변수, Method Area 의 Static 변수, Native Method Stack 의 JNI 참조

        - Heap 영역 (GC 의 실행 타이밍을 알 수 있음)
            - Young Generation 과 Old Generation 으로 나뉨.
            - Young Generation 에서 발생하는 GC 는 minor gc, Old Generation 에서 발생하는 GC 는 major gc
            - Young Generation 은 Eden / Survival 0 / Survival 1 세 영역으로 나뉜다.
                - Eden 은 새롭게 생성된 객체들이 할당되는 영역
                - Survival 영역은 minor gc 로부터 살아남은 객체들이 존재하는 영역
                - Survival 0 혹은 Survival 1 둘 중 하나는 꼭 비어 있어야 한다.
                - 새로운 객체가 계속 생성되다 보면 Eden 영역이 꽉 차게 되는 순간이 옴. 이  minor gc 가 일어남.
                  Mark And Sweep 이 진행된다. 루트로부터 Reachable 이라 판단된 객체는 Survival 0 영역으로 옮겨진다.
                  Survival 0 으로 옮겨진 객체들의 age-bit 가 증가함. minor gc 에서 살아남을 때마다 1씩 증가한다.
                  시간이 흘러 Eden 영역이 또 꽉차면 또 다시 minor gc 가 발생한다. 이번에는 Reachable 이라고 판단된 객체들이
                  Survival 1 영역으로 이동된다. 시간이 흘러 Eden 영역이 또 꽉차면 minor gc 가 발생한다. 이번에 살아남은 객체들은
                  Survival 0 영역으로 이동된다. Survival 0 영역으로 넘어온 객체 중 하나가 오래 살아남아 age-bit 3 이 됨.
                  JVM GC 에서는 일정 수준의 age-bit 를 넘어가면 오래도록 참조될 객체라고 판단하여 해당 객체를
                  Old Generation 에 넘겨줌. 이 과정을 Promotion 이라고 함. Java 8 에서는 Parallel GC 사용 기준 age-bit 가
                  15가 되면 Promotion 이 진행된다. 시간이 아주 많이 지나면 Old Generation 도 다 채워짐. 이 때 major gc 가
                  발생하면서 Mark And Sweep 방식을 통해 필요 없는 메모리를 비워준다.
                  이 major gc 는 minor gc 보다 오래 걸린다.
                - GC 설계자들이 어플리케이션을 분석해보니 대부분의 객체가 수명이 짧은 것을 발견. GC 도 결국 비용인데, 메모리의
                  특정 부분만을 탐색하며 해제하면 더 효율적. 어차피 대다수의 객체가 금방 사라지니 Young Generation 안에서 최대한
                  처리되도록 함.

                  1. Eden 영역에 새로운 객체가 할당
                  2. Eden 영역이 가득 차면 Minor GC가 발생
                  3. 참조가 있는 객체는 첫번째 Survivor로 이동
                  ※ 이동되면서 age bit가 1씩 증가
                  4. Eden 영역이 가득 차면 Minor GC가 발생
                  5. 참조가 살아있는 객체들은 두번째 Survivor로 이동
                  ※ 이동되면서 age bit가 1씩 증가
                  6. Minor GC 후에 특정 Age 임계치에 도달한 객체들은 Old Generation 으로 Promotion(이동)
                  (Java 8에서는 Parallel GC 방식 기준으로 age bit가 15가 되면 Promotion이 진행)
                  7. 때문에 Minor GC 가 계속되면 Old Generation 에 객체들이 계속 Promotion 된다. Old Generation 이 가득차게 되면 객체를 삭제하고 압축하기 위해 Majro GC 가 수행

        - Stop The World
            - GC 를 실행하기 위해 JVM 이 어플리케이션 실행을 멈추는 것.
            - 어플리케이션의 사용성을 유지하면서 효율적으로 GC 를 실행하는 것이 어려운 최적화 작업.
              Stop The World 시간을 최소화하는 것이 어려운 최적화 작업

        - GC 방식 살펴보기
            - Serial GC
                - 하나의 쓰레드로 GC 를 실행하는 방식
                - Stop The World 시간이 긺
                - 싱글 쓰레드 환경 및 Heap 이 매우 작을 때 사용
            - Parallel GC
                - 여러 개의 쓰레드로 GC 를 실행. 이에 따라 Serial GC 보다 Stop The World 시간이 더 짧음
                - 멀티코어 환경에서 어플리케이션 처리 속도를 향상하기 위해 사용
                - Java 8 의 default GC 방식
            - CMS GC
                - CMS (Concurrent-Mark-Sweep)
                - GC 작업을 어플리케이션과 동시에 실행하여 Stop The World 최소화
                - 메모리와 CPU 를 많이 사용하고 Mark And Sweep 과정 이후 메모리 파편화를 해결하는
                  Compaction 이 기본적으로 제공되지 않다는 단점이 있음
                - G1 GC 등장에 따라 Deprecated
            - G1 GC
                - G1 (가비지 퍼스트)
                - Heap 을 일정 크기의 Region 으로 잘게 나누어 어떤 영역은 Young Generation, 어떤 영역은 Old Generation 으로 활용
                - 런타임에 G1 GC 가 필요에 따라 영역별 Region 개수를 튜닝함. 그에 따라 Stop the world 를 최소화할 수 있음
                - Java 9 부터 default GC 방식

    - JVM GC 튜닝 맛보기
        - GC 튜닝은 성능 개선의 최종 단계. 객체 생성 자체를 줄이려는 코드 레벨에서의 개선이 선행되어야 한다.
        - JVM GC 튜닝의 목표
            - Old Generation 으로 넘어가는 객체 최소화하기
            - Major GC 시간을 짧게 유지하기
            -> Major GC 를 적게 발생시키거나 빠른 시간 내에 끝내는 것이 목표
        - 한정된 Heap 영역에 Young Generation 과 Old Generation 을 각각 얼마만큼 할당하는 것이 적당한지를 판단해야 한다.
          메모리가 너무 크다면 GC 가 가끔 일어나겠지만 오래 걸릴 것이고, 메모리가 너무 작다면 GC 는 자주 일어나겠지만 금방 끝날 것.
          어플리케이션의 구조 및 특성에 따라 판단해야 함.
        - GC 튜닝 과정
            - 현재 GC 상태 모니터링하기
            - 어플리케이션 성격에 알맞은 GC 방식과 메모리 크기 설정
            - 적용하기

        - JVM 메모리 모니터링
            - JDK 설치 시 기본으로 제공되는 jstat 이라는 툴 활용 가능
            - jstat gcutil 명령어로 현재 실행중인 프로세스에 대해 gc 와 관련된 정보 확인 가능
                ex) jstat -gcutil -t 8844 1000 10
            - jstat gccapacity 명령을 통해 프로세스가 heap 영역을 얼마나 사용 중인지 정확한 수치 확인 가능
                ex) jstat -gccapacity -t 8844 1000 10

- DFS/BFS
    - 탐색 알고리즘의 개념과 필요성
         - 탐색 알고리즘: 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘
         - 그래프: 정점과 간선으로 구성된, 한정된 자료구조를 의미. 각각의 지점을 정점, 정점과 정점의 연결을 간선
         - 각 정점이 서로 연결되어 있는지, 정해진 시간 내에 효율적으로 할 수 있는가? 를 확인하는 알고리즘

    - DFS
        - 현재 정점과 연결된 정점들을 하나씩 갈 수 있는지 검사하고, 특정 정점으로 갈 수 있다면 그 정점에 가서 같은 행위를 반복
          시작점에서 한 갈래로 더 이상 갈 수 없을 때까지 탐색하고, 더 갈 곳이 없다면 이전의 경로로 되돌아간다.
          같은 정점을 다시 방문하지 않도록 정점에 방문했다는 것을 표시.
          재귀 함수를 통해 구현
        - 장점
            - 코드가 직관적이고 구현하기 쉽다.
        - 단점
            - 재귀 함수를 이용하기 문에 함수 호출 비용이 추가로 들어감
            - 재귀 깊이가 지나치게 깊어지면 메모리 비용을 예측하기 어려움
            - 최단 경로를 알 수 없다.

    - BFS
        - 시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘
        - 큐를 이용하여 구현
            - 먼저 출발점을 큐에 넣는다.
            - 큐에 저장된 정점 하나를 Dequeue 한다.
            - Dequeue 된 정점과 연결된 모든 정점을 큐에 넣는다.
            - 큐가 비어있다면 반복을 종료
        - 장점
            - 효율적인 운영이 가능하고, 시간/공간 복잡도 면에서 안정적이다.
            - 간선의 비용이 모두 같을 경우, 최단 경로를 구할 수 있다.
        - 단점
            - DFS 에 비해 코드 구현이 어렵다.
            - 모든 지점을 탐색할 경우를 대비해, 큐의 메모리가 미리 준비되어 있어야 한다.

- 람다
    - Java 8 에서는 많은 새로운 기능들이 도입 되었고, 그 중에는 람다와 stream 도입을 통한
      함수형 프로그래밍도 있다. 람다를 통해 함수를 파라미터로 넘길 수 있고 변수에 할당할 수 있으며
      반환 값으로 반환할 수 있는 일급 시민으로써 사용할 수 있게 됨.
      이를 통해 코드 양도 줄이면서도 코드의 재사용성을 크게 높일 수 있다.

    - 동작 파라미터화
        - 함수 또는 코드 블록을 파라미터로 넘길 수 있게 하는 것

    - 람다를 사용하기 위한 조건 -> 함수형 인터페이스
      함수형 인터페이스는 하나의 추상메서드가 존재해야 한다.
      @FunctionalInterface 는 함수형 인터페이스로 사용 명시, 해당 인터페이스가 함수형 인터페이스의 조건을
      충족하지 못할 경우 에러를 띄우는 역할

    - 표준 라이브러리에 존재하는 함수형 인터페이스
        ex) Predicate, Consumer...

    - 익명 클래스는 단순히 편의를 위해서 클래스 내부에서 사용을 할뿐 컴파일이 되면
      별도의 클래스로 분리되어 나온다.
    - 하지만 람다의 경우 컴파일 해도 별도의 클래스 파일이 생성되지 않으며 람다는 그대로 존재

    - 람다 동작 과정
        - 람다를 정의를 한 파일의 바이트코드를 보면 람다가 정의된 곳은 INVOKEDYNAMIC 으로 대체가 되고 클래스 내부에
          새로운 메서드 하나가 생성됨. INVOKEDYNAMIC 은 Java 7 에서 도입되었으며 클래스에 생성을 런타임까지 지연시키는 역할.
          이 때문에 람다는 컴파일 단계에서 생성되지 않고 런타임까지 지연됨.
          람다의 정의로 인해서 생성되는 메서드들은 'lambda' 라는 prefix 가 오고 두 개의 '$' 가 옴

    - 람다를 사용하면 안되는 경우
        - this 를 사용할 경우
            - 만약 내부에서 this 를 사용해야 하면 람다 대신 익명 클래스 사용해야 함
        - 섀도우 변수 (shadow variable) 를 사용할 경우
            - shadow variable 는 inner scope 내부에 outer scope 에 정의한 똑같은 변수가 있을 경우 shadow 된다.
            - 람다는 변수 shadowing 을 잡아내지 못하고 에러를 띄우므로 익명 클래스 사용해야 함
        - 콘텍스트 오버로딩이 존재할 때
            - 람다는 파라미터나 반환 값 등을 통해서 해당 람다가 어느 익명 메서드의 구현인지를 내부적으로 추론하는데
              모든 요소가 같은 추상 메서드가 2개 이상 존재한다면 에러가 띄우므로 익명 클래스 사용해야 함
        - 람다 코드가 3줄을 넘어갈 때
            - 동작을 파악하는데 시간이 오래 걸리고 복잡한 코드가 나올수 있으므로 지양

    - 람다 표현식의 한계
        - 코드 자체로 동작이 명확하게 설명되지 않거나 람다가 길거나 읽기 어렵다면, 쓰지 않는 방향으로 리팩토링하는 것을 고려
        - 람다식은 기본적으로 익명 구현 객체 기반이기 때문에, 익명 객체 특성상 디버깅 할때 콜 스택(call stack) 추적이 매우 어려운 단점을 가지고 있다.
        - stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다.
        - 람다식을 통해 재귀 함수를 구축하면 실행 조차 안되는 컴파일 에러가 나타난다.

- 제네릭   https://mangkyu.tistory.com/241
    - 제네릭이란?
        - 컴파일 타임에 타입을 체크함으로써 코드의 안전성을 높여주는 기능
        - List<T> 에서 T 가 타입 매개 변수
        - List<String> 에서 String 이 매개 변수화된 타입

        - 제네릭을 사용하는 이유
            1. 컴파일 타임에 강력한 타입 검사
            2. 캐스팅 (타입 변환) 제거

        - 배열 vs 제네릭 타입
            - 배열
                Object[] objectArray = new Integer[1]
                Integer 가 Object 의 하위 타입이면 Integer 배열도 Object 배열의 하위 타입이 성립함
                공변
            - 제네릭
                List<Object> objectList = new ArrayList<Integer>(); // Compile Error
                List<Object> 와 ArrayList<Integer> 는 서로 다른 타입 매개 변수이므로 컴파일 에러를 띄운다.
                무공변

        - 변성 (variance)
            - 무공변(Invariance) - <T>
                타입 B 가 타입 A 의 하위 타입일 때, Category<B> 가 Category<A> 의 하위 타입이 아닌 경우.
            - 공변(Covariance) - <? extends T>
                타입 B 가 타입 A 의 하위 타입일 때, Category<B> 가 Category<A> 의 하위 타입인 경우
            - 반공변(Contravariance) - <? super T>
                타입 B 가 타입 A 의 하위 타입일 때, Category<B> 가 Category<A 의 상위 타입인 경우

    - 제네릭 타입과 메서드
        - 제네릭 타입: 타입을 파라미터로 가지는 클래스와 인터페이스
        - 제네릭 메서드: 선언부에 제네릭 타입이 선언된 형식
        - 제한된 제네릭 타입
            ex) <T extends Noodle> : Noodle 과 Noodle 의 하위 타입만 가능

    - 와일드 카드
        1. <?> Unbounded Wildcards
            모든 타입 가능
        2. <? extends Noodle> Upper Bounded Wildcards
            Noodle 과 Noodle 의 하위 타입 (상한 경계) -> 공변
        3. <? super Noodle> Lower Bounded Wildcards
            Noodle 과 Noodle 의 상위 타입 (하한 경계) -> 반공변

        ex)
        class CategoryHelper {
            public void popNoodle(Category<? extends Noodle> category)  {
                Noodle noodle = category.get() // 꺼내는건 OK
                category.set(new Noodle()); // 저장은 NO -> 하위 타입에 상위 타입을 대입할 위험이 있기 때문에 컴파일 오류
            }

            public void pushNoodle(Category<? super Noodle> category)  {
                category.set(new Noodle()); // 저장은 NO
                Noodle noodle = category.get() // 꺼내는건 NO -> 하위 타입에 상위 타입을 대입할 위험이 있기 때문에 컴파일 오류
            }
        }

        - 제네릭 타입을 언제 써야 할까? -> PECS
            - producer - extends, consumer - super -> 생성을 하는 곳에서는 extends, 소비를 하는 곳에서는 super

    - 제네릭 타입 소거
        - 제네릭은 컴파일 타임에 타입을 검사하고 런타임에는 타입을 소거해서 해당 정보를 알 수 없다. -> Java 5
          기존의 코드들도 돌아갈 수 있도록 하기 위해 타입 소거 도입

        1. 타입 매개변수의 경계가 없는 경우에는 Object 로, 경계가 있는 경우에는 경계 타입으로 타입 파라미터를 변경
        2. 타입 안정성을 유지하기 위해, 필요한 경우 타입 변환 추가
        3. 제네릭 타입을 상속받은 클래스의 다형성을 유지하기 위해 Bridge method 생성

- 쓰레드 풀
    - 프로그램: 어떤 목적을 달성하기 위해서 컴퓨터의 동작을 하나로 모아 놓은 것
    - 프로세스: 컴퓨터가 현재 실행중인 프로그램

    - 단순히 스레드만 사용해서 동시에 여러 작업을 실행시킬 수 있는 프로그램을 만들 수 있을까?
        - 문제
            - 스레드 생성비용이 크기 때문에 요청에 대한 응답시간이 늘어난다.
                1. Java 는 One-to-One Threading-model 로 Thread 생성한다.
                2. User Thread(Process 의 스레드) 생성시 OS Thread(OS 레벨의 스레드) 와 연결해야 한다.
                    - User Thread 는 OS Thread 에 대한 User Program 계층에서의 추상화
                3. 새로운 Thread 를 생성할 때 마다 OS Kernel 의 작업이 필요하다.
                4. Thread 는 생성 비용이 많이 든다.
                5. 작업 요청이 들어올 때마다 Thread 를 생성하면 최종적인 요청 처리 시간이 증가한다.

            - Thread 가 너무 많으면 여러가지 문제를 발생시킨다.
                1. Process 의 처리 속도보다 빠르게 요청이 쏟아져 들어오면
                2. 새로운 Thread 가 무제한적으로 계속 생성된다.
                3. Thread 가 많아 질수록 메모리를 차지하고 Context-Switching 이 더 자주 발생한다.
                4. 메모리 문제가 발생할 수 있고, CPU 오버헤드가 증가한다.

    - 그래서 나온 게 Thread Pool
        - Thread 를 허용된 개수 안에서 사용하도록 제한하는 시스템
        - Thread, 작업 큐로 이루어짐.
            1. 스레드풀에 작업 처리 요청
            2. 작업 큐에 작업들이 쌓이게 됨.
            3. 각 스레드로 작업을 보내고, 스레드는 작업을 처리함.
            4. 결과 전달

        - 해결
            - 미리 만들어 놓은 스레드를 재사용할 수 있기 때문에 새로운 스레드를 생성하는 비용을 줄일 수 있다.
            - 사용할 스레드 개수를 제한하기 때문에 무제한적으로 스레드가 생성되는 것을 방지

        => 여러 개의 작업을 동시에 처리하면서도 안정적으로 처리하고 싶을 때 Thread Pool 은 효과적

    - Java 의 Thread Pool
        - ThreadPoolExecutor 클래스르 이용해 스레드풀을 구현

        - maximumPoolSize
        - corePoolSize
        - keepAliveTime
            -> 항상 maximumPoolSize 만큼 유지하고 있지는 않음. 요청이 적을 때는 많은 양의 스레드를 계속 가지고 있을 이유가 없다.
               만약 작업이 없는데 스레드 개수가 최대이고, keepAliveTime 이후로도 계속 작업 요청이 없다면 스레드는 없어짐.
               무한히 없어지는게 아니라 corePoolSize 만큼 없어짐.
               따라서 최대 maximumPoolSize, 최소 corePoolSize 만큼 스레드를 가진다.

    - Tomcat 의 Thread Pool
        - Tomcat
            - SpringBoot 의 내장 Servlet Container 중 하나
            - Java 기반의 WAS
            - Java 의 스레드풀 클래스와 매우 유사한 자체 스레드풀 구현체를 가지고 있다.

        - Java 의 스레드풀과 다른점
            - Max-Connections
                - 톰캣이 최대로 동시에 처리할 수 있는 Connection 의 개수
                - Web 요청이 들어오면 톰캣의 Connector 가 Connection 을 생성하면서 요청된 작업을 스레드풀의 스레드에 연결한다.
            - Accept-Count
                - Max-Connections 이상의 요청이 들어왔을 때 사용하는 대기열 큐의 사이즈
                - Max-Connections 와 Accept-Count 이상의 요청이 들어왔을 때 추가적으로 들어오는 요청은 거절될 수 있다.

    - 어떻게 하면 스레드풀을 잘 설정해서 Server Application 을 효과적으로 구현할 수 있을까?
        - SpringBoot 설정을 통한 Tomcat Thread Pool 설정
            - server.tomcat.threads.max
                - 스레드풀에서 사용할 최대 스레드 개수, 기본 값은 200
                - 서버 어플리케이션이 동시에 처리할 수 있는 요청 개수와 관련있다.
                - 요청에 비해 너무 많게 설정 -> 놀고 있는 스레드가 많아져서 비효율 발생
                - 너무 적게 설정 -> 동시 처리 요청 수가 줄어든다. 평균응답시간, TPS 감소
                -> 기본적으로 스레드가 많아지면 CPU 오버헤드와 메모리에서 문제가 생길 수 있다.

            - server.tomcat.threads.min-spare
                - 스레드풀에서 최소한으로 유지할 스레드 개수, 기본값은 10
                - 너무 많이 설정 -> 스레드풀이 항상 유지해야 할 스레드 수가 너무 많아진다.
                - 적절하게 설정 -> 적은 수의 요청에서 새로운 스레드를 만들 필요없이 요청을 효과적을 처리할 수 있다.
                -> 잘못 설정했을 때 사용하지 않는 스레드가 메모리를 차지하면서 비효율을 발생시킨다.

            - server.tomcat.max-connections
                - 동시에 처리할 수 있는 최대 Connection 의 개수, 기본 값은 8192
                - 사실상 서버의 실질적인 동시 요청 처리 개수
                    - 톰캣의 커넥터 컴포넌트의 방식에 따라서 개수 설정
                        - Blocking IO: 1 Connection 1 Thread
                        - Non-Blocking IO: N Connection 1 Thread
                    - tomcat 8 버전 이후부터는 Non-Blocking IO 방식 사용
                - Non-Blocking IO 에서는 스레드풀을 최대 스레드 개수보다 많은 양의 Connection 을 유지할 수 있다.
                - Non-Blocking IO 에서는 최대 스레드 개수보다 적거나 같은 수의 max-connections 를 설정하는 것은 비효율적인
                  설정이 될 수 있다.

            - server.tomcat.accept-count
                - max-connections 이상의 요청이 들어왔을 때 사용하는 요청 대기열 큐의 사이즈, 기본 값은 100
                - 너무 크게 설정 -> 대기열이 커지면서 메모리 문제 유발
                - 너무 작게 설정 -> 요청이 몰렸을 때 들어오는 요청들을 거절해 버릴 수 있다.
                -> 이 설정을 하는 이유 중 하나는 부적절하거나 잘못된 요청이 한번에 너무 많이 들어와
                   서버에 장애를 발생시키는 것을 방지하기 위함도 있다.

    => 스레드풀을 설정해야 하는 이유
        - 스레드풀은 응답시간과 TPS 에 영향을 주는 하나의 요소이다.
        - 잘 조정된 스레드풀은 시스템의 성능을 끌어내고 안정적인 어플리케이션 운용을 가능하게 한다.
        - 부적절하게 설정된 스레드풀은 병목 현상, CPU 오버헤드, 메모리 문제를 유발할 수 있다.


- 함수형 프로그래밍
    - 값을 가지고 수학적 함수를 적용해 계산을 진행하는 패러다임의 한 종류
    - 특징
        1. 불변
            - 그 대상이 변경되지 않는 걸 의미
              ex) Optional
        2. 선언적
            - 선언적이라는 건 '무엇' 을 의미
              ex) stream

    - 함수형 언어 조건
        - 함수가 1급 객체
            - 함수 리터럴이 존재 (1급 객체이려면 해야 한다.)
              ex) 람다식
            - 함수를 인수로 제공하고 반환할 수 있어야 함
              ex) 함수형 인터페이스
            - 함수를 런타임시점에 생성 가능해야 함
                - 프로그램이 실행하는 과정 중에 함수가 생성될 수 있다는 의미
                  ex) 함수 합성

    - 값은 함수와 대상을 포함하는 개념
    - 수학적 함수는 순수 함수
    - 계산을 진행한다는 건 함수들의 조합과 합성을 통해 프로그램을 만들 수 있다는 의미

- OOP
    - 객체지향 프로그래밍 이란?
        - 프로그래밍 방법론
        - 사람이 현실을 바라보는 방법을 개발을 접목
            - 직관적으로 이해하기 쉽다.
            - 유지보수를 용이하게 만든다.

    - 키워드로 알아보는 객체지향
        - 객체
            - 객체는 현실의 무언가에 추상적으로 표현한 것
            - 클래스는 객체를 표현하는 하나의 수단
        - 협력과 책임, 역할
            - 다른 객체와 협력하는 역할을 맡고 있는 대상
            - 역할을 맡으면 임무를 수행할 책임이 생긴다.
            - 책임을 다하기 위한 데이터와 프로세스를 가지고 있다.
            - 협력: 시스템 목표를 달성하기 위해 여러 객체가 참여하여 행동하는 것
                   ex) 치킨을 튀겨서 손님에게 배달해야 한다.
            - 책임: 협력 속에서 본인이 수행해야 할 임무의 내용을 알고, 수행하는 것
                   ex) 치킨을 튀길 객체는 치킨을 맛있게 조리할 책임을 갖는다
            - 역할: 동일한 목적을 가진 책임의 묶음
                   ex) 치킨은 조리할 책임을 가지는 역할은 요리사이다
        - 메시지
            - 객체는 메시지를 통해 다른 객체에 책임을 다하라고 요구한다.
            - 메시지를 보내는 객체는 무엇을 할지만 요구하고, 어떻게 하는지는 신경쓰지 않아도 된다.
            - 객체는 책임을 수행하라고 요구받지만, 어떻게 처리할지는 자율에 맡긴다.
            - 책임을 수행하는 방법은 메시지를 보내는 것(메서드 통해서)
        - 자율성 (의인화)
            - 객체 지향과 현실 세계의 차이점
                - 현실 세계의 치킨 가게는 건물에 불과
                - 객체지향 세계의 치킨 가게는 스스로 치킨을 튀기고, 치킨을 건네어 준다.
            - 즉, 객체지향에선 객체가 자율적으로, 능동적으로 행동할 수 있다고 의인화해야 한다.
            - 자율적으로 메시지를 처리하기 위해서 자신의 책임을 수행하는데 필요한 데이터와 프로세스를 가지고 있다.
        - 다형성
            - 다형성을 활용하는 목적은 서로 다른 유형의 객체가 동일한 메시지에 대해 다르게 반응하기 위해서이다.
            - 동일한 메시지를 처리한다 == 같은 역할을 수행한다.
            - 다르게 반응한다 == 메시지 처리 방법은 자율적이다.

    - 정리
        - 객체는 현실의 개념을 추상화한 것이다.
        - 객체들은 서로 협력하고, 역할을 맡아 책임을 수행하여 문제 상황을 해결한다.
        - 하지만 현실의 사물과 달리 객체는 능동적이고 자율적인 존재이다.

    - 빠지기 쉬운 함정
        - 현실 세계를 반영하기 위한 설계를 시작하면 자칫 데이터 중심의 설계를 하기 쉽다.
        - 데이터 중심의 설계의 문제점
            1. getter, setter 가 과도하게 추가되어 결합도가 높아진다. (서로 알고 있는 객체가 많아진다.)
            2. 데이터를 처리하는 작업과 데이터가 분리되어 응집도가 낮아진다.
        - 책임 주도 개발
            1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임(협력)을 파악한다.
                ex) 치킨 주문을 받아 손님에게 배달해야 한다.
            2. 시스템 책임을 더 작은 책임으로 분할
                ex) 메시지 생성 (치킨 주문을 받는다 / 치킨을 요리한다 / 치킨을 손님에게 배달한다)
            3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
            4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
            5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

    -> grasp 패턴


- 싱글턴과 정적 클래스
    - 싱글턴
        - 싱글턴의 개념
            - 클래스의 인스턴스를 하나만 생성하고, 어디서든 그 인스턴스를 참조할 수 있도록 하는 패턴
            - 생성자가 여러 번 호출되더라도 실제로 생성되는 객체는 하나
        - 싱글턴을 쓰는 이유
            - 고정된 메모리 영역을 가지고 하나의 인스턴스만 사용하기 때문에 메모리 낭비 방지
            - 싱글턴 클래스의 인스턴스는 전역이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움
            - DBCP 처럼 공통괸 객체를 여러 개 생성해야 하는 상황에 많이 사용
        - 싱글턴 구현
            1. Eager initialization
                - static 을 로딩하면서 바로 메모리를 가진다. 래서 클라이언트에서 사용하지 않더라도 인스턴스가 항상 생성됨.
                - 예외 처리를 할 수 있는 방법이 없음
            2. Static block initialization
                - Eager initialization 과 유사
                - 인스턴스가 static block 내에서 생성됨
                - 예외 처리 가능
            3. Lazy initialization
                - getInstance() 호출 이외에는 인스턴스를 생성하지 않음
                - Eager initialization 의 단점 보완
                - 스레드 세이프 하지 않음
            4. Thread safe initialization
                - Synchronized 를 이용해서 하나의 스레드만 접근 가능하도록 설정
                - 성능 저하를 야기하는 비효율적인 방법
            5. Double-Checked Locking
                - null 체크를 Synchronized 블록 밖에서 한 번, 안에서 한 번 총 두 번 실행
                - 밖에서 하는 체크는 인스턴스가 있는 경우 빠르게 리턴하기 위해서,
                  안쪽에서 하는 체크는 인스턴스가 생성되지 않은 경우 하나의 인스턴스만 생성하기 위해서
            6. Bill Pugh Solution
                - Double-Checked 에 비해 구현이 간단
                - Lazy Loading 이 가능
                - Thread safe

    - 정적 클래스
        - 정적 클래스의 개념
            - 모든 메서드가 static 인 클래스 지칭, 또는 inner static class 를 뜻하기도 함
        - 정적 클래스 쓰는 이유
            - 상태를 가지고 있지 않고 global access 를 제공할 때 유용
            - static 은 컴파일 때 static binding 으로 싱글턴보다 좀 더 빠르다
            - 클래스 자체에 static 을 붙여 사용할 수 없다. (inner class 일 때만 가능)
        - 정적 클래스의 구현
            - static variable
                - 메모리에 고정적으로 할당되어, 프로그램이 종료될 때 해제되는 변수
            - static method
                - 객체 생성 없이 메소드 바로 호출 가능
                - 객체 생성 없이 접근하는 메서드이므로, static 이 아는 변수는 사용 불가능
            - static class
                - static nested class 라고 한다.
                - 외부클래스의 자원 중 static 이 붙은 것만 사용 가능
                - inner 클래스에 static 을 붙이지 않으면 inner 클래스에서 outer 클래스에 있는 필드 등에 참조할 수 있고
                  inner 클래스의 역할이 끝나도 gc 가 지우지 못해 메모리 낭비가 생긴다.

    - 싱글턴 vs 정적 클래스
        - 싱글턴
            - 하나의 인스턴스를 생성하여 재사용
            - 인터페이스 구현 가능
            - override 가능 (상속)
            - 필요에 따라 lazy 가능
            - OOP
        - 정적 클래스
            - 인스턴스 생성 x
            - 인터페이스 구현 불가능
            - override 불가능
            - static binding 으로 빠르게 로딩
            - OOP x

- Java final 과 불변 객체
    - 자바 final
        - 한 번만 할당 가능하다는 선언
        - 재할당하려고 하면 컴파일 오류가 발생
        - 버그 발생 가능성이 줄어들고, 버그를 찾는 시점이 빨라져 서비스 안정성이 높아짐
    - 불변 객체란
        - 한 번 생성되면 상태를 수정할 수 없는 객체 -> 생성이 된 불변 객체는 신뢰할 수 있다.
    - 불변 객체를 사용해야 하는 이유
        - 스레드 동기화 문제 방지

- 자바 직렬화
    - 자바 직렬화의 흐름
        - 직렬화
            - 객체의 상태를 영속화하는 메커니즘
            - 객체를 다른 환경에 저장했다가 나중에 재구성 할 수 있게 만드는 과정
            - 객체의 상태를 영속해야 할 필요가 있을 때 사용
            - 다른 VM 에게 객체의 정보를 바이트 스트림으로 변환해서 전송해야 할 때 사용
        - 직렬화/역직렬화 흐름
            - 객체는 writeObject 를 거쳐 직렬화 되어 어딘가(DB, File, Memory)에 보관되었다가 readObject 에 의해 역직렬화 되면서
              객체로 재생성
    - 자바 직렬화의 위험성
        - 보안
            - 보이지 않는 생성자, readObject
            -> 해결: 커스텀 직렬화
                    직렬화 대상 클래스에 readObject 메서드를 새롭게 정의해주면 된다.
        - 유지보수성
        - 테스트
        - 그 외 다수 (싱글톤 문제, 역직렬화 폭탄 등)
            - 싱글톤 문제
                - 싱글톤 객체를 직렬화 했다가 역직렬화하여 사용하면 싱글톤의 성격을 잃어버린다.
                -> 해결: readResolve 를 정의해주면 된다.
                        readObject 가 불린 이후에 readResolve 가 불리게 되면서 역직렬화하여 생성한 객체는 사용하지 않고
                        readResolve 에서 반환하는 객체를 사용.
                        만약 클래스의 인스턴스 변수가 존재하는 경우 전부 transient 예약어를 이용해서 직렬화-역직렬화 대상이 되지 않도록
                        해주어야 한다. 그렇지 않으면 참조필드의 영역값을 훔쳐오는 행위가 가능해짐.

- java version
    - java version
        - java 8
            - 큰 변화가 생김. 빅데이터가 떠오르면서 병렬 처리에 대한 관심이 높아짐에 따라 병렬 환경을 쉽게 관리할 수 있는 방향으로 가고자
              Stream API 가 추가됨.
        - java 9
            - 버전이 올라가면서 JDK 의 규모가 커지게 되고 일부 패키지만 필요로 하는 작은 환경에서 사용하지 않는 패키지들도 런타임에
              실행되어야 했다. 개발자가 라이브러리와 대규모 응용 프로그램을 쉽게 구성하고 관리할 수 있도록 모듈화 지원
    - java 9
        - Modules
            - 패키지가 클래스들의 묶음이라면 모듈은 패키지의 묶음
            - 기존 패키지 방식은 여러 패키지에서 공용으로 사용되는 클래스를 외부에 숨길 수 없었다. 이렇게 되면 라이브러리 내부 뿐만 아니라
              외부에서도 클래스 접근이 가능하게 된다. 그리고 런타임 시 사용하지 않는 클래스들도 모두 포함해야 했다.
            - 모듈화를 통해 패키지를 캡슐화하고 위 문제들을 해결
        - private methods in interfaces
            - private 메서드를 사용해서 메서드를 분리할 수 있고 중복되는 코드 재사용 가능
            - private static 도 사용 가능하게 됨
        - 불변 컬렉션 생성
            - List.of(), Set.of(), Map.of()
        - Compact String
            - 자바는 내부적으로 UTF-16 을 사용하기 때문에 모든 문자가 2byte 로 구성되고 1byte 로 표현될 수 있는 영어도 빈 공간을
              사용해야 했다.
            - java 6 버전에서 VM 옵션을 활성화해서 문자열을 char 배열 대신에 byte 배열로 저장할 수 있었다.
              하지만 성능 문제로 7 버전에서 삭제되고 9 버전에 Compact String 으로 돌아옴.
            - 자바 9 버전 이상의 String 클래스를 보면 인스턴스 변수가 byte 배열로 되어 있어 1byte 로도 저장이 가능해짐
        - try-with-resource 향상
            - 자원을 try 문 밖에서 할당하게 된다면 그 변수를 try 문 안에서 바로 사용할 수가 없었다.
              자바 9 버전에서는 밖에서 할당한 변수도 try 문 안에서 바로 사용 가능
        - Optional API 추가
    - java 10
        - Local variable type interface (로컬 변수 타입 추론)
            - 하위호환성을 중요시 하는 java 는 기존의 변수명을 var 로 사용했을 것을 염두하여 키워드로 만들지 않음
              따라서 var 를 변수나 메서드명으로 사용 가능
            - var 는 인스턴스 변수로 사용이 불가능하고 반드시 초기화해야 함
            - var 형식의 지역 변수에 익명 클래스를 할당하면 부모가 아닌 익명 클래스 형식을 유추
        - Optional.orElseThrow()
            - 인자 없이 사용 가능해짐.
            - 인자 없이 사용해서 객체가 비어 있을 경우에는 NoSuchElementException 발생
        - Unmodifiable Collections
            - copyOf() -> List.copyOf(), Set.copyOf(), Map.copyOf()
            - toUnmodifiable -> toUnmodifiableList(), toUnmodifiableMap, toUnmodifiableSet()
    - java 11
        - Local-Variable Syntax for Lambda
            - var 를 람다 표현식의 매개변수로 사용할 수 있게 확장됨
            - var 를 매개변수로 사용하게 된다면 @NotNull 같은 어노테이션을 사용할 수 있게 된다.
        - String API Additions
            - repeat(int): 문자열 반복
            - lines(): 라인 단위로 분할하여 스트림으로 반환
            - strip(): 문자열 앞 뒤 공백 제거
            - stripLeading(): 문자열 앞 공백 제거
            - stripTrailing(): 문자열 뒤 공백 제거
            - isBlank(): 문자열이 비어 있거나 공백만 있는 경우 true 반환
            * trim() 과 차이점은 유니코드의 공백 문자를 인식
        - New File Methods
            - writeString()
            - readString()
            - toArray


