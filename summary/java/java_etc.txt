- Serializable 은 무엇일까요?  https://www.slideshare.net/sunnykwak90/java-serialization-46382579
    - 직렬화 기술 이해
        - 직렬화란 무엇인가?
            - 직렬화는 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷
              (예를 들면 파일 또는 메모리 버퍼, 네트워크 연결 링크를 통해 전송될 수 있는 형태) 으로 변환.
        - 직렬화는 왜 중요한가?
            - 거의 모든 소프트웨어는 네트워크를 통해 데이터를 주고 받으며, 프로그램을 구현하는데 필요한 기반 기술 중에서 빼놓을 수 없게 됨.
            - 직렬화는 네트워크 의존성이 높은 소프트웨어일 경우, 전체 성능을 좌우할 수도 있는 중요한 기술이다.
        - 직렬화 적용 분야
            - 파일 저장소 (File storage)
                - 프로그램 실행 중에 생성된 데이터를 영구 저장소(파일 시스템) 등에 저장한 후, 이후에 프로그램이 다시 실행되었을 때 저장된
                  데이터를 메모리 상에 객체 형태로 복구해 사용한다.
            - 네트워크 통신
                - 네트워크 상에 떨어져 있는 프로그램 간에 데이터를 주고 받기 위해 데이터를 직렬화한 후, 패킷에 담아 전송
            - 데이터베이스
                - 복잡한 형태의 객체를 데이터베이스에 저장할 때 직렬화된 문자열 형태로 테이블의 칼럼에 저장하기도 한다.
            - 웹 환경
                - 웹 서버에서 브라우저(클라이언트)로 구조화된 데이터를 전송할 때 직렬화한 후 JSON 형식 등 전달하는 방식이 점차 많이 사용됨
        - 직렬화 기법 선택 시 고려할 점
            - 단순성(simple)
                - 사용하기가 복잡하지 않아야 한다.
            - 경량(compact)
                - 프레임워크(혹은 라이브러리)의 규모가 작아야 한다.
            - 유연성(flexible)
                - 다양한 데이터 타입을 직렬화할 수 있어야 한다.
            - 버전지원(versioning)
                - 객체의 데이터 구조는 설계 및 개발, 나아가 유지보수 단계에서 변화될 수 있다.
            - 속도(fast)
                - 처리 속도가 빠르면 빠를수록 좋다.
            - 확장성(scalable)
                - 복잡하거나, 거대한 형태의 데이터를 직렬화할 수 있어야 한다.
        - 직렬화 데이터 형식
            - Binary
                - 메모리에 저장된 데이터를 최소한의 가공 혹은 가공 없이 바이트의 연속된 형태로 저장하는 방식
            - JSON(JavaScript Object Notation)
                - 텍스트 형식이므로 사람과 기계 모두 읽기 가능하다. 다양한 프로그래밍 언어에서 읽고 쓸 수 있기 때문에 널리 사용됨
            - XML(Extensible Markup Language)
                - 텍스트 형식이며, JSON 에 비해 복잡하다. JSON 에 대해 가지는 장점은 스키마를 적용할 수 있고 무결성 검사가 가능하다.
            - YAML(YAML Ain't Markup Language)
                - XML 에 비해 사람이 읽고 쓰기 쉽도록 고안된 마크업 언어이다. 문법이 상대적으로 단순하고, 가독성이 높게 설계되어 있다.
        - 왜 성능이 중요한가?
            - CPU 비용
                - 메모리에 존재하는 바이너리 형태의 객체를 디스크 등에 저장할 수 있는 형태(텍스트 등)로 저장하기 위해서는 변환 처리 과정이
                  필요하며, 반대의 처리 또한 필요하다.
            - 메모리 비용
                - 변환 작업을 수행하는 과정에서 임시 버퍼(temporary buffer)를 할당하고, 네트워크를 통한 송수신 과정에서 스트림 처리 등에
                  따른 공간 할당이 필요하다.
            - 네트워크 비용
                - 직렬화를 수행하는 대다수의 프로그램 혹은 시스템은 네트워크를 통해 데이터를 주고 받게 된다. 네트워크 송수신에 있어서 패킷의
                  크기가 커질수록 전체 성능은 떨어진다.

    - 직렬화 프레임워크
        - JDK 의 Serializable 인터페이스
            - 프로그래밍하기 가장 쉽고, Serializable 인터페이스를 이용해 별도의 라이브러리 없이 즉시 사용할 수 있다.
            - 클래스를 릴리즈한 후에는 구현을 변경하기 어려워 유연성을 감소시킨다.
            - C++, 파이썬 등 다른 언어로 구현된 프로그램과 데이터를 교환할 수 없다.
            - 기본 연산자의 취약점으로 인해 불변 값이 손상되거나, 비정상적인 접근이 발생할 수 있다. (invariant corruption and illegal access)
            - 커스터마이징이 불가능하고, 소스 코드를 수정할 수 있어야 한다.
        - Java externalization (직렬화 코드를 직접 구현)
            - 객체를 저장 및 복구하는 Externalization 인터페이스를 구현해 직접 직렬화를 구현한다.
            - 인스턴스의 컨텐츠를 저장하고 복구하는 역할을 수행하는 클래스를 구현해야 한다.
            - 클래스의 구조가 변경될 때 마다, 읽고 쓰는 코드를 수정해야 한다.
        - Google GSON
            - 자바 객체를 JSON 으로 변환하거나 반대의 작업을 수행하는 자바 라이브러리.
            - 직렬화된 객체의 소스 코드를 필요로 하지 않는다.
            - 커스텀 표현을 지원한다.
        - Jackson JSON
            - 고성능, 인공공학적 JSON 프로세서 자바 라이브러리
            - 광범위한 커스터마이징 툴 지원
            - 혼합 어노테이션
            - 실체화된 인터페이스
            - 다양한 데이터 포맷 : JSON, CSV, Smile(binary JSON), XML, YAML
        - BSON for Jackson
            - 바이너리 인코딩된 JSON
            - 몽고 DB 의 주된 데이터 교환 포맷
            - 확장 프로그램 작성 가능
        - Protocol Buffers
            - 구조적인 데이터를 확장 가능하며 효율적인 포맷을 변환하는 방법 제공
            - 구글 내부에서 대부분의 내부 RPC 프로토콜과 파일 포멧에 Protocol Buffers 를 사용 중.
            - Java, C++, Python 지원
        - Kryo
            - 빠르고 효율적인 객체 그래프 직렬화 자바 프레임워크
            - 구글 코드 상의 오픈 소스 프로젝트
            - 자동화된 깊고 얕은 복사/복제
            - 소스 클래스에 대한 코드 작성 요건이 거의 없음


- 컬렉션 방어적 복사
    - 방어적 복사! 를 하려면 copyOf를 해야 합니다.
    - 복사본 컬렉션에 대한 요소 추가 / 삭제 시도 시 UOE가 발생한다는 점은 unmodifiableList와 동일합니다.
      그러나 원본 컬렉션에서 요소 추가 / 삭제 가 일어나도, 영향을 받지 않습니다
    - 그럼에도 불구하고 copyOf()로 만들어낸 컬렉션이 완전한 불변이라고 볼 수는 없습니다.
      왜냐하면 copyOf의 반환값으로 전달된 unmodifiable list에서 객체를 꺼내서,
      그 객체 내부의 값을 변경할 경우, 아니면 외부에서 그 객체의 값을 변경할 경우에는
      요소 까지 깊은 복사를 하지는 않았기 때문에 값이 변경되기 때문입니다.
    - 컬렉션의 요소가 되는 값 객체들이 불변을 보장한다면, copyOf와 만나서 완전 불변이 가능

    - 따라서 기본 제공되는 API 를 사용하여 컬렉션을 복사한 경우, 외부로부터의 변경에 취약하지 않은 컬렉션을 만들기 위해서는 내부 요소가 불변 객체여야 함을 알 수 있다.


- 접근제어자를 사용하는 이유
    - 객체를 사용하는 입장에서 객체 내부적으로 사용하는 변수나 메소드에 접근함으로써 개발자가 의도하지 못한 오동작을 일으키기도 합니다.
      이러한 문제로부터 객체의 로직을 보호하기 위해서는 멤버에 따라서 외부의 접근을 허용하거나 차단해야 할 필요
    - 사용자에게 객체를 조작할 수 있는 수단만을 제공함으로써 결과적으로 객체의 사용에 집중할 수 있도록 돕기 위함
    -> 의도치 않은 실수를 줄이기 위함과 정보 은닉의 목적