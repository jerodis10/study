- Serializable 은 무엇일까요?  https://www.slideshare.net/sunnykwak90/java-serialization-46382579
    - 직렬화 기술 이해
        - 직렬화란 무엇인가?
            - 직렬화는 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷
              (예를 들면 파일 또는 메모리 버퍼, 네트워크 연결 링크를 통해 전송될 수 있는 형태) 으로 변환.
        - 직렬화는 왜 중요한가?
            - 거의 모든 소프트웨어는 네트워크를 통해 데이터를 주고 받으며, 프로그램을 구현하는데 필요한 기반 기술 중에서 빼놓을 수 없게 됨.
            - 직렬화는 네트워크 의존성이 높은 소프트웨어일 경우, 전체 성능을 좌우할 수도 있는 중요한 기술이다.
        - 직렬화 적용 분야
            - 파일 저장소 (File storage)
                - 프로그램 실행 중에 생성된 데이터를 영구 저장소(파일 시스템) 등에 저장한 후, 이후에 프로그램이 다시 실행되었을 때 저장된
                  데이터를 메모리 상에 객체 형태로 복구해 사용한다.
            - 네트워크 통신
                - 네트워크 상에 떨어져 있는 프로그램 간에 데이터를 주고 받기 위해 데이터를 직렬화한 후, 패킷에 담아 전송
            - 데이터베이스
                - 복잡한 형태의 객체를 데이터베이스에 저장할 때 직렬화된 문자열 형태로 테이블의 칼럼에 저장하기도 한다.
            - 웹 환경
                - 웹 서버에서 브라우저(클라이언트)로 구조화된 데이터를 전송할 때 직렬화한 후 JSON 형식 등 전달하는 방식이 점차 많이 사용됨
        - 직렬화 기법 선택 시 고려할 점
            - 단순성(simple)
                - 사용하기가 복잡하지 않아야 한다.
            - 경량(compact)
                - 프레임워크(혹은 라이브러리)의 규모가 작아야 한다.
            - 유연성(flexible)
                - 다양한 데이터 타입을 직렬화할 수 있어야 한다.
            - 버전지원(versioning)
                - 객체의 데이터 구조는 설계 및 개발, 나아가 유지보수 단계에서 변화될 수 있다.
            - 속도(fast)
                - 처리 속도가 빠르면 빠를수록 좋다.
            - 확장성(scalable)
                - 복잡하거나, 거대한 형태의 데이터를 직렬화할 수 있어야 한다.
        - 직렬화 데이터 형식
            - Binary
                - 메모리에 저장된 데이터를 최소한의 가공 혹은 가공 없이 바이트의 연속된 형태로 저장하는 방식
            - JSON(JavaScript Object Notation)
                - 텍스트 형식이므로 사람과 기계 모두 읽기 가능하다. 다양한 프로그래밍 언어에서 읽고 쓸 수 있기 때문에 널리 사용됨
            - XML(Extensible Markup Language)
                - 텍스트 형식이며, JSON 에 비해 복잡하다. JSON 에 대해 가지는 장점은 스키마를 적용할 수 있고 무결성 검사가 가능하다.
            - YAML(YAML Ain't Markup Language)
                - XML 에 비해 사람이 읽고 쓰기 쉽도록 고안된 마크업 언어이다. 문법이 상대적으로 단순하고, 가독성이 높게 설계되어 있다.
        - 왜 성능이 중요한가?
            - CPU 비용
                - 메모리에 존재하는 바이너리 형태의 객체를 디스크 등에 저장할 수 있는 형태(텍스트 등)로 저장하기 위해서는 변환 처리 과정이
                  필요하며, 반대의 처리 또한 필요하다.
            - 메모리 비용
                - 변환 작업을 수행하는 과정에서 임시 버퍼(temporary buffer)를 할당하고, 네트워크를 통한 송수신 과정에서 스트림 처리 등에
                  따른 공간 할당이 필요하다.
            - 네트워크 비용
                - 직렬화를 수행하는 대다수의 프로그램 혹은 시스템은 네트워크를 통해 데이터를 주고 받게 된다. 네트워크 송수신에 있어서 패킷의
                  크기가 커질수록 전체 성능은 떨어진다.

    - 직렬화 프레임워크
        - JDK 의 Serializable 인터페이스
            - 프로그래밍하기 가장 쉽고, Serializable 인터페이스를 이용해 별도의 라이브러리 없이 즉시 사용할 수 있다.
            - 클래스를 릴리즈한 후에는 구현을 변경하기 어려워 유연성을 감소시킨다.
            - C++, 파이썬 등 다른 언어로 구현된 프로그램과 데이터를 교환할 수 없다.
            - 기본 연산자의 취약점으로 인해 불변 값이 손상되거나, 비정상적인 접근이 발생할 수 있다. (invariant corruption and illegal access)
            - 커스터마이징이 불가능하고, 소스 코드를 수정할 수 있어야 한다.
        - Java externalization (직렬화 코드를 직접 구현)
            - 객체를 저장 및 복구하는 Externalization 인터페이스를 구현해 직접 직렬화를 구현한다.
            - 인스턴스의 컨텐츠를 저장하고 복구하는 역할을 수행하는 클래스를 구현해야 한다.
            - 클래스의 구조가 변경될 때 마다, 읽고 쓰는 코드를 수정해야 한다.
        - Google GSON
            - 자바 객체를 JSON 으로 변환하거나 반대의 작업을 수행하는 자바 라이브러리.
            - 직렬화된 객체의 소스 코드를 필요로 하지 않는다.
            - 커스텀 표현을 지원한다.
        - Jackson JSON
            - 고성능, 인공공학적 JSON 프로세서 자바 라이브러리
            - 광범위한 커스터마이징 툴 지원
            - 혼합 어노테이션
            - 실체화된 인터페이스
            - 다양한 데이터 포맷 : JSON, CSV, Smile(binary JSON), XML, YAML
        - BSON for Jackson
            - 바이너리 인코딩된 JSON
            - 몽고 DB 의 주된 데이터 교환 포맷
            - 확장 프로그램 작성 가능
        - Protocol Buffers
            - 구조적인 데이터를 확장 가능하며 효율적인 포맷을 변환하는 방법 제공
            - 구글 내부에서 대부분의 내부 RPC 프로토콜과 파일 포멧에 Protocol Buffers 를 사용 중.
            - Java, C++, Python 지원
        - Kryo
            - 빠르고 효율적인 객체 그래프 직렬화 자바 프레임워크
            - 구글 코드 상의 오픈 소스 프로젝트
            - 자동화된 깊고 얕은 복사/복제
            - 소스 클래스에 대한 코드 작성 요건이 거의 없음


- 컬렉션 방어적 복사
    - 방어적 복사! 를 하려면 copyOf를 해야 합니다.
    - 복사본 컬렉션에 대한 요소 추가 / 삭제 시도 시 UOE가 발생한다는 점은 unmodifiableList와 동일합니다.
      그러나 원본 컬렉션에서 요소 추가 / 삭제 가 일어나도, 영향을 받지 않습니다
    - 그럼에도 불구하고 copyOf()로 만들어낸 컬렉션이 완전한 불변이라고 볼 수는 없습니다.
      왜냐하면 copyOf의 반환값으로 전달된 unmodifiable list에서 객체를 꺼내서,
      그 객체 내부의 값을 변경할 경우, 아니면 외부에서 그 객체의 값을 변경할 경우에는
      요소 까지 깊은 복사를 하지는 않았기 때문에 값이 변경되기 때문입니다.
    - 컬렉션의 요소가 되는 값 객체들이 불변을 보장한다면, copyOf와 만나서 완전 불변이 가능

    - 따라서 기본 제공되는 API 를 사용하여 컬렉션을 복사한 경우, 외부로부터의 변경에 취약하지 않은 컬렉션을 만들기 위해서는 내부 요소가 불변 객체여야 함을 알 수 있다.


- 접근제어자를 사용하는 이유
    - 객체를 사용하는 입장에서 객체 내부적으로 사용하는 변수나 메소드에 접근함으로써 개발자가 의도하지 못한 오동작을 일으키기도 합니다.
      이러한 문제로부터 객체의 로직을 보호하기 위해서는 멤버에 따라서 외부의 접근을 허용하거나 차단해야 할 필요
    - 사용자에게 객체를 조작할 수 있는 수단만을 제공함으로써 결과적으로 객체의 사용에 집중할 수 있도록 돕기 위함
    -> 의도치 않은 실수를 줄이기 위함과 정보 은닉의 목적


- 다형성(polymorphism)
    서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
    부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다형성이다.
    이처럼 다형성을 사용하면, 구체적으로 현재 어떤 클래스 객체가 참조되는 지는 무관하게 프로그래밍하는 것이 가능하다.
    상속 관계에 있으면, 새로운 자식 클래스가 추가되어도 부모 클래스의 함수를 참조해오면 되기 때문에 다른 클래스는 영향을 받지 않게 된다.

    같은 모양의 코드가 다른 행위를 하는 것을 나타낸다. 자바에선 대표적으로 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상메소드, 추상클래스 방법이 모두 다형성
    하나의 객체가 여러가지 타입을 가질 수 있는 것.

    - Overriding 오버라이딩
        오버라이딩은 Method 재정의라고 할 수 있다. 슈퍼 클래스의 메서드 이름, 매개 변수, 같은 반환 값이지만 내부 로직을 새롭게 재정의하는 개념이다.
    - Overloading 오버로딩
        오버로딩은 같은 이름의 Method 이지만 매개 변수의 개수, 리턴 타입과 같은 부분이 다름으로 여러 개의 같은 이름 메서드를 정의하는 것을 말한다.


- static 이란?
        정적(static)은 고정된이란 의미를 가지고 있습니다. Static 이라는 키워드를 사용하여 Static 변수와 Static 메소드를 만들 수 있는데
        다른말로 정적필드와 정적 메소드라고도 하며 이 둘을 합쳐 정적 멤버라고 합니다. (클래스 멤버라고도 합니다.)
        정적 필드와 정적 메소드는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버입니다. 그렇기에 클래스 로더가 클래스를 로딩해서
        메소드 메모리 영역에 적재할때 클래스별로 관리됩니다. 따라서 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있습니다.

    - 정적(Static) 멤버 생성
        - Static
            - 주로 클래스들이 할당
            - GC 관여 x
            - 모든 객체가 메모리를 공유
        - Heap
            - 주로 객체들이 할당
            - GC 관여
            - 메모리를 공유하지 않음

        - Static 키워드를 통해 생성된 정적멤버들은 Heap 영역이 아닌 Static 영역에 할당됩니다. Static 영역에 할당된 메모리는
          모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점을 가지지만 Garbage Collector 의 관리 영역 밖에 존재하기에
          Static 영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재하게 됩니다.
          그렇기에 Static 을 너무 남발하게 되면 만들고자 하는 시스템 성능에 악영향을 줄 수 있습니다.

    - 정적(Static) 멤버 선언
        - 필드나 메소드를 생성 시 인스턴스로 생성할것인지 정적으로 생성할것인지에 대한 판단 기준은 공용으로 사용하느냐 아니냐로 내리면 됩니다.
          그냥 생성한다면 자동으로 인스턴스로 생성되며 정적으로 생성하려면 필드와 메소드 선언 시 static 이라는 키워들를 추가적으로 붙이면 됩니다.

        - 정적 메소드는 클래스가 메모리에 올라갈 때 정적 메소드가 자동적으로 생성됩니다. 그렇기에 정적 메소드는 인스턴스를 생성하지 않아도 호출을 할 수 있습니다.
          정적 메소드는 유틸리티 함수를 만드는데 유용하게 사용됩니다.


- Call by Reference와 Call by Value의 차이   https://steady-coding.tistory.com/613   https://deveric.tistory.com/92
    - 자바의 메소드(함수) 호출 방식
        - Call by value는 메서드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값(value)을 복사하여 보낸다.
        - Call by reference는 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 참조값, 혹은 주소, 포인터(Address)를 복사하여 보낸다.
           즉 매개변수를 변경할 경우 원본도 같이 변경되는 Call by reference

        - 자바는 기본형 타입 변수와 참조형 타입 변수가 있는데 둘 다 call by value 방식으로 메소드에서 받아진다
          대신 기본형 타입은 그 값을 복사 해서 주지만 참조형 타입은 값의 래퍼런스(주소)가 저장되는 것이므로 그 값의 래퍼런스가 복사 되어진다
        - 참조가 아닌 각각의 필드 값을 Getter/Setter를 이용해서 바꾸면 예외적으로 이런 경우에는 두개의 값이 변경됩니다.
          이런 예외적인 부분 때문에 참조형이 Call by Reference라는 오해를 받게 된다고 생각한다.
          왜 이런 부분이 가능할까요? 자바가 함수의 인자로 전달해주는 것은 어떤 것을 참조 하고 있는지에 대한 (복사된) 참조 값을 전달하기 때문이다.
          (접근제어자로 막혀있지 않은 한) 자바에서 객체를 컨트롤 하는 행위는 어떤 장소이든 간에 그 객체를 참조하는 참조값만 알고 있다면 가능하다.


- hashCode 와 equals
    - 만약 ORM 을 사용하고 있는 경우라면, hashCode 와 equals 를 오버라이드 하는 메소드 내부에서 Getter 를 사용하기를 권장한다.
      그 이유는 ORM 에 의해 fields 가 Lazy Loaded 되어, getter 를 부르기 전에는 사용이 불가능할 수 있기 때문이다.
    - 단, equals 와 hashCode 는 모두 VO(Value Object)에서만 사용하는 것을 권장합니다.
      값을 나타내는 것 외에 기능을 갖고 있는 인스턴스에서는 문제가 발생할 여지가 많아 웬만해선 사용하지 않는 것을 권장합니다.


- String 최적화   https://madplay.github.io/post/difference-between-string-stringbuilder-and-stringbuffer-in-java
    - JDK 1.5 버전부터는 String도 연산 과정에서 StringBuilder를 사용하도록 변경되었다. 그래서 예전보다는 더 좋아진 성능을 기대해도 된다.
        - 컴파일 한 후에 바이트 코드를 확인해보자. 결과를 확인할 때는 클래스 파일을 역어셈블해주는 javap 명령어에 디어셈블 결과를 출력해주는 -c 옵션을 넣으면 된다.

    - 디컴파일해서 확인해보면 StringBuilder를 사용하도록 개선되었지만 반복문 안에서 문자열을 더하는 연산을 한다면
      StringBuilder가 반복문 횟수만큼 생성되기 때문에 상대적으로 느릴 수밖에 없다.

    - StringBuilder와 StringBuffer는 가변의 속성을 가지고 있다는 점이 불변인 String과 비교되는 큰 차이다.
      이 둘은 문자열을 한 번 만들고 연산이 필요할 때마다 크기를 변경해가며 문자열을 변경한다. 따라서 변경될 때마다 새롭게 객체를 만드는 String 보다 더 빠르다.

    - StringBuilder는 내부적으로 문자열을 저장하기 위한 메모리 공간을 지니는데, String과 달리 해당 공간에 대해 문자를 추가하거나 삭제하는 것이 가능하다.
      버퍼라는 데이터를 임시로 저장하는 공간에 메모리를 저장해두고
      버퍼의 공간이 모자르다면 가변적으로 공간을 늘리는 형식으로 작동한다.


- 리플렉션이란
    - 구체적인 Class Type을 알지 못해도, 그 클래스의 메서드, 변수들에 접근 할 수 있도록 해주는 JAVA API
    - gc의 대상이 되지 않은 영역 Method Area 영역을 뒤져서 클래스에 대한 정보를 가져온다.
       (Method Area에는 Static 변수들을 비롯한, 생성자 , Method, SuperClass등 의 정보가 올라가게됩니다.


- 자바 8
    시대의 흐름에 의해 프로그래밍의 생태계가 변하고 있다. 더 이상 싱글 코어로는 한계에 다다르게 되면서 멀티코어 CPU 가 대중화 되고 있다.
    Java 8 은 시대 흐름에 맞게 병렬 프로세싱을 활용하고자 했고, 그로 인해 기존 Java 에서는 구현하기 어려웠던 부분을 Java 8 을 기점으로
    함수형 프로그래밍과 비동기 논블로킹 방식을 도입을 통해 해결했다. 미래 사회에서 함수형 프로그래밍은 더욱 주목받을 것으로 보이기 때문에
    개발자라면 함수형 프로그래밍을 익힌다면 큰 도움이 되리라 생각한다.


- 캡슐화(encapsulation)
    특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶는 것을 캡슐화라고 한다.
    응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법
    객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것

    낮은 결합도를 유지할 수 있도록 설계하는 것
    한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것 (객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것!)
    응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법
    캡슐화는 어떻게 높은 응집도와 낮은 결합도를 갖게 할까? 바로 정보 은닉을 활용한다.

    쉽게 말해 모듈화를 의미한다. 이러한 캡슐화를 통해 정보를 객체 안에 포함시키고, 그 정보에 대한 직접 접근은 허용하지 않는 대신,
    필요에 따라 확인할 수 있는 인터페이스를 외부에 공개함으로써 정보 은닉 효과도 자연스럽게 따라온다.


- static 의 의미와 사용법
    - new 로 객체를 생성하다보면 메모리를 많이 사용하게 됩니다. 그리고 생성하는 객체가 공통적으로 많이 쓰는 객체라면
      더욱더 전역적으로 하나만 있다면 객체를 새로 생성하지 않더라도 가져다가 쓰기만 하면 될 것입니다. 그래서 static 이 생겨나게 되었습니다.
    - 일반적으로 우리가 만든 Class는 Static 영역에 생성되고, new 연산을 통해 생성한 객체는 Heap영역에 생성됩니다.
    - 객체의 생성시에 할당된 Heap영역의 메모리는 Garbage Collector를 통해 수시로 관리
    - Static 키워드를 통해 Static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리
    - Garbage Collector의 관리 영역 밖에 존재하므로 Static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재하므로 자주 사용하게 되면 시스템의 퍼포먼스에 악영향

    - Static 변수와 static 메소드는 Static 메모리 영역에 존재하므로 객체가 생성되기 이전에 이미 할당이 되어 있습니다. 그렇기 때문에 객체의 생성없이 바로 접근(사용)할 수 있습니다.


- Static 변수
        일반적으로 상수들만 모아서 사용하며 상수의 변수명은 대문자와 _를 조합하여 이름짓는다. 또한 상속을 방지하기 위해 final class로 선언을 한다.