- 객체 지향 프로그래밍이란
    - 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로
      파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
    - 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

    - 추상화
        필요로 하는 속성이나 행동을 추출하는 작업
        추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.
        즉, 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것이 추상화다

    - 캡슐화
        특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶는 것을 캡슐화라고 한다.
        응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법
        객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것
        객체 지향은 모든 객체의 모듈화를 추구. 좋은 모듈화는 캡슐화, 은닉화가 적절히 구현되고 유지되는 것을 지향한다.

    - 상속(inherutance)
        자식 클래스를 외부로부터 은닉하는 캡슐화의 일종이라고 말할 수 있다.
        자식 클래스 자체를 캡슐화하여 '사람 클래스'와 같은 외부에 은닉하는 것으로 확장되는 것
        상속은 코드의 재사용성을 높이고 확장성을 높여준다.


- 캡슐화와(Encapsulation) 은닉화(Information Hiding)
    - 캡슐화
        - 관련된 요소들을 묶음으로써 캡슐 내부와 외부를 구별 짓는 장치
        - 객체 외부에서는 개체 내부 정보를 직접 접근하거나 조작할 수 없고,
          외부에서 접근할 수 있도록 정의된 오퍼레이션을 통해서만 관련 데이터에 접근할 수 있다 ex). getter ,setter

        - 객체의 세부내용이 외부에 은폐(정보은닉)되어, 변경이 발생할 때 오류발생이 적어짐
        - 각 객체가 가지고 있는 데이터들은 해당 객체 속에 숨어 있기 때문에 외부 객체에서 볼 수 없다.
        - 객체들 간의 메시지를 주고 받을 때 각 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 간결해지고, 객체간의 결합도가 낮아짐

    - 정보은닉
        - 캡슐내의 요소들에 대한 세부 구현사항을 외부에 숨기는 장치
        - 정보 은닉은 private 키워드를 활용해서 외부에서 클래스 내부의 정보에 접근하지 못하도록 하는 기능

        - 정보은닉은 캡슐화 되어 있는 데이터와 함에 대해서 외부에서 해당 함수가 어떻게 구현되어 있는지에 대한 세부 사항을 숨기는 것이다.
        - 캡슐화가 되어 있다고 해서 반드시 정보은닉이 되는 것은 아니다.


- 객체 지향 설계 과정
    - 제공해야 할 기능을 찾고 세분화한다. 그리고 그 기능을 알맞은 객체에 할당한다.
    - 기능을 구현하는데 필요한 데이터를 객체에 추가한다.
    - 그 데이터를 이용하는 기능을 넣는다.
    - 기능은 최대한 캡슐화하여 구현한다.
    - 객체 간에 어떻게 메소드 요청을 주고받을 지 결정한다.


- 람다식(Lambda Expression) 이란?
    - 정의
        - 람다식으로 선언된 함수는 1급 객체이기 때문에 매개변수로 전달이 가능

    - 특징
         람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
         람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.

    - 단점
        - 람다를 사용하면서 만든 익명함수는 재사용이 불가능하다.


- 함수형 인터페이스(Functional Interface) 란?
    - 함수형 인터페이스란 함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션으로, 인터페이스에 선언하여 단 하나의 추상 메소드만을 갖도록 제한하는 역할
    - 함수형 인터페이스의 등장으로 우리는 함수를 변수처럼 선언할 수 있게 되었고, 코드 역시 간결하게 작성할 수 있게 되었다.


- 컬렉션 프레임워크에 대해 설명해주세요.
    다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.


- Serializable 은 무엇일까요?  https://www.slideshare.net/sunnykwak90/java-serialization-46382579
    - 직렬화 기술 이해
        - 직렬화란 무엇인가?
            - 직렬화는 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷
              (예를 들면 파일 또는 메모리 버퍼, 네트워크 연결 링크를 통해 전송될 수 있는 형태) 으로 변환.
        - 직렬화는 왜 중요한가?
            - 거의 모든 소프트웨어는 네트워크를 통해 데이터를 주고 받으며, 프로그램을 구현하는데 필요한 기반 기술 중에서 빼놓을 수 없게 됨.
            - 직렬화는 네트워크 의존성이 높은 소프트웨어일 경우, 전체 성능을 좌우할 수도 있는 중요한 기술이다.
        - 직렬화 적용 분야
            - 파일 저장소 (File storage)
                - 프로그램 실행 중에 생성된 데이터를 영구 저장소(파일 시스템) 등에 저장한 후, 이후에 프로그램이 다시 실행되었을 때 저장된
                  데이터를 메모리 상에 객체 형태로 복구해 사용한다.
            - 네트워크 통신
                - 네트워크 상에 떨어져 있는 프로그램 간에 데이터를 주고 받기 위해 데이터를 직렬화한 후, 패킷에 담아 전송
            - 데이터베이스
                - 복잡한 형태의 객체를 데이터베이스에 저장할 때 직렬화된 문자열 형태로 테이블의 칼럼에 저장하기도 한다.
            - 웹 환경
                - 웹 서버에서 브라우저(클라이언트)로 구조화된 데이터를 전송할 때 직렬화한 후 JSON 형식 등 전달하는 방식이 점차 많이 사용됨
        - 직렬화 기법 선택 시 고려할 점
            - 단순성(simple)
                - 사용하기가 복잡하지 않아야 한다.
            - 경량(compact)
                - 프레임워크(혹은 라이브러리)의 규모가 작아야 한다.
            - 유연성(flexible)
                - 다양한 데이터 타입을 직렬화할 수 있어야 한다.
            - 버전지원(versioning)
                - 객체의 데이터 구조는 설계 및 개발, 나아가 유지보수 단계에서 변화될 수 있다.
            - 속도(fast)
                - 처리 속도가 빠르면 빠를수록 좋다.
            - 확장성(scalable)
                - 복잡하거나, 거대한 형태의 데이터를 직렬화할 수 있어야 한다.
        - 직렬화 데이터 형식
            - Binary
                - 메모리에 저장된 데이터를 최소한의 가공 혹은 가공 없이 바이트의 연속된 형태로 저장하는 방식
            - JSON(JavaScript Object Notation)
                - 텍스트 형식이므로 사람과 기계 모두 읽기 가능하다. 다양한 프로그래밍 언어에서 읽고 쓸 수 있기 때문에 널리 사용됨
            - XML(Extensible Markup Language)
                - 텍스트 형식이며, JSON 에 비해 복잡하다. JSON 에 대해 가지는 장점은 스키마를 적용할 수 있고 무결성 검사가 가능하다.
            - YAML(YAML Ain't Markup Language)
                - XML 에 비해 사람이 읽고 쓰기 쉽도록 고안된 마크업 언어이다. 문법이 상대적으로 단순하고, 가독성이 높게 설계되어 있다.
        - 왜 성능이 중요한가?
            - CPU 비용
                - 메모리에 존재하는 바이너리 형태의 객체를 디스크 등에 저장할 수 있는 형태(텍스트 등)로 저장하기 위해서는 변환 처리 과정이
                  필요하며, 반대의 처리 또한 필요하다.
            - 메모리 비용
                - 변환 작업을 수행하는 과정에서 임시 버퍼(temporary buffer)를 할당하고, 네트워크를 통한 송수신 과정에서 스트림 처리 등에
                  따른 공간 할당이 필요하다.
            - 네트워크 비용
                - 직렬화를 수행하는 대다수의 프로그램 혹은 시스템은 네트워크를 통해 데이터를 주고 받게 된다. 네트워크 송수신에 있어서 패킷의
                  크기가 커질수록 전체 성능은 떨어진다.

    - 직렬화 프레임워크
        - JDK 의 Serializable 인터페이스
            - 프로그래밍하기 가장 쉽고, Serializable 인터페이스를 이용해 별도의 라이브러리 없이 즉시 사용할 수 있다.
            - 클래스를 릴리즈한 후에는 구현을 변경하기 어려워 유연성을 감소시킨다.
            - C++, 파이썬 등 다른 언어로 구현된 프로그램과 데이터를 교환할 수 없다.
            - 기본 연산자의 취약점으로 인해 불변 값이 손상되거나, 비정상적인 접근이 발생할 수 있다. (invariant corruption and illegal access)
            - 커스터마이징이 불가능하고, 소스 코드를 수정할 수 있어야 한다.
        - Java externalization (직렬화 코드를 직접 구현)
            - 객체를 저장 및 복구하는 Externalization 인터페이스를 구현해 직접 직렬화를 구현한다.
            - 인스턴스의 컨텐츠를 저장하고 복구하는 역할을 수행하는 클래스를 구현해야 한다.
            - 클래스의 구조가 변경될 때 마다, 읽고 쓰는 코드를 수정해야 한다.
        - Google GSON
            - 자바 객체를 JSON 으로 변환하거나 반대의 작업을 수행하는 자바 라이브러리.
            - 직렬화된 객체의 소스 코드를 필요로 하지 않는다.
            - 커스텀 표현을 지원한다.
        - Jackson JSON
            - 고성능, 인공공학적 JSON 프로세서 자바 라이브러리
            - 광범위한 커스터마이징 툴 지원
            - 혼합 어노테이션
            - 실체화된 인터페이스
            - 다양한 데이터 포맷 : JSON, CSV, Smile(binary JSON), XML, YAML
        - BSON for Jackson
            - 바이너리 인코딩된 JSON
            - 몽고 DB 의 주된 데이터 교환 포맷
            - 확장 프로그램 작성 가능
        - Protocol Buffers
            - 구조적인 데이터를 확장 가능하며 효율적인 포맷을 변환하는 방법 제공
            - 구글 내부에서 대부분의 내부 RPC 프로토콜과 파일 포멧에 Protocol Buffers 를 사용 중.
            - Java, C++, Python 지원
        - Kryo
            - 빠르고 효율적인 객체 그래프 직렬화 자바 프레임워크
            - 구글 코드 상의 오픈 소스 프로젝트
            - 자동화된 깊고 얕은 복사/복제
            - 소스 클래스에 대한 코드 작성 요건이 거의 없음


- 컬렉션 방어적 복사
    - 방어적 복사! 를 하려면 copyOf를 해야 합니다.
    - 복사본 컬렉션에 대한 요소 추가 / 삭제 시도 시 UOE가 발생한다는 점은 unmodifiableList와 동일합니다.
      그러나 원본 컬렉션에서 요소 추가 / 삭제 가 일어나도, 영향을 받지 않습니다
    - 그럼에도 불구하고 copyOf()로 만들어낸 컬렉션이 완전한 불변이라고 볼 수는 없습니다.
      왜냐하면 copyOf의 반환값으로 전달된 unmodifiable list에서 객체를 꺼내서,
      그 객체 내부의 값을 변경할 경우, 아니면 외부에서 그 객체의 값을 변경할 경우에는
      요소 까지 깊은 복사를 하지는 않았기 때문에 값이 변경되기 때문입니다.
    - 컬렉션의 요소가 되는 값 객체들이 불변을 보장한다면, copyOf와 만나서 완전 불변이 가능

    - 따라서 기본 제공되는 API 를 사용하여 컬렉션을 복사한 경우, 외부로부터의 변경에 취약하지 않은 컬렉션을 만들기 위해서는 내부 요소가 불변 객체여야 함을 알 수 있다.


- 접근제어자를 사용하는 이유
    - 객체를 사용하는 입장에서 객체 내부적으로 사용하는 변수나 메소드에 접근함으로써 개발자가 의도하지 못한 오동작을 일으키기도 합니다.
      이러한 문제로부터 객체의 로직을 보호하기 위해서는 멤버에 따라서 외부의 접근을 허용하거나 차단해야 할 필요
    - 사용자에게 객체를 조작할 수 있는 수단만을 제공함으로써 결과적으로 객체의 사용에 집중할 수 있도록 돕기 위함
    -> 의도치 않은 실수를 줄이기 위함과 정보 은닉의 목적


- 다형성(polymorphism)
    서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
    부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다형성이다.
    이처럼 다형성을 사용하면, 구체적으로 현재 어떤 클래스 객체가 참조되는 지는 무관하게 프로그래밍하는 것이 가능하다.
    상속 관계에 있으면, 새로운 자식 클래스가 추가되어도 부모 클래스의 함수를 참조해오면 되기 때문에 다른 클래스는 영향을 받지 않게 된다.

    같은 모양의 코드가 다른 행위를 하는 것을 나타낸다. 자바에선 대표적으로 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상메소드, 추상클래스 방법이 모두 다형성
    하나의 객체가 여러가지 타입을 가질 수 있는 것.

    - Overriding 오버라이딩
        오버라이딩은 Method 재정의라고 할 수 있다. 슈퍼 클래스의 메서드 이름, 매개 변수, 같은 반환 값이지만 내부 로직을 새롭게 재정의하는 개념이다.
    - Overloading 오버로딩
        오버로딩은 같은 이름의 Method 이지만 매개 변수의 개수, 리턴 타입과 같은 부분이 다름으로 여러 개의 같은 이름 메서드를 정의하는 것을 말한다.


- static 이란?
        정적(static)은 고정된이란 의미를 가지고 있습니다. Static 이라는 키워드를 사용하여 Static 변수와 Static 메소드를 만들 수 있는데
        다른말로 정적필드와 정적 메소드라고도 하며 이 둘을 합쳐 정적 멤버라고 합니다. (클래스 멤버라고도 합니다.)
        정적 필드와 정적 메소드는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버입니다. 그렇기에 클래스 로더가 클래스를 로딩해서
        메소드 메모리 영역에 적재할때 클래스별로 관리됩니다. 따라서 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있습니다.

    - 정적(Static) 멤버 생성
        - Static
            - 주로 클래스들이 할당
            - GC 관여 x
            - 모든 객체가 메모리를 공유
        - Heap
            - 주로 객체들이 할당
            - GC 관여
            - 메모리를 공유하지 않음

        - Static 키워드를 통해 생성된 정적멤버들은 Heap 영역이 아닌 Static 영역에 할당됩니다. Static 영역에 할당된 메모리는
          모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점을 가지지만 Garbage Collector 의 관리 영역 밖에 존재하기에
          Static 영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재하게 됩니다.
          그렇기에 Static 을 너무 남발하게 되면 만들고자 하는 시스템 성능에 악영향을 줄 수 있습니다.

    - 정적(Static) 멤버 선언
        - 필드나 메소드를 생성 시 인스턴스로 생성할것인지 정적으로 생성할것인지에 대한 판단 기준은 공용으로 사용하느냐 아니냐로 내리면 됩니다.
          그냥 생성한다면 자동으로 인스턴스로 생성되며 정적으로 생성하려면 필드와 메소드 선언 시 static 이라는 키워들를 추가적으로 붙이면 됩니다.

        - 정적 메소드는 클래스가 메모리에 올라갈 때 정적 메소드가 자동적으로 생성됩니다. 그렇기에 정적 메소드는 인스턴스를 생성하지 않아도 호출을 할 수 있습니다.
          정적 메소드는 유틸리티 함수를 만드는데 유용하게 사용됩니다.


- Call by Reference와 Call by Value의 차이   https://steady-coding.tistory.com/613   https://deveric.tistory.com/92
    - 자바의 메소드(함수) 호출 방식
        - Call by value는 메서드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값(value)을 복사하여 보낸다.
        - Call by reference는 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 참조값, 혹은 주소, 포인터(Address)를 복사하여 보낸다.
           즉 매개변수를 변경할 경우 원본도 같이 변경되는 Call by reference

        - 자바는 기본형 타입 변수와 참조형 타입 변수가 있는데 둘 다 call by value 방식으로 메소드에서 받아진다
          대신 기본형 타입은 그 값을 복사 해서 주지만 참조형 타입은 값의 래퍼런스(주소)가 저장되는 것이므로 그 값의 래퍼런스가 복사 되어진다
        - 참조가 아닌 각각의 필드 값을 Getter/Setter를 이용해서 바꾸면 예외적으로 이런 경우에는 두개의 값이 변경됩니다.
          이런 예외적인 부분 때문에 참조형이 Call by Reference라는 오해를 받게 된다고 생각한다.
          왜 이런 부분이 가능할까요? 자바가 함수의 인자로 전달해주는 것은 어떤 것을 참조 하고 있는지에 대한 (복사된) 참조 값을 전달하기 때문이다.
          (접근제어자로 막혀있지 않은 한) 자바에서 객체를 컨트롤 하는 행위는 어떤 장소이든 간에 그 객체를 참조하는 참조값만 알고 있다면 가능하다.


- hashCode 와 equals
    - 만약 ORM 을 사용하고 있는 경우라면, hashCode 와 equals 를 오버라이드 하는 메소드 내부에서 Getter 를 사용하기를 권장한다.
      그 이유는 ORM 에 의해 fields 가 Lazy Loaded 되어, getter 를 부르기 전에는 사용이 불가능할 수 있기 때문이다.
    - 단, equals 와 hashCode 는 모두 VO(Value Object)에서만 사용하는 것을 권장합니다.
      값을 나타내는 것 외에 기능을 갖고 있는 인스턴스에서는 문제가 발생할 여지가 많아 웬만해선 사용하지 않는 것을 권장합니다.


- String 최적화   https://madplay.github.io/post/difference-between-string-stringbuilder-and-stringbuffer-in-java
    - JDK 1.5 버전부터는 String도 연산 과정에서 StringBuilder를 사용하도록 변경되었다. 그래서 예전보다는 더 좋아진 성능을 기대해도 된다.
        - 컴파일 한 후에 바이트 코드를 확인해보자. 결과를 확인할 때는 클래스 파일을 역어셈블해주는 javap 명령어에 디어셈블 결과를 출력해주는 -c 옵션을 넣으면 된다.

    - 디컴파일해서 확인해보면 StringBuilder를 사용하도록 개선되었지만 반복문 안에서 문자열을 더하는 연산을 한다면
      StringBuilder가 반복문 횟수만큼 생성되기 때문에 상대적으로 느릴 수밖에 없다.

    - StringBuilder와 StringBuffer는 가변의 속성을 가지고 있다는 점이 불변인 String과 비교되는 큰 차이다.
      이 둘은 문자열을 한 번 만들고 연산이 필요할 때마다 크기를 변경해가며 문자열을 변경한다. 따라서 변경될 때마다 새롭게 객체를 만드는 String 보다 더 빠르다.

    - StringBuilder는 내부적으로 문자열을 저장하기 위한 메모리 공간을 지니는데, String과 달리 해당 공간에 대해 문자를 추가하거나 삭제하는 것이 가능하다.
      버퍼라는 데이터를 임시로 저장하는 공간에 메모리를 저장해두고
      버퍼의 공간이 모자르다면 가변적으로 공간을 늘리는 형식으로 작동한다.


- 리플렉션이란
    - 구체적인 Class Type을 알지 못해도, 그 클래스의 메서드, 변수들에 접근 할 수 있도록 해주는 JAVA API
    - gc의 대상이 되지 않은 영역 Method Area 영역을 뒤져서 클래스에 대한 정보를 가져온다.
       (Method Area에는 Static 변수들을 비롯한, 생성자 , Method, SuperClass등 의 정보가 올라가게됩니다.


- 자바 8
    시대의 흐름에 의해 프로그래밍의 생태계가 변하고 있다. 더 이상 싱글 코어로는 한계에 다다르게 되면서 멀티코어 CPU 가 대중화 되고 있다.
    Java 8 은 시대 흐름에 맞게 병렬 프로세싱을 활용하고자 했고, 그로 인해 기존 Java 에서는 구현하기 어려웠던 부분을 Java 8 을 기점으로
    함수형 프로그래밍과 비동기 논블로킹 방식을 도입을 통해 해결했다. 미래 사회에서 함수형 프로그래밍은 더욱 주목받을 것으로 보이기 때문에
    개발자라면 함수형 프로그래밍을 익힌다면 큰 도움이 되리라 생각한다.


- 캡슐화(encapsulation)
    특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶는 것을 캡슐화라고 한다.
    응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법
    객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것

    낮은 결합도를 유지할 수 있도록 설계하는 것
    한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것 (객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것!)
    응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법
    캡슐화는 어떻게 높은 응집도와 낮은 결합도를 갖게 할까? 바로 정보 은닉을 활용한다.

    쉽게 말해 모듈화를 의미한다. 이러한 캡슐화를 통해 정보를 객체 안에 포함시키고, 그 정보에 대한 직접 접근은 허용하지 않는 대신,
    필요에 따라 확인할 수 있는 인터페이스를 외부에 공개함으로써 정보 은닉 효과도 자연스럽게 따라온다.


- static 의 의미와 사용법
    - new 로 객체를 생성하다보면 메모리를 많이 사용하게 됩니다. 그리고 생성하는 객체가 공통적으로 많이 쓰는 객체라면
      더욱더 전역적으로 하나만 있다면 객체를 새로 생성하지 않더라도 가져다가 쓰기만 하면 될 것입니다. 그래서 static 이 생겨나게 되었습니다.
    - 일반적으로 우리가 만든 Class는 Static 영역에 생성되고, new 연산을 통해 생성한 객체는 Heap영역에 생성됩니다.
    - 객체의 생성시에 할당된 Heap영역의 메모리는 Garbage Collector를 통해 수시로 관리
    - Static 키워드를 통해 Static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리
    - Garbage Collector의 관리 영역 밖에 존재하므로 Static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재하므로 자주 사용하게 되면 시스템의 퍼포먼스에 악영향

    - Static 변수와 static 메소드는 Static 메모리 영역에 존재하므로 객체가 생성되기 이전에 이미 할당이 되어 있습니다. 그렇기 때문에 객체의 생성없이 바로 접근(사용)할 수 있습니다.


- Static 변수
        일반적으로 상수들만 모아서 사용하며 상수의 변수명은 대문자와 _를 조합하여 이름짓는다. 또한 상속을 방지하기 위해 final class로 선언을 한다.


- Static 클래스
    static 메소드에서는 static이 선언되지 않은 변수에 접근이 불가능
    우리가 Test.printName() 을 사용하려고 하는데, name1은 new 연산을 통해 객체가 생성된 후에 메모리가 할당됩니다.
    하지만 static 메소드는 객체의 생성 없이 접근하는 함수이므로, 할당되지 않은 메모리 영역에 접근을 하므로 문제가 발생
    그러므로 static 메소드에서 접근하기 위한 변수는 반드시 static 변수로 선언


- 왜 inner 클래스에는 static을 붙여줘야 할까?
    1) Inner class (Non-static nested class) 는 Outer class 의 인스턴스화 이후 Inner class 의 인스턴스화가 가능하며
    2) 두 인스턴스의 관계정보는 Inner class의 인스턴스 안에 만들어져 메모리 공간을 더 차지하며, 생성시간도 더 걸린다.
    3) 더 심각한 문제는 Inner class 가 Outer class 인스턴스에 대한 참조를 갖고 있기 때문에, Garbage Collection 은 Outer class 의 인스턴스를
       수거 대상으로 보지 않아 GC 의 대상에서 빠지게 된다. (더 쉽게 풀어쓰자면 inner class, outer class 두 인스턴스가 연결되어 있어서 outer class 인스턴스의 메모리를 못 뺏는 것)
    4) 때문에 Outer class 를 참조할 일이 없다면, Nested class 는 static 을 붙여 무조건 static nested class 를 만들자!


- java의 main 메서드가 static인 이유
    - 프로그램 실행시 먼저 static 영역 메모리에 적재된다.
    - main 메소드 같은 경우는 객체를 생성하지 않아도 자동으로 실행되어 작업을 수행해야하는 부분이기 때문에 static으로 선언
    - public 접근 제어자는 JVM이 main 함수가 어디에 있건 접근 가능하기 위해서
    - (String args[]) 는 매개변수로 문자열 배열을 줄 수 있음


- 객체(Object) VS 인스턴스(Instance)
	- 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
	- 객체를 클래스의 인스턴스라고도 부른다 => ‘인스턴스화하여 레퍼런스를 할당한’ 객체를 인스턴스라고 말하지만,
	  이는 원본(추상적인 개념)으로부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.


- Lambda란
    - 함수형 프로그래밍 언어에서 사용되는 개념으로 익명 함수라고도 합니다. 메서드를 하나의 '식(expression)'으로 표현한 것이다. 메서드를 람다식으로
      표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명 함수(anonymous function)'이라고도 한다.

    - 배경
        인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스를 이용하는데 일회성으로 사용하는 구현 클래스를 계속 선언하는 것은
        비효율적이기 때문에 익명 클래스나 람다를 이용하여 구현 클래스를 선언합니다.

    - 함수 객체
        특정 동작을 목적으로 추상 메서드를 하나만 담은 인터페이스나 추상 클래스를 함수 객체라합니다.


- 람다
    - Java 8 에서는 많은 새로운 기능들이 도입 되었고, 그 중에는 람다와 stream 도입을 통한
      함수형 프로그래밍도 있다. 람다를 통해 함수를 파라미터로 넘길 수 있고 변수에 할당할 수 있으며
      반환 값으로 반환할 수 있는 일급 시민으로써 사용할 수 있게 됨.
      이를 통해 코드 양도 줄이면서도 코드의 재사용성을 크게 높일 수 있다.
    - 람다를 사용하기 위한 조건 -> 함수형 인터페이스
    - 익명 클래스는 단순히 편의를 위해서 클래스 내부에서 사용을 할뿐 컴파일이 되면 별도의 클래스로 분리되어 나온다.
    - 하지만 람다의 경우 컴파일 해도 별도의 클래스 파일이 생성되지 않으며 람다는 그대로 존재

    - 람다를 사용하면 안되는 경우
        - this 를 사용할 경우
            - 만약 내부에서 this 를 사용해야 하면 람다 대신 익명 클래스 사용해야 함
        - 섀도우 변수 (shadow variable) 를 사용할 경우
            - shadow variable 는 inner scope 내부에 outer scope 에 정의한 똑같은 변수가 있을 경우 shadow 된다.
            - 람다는 변수 shadowing 을 잡아내지 못하고 에러를 띄우므로 익명 클래스 사용해야 함
        - 콘텍스트 오버로딩이 존재할 때
            - 람다는 파라미터나 반환 값 등을 통해서 해당 람다가 어느 익명 메서드의 구현인지를 내부적으로 추론하는데
              모든 요소가 같은 추상 메서드가 2개 이상 존재한다면 에러가 띄우므로 익명 클래스 사용해야 함
        - 람다 코드가 3줄을 넘어갈 때
            - 동작을 파악하는데 시간이 오래 걸리고 복잡한 코드가 나올수 있으므로 지양

    - 람다 표현식의 한계
        - 코드 자체로 동작이 명확하게 설명되지 않거나 람다가 길거나 읽기 어렵다면, 쓰지 않는 방향으로 리팩토링하는 것을 고려
        - 람다식은 기본적으로 익명 구현 객체 기반이기 때문에, 익명 객체 특성상 디버깅 할때 콜 스택(call stack) 추적이 매우 어려운 단점을 가지고 있다.
        - stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다. (최근엔 비슷함)
        - 람다식을 통해 재귀 함수를 구축하면 실행 조차 안되는 컴파일 에러가 나타난다.


    - 메소드를 간결한 함수 식으로 표현
    - 지금까지 자바에서는 메서드를 하나 표현하려면 클래스를 정의해야 했다. 하지만 람다식으로 표현하면 메서드의 이름과 반환값을 생략할 수 있고
      이를 변수에 넣어 자바 코드가 매우 간결해지는 장점이 있다.
    - 인터페이스를 익명 클래스로 구현한 익명 구현 객체를 짧게 표현한 것
    - 오로지 인터페이스로 선언한 익명 구현 객체만이 람다식으로 표현이 가능하다.
      그리고 람다 표현이 가능한 이러한 인터페이스를 가리켜 함수형 인터페이스라 총칭한다.
    - 함수형 인터페이스란 딱 하나의 추상 메소드가 선언된 인터페이스
    - 사실 컴파일러 스스로 람다 함수식을 보고 추론하여 타입을 유추
        1. 람다식을 받는 메소드의 매개변수의 타입을 본다.
        2. 함수형 인터페이스 정의문을 찾아 추상 메소드 형태를 본다.
        3. 추상 메서드에 정의된 타입에 따라 람다식의 타입을 자동으로 판별해준다.

    - 람다 표현식의 한계
        1. 문서화를 할 수 없다.
            - 람다 자체는 이름이 없는 함수이기 때문에 메서드나 클래스와 다르게 문서화 불가.
        2. 디버깅이 다소 어렵다.
            - 기본적으로 익명 구현 객체 기반이기 때문에, 익명 객체 특성상 디버깅 할때 콜 스택(call stack) 추적이 매우 어려운 단점을 가지고 있다.
        3. stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다
        4. 람다를 남발하면 코드가 지저분해질 수 있다.
        5. 재귀로 만들경우에는 다소 부적합하다.
            - 람다식을 통해 재귀 함수를 구축하면 실행 조차 안되는 컴파일 에러가 나타난다.


- 제네릭이란, 왜 쓰는지 어디에 써 봤는지 알려주세요
    - 제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다.
    - 자바5 이전에는 실수로 엉뚱한 타입의 객체를 넣어두면 런타임에 형변환 오류가 나는 문제가 있었다.
    - 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려준다.
    - 컴파일 과정에서 오류를 차단 할 수 있다는 것이다. (안전하고 명확한 프로그래밍이 가능)


- 제네릭(Generic)
    - 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
    - 제네릭으로 배열을 생성할 수는 없다.
    - static 변수에도 제네릭을 사용할 수 없다. static 변수는 인스턴스에 종속되지 않는 클래스변수로써 모든 인스턴스가 공통된 저장공간을 공유하게 되는 변수이다.
      하지만, static 메서드에는 제네릭을 사용할 수 있다.
    - static 변수의 경우에 제네릭을 사용하면 여러 인스턴스에서 어떤 타입으로 공유되어야 할지 지정할 수가 없어서 사용할 수 없다. static 변수는 값 자체가 공유되기 때문이다.
      값 자체가 공유되려면 타입에 대한 정보도 있어야 한다.
    - 하지만, static 메서드의 경우 메서드의 틀만 공유된다고 생각하면 된다. 그리고 그 틀 안에서 지역변수처럼 타입 파라미터가 다양하게 오가는 형태로 사용될 수 있는 것이다.


- 제네릭을 사용하는 이유
    - 제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때 마다 형변환을 해야 했다. jdk 1.5 부터는 제네릭을 사용하면 컬렉션에 담을 수 있는 타입을 컴파일러에게 알려주며,
      컴파일러가 알아서 형변환 코드를 추가한다. 또한 엉뚱한 객체를 넣는 코드가 있다면 컴파일 타임에 차단해준다.
    - 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있다. 실행 시(런타임 시) 타입 에러가 나는것보다는 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지하는 것이 좋다.
    - 제네릭 코드를 사용하면 타입을 국한하기 떄문에 요소를 찾아올 때 타입 변환을 할 필요가 없어 프로그램 성능이 향상된다.


- 제네릭 싱글톤 팩토리
    불변 객체를 여러 타입으로 활용할 수 있게 만들어야 할 때가 있는데, 이때는 제네릭 싱글톤 팩토리를 만들면 된다. Collections.reverseOrder[Comparator]이 좋은 예다
    만약 제네릭을 쓰지 않았다면 요청 타입마다 형변환하는 정적 팩토리를 만들었어야 할 것이다. (타입별로 정적메소드가 1개씩..)


- stream에 lazy란?   https://bugoverdose.github.io/development/stream-lazy-evaluation/   https://youngs-java-study.tistory.com/8
    스트림 파이프라인을 실행하게 되면 JVM은 곧바로 스트림 연산을 실행시키지 않는다. 그 대신 최소한의 필수적인 작업만을 수행하고자, 즉 지연 연산을 위한 준비작업을 수행한다.
    이 준비 작업이란 우선 스트림 파이프라인이 어떠한 중간연산과 최종연산으로 구성되어있는지에 대한 검사로 시작된다.
    이러한 검사 결과를 바탕으로 JVM은 사전에 어떠한 방식으로 최적화를 진행할지 미리 계획하고, 그 계획에 따라 스트림의 개별 요소에 대한 스트림 연산을 수행하게 된다.

    먼저 스트림 연산들은 중간 연산과 최종 연산으로 구분됩니다. 중간 연산은 호출 즉시 실행되지 않고 단지 파이프라인을 구성하는 일만 합니다.
    실제로 최종 연산이 호출될 때 중간 연산을 포함한 전체 파이프라인이 실행됩니다. 이때 중간 연산이 호출된 즉시 실행되지 않고,
    최종 연산이 호출될 때 뒤늦게 실행된다고 하여 스트림이 게으른(Lazy) 특성을 가진다고 표현합니다.

    그리고 스트림에서 제공하는 최적화 전략으로는 루프퓨전과 쇼트서킷이 대표적이다.

    끊어진 순회 (Short Circuit)
    ‘게으르다’는 약간은 부정적인 단어가 사용되었지만 스트림은 이 게으른 특성 덕분에 전체 파이프라인 구성을 보고 최적화된 실행을 계획할 수 있습니다. 앞에서 살펴본 예와 같이 findFirst 같은 최종연산이 있으면 굳이 전체 스트림을 순회하지 않고 첫번째 항목을 찾을 때 까지만 순회하도록 실행을 계획하는 것입니다.

    혼합된 루프(Fusion Loop)
    스트림의 게으른 특성 때문에 효과를 발휘하는 또 다른 특성으로 혼합된 루프(Fusion Loop) 라는 기법도 있습니다. 중간 연산에서 filter, map 등의 순회 연산이 연속되는 경우 각각 루프를 도는 것이 아니라 하나의 루프로 중간 연산을 함께 수행하도록 하는 방법이라고 할 수 있습니다. 스트림을 쓰다보면 루프를 너무 많이 돌아서 비효율적인 것이 아닌가 내심 걱정은 되지만, 루프 몇 번 더 돈다고 성능에 큰 영향이 없다고 스스로를 안심시키곤 했는데 팩트를 벗어난 걱정이었습니다.

    근본적으로 지연 평가(Lazy Evaluation)을 사용한다. 이 덕분에 무한 스트림을 다룰 수 있게 된다.

    지연 연산으로 메모리를 절약할 수 있고, 성능에서 이익을 얻을 수 있습니다.
        Eager Evaluation
            함수형 프로그래밍 또는 Lazy Evaluation을 접해보지 못한 사람들은 이 코드의 처리과정이

            전체 요소들 중 6보다 작은 수를 구한다.
            1번에서 구한 요소들중 2로 나누어지는 수를 구한다.
            그 수에 10을 곱한다.
            이처럼 진행될 것이라 생각할 수 있지만, 아니다.

        Lazy Evaluation
            이 코드의 진행방식은 각 요소들에 대해 아래와 같은 방식으로 진행된다.

            6보다 작은지 검사한다 ( 6보다 클 경우 2번 3번 과정을 무시하고 다음 요소 검사 진행)
            2로 나누어 지는지 검사한다. ( 2로 나누어지지 않을 경우 3번 과정을 무시하고 다음 요소 검사 진행)
            10을 곱하여 출력한다.
            이처럼 불필요한 연산과정을 하지않고 각 요소에 대해 검사가 진행된다.

            불필요한 연산을 하지 않은 두번째 처리과정이 성능면에서 우월하다.


- Stream API의 실행 순서    https://mangkyu.tistory.com/115
    Stream API를 정확히 알고 사용하지 못하면 처리 속도의 지연을 야기할 수 있다. 그렇기 때문에 우리가 작성한 Stream API 코드가 어떻게 동작할 것인지 정확히 이해하고 있는 것이 중요하다.
    모든 데이터에 대해 filter가 진행되고 forEach가 실행되는 수평적 구조로 순회하는 것이 아니라, 각각의 데이터에 대해 filter와 forEach가 먼저 수행하는 수직적 구조로 순회
    Stream API를 사용할 때에는 반드시 연산 순서를 고려하여 코드를 작성
    동일한 입력과 결과에 대해 더 적은 연산으로 처리 가능.


- java stream paralled 사용시 주의사항   https://catsbi.oopy.io/0428be55-8c8d-40a2-923a-acc738d74a14
    - 박싱을 주의하라.
        자동 박싱과 언박싱은 성능을 크게 떨어트리는 요소 중 하나다. 자바에서는 이런 박싱 비용을 절약하기 위해
        특화 스트림(IntStream, LongStream, DoubleStream)을 제공한다. 따라서 되도록 기본형 특화 스트림을 사용하는게 좋다.

    - 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
        순서에 의존하는 연산(ex: limit, findFirst)은 병렬 스트림에서 수행하기 위해선 많은 비용이 필요하다.

    - 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라
        처리해야 할 요소 수가 N 이고 하나의 요소를 처리하는데 드는 비용이 Q라 하면 전체 스트림 파이프라인 처리 비용은 N*Q라 할 수 있는데,
        Q가 높아진다는 것은 병렬 스트림으로 성능 개선을 할 여지가 있음을 의미한다.

    - 소량의 데이터는 병렬 스트림이 도움되지 않는다.
        소량의 데이터는 병렬화 과정에 생기는 부가 비용이 더 크기에 순차 스트림을 사용하는게 더 효율적이다.

    - 적절한 자료구조인지 확인하자.
        ArrayList같은 경우 요소를 탐색하지 않고도 리스트를 분할 할 수 있기에 병렬 스트림을 사용하기 적절한
        반면 LinkedList는 분할하기 위해 모든 요소를 탐색해야 하기에 적절하지 않다.

        ArrayList는 인덱스로 요소를 관리하여 데이터를 쪼개기 쉽지만, HashSet, TreeSet은 요소 분리가 쉽지 않고,
        LinkedList도 링크를 따라가야 하기에 분리가 쉽지 않다. 요소 분리가 쉽지 않은 자료구조는 상대적으로 병렬 처리가 늦다.

    - 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 성능이 달라질 수 있다.
        map이나 SIZED 스트림은 크기를 알고 있기에 스트림 분할을 할 수 있고 병렬 처리가 수월하지만,
        필터 연산같은 경우 스트림의 길이를 예측할 수 없기 때문에 효과적으로 스트림을 병렬 처리할 수 있을지 알 수 없게 된다.

    - 최종 연산의 병합 과정(ex: Collector의 combiner) 비용을 살펴보라
        병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분 결과를 합치는 과정에서 상쇄될 수 있다.


- 빌더 패턴(Builder Pattern)을 사용해야 하는 이유
    1. 필요한 데이터만 설정할 수 있음
        생성자나 정적 메소드를 이용하는 경우라면 더미 값을 넣어주거나 생성자를 새로 만들어주어야 한다.
        생성자 또는 정적 메소드와 비교하여 테스트용 객체를 생성할 때 용이하게 해주고, 불필요한 코드의 양을 줄이는 등의 이점

    2. 유연성을 확보할 수 있음
        빌더 패턴을 이용하면 새로운 변수가 추가되는 등의 상황이 생겨도 기존의 코드에 영향을 주지 않을 수 있다.

    3. 가독성을 높일 수 있음
        빌더 패턴을 적용하면 직관적으로 어떤 데이터에 어떤 값이 설정되는지 쉽게 파악하여 가독성을 높일 수 있다.

    4. 변경 가능성을 최소화할 수 있음
        Setter를 구현한다는 것은 불필요하게 변경 가능성을 열어두는 것이다. 이는 유지보수 시에 값이 할당된 지점을 찾기 힘들게 만들며 불필요한 코드 리딩 등을 유발한다.
        값을 할당하는 시점이 객체의 생성뿐이라면 객체에 잘못된 값이 들어왔을 때 그 지점을 찾기 쉬우므로 유지보수성이 훨씬 높아진다.

    다음의 2가지 상황에서는 빌더를 구현할 필요가 없다.
        - 객체의 생성을 라이브러리로 위임하는 경우
            엔티티(Entity) 객체나 도메인(Domain) 객체로부터 DTO를 생성하는 경우라면 직접 빌더를 만들고 하는 작업이 번거로우므로
            MapStruct나 Model Mapper와 같은 라이브러리를 통해 생성을 위임할 수 있다.

        - 변수의 개수가 2개 이하이며, 변경 가능성이 없는 경우
            정적 팩토리 메소드를 사용하는 것이 더 좋을 수도 있다. 빌더의 남용은 오히려 코드를 비대하게 만들 수 있으므로
            변수의 개수와 변경 가능성 등을 중점적으로 보고 빌더 패턴을 적용할지 판단하면 된다.


- 오토박싱과 언박싱은 어떤 차이가 있습니까?
    - 기능적 편의성을 위하여 오토 박싱 / 언박싱을 제공하지만, 다른 타입간의 형 변환은 어플리케이션의 성능에 영향을 미치게 된다.
    - 비록 사소한 차이 일지라도 어플리케이션의 성능 측면에서 봤을때 반드시 필요한 상황이 아니라면 지양 해야 하는 것이 옳다.
    - 코드에 불필요한 auto casting이 반복적으로 이루어지고 있는지 확인하는 것은 대용량 서비스를 개발하는데 있어서 꼼꼼히 파악해야하는 요소


- String  vs  StringBuffer/StringBuilder
    - String 클래스는 불변하기 때문에 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성된
    - 새로운 메모리영역을 가리키게 변경되고 처음 선언했던 "hello"로 값이 할당되어 있던 메모리 영역은 Garbage 로 남아있다가
      GC(garbage collection)에 의해 사라지게 되는 것
    - String 은 불변성을 가지기 때문에 변하지 않는 문자열을 자주 읽어들이는 경우 String 을 사용해 주시면 좋은 성능을 기대
    - 문자열 추가,수정,삭제 등의 연산이 빈번하게 발생하는 알고리즘에 String 클래스를 사용하면 힙 메모리(Heap)에
      많은 임시 가비지(Garbage)가 생성되어 힙메모리가 부족으로 어플리케이션 성능에 치명적인 영향을 끼치게 됩니다.
    - String 과는 반대로 StringBuffer/StringBuilder 는 가변성 가지기 때문에
      .append() .delete() 등의 API 를 이용하여 동일 객체 내에서 문자열을 변경하는 것이 가능


- java immutable Object
    - 불변 객체는 재할당은 가능하지만, 한번 할당하면 내부 데이터를 변경할 수 없는 객체
    - 불변 클래스는 함수형 프로그래밍 그리고 스레드 안전성과 도메인 모델의 일관성을 유지하는 데 좋은 특징이다.


- 예외 처리 방법
    - 예외 처리 방법 : 예외 복구, 예외 처리 회피, 예외 전환 방법
      (try ~ catch문 안에 throw 예외던지기 / 메소드() throws Exception 등)
    - throw는 예외를 발생시키는 명령이다. throw 뒤에는 예외 정보를 가지고 있는 예외 클래스가 위치한다.
      자바 가상 머신은 이 클래스를 기준으로 어떤 catch 구문을 실행할 것인지를 결정한다. 또 실행되는 catch 구문에서는 예외 클래스를 통해서
      예외 상황의 원인에 대한 다양한 정보를 얻을 수 있다. 이 정보를 바탕으로 문제를 해결하게 된다.


- 메소드() throws Exception
    - 강제로 Exception을 자신을 호출한 상위메소드에 책임 전가
    - 메소드 뒤에 throws ~~ 를 사용하고 싶지 않으면 그냥 서비스 구현하는 곳에서에서 try catch 쓰면 된다(catch문에 예외 발생 시 처리 로직 구현하거나.. 단, 책임을 전가하지는 않는다)
    - exception이 발생할 여지가 있는곳에 try catch문을 작성함으로서 예외가 발생하더라도 구동중이던 어플리케이션이 중간에 멈추지않게끔 하는게 예외처리인데
      메서드에서 throws Exception을 해주게되면 해당 메서드 내에서 예외가 발생하면 자신이 처리하는게 아니고 자신을 호출한 상위메서드로 예외를 던지게 된다.


- static
    - 공통 사용, 모든 객체 메모리 공유
        - 인스턴트 생성 x
        - gc 관여 x
        ex) Math.round()

        - static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나
          값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있습니다.
        - Garbage Collector의 관리 영역 밖에 존재하므로 Static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재하므로 자주 사용하게 되면 시스템의 퍼포먼스에 악영향
        - 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용합니다.
        ex) Math.round()

        - Static
            - 주로 클래스들이 할당
            - GC 관여 x
            - 모든 객체가 메모리를 공유
        - Heap
            - 주로 객체들이 할당
            - GC 관여
            - 메모리를 공유하지 않음


- static 클래스, static 변수, static 메소드 차이   https://velog.io/@mooh2jj/Java-static-%EB%B3%80%EC%88%98-static-%EB%A9%94%EC%84%9C%EB%93%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-static-%ED%81%B4%EB%9E%98%EC%8A%A4
    - Static 변수
        일반적으로 변하지 않는 상수의 값을 갖는 경우가 많으므로 public static final로 활용된다.

        class Number{
            static int num = 0; //클래스 필드
            int num2 = 0; //인스턴스 필드
        }

    - Static 메소드
        일반적으로는 유틸리티 관련 함수들은 여러 번 사용되므로 static 메소드로 구현을 하는 것이 적합
        static 메소드를 사용하는 대표적인 Util Class로는 java.uitl.Math

    - Static 클래스
        static 클래스는 중첩 클래스(nested class)를 사용할 때 사용한다.

        - 왜 inner 클래스에는 static을 붙여줘야 할까?   https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9E%90%EB%B0%94%EC%9D%98-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-static-%EC%9C%BC%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%98%EC%9E%90
            inner 클래스를 선언할때 static 키워드를 붙여주지 않으면 '외부 참조' 현상 때문에, 내부 클래스 인스턴스를 생성하기 위해
            우선적으로 만들었던 외부 클래스 인스턴스가 정상적으로 GC 수거가 안되 메모리에 잔존하게 되어 문제점을 일으키게 된다.
            따라서 내부 클래스가 외부 클래스의 멤버를 가져와 사용하는 경우가 아닌 경우 반드시 내부 클래스를 선언 할 때는 static 키워드를 붙여주어야 한다.

            정적 멤버 클래스는 외부 인스턴스 없이도 만들어질 수 있기 때문에 '외부 참조'가 존재하지 않게 되고,
            이로 인해 일회용으로 사용된 바깥 클래스 객체는 더이상 내부 클래스 객체와 아무런 관계가 아니게 되어
            정상적으로 GC 수거 대상이 되어 메모리 관리가 잘 된 것이다.


- private final 과 private static final ??
    만약 private final로 선언한다면 직접적으로 값을 참조할 수는 없지만 생성자를 통해 값을 참조할 수 있다.
    하지만 private static final의 경우에는 생성자를 통해 값을 참조할 수 없다.

    private static final을 선언한 변수를 사용하면 재할당하지 못하며, 메모리에 한 번 올라가면 같은 값을 클래스 내부의 전체 필드, 메서드에서 공유한다.
        (private static 은 메모리에 올라가므로 초기화를 반드시 해주어야 한다. 안해주면 컴파일 에러 난다.)
    private final을 선언한 변수를 사용하면 재할당하지 못하며, 해당 필드, 메서드 별로 호출할 때마다 새로이 값이 할당(인스턴스화)한다.

    상수로 사용하려고 할 때, 그 값은 변하지 않을 것인데 호출할 때마다 새롭게 인스턴스화할 필요가 없다. 한 번 메모리에 올려놓고 계속 같은 값을 가져다 쓰면 될 일이다.


- 클래스변수, 인스턴스변수, 지역 변수
    멤버변수 중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수
    멤버 변수를 제외한 나머지 변수들은 모두 지역 변수, 지역변수 - 메서드 내 선언


- java immutable Object
    불변 객체란 한번 할당하면 내부 데이터를 변경할 수 없는 객체
    불변 객체는 read-only 메소드만을 제공하며, 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사(defensive-copy)를 통해 제공한다.

    - 장점
        - 객체에 대한 신뢰도가 높아집니다. 객체가 한번 생성되어서 그게 변하지 않는다면 transaction 내에서 그 객체가 변하지 않기에 우리가 믿고 쓸 수 있기 때문입니다.
        - 생성자, 접근메소드에 대한 방어 복사가 필요 없습니다.
        - 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있습니다.

    - 단점
        - 객체가 가지는 값마다 새로운 객체가 필요합니다. 따라서 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능저하를 발생시킬 수 있습니다.

    - 불변 class를 만드는 방법
        - 모든 class field 변수는 final로 선언
        - 모든 class field 변수의 setter 메서드 선언 X
        - class를 상속하지 못하도록 선언 (class를 final로 선언하거나 생성자를 private로 선언)
        - 모든 field 변수가 final이 아닐때 즉 가변객체타입의 field 변수가 있을 경우 그 가변객체 타입의 field변수에 대해 직접적으로 접근하지 못하도록
          copy 객체를 생성하여 새로운 인스턴스를 반환하도록 방어적 복사본 전략을 사용

        - 불변 객체란 한번 할당하면 내부 데이터를 변경할 수 없는 객체
        - Thread-safe, 안정성/성능
        - side effect 최소화
        - GC 성능 업
            불변객체를 한번 메모리에 할당하게 되면 같은 객체를 계속 호출하여도, 새롭게 할당하지 않아도 되므로 GC의 성능을 높힐 수 있다.
        - 불변객체를 필드로 사용할 때 방어적 복사가 필요없다.
            인스턴스 필드에 가변객체가 포함된다면 방어적 복사를 이용하여 전달해라


        - Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
            멀티 쓰레드 환경에서 동기화 문제가 발생하는 이유는 공유 자원에 동시에 쓰기(Write) 때문이다. 하지만 만약 공유 자원이 불변이라면
            더 이상 동기화를 고려하지 않아도 될 것이다. 왜냐하면 항상 동일한 값을 반환할 것이기 때문이다. 이는 안정성을 보장할 뿐만 아니라 동기화를 하지 않음으로써 성능상의 이점도 가져다준다.

        - 실패 원자적인(Failure Atomic) 메소드를 만들 수 있다.
            가변 객체를 통해 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있고, 불안정한 상태를 갖는 객체는 또 다른 에러를 유발할 수 있다.
            하지만 불변 객체라면 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지할 수 있을 것이다. 그리고 예외가 발생하여도 오류가 발생하지 않은 것 처럼 다음 로직을 처리할 수 있다.

            - 실패 원자적으로 만들기
                1. 불변객체
                2. 매개변수 유효성 검사
                    - 작업 수행에 앞서 매개변수의 유효성을 검사하는 것
                3. 복구 코드
                    - 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법
                    - 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이는데, 자주 쓰이는 방법은 아니다.

        - Cache나 Map 또는 Set 등의 요소로 활용하기에 더욱 적합하다.
            만약 캐시나 Map, Set 등의 원소인 가변 객체가 변경되었다면 이를 갱신하는 등의 부가 작업이 필요할 것이다.
            하지만 불변 객체라면 한 번 데이터가 저장된 이후에 다른 작업들을 고려하지 않아도 되므로 사용하는데 용이하게 작용할 것이다.

        - 부수 효과(Side Effect)를 피해 오류가능성을 최소화할 수 있다.
            - 객체의 수정자(Setter)를 통해 여러 객체들에서 값을 변경한다면 객체의 상태를 예측하기 어려워질 것이다.
            - 불변 객체는 객체의 상태가 유지되기 때문에 안전하게 객체를 다시 사용할 수 있다.

            불변 객체는 기본적으로 값의 수정이 불가능하기 때문에 변경 가능성이 적으며, 객체의 생성과 사용이 상당히 제한된다.
            그렇기 때문에 메소드들은 자연스럽게 순수 함수들로 구성될 것이고, 다른 메소드가 호출되어도 객체의 상태가 유지되기 때문에 안전하게 객체를 다시 사용할 수 있다.
            이러한 불변 객체는 오류를 줄여 유지보수성이 높은 코드를 작성하도록 도와줄 것이다.

        - 다른 사람이 작성한 함수를 예측가능하며 안전하게 사용할 수 있다.
            불변성이 보장된 함수라면 다른 사람이 개발한 함수를 위험없이 이용할 수 있다.

        - 가비지 컬렉션의 성능을 높일 수 있다. ??
            GC가 수행될 때, 가비지 컬렉터가 컨테이너 객체 하위의 불변 객체들은 Skip할 수 있도록 도와준다.
            왜냐하면 해당 컨테이너 객체(ImmutableHolder)가 살아있다는 것은 하위의 불변 객체들(value) 역시 처음에 할당된 상태로 참조되고 있음을 의미하기 때문이다.
            결국 불변의 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체의 수가 줄어서 스캔해야 하는 메모리 영역과 빈도수 역시 줄어들 것이고, GC가 수행되어도 지연 시간을 줄일 수 있을 것이다.


- interface와 abstract class
    - 인터페이스
        - 생성자를 가질 수 없어 객체화가 불가능
        - 디폴트 메서드 + 추상메서드로 구성
        - 다중 상속이 가능

    - 추상클래스
        - 생성자를 가지기 때문에 객체화가 가능
        - 필드를 가질 수 있다
        - 다중 상속 불가

    -> 인터페이스를 사용하는 이유를 협업이라고 하기도한다. 하나의 규격을 만들어 놓으면 협업이 가능하다.


- 인터페이스 vs 추상클래스
    - 인터페이스
        - 다중 구현 지원
        - 인터페이스끼리 다중 상속 지원
        - 상속에 얽메이지 않고, 공통 기능이 필요할 때마다 추상 메서드를 정의해놓고 구현하는 식으로 추상클래스보다 자유롭게 붙였다 땟다 사용 가능
        - 인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점

        - 자유로운 타입 묶음
            - 서로 논리적이지 않고 관련이 적은 클래스끼리 필요에 의해 형제 타입 처럼 묶어 버릴 수 있다.

        - 인터페이스 다형성 이용 설계
            - 추상클래스는 클라이언트에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌이라면,
              인터페이스는 반대로 먼저든 나중이든 그때 그때 필요에 따라 구현해서 자유롭게 붙였다 땟다하는 느낌

    - 추상 클래스
        - 단일 상속만 허용
        - 추상 메소드 외에 일반클래스와 같이 일반적인 필드, 메서드, 생성자를 가질수 있다.
          이러한 특징으로, 추상클래스는 추상화(추상 메서드)를 하면서 중복되는 클래스 멤버들을 통합 및 확장을 할 수 있다.
        - 같은 추상화인 인터페이스와 다른점은, 추상클래스는 클래스간의 연관 관계를 구축하는 것에 초점을 둔다.

        - 중복 멤버 통합
            - 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많아 중복 멤버 통합을 할 때
              상수 밖에 정의 못하는 인터페이스는 불가능

        - 추상클래스의 다형성 이용 설계
            - 클라이언트(ExamConsole)에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌

        - 명확한 계층 구조 추상화
            - 추상클래스나 인터페이스나 추상 메소드를 이용한 구현 원칙을 강제한다는 점은 같지만, 추상클래스는 '클래스로서' 클래스와 의미있는 연관 관계를 구축할때 사용된다
            - 의미있는 연관 관계란, 부모와 자식 간의 논리적으로 묶여있는 관계라고 보면 된다.

    -> 인터페이스 : impements 라는 키워드처럼 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌
       추상 클래스 : extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 느낌

    -> 가장 큰 특징이라고 할 수 있는 추상 클래스의 중복 멤버 통합과 인터페이스의 다중 상속 기능을 같이 사용하는 여러가지 코드 패턴들이 나왔고, 디자인 패턴의 근간이 됨.


- 람다식
    - 함수를 하나의 식(expression)으로 표현한 것이다. 이름이 없는 함수 익명 함수이기도 하다.
    - 정확히 말하면 함수형 인터페이스를 익명 클래스로 구현한 익명 구현 객체를 짧게 표현한 것
    - 불필요한 코드를 줄이고, 가독성을 높이기 위함. 컴파일러가 문맥을 살펴 타입을 추론


- stream vs for
    - for 문
        - java 1부터 지원
        - for (초기화; 조건; 후처리)

    - 향상된 for 문
        - java 5부터 지원
        - 가독성 up, 안정성 up

    - stream
        - java 8부터 지원
        - stream 생성 -> 중간 연산 -> 최종 연산

    - 둘 다 다량의 데이터 처리 작업에 사용

    - 차이점
        - 함수 객체 vs 코드 블럭
            - for 문은 코드 블록으로 표현
            - 스트림 파이프라인은 함수 객체로 표현 (람다 or 메서드 참조)
            -> 람다식에는 final 변수만 읽을 수 있기 때문에 지역 변수를 수정할 수 없다.
            -> for 문에서는 할 수 있는 continue, break 로직은 stream 에서는 할 수 없다.

        - 외부 반복 (how) vs 내부 반복 (what)
            - 외부 반복: for 문, 구체적인 구현 로직이 외부에 노출
            - 내부 반복: stream, 로직이 노출되지 x

        - 가독성
            ex) for 문의 경우 if 문의 중첩으로 인해 indent depth 가 깊어져 가독성이 떨어질 수 있으나
                stream 의 경우, 조건들을 filter 의 체이닝 형식을 통해 표현할 수 있기 때문에 보다 간결한 표현 가능

            ex) if 문의 중첩 만 있을 경우, 메서드 추출을 통해서 충분히 indent depth 를 줄여 가독성을 높일 수 있었음.
                하지만, for 문으로 요소를 순회하면서 return 을 하는 경우에는 메서드 추출을 통해 indent depth 를
                줄이는 것이 어려움.
                이런 경우, stream 을 이용하면 depth 를 줄여 가독성을 높일 수 있음.

            - 상황에 따라 stream 이 더 가독성이 안 좋을 수도 있음.

        - 디버깅
            - stream 은 많은 내부 수행 작업과 지연 연산으로 인해 디버깅이 다소 어려울 수 있다.
            - for 문은 예외가 발생하는 stack trace 가 간결하게 출력되서 디버깅에 유리할 수 있다.

        - 병렬 처리
            - for 문의 경우, Runnable 등을 활용해 병렬 처리를 위한 코드를 일일이 작성해야 함.
              로직이 복잡해질 경우 직접 구현하기도 까다롭고 신경쓸 것도 많아짐
              데이터들을 몇 개로 어떻게 나눌 것인지, 혹은 발생할 수 있는 동시성 문제가 있는지를 고려해야 한다.
            - stream 을 이용하면 위의 내용들을 stream 이 내부적으로 처리해 주기 때문에 보다 쉽게 병렬 처리 표현 가능

        - 성능
            - int 배열에서 for 문이 stream 보다 빠른 이유
                - for 는 나온지 오래된 만큼 stream 에 비해 JVM 에서 최적화가 충분히 이루어졌다.

                - stream 을 사용하려면 stream 객체를 생성해야 한다.
                  이 생성 과정에서 여러 작업들이 이루어지고 stream 에서 필요한 다른 객체를 생성하는데 오버헤드가 발생
                - for 는 추가적인 객체 생성 없이 인덱스를 통해서 메모리에 직접 접근을 하기 때문에
                  stream 에 비해 오베헤드가 발생하지 않는다.

            - 향상된 for 문에서는 원시타입 배열에 어떻게 접근 할까?
                - 향상된 for 문에서는 컬렉션을 순회할 때와 마찬가지로 iterator 를 이용할 것이라고 예상할 수 있지만
                  원시타입 배열이 들어온 경우에는 iterator 가 아닌 전통 for 문의 형식으로 바꾸어서 순회.
                  따라서 int 배열에 대한 작업에서는 전통 for 문과 향상된 for 문이 비슷한 성능을 보임

            - List 에서 성능 차이가 미미한 이유
                - int 배열은 요소들이 원시타입인 반면 컬렉션은 Wrapper 타입이 들어오게 된다.
                  그래서 박싱 및 언박싱에 대한 오버헤드가 발생한다. 이 오버헤드는 충분히 크기 때문에
                  컬렉션에 대한 성능은 이 오버헤드에 지배되면서 큰 성능 차이를 보이지 못함.

            => 하지만, 오늘날의 하드웨어는 충분히 빠르기 때문에 소프트웨어에서는 성능보다는 다른 점들을 더욱 신경쓰는 추세.
               유지보수, 가독성 등을 고려하는 것이 더욱 좋을 수 있음.

    - 결론
        - 가독성
            - 추상화된 api 를 제공하고, 보다 What 중심의 코드를 작성할 수 있어 가독성이 더 좋을 수 있다. (개인 차이 존재)

        - 디버깅
            - for 문에 비해 stream 이 디버깅이 어렵다.

        - 병렬 처리
            - 비교적 stream 을 이용한 병렬 처리가 간단하다.

        - 성능
            - for 문이 성능이 더 좋을 수 있다.

        - 스트림을 적용하기 좋은 조건
            - 원소들의 시퀀스를 일관되게 변환한다.
            - 원소들의 시퀀스를 필터링 한다.
            - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.
            - 원소들의 시퀀스를 컬렉션에 모은다.
            - 원소들의 시퀀스를 특정 조건을 만족하는 원소를 찾는다.

        => 어느 하나가 절대적으로 좋은 것이 아닌 각각의 장단점이 있다.
           따라서, 차이를 인지하고 이를 적절히 사용하는 것이 바람직하다.


- Stream 이란  https://hudi.blog/java-stream/
    JDK 8 버전부터 제공된 컬렉션 혹은 배열에 저장된 요소를 하나씩 참조하여 람다 표현식으로 처리할 수 있는 반복자이다. 스트림이 존재하기 이전에는 Iterator 인터페이스를 사용했다고 한다.

    람다 표현식
    스트림은 람다식으로 요소 처리 코드를 제공한다. 스트림이 제공하는 대부분의 요소 처리 메소드는 함수형 인터페이스를 사용하므로, 람다식으로 요소 처리 코드를 제공할 수 있다.

    생성, 중간처리, 최종처리
    후술하겠지만, 스트림의 처리는 생성, 중간처리, 최종처리 3단계로 구분된다.

    재사용 불가능
    스트림은 생성되고, 중간처리를 거쳐 최종처리까지 완료되면 닫히게된다. 이미 닫힌 스트림은 재사용할 수 없으며, 재사용을 시도할 경우 예외가 발생한다. 즉 스트림은 일회용이다.

    원본 데이터를 변경하지 않는다
    스트림은 원본 객체의 값을 사용하기만 할 뿐 변경하지 않는다. 스트림은 최종 처리를 통해 원본과 무관한 새로운 객체를 생성한다.

    - Stream은 Immutable 하다. 다시 말해 원본의 데이터를 변경하지 않는다.
    - Stream의 연산은 lazy 하다. 즉 필요 할 때만 연산함으로 효율적인 처리가 가능하다.
    - Stream은 재사용이 불가능하다.
    - Stream 생성, 중개연산, 최종연산 세 단계로 구분된다.

    - 원본 데이터를 변경하지 않는다.
        스트림은 연산 과정 중 데이터 시퀀스를 변경하지 않습니다.

    - 일회용이다.
        생성된 스트림은 Iterator처럼 일회용입니다. 스트림을 종단 연산을 통하여 최종 결과를 반환받을 경우 스트림이 닫히게 되며, 재사용(종단 연산 호출) 할 수 없습니다.

    - 중간 연산과 종단 연산
        스트림의 연산은 중간 연산과 종단 연산으로 구분이 됩니다. 이러한 중간 연산과 종단 연산으로 구성한 연산을 통하여 데이터 시퀀스를 처리하는
        연산 단계를 스트림 파이프라인 이라고 부릅니다. 스트림 파이프라인은 최종적으로 종단 연산으로 끝나여 하며 그 사이에 0개 이상의 중간 연산이 존재할 수 있습니다.
        중간 연산은 모두 한 스트림을 집계 연산을 거친 후 다른 스트림으로 반환하는 역할. 스트림을 반환하기 때문에 또 다른 중간 연산으로 연결(체이닝) 가능

    - 지연 연산
        종단 연산이 없는 스트림 파이프는 아무런 동작을 하지 않습니다.

    - 순차 수행 및 병렬 수행
        스트림은 데이터들의 흐름이다. 일반적으로 스트림에서는 이러한 흐름이 한 방향으로만 흐르며 순차적으로 처리되는 방식으로 구성
        하지만 처리해야 하는 데이터가 많을 경우 데이터 스퀀스들을 분할(fork)하여 처리한 후 취함(join)하는 방식의 병렬 수행을 지원
        기본적으로 병렬 수행을 할 경우 ForkJoinPool을 이용하여 수행
        멀티 쓰레드 비용, 데이터를 분할하고 순서가 보존되어야 하는 연산의 경우 취합 과정의 비용 등을 고려하여 선택해야 한다.


- 스트림 지연 연산과 최적화   https://bugoverdose.github.io/development/stream-lazy-evaluation/
    - 지연 연산과 최적화
        지연 연산이란 결과값이 필요할 때까지 계산을 늦추는 기법
        스트림 파이프라인을 실행하게 되면 JVM은 곧바로 스트림 연산을 실행시키지 않는다. 그 대신 최소한의 필수적인 적업만을 수행하고자,
        즉 지연 연산을 위한 준비작업을 수행한다. 이 준비 작업이란 우선 스트림 파이프라인이 어떠한 중간연산과 최종연산으로 구성되어 있는지에 대한 검사로 시작된다.
        이러한 검사 결과를 바탕으로 JVM은 사전에 어떠한 방식으로 최적화를 진행할지 미리 계획하고, 그 계획에 따라 스트림의 개별 요소에 대한 스트림 연산을 수행한다.

        스트림에서 제공하는 최적화 전략으로는 루프퓨전과 쇼트서킷이 대표적이다.

    - 루프퓨전
        파이프라인에서 연속적으로 체이닝된 복수의 스트림 연산을 하나의 연산 과정으로 병합시키는 것.
        복수의 스트림 연산이 하나로 병합되는 것을 최적화라고 볼 수 있는 이유는 기본적으로 개별 스트림 요소에 접근하는 횟수가 최소화되기 때문.
        만약 루프병합이 일어나지 않는다면 개별 스트림 연산에서 매번 스트림의 요소를 처음부터 다 순회해야함.

    - 쇼트서킷
        불필요한 연산을 의도적으로 수행하지 않음으로써 실행 속도를 높이는 기법.
        limit과 같은 연산을 활용하여 스트림의 일부 요소들에 대한 연산을 완전히 생략하는 것을 의미.

    - 제약사항
        연산의 종류에 따라 스트림 파이프라인 전체에 대해 루프퓨전이 일어나지 않는 경우도 존재한다.
            ex) 파이프라인 중간에 sorted를 통한 정렬 작업이 추가되면 스트림을 구성하는 모든 요소 순회

        상황에 따라 루프병합이 발생하지 않을 수 있다는 점은 무한스트림에서 특히 문제가 될 수 있다.
        예를 들어 생성될 때 임의의 정수값을 필드로 지니는 객체들로 구성된 무한스트림에 대해 limit(5)로 첫 5개의 데이터를 고르고,
        해당 5개의 요소들을 sorted로 정렬하려는 경우를 생각해보자. 만일 limit와 sorted의 순서를 반대로 적용한다면
        기본적으로 서버가 다운될 때까지 연산은 종료되지 않을 것이다.
        sorted 작업 자체가 종료되지 않는 것이 아니라, sorted에 전달할 스트림을 준비하는 작업이 끝나지 않는다는 것이다.

    -> 스트림은 지연 연산을 기반으로 한 루프퓨전과 쇼트서킷 등의 최적화 덕분에 스트림의 요소들은 하나씩 스트림 파이프라인에 입력되며
       개별적으로 모든 작업이 수행되는 방식으로 동작할 수 있는 것.


- 자바 LTS(Long-Term Support) 버전별 특징 (8, 11, 17)
    - Java 8
        - 인터페이스에 디폴트 메소드와 정적 메소드
        - 함수형 인터페이스
        - 람다 표현식
        - Stream API
        - Date and Time API
            - LocalDate, LocalTime, LocalDateTime 등의 라이브러리를 통해 기존보다 훨씬 쉽게 날짜 관련 로직을 작성할 수 있게 되었다.
            - 기존에 사용하던 날짜 관련 클래스인 Date, Calendar 등은 가변 객체이므로 Thread-Safe하지 않다.
        - Optional
        - 배열 정렬의 병렬 처리
            - Arrays.parallelSort() 를 통해 병렬적으로 배열을 정렬
        - Java 8의 Default GC는 Paralle GC

    - Java 11
        - String, FIles 클래스에 메소드 추가
        - 자바 파일 실행
        - default GC 변경 - G1GC

        - String 클래스에 새로운 메소드 추가
            - strip(): 문자열 앞, 뒤의 공백 제거.
            - stripLeading(): 문자열 앞의 공백 제거.
            - stripTrailing(): 문자열 뒤의 공백 제거.
            - isBlank(): 문자열이 비어있거나, 공백만 포함되어 있을 경우 true를 반환한다.
                - String.trim().isEmpty() 와 결과가 동일함.
            - repeat(n): n개만큼 문자열을 반복하여 붙여서 반환함.

        - Files 클래스에 새로운 메소드 추가
            - writeString: 파일에 문자열을 작성하고 Path로 반환
            - readString: 파일 전체 내용을 읽어서 String으로 반환
            - isSameFile: 두 Path가 같은 파일 체크

        - 컬렉션의 toArray() 메소드를 오버 로딩하는 메소드가 추가
            - 원하는 타입의 배열을 선택하여 반환 가능
                List sampleList = Arrays.asList("Java", "Kotlin");
                String[] sampleArray = sampleList.toArray(String[]::new);

        - 자바 파일 실행
            - javac를 통해 컴파일 하지 않고도, 바로 java 파일을 실행할 수 있게 되었다.
                // Java 11 이전
                $ javac HelloWorld.java
                $ java Helloworld
                Hello Java 8!

                // Java 11 이후
                $ java HelloWorld.java
                Hello Java 11!

            - 이전 java는 소스를 컴파일하여 class로 뽑은 후 class를 실행했는데 java를 통해 바로 실행할 수 있게 되었다.

        - Java 11의 Default GC는 G1 GC

    - Java 17
        - Pattern Matching for switch (Preview)
            - 이제 객체를 전달하여 기능을 전환하고 특정 유형을 확인할 수 있다.
        - Foreign Function & Memory API (Incubator)
            - Java Native Interface(JNI)를 대체
            - 기본 함수를 호출하고 JVM 외부의 메모리에 액세스
        - Sealed Classes (Finalized) (자바 15)
        - RandomGenerator(의사난수 생성기)
        - ZGC 도입 (자바 15)
        - NullPointerException이 어떤 변수에 의해 발생했는지 설명 (자바 14)


- Java Development Kit (JDK) 버전별 변화( 8 ~ 17까지)   https://catsbi.oopy.io/d7f0502c-5ec3-4b8b-a99b-5f61c1097093
    - JDK 8
        - 람다식: 함수형 프로그래밍을 위한 람다식 추가
        - Stream API: 컬렉션 처리를 위한 Stream API 추가
        - 메서드 참조: 람다식을 더 간결하게 표현하는 메서드 참조 추가
        - Optional 클래스: null 체크를 간편하게 도와주는 Optional 클래스 추가

        함수형 프로그래밍을 위한 람다식과 Stream API가 추가되었다. 람다식은 함수형 프로그래밍을 위한 기능으로, 코드를 더욱 간결하고 가독성 있게
        작성할 수 있게 해준다. 또한 Stream API는 컬렉션 처리를 위한 API로, 병렬 처리가 가능하며, 많은 양의 데이터를 처리할 때 유용하다.
        또한 메서드 참조와 Optional 클래스도 추가되었으며, 코드를 더욱 간결하게 작성할 수 있게 해준다.

    - JDK 11
        - HTTP 클라이언트: HTTP/2를 지원하는 HTTP 클라이언트 추가
            - HTTP/2를 지원하는 HTTP 클라이언트가 추가되었다. 이를 사용하면 HTTP/2를 지원하는 서버와 더욱 빠르고 안전하게 통신할 수 있게 되었다.

        - 로컬 변수 문법 개선: var 키워드로 로컬 변수를 선언할 때 초기화 구문이 없어도 됨
            - 타입을 명시하지 않아도 적절한 타입으로 추론할 수 있게 됌
            ⇒ 하지만 var 키워드를 남용하면 코드의 가독성을 떨어뜨릴 수 있으므로, 적절하게 사용해야한다.
              또한 var 키워드를 사용하면 변수의 타입을 명시적으로 지정하지 않으므로, 변수의 용도나 목적에 대한 이해가 필요합니다.

        이번 버전에서는 HTTP/2를 지원하는 HTTP 클라이언트와 로컬 변수 문법 개선 기능이 추가됌.
        HTTP 클라이언트는 HTTP/2를 지원하기 때문에 더욱 빠르고 안전한 웹 개발이 가능해졌으며, 로컬 변수를 선언할 때 초기화 구문이 없어도 되도록
        개선되었기 때문에, 코드를 더욱 간결하고 가독성 있게 작성할 수 있게 해준다.

    - JDK 17
        - Pattern Matching for switch 업데이트 (Preview)
            switch 문에서 pattern matching을 사용할 수 있도록 한다.

        - Pattern Matching for instanceof (Second Preview)
            instanceof 연산자에서 pattern matching을 사용할 수 있도록 한다.

        - 향상된 난수 생성

        - Sealed 클래스 업데이트
            sealed 클래스의 경우 클래스의 상속 계층 구조를 미리 선언할 수 있도록 한다.
            이를 통해 클래스의 확장성과 보안성을 높일 수 있다.

        - Vector API 업데이트

        - Foreign Function and Memory API 업데이트 (Incubator)