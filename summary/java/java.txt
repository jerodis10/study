- 멀티 쓰레드 프로그래밍을 개발할 때 주의해야 할 점
    - 공유 데이터를 사용하는 코드 영역인 임계구역에서 서로 다른 쓰레드가 간섭하지 않도록 쓰레드를 동기화 시켜 신뢰성 있는 데이터와 로직이
      산출(?)될 수 있게끔 코드를 작성해야합니다. 락을 거는 행위는 성능에 영향을 미치고 데드락을 유발할 수도 있으니 조심해야 합니다.

- 쓰레드를 구현하기 위한 인터페이스, 클래스
    Runnable 인터페이스를 사용하여 람다 혹은 내부크래스로 run() 메서드 구현
    새로운 클래스를 정의하고 Thread 클래스를 상속받은 후 run() 메서드 구현

    다른 클래스를 상속받지 않아도 될 때 => Thread 클래스 상속 후 구현
    Thread 클래스에 존재하는 다른 메소드들도 사용하고 싶을 때 => Thread 클래스 상속 후ㄱ 구현
    그외는 Runnable 구현

- 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object 클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다.
  이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
    - equals()란?
        - equals 메소드는 기본적으로 2개의 객체가 동일한지 검사하기 위해 사용
        - 2개의 객체가 참조하는 것이 동일한지를 확인하는 것이며, 이는 동일성(Identity)을 비교하는 것
        - 동일한 메모리 주소일 경우에만 동일한 객체가 된다.

        - 하지만 프로그래밍을 하다보면 동일한 객체가 메모리 상에 여러 개 띄워져있는 경우가 있다. 해당 객체는 서로 다른 메모리에
          띄워져있으므로 동일한(Identity) 객체가 아니다. 하지만 프로그래밍 상으로는 같은 값을 지니므로 같은 객체로 인식되어야 하는데,
          이러한 동등성(Equality)를 위해 우리는 값으로 객체를 비교하도록 equals 메소드를 오버라이딩해주는 것이다.

    - hashCode()란?
        - 실행 중에(Runtime) 객체의 유일한 integer 값을 반환
        - Object 클래스에서는 heap 에 저장된 객체의 메모리 주소를 반환하도록 되어있다. (항상 그런 것은 아니다.)
        - hashCode 는 HashTable 과 같은 자료구조를 사용할 때 데이터가 저장되는 위치를 결정하기 위해 사용된다.

    - equals 와 hashCode 의 관계
        - 동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다. 그렇기 때문에
          우리가 equals() 메소드를 오버라이드 한다면, hashCode() 메소드도 함께 오버라이드 되어야 한다.
        - Java 프로그램을 실행하는 동안 equals 에 사용된 정보가 수정되지 않았다면, hashCode 는 항상 동일한 정수값을 반환해야 한다.
          (Java 의 프로그램을 실행할 때 마다 달라지는 것은 상관이 없다.)
          두 객체가 equals()에 의해 동일하다면, 두 객체의 hashCode() 값도 일치해야 한다.
          두 객체가 equals()에 의해 동일하지 않다면, 두 객체의 hashCode() 값은 일치하지 않아도 된다.

    - hashCode() Override 의 필요성
        - hashCode 를 equals 와 함께 재정의하지 않으면 코드가 예상과 다르게 작동하는 위와 같은 문제를 일으킨다.
          정확히 말하면 hash 값을 사용하는 Collection(HashSet, HashMap, HashTable)을 사용할 때 문제가 발생
        - hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true 여야 논리적으로 같은 객체라고 판단한다.
          hashCode 메서드가 재정의 되어있지 않으면 Object 클래스의 hashCode 메서드가 사용됨
        - intellij 의 Generate 기능을 사용했더니 Objects.hash 메서드를 호출하는 로직으로 hashCode 메서드가 재정의 됐다.
          Objects.hash 메서드는 hashCode 메서드를 재정의하기 위해 간편히 사용할 수 있는 메서드이지만 속도가 느리다.
          인자를 담기 위한 배열이 만들어지고 인자 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다.
          성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제 없다.
          민감한 경우에는 직접 재정의해주는 게 좋다.

        - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode 가 서로 다른 값을 반환할 필요는 없다.
          단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.
        - HashMap 의 구현은 해시 코드가 다른 엔트리끼리는 동치성 비교 자체를 하지 않도록 최적화 되어 있다.
        - hashCode 를 만드는 해시 함수를 equals 메소드를 재정의할 때 사용한 필드와 같은 필드를 사용하자.
        - 만약 객체는 같은 해시 코드를 가지게 되면 전부 같은 버킷에 해시되므로 해시 테이블은 아주 긴 링크드 리스트가 많이 생기게 될 것
        - 해시 테이블(hash table)의 평균 시간 복잡도는 O(1)이고, 최악의 로직을 가진 해시 테이블의 시간 복잡도는 O(n) 이다.
        - 만약 이 해시 테이블이 해시 충돌(hash collision) 해결을 해시 체이닝(hash chaining) 방식으로 구현했다면,
          실제 링크드 리스트(linked list) 처럼 동작한다.

    - 만약 ORM 을 사용하고 있는 경우라면, hashCode 와 equals 를 오버라이드 하는 메소드 내부에서 Getter 를 사용하기를 권장한다.
      그 이유는 ORM 에 의해 fields 가 Lazy Loaded 되어, getter 를 부르기 전에는 사용이 불가능할 수 있기 때문이다.

    - HashMap 내부 구현
        - 해싱함수를 통해 인덱스를 산출
        - 인덱스를 통한 접근으로 시간복잡도 O(1)의 빠른 성능
        - key 는 무한하지만 인덱스는 한정되어 있어 충돌은 불가피
        - 충돌을 줄이기 위해 HashMap 은 버킷의 사이즈를 조절
        - 충돌이 일어날 시, 충돌 수가 적으면 LinkedList 방식으로 충돌된 객체들을 관리하다가 임계점을 넘으면 Red-Black Tree 방식으로
          객체들을 저장
        - https://lordofkangs.tistory.com/78

    - https://velog.io/@tamxt4047/equals-hashCode
    - https://camel-context.tistory.com/52

- StringBuilder 와 StringBuffer 의 차이는 무엇일까요?
    - 연산이 많지 않을때는 위에 나열된 어떤 클래스를 사용하더라도 이슈가 발생할 가능성은 거의 없습니다. 그러나 연산횟수가 많아지거나
      멀티쓰레드, Race condition 등의 상황이 자주 발생 한다면 각 클래스의 특징을 이해하고 상황에 맞는 적절한 클래스를 사용해 주셔야 합니다

    - String  vs  StringBuffer/StringBuilder
        - String 클래스는 불변하기 때문에 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성된
        - 새로운 메모리영역을 가리키게 변경되고 처음 선언했던 "hello"로 값이 할당되어 있던 메모리 영역은 Garbage 로 남아있다가
          GC(garbage collection)에 의해 사라지게 되는 것
        - String 은 불변성을 가지기 때문에 변하지 않는 문자열을 자주 읽어들이는 경우 String 을 사용해 주시면 좋은 성능을 기대
        - 문자열 추가,수정,삭제 등의 연산이 빈번하게 발생하는 알고리즘에 String 클래스를 사용하면 힙 메모리(Heap)에
          많은 임시 가비지(Garbage)가 생성되어 힙메모리가 부족으로 어플리케이션 성능에 치명적인 영향을 끼치게 됩니다.
        - String 과는 반대로 StringBuffer/StringBuilder 는 가변성 가지기 때문에
          .append() .delete() 등의 API 를 이용하여 동일 객체내에서 문자열을 변경하는 것이 가능

    - StringBuffer  vs  StringBuilder
        - 가장 큰 차이점은 동기화의 유무
        - StringBuffer 는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다는 점
            - 참고로 String 도 불변성을 가지기때문에 마찬가지로  멀티쓰레드 환경에서의 안정성(thread-safe)을 가지고 있습니다.
        - StringBuilder 는 동기화를 지원하지 않기때문에 멀티쓰레드 환경에서 사용하는 것은 적합하지 않지만 동기화를 고려하지 않는 만큼
          단일쓰레드에서의 성능은 StringBuffer 보다 뛰어납니다.

    String          :  문자열 연산이 적고 멀티쓰레드 환경일 경우
    StringBuffer    :  문자열 연산이 많고 멀티쓰레드 환경일 경우
    StringBuilder   :  문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우

- System.out.println 메소드는 현업에서 절대 쓰지 말라고하는 메소드인데요. 그 이유가 무엇일까요?
    - 휘발된다.
        - System.out.println() 은 로그가 표준 출력으로 출력된다. 즉, 파일로 저장되지 않고 휘발된다는 의미이다.
          로그는 에러가 발생한 상황을 기록하고, 추후 확인하여 문제를 진단하고, 재현하고, 고치기 위해 사용된다.
          하지만 표준 출력으로 한번 출력되고 어디에도 저장되지 않으면 로그의 제 역할을 할 수 없다.
    - 에러 발생 시 추적할 수 있는 최소한의 정보가 남지 않는다.
        - System.out.println() 은 인자로 전달한 문자열만을 출력한다.
          문제가 발생한 날짜, 시각 그리고 문제의 수준, 로그가 발생한 위치 등 최소한의 정보가 기록되지 않는다는 것 이다.
    - 로그 출력 레벨을 사용할 수 없다.
        - 로컬에서 개발할 때에는 디버깅을 위한 아주 상세한 정보가 출력되어 확인할 수 있어야한다. 하지만, 프로덕션에서 동작하는 코드는
          에러/장애가 발생할 때 문제를 진단할 수 있는 정보만을 남겨야한다. 개발시에만 사용되는 정보와 문제 상황에 대한 정보가
          함께 로깅된다면 문제 해결을 위한 정작 중요한 정보를 얻기 힘들 뿐더러, 민감한 정보를 로그로 남길수도 있기 때문이다.
          또한 의미없는 로그가 쌓여 서버 용량을 차지할 수도 있다.
        - 따라서 로깅 라이브러리는 환경에 맞게(로컬 개발 환경, 개발 서버, 프로덕션 서버 등) 로그가 출력될 수 있도록 로그 출력 레벨이라는
          기능을 제공한다. 많이 사용되는 Logback 이라는 라이브러리에서는 TRACE, DEBUG, INFO, WARN, ERROR, FATAL 와
          같은 레벨을 제공한다. 하지만 System.out.println() 은 이런 기능을 제공하지 않는다. 어떤 환경에서든 동일한 로그가 출력된다.
          프로덕션에서 이런 로그를 제거하려면 코드를 일일히 제거하거나 주석처리하거나 별도의 조건문을 설정하는 등 번거로운 일들을 해야한다.
    - 성능저하의 원인이 될 수 있다.
        - System.out.println() 의 구현을 한번 살펴보자.
        - println() 은 newLine() 을 호출한다. newLine() 의 구현도 살펴보자.
        - synchronized 키워드가 붙어있다. 이때 newLine() 메소드는 임계영역(critical section)이 된다. 멀티 쓰레드 환경에서
          A 쓰레드가 newLine() 메소드를 실행하면, 메소드는 잠기게 된다. 다른 쓰레드는 A 쓰레드가 모두 사용하고 잠금을 풀어준 뒤에서야
          newLine() 메소드를 실행할 수 있다. 오버헤드가 발생하게 되는 것이다.
        - 스프링을 실행하는 톰캣은 멀티 쓰레드로 동작한다. 요청이 오면 쓰레드 풀에서 쓰레드를 하나 가져와 요청을 처리한다. 그런데,
          System.out.println() 을 여러 쓰레드가 사용하면 그만큼 위에서 이야기한 오버헤드가 발생하고 처리가 느려질 것 이다.
          따라서 실제 프로덕트의 코드에서는 System.out.println() 을 절대 사용해서는 안된다.

    - synchronized 키워드는 왜 현업에서 큰 성능 저하를 일으킬 수 있을까요?
      Blocking IO는 왜 성능을 저하시킬 수 있을까요?
      synchronized 가 Blocking IO 와 만나면 어떻게 환장의 성능하락을 만들 수 있는걸까요?
      이 두 개가 만났을 때 스레드가 어떻게 동작할지, CPU 사용률은 어떻게 될지 시뮬레이션을 해보세요.

- ArrayList 는 내부적으로 어떻게 구현되어있을까요?
    - ArrayList 는 배열을 좀 더 편하게 쓸수있도록 Java 에서 제공해주는 Class 입니다. 일반 배열과는 다르게 메모리가 가능한한
      추가할 수 있고 삭제에 대해서도 해당 index 를 비워두기만 하는게 아니라 재정렬해주는 기능을 기본으로 제공해주고 있습니다.
    - ArrayList 는 새 요소를 추가하고자 할 때, capacity 가 기존 배열의 크기와 같아지면 기존 용량의 1.5배만큼 증가시키고 그 크기가 늘어난
      배열에 기존 elementData 를 copy 한다. 실제로는 정적 배열을 사용하지만, 요소가 추가될 때마다 최소 증가량을 계산하여 크기를 늘리는 방식
    - 자료를 대량으로 추가하거나 삭제하면 내부 처리 작업이 늘어나서 성능이 떨어질 수 있다.
    - add: 실제로 배열의 크기를 재산정하고 기존(old)에 있던 정보를 새로운 배열(new)에 넣는 메서드입니다.
           크기를 재산정 할때는 원래크기만큼 새로운 배열에 복사를 해야하므로 시간복잡도 O(n)을 가지며 추가할 때 O(1)
    - remove: remove 메서드를 실행하면 가장 먼저 입력받은 index 가 적절한 값인지 체크합니다. 그리고 삭제되는 Object 의 값을 가져와서
              변수에 담습니다. 그 후 arraycopy 를 이용해 삭제되는 부분 + 1 ~ 마지막까지의 영역을 삭제되는 부분의 시작점을 기준으로
              해서 옮깁니다. 그러면 삭제될 부분의 값은 다음 index 의 값으로 겹쳐서 덮여 쓰여지게 됩니다. 그리고 size 의 마지막 index 는
              size - 1의 값과 중복되기 때문에 null 처리를 하여 GC가 삭제할 수 있도록 합니다. 그 후 임시 변수에 담아두었던
              삭제된 값을 리턴합니다.
              삭제를 할때 우리는 index + 1에서 부터의 값을 index 부터 시작하게끔 복사한다는 것을 알 수 있었습니다. 그때 O(n)의
              시간복잡도를 가지며 마지막 값을 null 로 변경해줍니다. 이때는 O(1)을 가지겠죠. 삭제에 대해서는 항상
              시간복잡도 O(n)을 가진다는 것을 알 수 있습니다.

- 스레드는 왜 써야하는 것일까요? https://cbw1030.tistory.com/282,  https://www.crocus.co.kr/1510
    - 프로세스는 실행중인 프로그램이다. 즉, 메모리에 올라간 상태이다.
    - 쓰레드는 실행 흐름(절차)을 갖는 줄이다. 즉, 프로세스 내에서 실행 흐름을 의미한다. 프로세스 내의 명령어 블록으로 시작점과 종료점을 가짐.
    - 자바에서 스레드를 사용하는 이유
        - 동시에 두 가지 이상의 활동을 하기 위함이다.
        - 그리고 프로세스끄리는 정보를 주고 받을 수는 없지만, 다중 스레드 작업 시에 각 스레드끼리는 정보를 주고받을 수 있는 장점이 있다.
    - 스레드 사용 이유
        - 운영체제는 시스템 작업을 효율적으로 관리하기 위해 스레드를 이용한다.
        - 즉, 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행하게 되면 프로세스를 생성하여 자원을 할당하는 과정도 줄어들 뿐더러
          프로세스를 컨텍스트 스위칭(Context Switching)하는 것 보다 오버헤드를 더 줄일 수 있게 된다.
        - 뿐만 아니라 프로세스간의 통신 비용보다 하나의 프로세스 내에서 여러 스레드간의 통신 비용이 훨씬 적으므로 작업들 간의 통신 부담을 줄일 수 있게 된다.
        - 멀티스레드를 사용하는 큰 이유 중의 하나가 바로 다중 CPU 하드웨어를 충분히 활용하고자 하는 것이다.
    - 스레드가 프로세스보다 안좋을 때
        - 멀티 프로세스 구조에서 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 자식 프로세스 하나만 죽는다 해서 다른 곳에 영향을 끼치지는 않는다.
          하지만 멀티 스레드 구조에서 자식 스레드중 하나에 문제가 생긴 경우에는 전체 프로세스가 영향을 받게 된다.(ex : thread I/O)
          그리고 멀티 스레딩을 너무 자주 사용하게 된다면 컨텍스트 스위칭의 비용이 상당히 높기 때문에 오히려 시스템 성능 저하를 초래 할 수도 있고
          메모리가 공유되기 때문에 안정성 및 보안을 좀 더 추구하는 경우에는 멀티 스레드보단 멀티 프로세싱이 더 좋다.
        - 메모리 구분이 필요할 경우에는 멀티프로세스가 유리하고, 컨텍스트 스위칭이 자주 일어나고 데이터 공유가 빈번하면 멀티 스레드를 사용하는것이 유리합니다.
    - 특징  https://jungwoong.tistory.com/45, https://olivejua-develop.tistory.com/68
        - 메모리 영역을 공유를 하기 때문에 메모리 공간과 시스템 자원 소모가 줄어들게 되며,
          멀티 프로세스와 다르게 캐시메모리를 초기화할 필요가 없기 때문에 컨텍스트 스위칭 연산이 빠릅니다.
        - 스레드간의 자원을 공유하기 때문에 동기화 문제가 발생할 수 있기 때문에 주의깊은 설계가 필요합니다.
        - 하나의 스레드가 문제가 생기면 프로세스내의 다른 스레드에도 문제가 생길 수 있습니다.
        - 쓰레드가 프로세스보다 컨텍스트 스위칭이 빠른 이유는 메모리 영역을 공유하기 때문이다. 실제로 공유되는 데이터가 있고 아닌 데이터가 있다.


- 0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?

- 자바에서 동시성과 관련된 예약어를 모두 말씀해주세요.

- Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.

- Serializable 은 무엇일까요?

- GC란 무엇이고, 왜 써야할까요?

- 잘 운영하고 있던 어플리케이션이 갑자기 Out of Memory Error(OOM)를 내며 프로세스가 종료되었습니다. 어떻게 대처해볼 수 있을까요?

- 서비스를 운영하면 모니터링을 해야할 일이 많은데 어떤 툴들을 사용해볼 수 있을까요?

- JIT 컴파일러란 무엇이고, 이것은 왜 필요할까요?

- 힙에 메모리를 할당하는 과정에서 어떤 일들이 벌어지나요?

