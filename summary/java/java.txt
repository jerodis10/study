- 객체 지향 프로그래밍의 특징   https://blog.itcode.dev/posts/2021/08/07/what-is-oop
    - 추상화
    - 객체 연결
    - 4 원칙
    - SOLID
    - 디자인패턴

    객체란 현실 세계에 존재하는 것들에서 속성과 동작을 추려내서 필드와 메소드로 정의한 것.
    객체 지향은 이러한 객체들을 연결시켜 프로그래밍 함으로써
    캡슐화, 추상화, 다형성, 상속을 이용해
    역할과 구현을 구분을 통한 느슨한 관계 설정으로 보다 유연하고 변경이 용이한 프로그램 설계를 가능하게 만들었습니다.


- OOP 의 4가지 특징   https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95
    - 캡슐화(encapsulation)
        - 은닉화
        - 응집도, 독립성

        객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호 작용하도록 유도
        객체의 응집도와 독립성을 높임으로써 객체의 모듈화 지향

        클래스의 내부 변수와 메소드를 하나로 패키징
        여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항 반영 가능
        접근제어자를 통해 객체의 캡슐화, 은닉화를 구현

    - 추상화(Abstraciton)
        - 공통
        - 추상 클래스, 인터페이스

        객체의 공통적인 속성과 기능을 추출하여 정의하는 것
        자바에서는 추상 클래스와 인터페이스를 통해 추상화를 구현

    - 다형성(polymorphism)
        - 참조
        - 오버라이딩, 오버로딩

        - 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것
        - 대표적인 예로 우리가 앞서 본 메서드 오버라이딩과 메서드 오버로딩(method overloading)이 있습니다.

        - 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것

    - 상속(inherutance)
        - 요소 상속
        - 공통 추출

        자식 클래스가 부모 클래스의 기능을 그대로 물려받는 것
        객체가 다른 객체를 상속받아 상속받은 객체의 요소를 사용하는 것.
        클래스들 간 공유하는 속성과 기능들을 추출하여 반복적인 코드 최소화

        - 상속 재사용의 단점
            - 상위 클래스(부모 클래스)의 변경이 어려워진다.
                부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경이 필요하다면? 이를 의존하는 자식 클래스들이 영향을 받게 된다.

            - 불필요한 클래스가 증가할 수 있다.
                유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.

            - 상속이 잘못 사용될 수 있다.
                같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다. 상속 받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때 이에 해당한다.

        - 해결책은?
            - 객체 조립(Composition), 컴포지션 ??
                객체 조립은, 필드에서 다른 객체를 참조하는 방식으로 구현
                상속에 비해 비교적 런타임 구조가 복잡해지고, 구현이 어려운 단점이 존재하지만 변경 시 유연함을 확보하는데 장점이 매우 크다.
                따라서 같은 종류가 아닌 클래스를 상속하고 싶을 때는 객체 조립을 우선적으로 적용하는 것이 좋다.

        - 그럼 상속은 언제 사용?
            - IS-A 관계가 성립할 때
            - 재사용 관점이 아닌, 기능의 확장 관점일 때


- 객체지향의 설계 원칙 (SOLID)
    SOLID 객체 지향 원칙을 적용하면 코드를 확장하고 유지 보수 관리하기가 더 쉬워지며,
    불필요한 복잡성을 제거해 리팩토링에 소요되는 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있다.

    - SRP(Single Responsibility) - 단일 책임 원칙
        한 클래스는 하나의 책임만 가져야 한다.
        이를 지키지 않으면, 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.

    - OCP(Open-Closed) - 개방-폐쇄 원칙
        확장에는 열려있고, 수정에는 닫혀있어야 한다.
        기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
        이를 지키지 않으면, instanceof와 같은 연산자를 사용하거나 다운 캐스팅이 일어난다.

    - LSP(Liskov Substitution) - 리스코프 치환 원칙
        상위 타입은 항상 하위 타입으로 대체할 수 있어야 한다.
        상속 관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.

        자식 클래스가 부모 클래스의 메소드 시그니처를 자기 멋대로 변경하거나,
        자식 클래스가 부모 클래스의 의도와 다르게 메소드를 오버라이딩 하는 경우 LSP 위반

    - ISP(Interface Segregation) - 인터페이스 분리 원칙
        인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
        각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.

        인터페이스 내에 메소드는 최소한 일수록 좋다.
        (하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.)
        SRP와 같은 문제에 대한 두 가지 다른 해결책이다.

    - DIP(Dependency Inversion) - 의존관계 역전 원칙
        구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라.
        DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.


- 객체지향 5원칙(SOLID) 중 본인이 가장 중요하다고 생각하는 원칙에 대해 설명하시오.
    5가지의 객체 지향 설계 원칙인 SOLID가 얘기하는 핵심은 결국 추상화와 다형성이다.
    DIP를 통해 구체 클래스에 의존하지 않고 추상 클래스(또는 인터페이스)에 의존함으로써 우리는 유연하고 확장가능한 애플리케이션을 만들 수 있는 것이다.
    다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙
    의존 역전 원칙이 위배되면 개방 폐쇄 원칙 역시 위배될 가능성이 높다.


- 접근제어자를 사용하는 이유
    접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
    데이터가 유효한 값을 유지하도록 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.
    객체 지향 개념에선 캡슐화(encapsulation)이라 한다.

    1) private : 같은 클래스 내에서만 접근 가능
    2) default : 같은 패키지 내에서만 접근 가능
    3) protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
    4) public : 접근 제한이 전혀 없다.


- static을 사용하는 이유에 대해 설명해주세요.  https://tweety1121.tistory.com/entry/java-static-%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-static-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C
    인스턴스를 생성할 경우 각 인스턴스는 독립적이기 때문에 서로 다른 값을 유지한다.
    static을 사용하면 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문에 인스턴스들이 공통적으로 값을 유지해야할 때 사용한다.
    GC 관리 영역밖에 존재하기 때문에 자주 사용할 경우 퍼포먼스에 악영향을 줄 수 있다.


- static이란?
    Static(정적)은 고정된이라는 의미를 가지고 있으며,
    프로그램이 시작되는 시점에 클래스 로더가 클래스를 해석하여 메소드 영역 혹은 힙 영역에 클래스 메타 데이터 및 정적 변수 등을 적재한다.


- static은 어디에 저장되는가?
  java 8 이전에는 메소드 영역인 Permanent 영역, Java 8 이후에는 힙 영역에 저장된다.


- static 사용을 왜 지양해야 하는가?
  메모리 문제
  동시성 이슈 문제
  런타임 다형성 불가
  객체의 상태를 이용할 수 없다.
  테스트하기 어려움


- static은 언제 사용하는가?
  상수 정의
  유틸리티 클래스 정의


- main 메서드에 Static 이 생략되면 실행이 되나요?
    - 안됩니다. main 이라는 이름은 JVM에서 약속된 프로그램 시작을 의미하는 메서드입니다. Static이 선언되어 있지 않다면 메모리에 올라가 있지 않은
      상태이므로 JVM 은 main 메서드를 찾아서 실행 할 수 없게 됩니다.
        1) public : JVM이 어디서든 접근가능하도록 함.
        2) static : 메모리에 main 메서드를 올림.
        3) void : main의 반환 타입
        4) main :  JVM의 약속된 이름
        5) String[] args : command line parameter

    - 그렇다면 final 을 선언하면 어떻게 될까요? 메서드에 final 이 선언된다는 의미는 더이상 오버라이딩을 할 수 없다는 의미입니다.
      따라서 main 메서드를 실행하는 데는 아무 영향이 없습니다.


- 클래스 로딩 정리 ??   https://velog.io/@skyepodium/%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A1%9C%EB%94%A9%EB%90%98%EA%B3%A0-%EC%B4%88%EA%B8%B0%ED%99%94%EB%90%98%EB%8A%94%EA%B0%80#1-%EC%A0%95%EC%9D%98-1
    1) 클래스 로딩 시점
        클래스의 인스턴스 생성
        클래스의 정적 변수 사용 (단, 정적 변수는 final로 선언된 상수 x)
        클래스의 정적 메소드 호출

    2) 내부 클래스 로드 여부
        외부 클래스가 로딩 - 내부의 클래스 로딩 X
        내부 클래스만 로딩 - 외부의 클래스는 로딩 X

    - 초기화
        1) 정의
            클래스 초기화는 static 블록과 static 멤버 변수의 값을 할당하는 것을 의미합니다.
            내부의 클래스는 초기화 대상 x

        2) 언제 초기화 되는가
            클래스의 인스턴스 생성
            클래스의 정적 메소드 호출
            클래스의 정적 변수 할당
            클래스의 정적 변수 사용 (final x)

            사실 위의 클래스 로드 시점과 같습니다. 클래스가 로드되면 초기화도 바로 진행됩니다.

        3) 초기화 진행순서
            1. 정적 블록
            2. 정적 변수
            3. 생성자

        4) 오직 한번만 클래스가 로딩됨을 보장
            클래스가 로딩될때 초기화도 수행
            JVM에 클래스가 로딩되고 초기화될때는 순차적으로 동작함을 보장합니다.
            멀티 스레드 환경에서 여러개의 스레드가 클래스를 동시에 로딩하려고 오직 한개의 클래스만 로딩됩니다.
            10개의 스레드가 동시에 클래스 로딩을 시도해도 클래스 로딩은 한번만 수행되고, 그때 한번 초기화를 수행합니다.
            멀티 스레드 환경에서 스레드 세이프함을 의미

        5) 싱글톤 - LazyHolder
            클래스 로딩 및 초기화 과정이 스레드 세이프함을 이용하여 싱글톤 인스턴스를 만들 수 있다.
            장점
                스레드 세이프 (오직 1개의 싱글톤 인스턴스 생성)
                필요할때 인스턴스 생성(getInstance 메서드 호출 시점)
                모든 자바 버전에서 사용가능


- 자바의 참조형은 Call by Reference 인가??   https://bcp0109.tistory.com/360
    Call by Value 는 메서드를 호출할 때 값을 넘겨주고, Call by Reference 는 참조 (주소)를 직접 전달
    Call by Reference 는 참조 자체를 넘기기 때문에 새로운 객체를 할당하면 원본 변수도 영향을 받습니다.
    원시 타입 (Primitive Type) 은 Stack 영역에 변수와 함께 저장되며
    참조 타입 (Reference Type) 객체는 Heap 영역에 저장되고 Stack 영역에 있는 변수가 객체의 주소값을 갖고 있습니다.
    자바가 함수의 인자로 전달해주는 것은 어떤 것을 참조 하고 있는지에 대한 (복사된) 참조 값을 전달하기 때문이다.

    Call by value는 메소드를 호출할 때 넘겨주고 싶은 변수(인자)를 지정하면, 메소드의 매개변수가 지정한 변수 값의 복사본으로 초기화되는 것이다.
    Call by reference는 메소드를 호출할 때 넘겨주고 싶은 변수(인자)를 지정하면, 메소드의 매개변수가 지정한 변수의 레퍼런스로 초기화되는 것이다.

    Java에서 인자를 넘기는 과정에 직접적인 참조를 넘긴 게 아닌, 주소 값을 복사해서 넘기기 때문에 이는 Call by value이다.

- 자바 메모리 영역이 할당되는 시점은 언제인가요?
    - Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
    - Stack 영역 : 컴파일 타임 시 할당
    - Heap 영역 : 런타임시 할당

    ※ 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정
    ※ 런타임 : 컴파일 타임 이후 프로그램이 실행되는 때


- 메모리 주소만으로 Heap의 인스턴스에 접근할 수 있을까 ??
    - 접근할 수 없다
        - 개발자는 객체의 주소를 직접적으로 지정할 수 없다
            - JVM만이 객체가 메모리에 저장되어 있는 위치를 알고 있으며, 할당 작업을 실행하는 동안 해당 주소를 변수에 할당한다.

        - JVM만이 객체가 메모리에 저장되어 있는 위치를 아는 이유
            - 자바에선 변수의 메모리 주소를 얻는 것은 무의미하다.
            - 왜냐하면 JVM은 자유롭게 객체를 구현하고, GC를 이용해 그 객체의 위치를 이동시키기 때문


- 인터페이스 vs 추상클래스
    - 공통점
        - 추상 메소드를 가지고 있어야 한다.
        - 인스턴스화 할 수 없다 (new 생성자 사용 X)

    - 추상 클래스
        - 추상 메소드 외에 일반클래스와 같이 일반적인 필드, 메서드, 생성자를 가질수 있다.
        - 단일 상속만 허용
        - 추상화(추상 메서드)를 하면서 중복되는 클래스 멤버들을 통합 및 확장

    - 인터페이스
        - 상수와 추상메소드로 구성되며, JAVA 8 부터는 default 메소드와 static 메소드 또한 인터페이스의 멤버로 추가
        - 다중 상속 지원
        - 부모 자식 관계인 상속에 얽매이지 않고, 공통 기능이 필요할 때마다 추상 메서드를 정의해놓고 구현(implement)하는 식으로
          추상클래스보다 자유롭게 다형성 구현 가능


- 인터페이스 다중상속을 사용하는 경우(사용하는 이유)
    인터페이스는 다중 상속에 대해 제약을 받지 않기 때문에, 일부만 묶고 싶은 클래스들을 implements 키워드로 등록시키면,
    각기 다른 부모클래스를 상속하고 있는 자식 클래스에 인터페이스를 구현(상속) 시켜줌으로써 형제 클래스 끼리 묶는 타입 통합을 이루어 낼 수 있는 것이다.
    즉, 아무 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다.


- 마커 인터페이스 ??
    - 일반적인 인터페이스와 동일하지만 사실상 아무 메소드도 선언하지 않은 인터페이스
        ex) Serializable, Cloneable, Spring에서 event 리스너를 사용한다면 종종 보이는 EventListener

    - 대부분의 경우에는 단순한 타입 체크


- 오버로딩과 오버라이딩
    - 오버로딩
        - 동일 이름, 다른 매개변수 타입/개수

        - 매개변수의 개수나 타입의 순서를 다르게 하면, 하나의 이름으로 메소드를 여러 개 정의하는 것
        - 생성자 오버로딩은 동일한 이름을 가진 메소드들의 매개 변수의 타입 또는 개수가 모두 달라야 성립한다. ??

    - 오버라이딩
        - 상위 클래스의 메소드와 동일한 시그니처를 가진 메소드 재정의

        - 정의
            - 상위 클래스가 가지고 있는 메소드를 같은 이름의 메소드를 재정의 하는 것
        - 조건
            - 부모 클래스의 메소드와 동일한 시그니처를 가져야 한다.
            - 접근 제어자는 부모 클래스의 메소드보다 좁은 범위로 변경할 수 없다.
            - 부모 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.

    - 오버라이드한 메소드는 동적으로 선택되고, 오버로딩한 메소드는 정적으로 선택된다.


- 오버로딩이 무엇인가?
    오버로딩은 같은 이름의 메소드를 중복하여 정의하는 것을 의미한다. 즉, 서로 다른 메소드 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이라고 할 수 있다.


- 메소드 시그니처란?
    메소드 시그니처는 메소드의 이름과 매개변수 리스트의 조합을 말한다. 자바 컴파일러는 메소드 시그니처를 통해 메소드 간의 차이를 식별한다.


- 오버로딩의 장점
    유사한 기능을 하는 동일한 이름의 메소드가 묶여있기 때문에 메소드명을 절약할 수 있고 기능 예측이 쉬워져서 소스코드의 가독성이 향상된다는 장점이 있다.
    또한 매개변수 값에 따라 다양한 처리를 할 수 있으므로 다형성을 구현할 수 있다.


- 오버라이딩이 무엇인가?
    상속 관계에 있는 클래스 간에 같은 이름의 메소드를 정의하는 기술을 오버라이딩이라고 한다.


- 오버라이딩의 조건은?
    부모 클래스의 메소드와 동일한 시그니처를 갖어야 하는 조건,
    접근 제어자는 부모 클래스보다 좁은 범위로 변경할 수 없다는 조건,
    부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다는 조건이 있다.


- 오버라이딩을 왜 사용하는가?
    다형성을 구현하기 위해 사용한다.


- 람다식(Lambda Expression) 이란?
    - 정의
        - 자바8 이후 나온 함수형 프로그래밍으로 함수형 인터페이스를 통해 함수를 하나의 식으로 표현한 것.
        - 실행시 익명구현 객체를 생성하는 방식으로 구동된다.
        - 컴파일러가 문맥을 살펴 타입을 추론

    - 람다식의 타입 추론
        - 리턴 타입도 파라미터 타입도 없는 람다식을 컴파일러가 이 함수가 어떤 타입 함수인지 알고 문법을 허용하는 것일까?
            사실 컴파일러 스스로 람다 함수식을 보고 추론하여 타입을 유추하기 때문에 가능한 것

            1. 람다식을 받는 메소드의 매개변수 타입을 본다.
            2. 함수형 인터페이스 정의문을 찾아 추상 메소드 형태를 본다.
            3. 추상 메서드에 정의된 타입에 따라 람다 함수식의 타입을 자동으로 판별해준다.

    - 장점
        - 코드를 간결하게 만들 수 있다.
        - 식에 개발자의 의도가 명확히 드러나 가독성이 높아진다.
        - 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.
        - 병렬 프로그래밍이 용이하다. ??

    - 단점
        - 람다는 문서화를 할 수 없다??

        - 디버깅이 어렵다.
            람다식은 기본적으로 익명 구현 객체 기반이기 때문에, 익명 객체 특성상 디버깅 할때 콜 스택(call stack) 추적이 매우 어려운 단점을 가지고 있다.
            이는 람다가 내부적으로 수행하는 작업이 더 많기 때문에 발생하는 현상이기 때문에,
            코드가 복잡해 질수록 어디에서 문제가 발생했는지 확인하기가 어려워지게 된다. 그리고 이는 곧 성능과 연결 되기 도 한다.

        - stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다??

        - 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
            기존에는 동작 행위를 미리 클래스의 메서드로 정의해놓고 실행부에서 갖다 쓰는 것이었지만, 람다는 동작 행위를 실행부에서 지정하는 식이다.
            람다식을 남발하다보면 비스무리한 람다 함수를 메서드 아규먼트로 지정하고 있을 수 있다.

        - 재귀로 만들 경우에 부적합하다. ??
            람다식을 통해 재귀 함수를 구축하면 실행 조차 안되는 컴파일 에러가 나타난다.


- 함수형 인터페이스(Functional Interface) 란?
    - 정의
        - 딱 하나의 추상 메소드가 선언된 인터페이스
            람다식 자체가 하나의 메소드를 한줄로 정의하는 표현식이기 때문에, 인터페이스에 두개 이상 추상 메서드가 들어있으면 이를 코드로 겹쳐 표현할 방법이 달리 없기 때문
        - @FunctionalInterface 어노테이션을 붙여주게 된다면 두 개 이상의 메소드 선언 시 컴파일 오류를 발생시켜준다.
        - 함수형 인터페이스를 사용하는 이유는 람다식이 함수형 인터페이스를 반환하기 때문

    - Java에서 제공하는 함수형 인터페이스
        - Java에는 자주 사용될 것 같은 함수형 인터페이스가 이미 정의되어 있으며, 총 4가지 함수형 인터페이스를 지원하고 있다.
            Supplier<T> : 매개변수 없이 반환값 만을 갖는 함수형 인터페이스
            Consumer<T> : 객체 T를 매개변수로 받아서 사용하며, 반환값은 없는 함수형 인터페이스
            Function<T, R> : 객체 T를 매개변수로 받아서 처리한 후 R로 반환하는 함수형 인터페이스
            Predicate<T> : 객체 T를 매개 변수로 받아 처리한 후 Boolean을 반환

    - 메소드 참조(Method Reference)
        - 함수형 인터페이스를 람다식이 아닌 일반 메소드를 참조시켜 선언하는 방법
        - 일반 메소드를 참조하기 위해서는 다음의 3가지 조건을 만족해야 한다.
            함수형 인터페이스의 매개변수 타입 = 메소드의 매개변수 타입
            함수형 인터페이스의 매개변수 개수 = 메소드의 매개변수 개수
            함수형 인터페이스의 반환형 = 메소드의 반환형
        - 참조가능한 메소드는 일반 메소드, Static 메소드, 생성자가 있으며 클래스이름::메소드이름 으로 참조할 수 있다.
          이렇게 참조를 하면 함수형 엔터페이스로 반환이 된다.


- 제네릭
    - 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
    - 제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다.
      jdk 1.5 부터는 제네릭을 사용하면 컬렉션에 담을 수 있는 타입을 컴파일러에게 알려주며, 컴파일러가 알아서 형변환 코드를 추가한다.
    - 장점
        - 컴파일러의 검사력 (컴파일 시 체크)
        - 형변환이 필요없고, 타입안정성이 보장된다. (type-safe)
        - 코드의 재사용성이 높아진다.


- 제네릭 와일드 카드
    - 제네릭타입<?> : 타입 파라미터를 대치하는 것으로 모든 클래스나 인터페이스타입이 올 수 있다.
    - 제네릭타입<? extends 상위타입> : 와일드카드의 범위를 특정 객체의 하위 클래스만 올 수 있다.
    - 제네릭타입<? super 하위타입> : 와일드카드의 범위를 특정 객체의 상위 클래스만 올 수 있다.


- 컬렉션 프레임워크에 대해 설명해주세요.
    - 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것

        - Collection 인터페이스 : 순서나 집합적인 저장 공간
            - List 인터페이스
                중복 O, 순서 O

                ArrayList
                    - 단방향 포인터 구조로 각 데이터에 대한 인덱스를 가지고 있어 조회 기능에 성능이 뛰어남
                    - 검색이 빠르다. 순차적으로 데이터가 추가된다면 빠르다.
                    - 하지만 List들의 중간중간 데이터에 빈번한 추가 삭제가 일어난다면 느리다.
                    - 동기화 보장 x

                LinkedList
                    - 양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번할 경우 데이터의 위치정보만 수정하면 되기에 좋은 성능
                    - 하지만 검색이 느리다.
                    - 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임

                Vector (동기화 보장)
                    - 과거에 대용량 처리를 위해 사용했으며, 내부에서 자동으로 동기화처리가 일어나 비교적 성능이 좋지 않고 무거워 잘 쓰이지 않음
                    - ArrayList와 내부 구조는 동일하지만 Thread safe 하다.

                Stack (후입선출)

            - Set 인터페이스
                중복 x, 순서 x

                HashSet
                    - 가장 빠른 임의 접근 속도
                    - 순서를 예측할 수 없다.
                    - Thread safe 하지 않다.

                TreeSet
                    - 정렬방법을 지정할 수 있다. (기본은 오름차순 정렬)
                    - Thread safe 하지 않다.

                LinkedHashSet
                    - 입력된 순서대로 저장한다.
                    - Thread safe 하지 않다.

            - Queue
                LinkedList
                PriorityQueue

        - Map 인터페이스 : 키와 값으로 데이터 핸들
            key 중복 x, value 중복 o, 순서 x
            키(Key), 값(Value)의 쌍으로 이루어진 데이터으 집합으로, 순서는 유지되지 않으며 키(Key)의 중복을 허용하지 않으나 값(Value)의 중복은 허용

            Hashtable
                - HashMap 보다는 느리지만 동기화 지원
                - null 불가

            HashMap
                - 중복과 순서가 허용되지 않으며 null 값이 올 수 있다.

            TreeMap
                - 정렬된 순서대로 키(Key)와 값(Value)을 저장하여 검색이 빠름
                - 오름차순으로 정렬되며, 정렬되는 순서는 숫자 > 알파벳 대문자 > 알파벳 소문자 > 한글 순이다.

    - Collection을 사용하는 이유
        1. 일괄된 API
            Collection에서 상속받아 통일된 메서드를 사용
            표준화된 여러 메서드를 이용해 데이터를 저장하고 처리 가능
        2. 프로그래밍 노력 감소
            객체 지향 프로그래밍의 추상화의 기본 개념이 성공적으로 구현
        3. 프로그램 속도 및 품질 향상
            Collection을 사용하여 최상의 구현을 생각할 필요없이 간단하게 Collection API를 사용하여 구현


- 데이터를 담고 처리하는 방법에는 배열(Array)이 있는데 왜 Collection을 사용하는 걸까?


- Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요. ??
    - hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,
      해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교합니다. 이 두 개가 모두 맞으면 중복 객체입니다.


- Collection 에 list , map들은 불변한가? 이유는?
    list, map 들이 불변성을 가진다면 해당 객체에 요소 추가, 삭제 등 수정할 수가 없다.
    생성자의 인자로 받거나 getter 메서드에서 내부의 객체를 반환할 때, 방어적 복사를 통해 불변성 보장해야 한다.


- 함수형 프로그래밍
    함수형 프로그래밍 패러다임은 선언형 프로그래밍의 특성을 함수를 통하여 구현하는 패러다임입니다. 기존의 명령형 프로그래밍 패러다임은 데이터를 가지고
    어떻게(how) 연산을 수행할지에 대해서 명령을 한다면, 함수형 프로그래밍 패러다임의 경우는 어떻게가 아닌 무엇(what)을 수행할 건 지 선언만 하고
    어떻게 처리할지는 신경쓰지 않습니다. 즉, 더욱 높은 단계의 추상화를 도입한 것.

    함수형 프로그래밍에는 참조 투명성이라는 특징이 존재한다.
    외부의 값을 참조하는 것이 아니라 input parameter 값에 따라서만 결과 값을 얻는 것을 '참조가 투명하다'고 한다.


- stream vs for
    - 컬렉션과 같은 저장 요소를 반복적으로 처리할 수 있는 기능

    - 외부 반복 (how) vs 내부 반복 (what)
        - for 문은 코드 블록으로 표현함으로써 구체적인 구현 로직이 외부에 노출
        - 함수 객체로 표현함으로써 로직이 노출되지 x

    - 가독성
        - for 문의 경우 if 문의 중첩으로 인해 indent depth 가 깊어져 가독성이 떨어질 수 있으나
        - stream 의 경우, 조건들을 filter 의 체이닝 형식을 통해 표현할 수 있기 때문에 보다 간결한 표현 가능

    - 디버깅
        - for 문은 예외가 발생하는 stack trace 가 간결하게 출력되서 디버깅에 유리할 수 있다.
        - stream 은 많은 내부 수행 작업과 지연 연산으로 인해 디버깅이 다소 어려울 수 있다.

    - 병렬 처리
        - for 문의 경우, Runnable 등을 활용해 병렬 처리를 위한 코드를 일일이 작성해야 함.
          데이터들을 몇 개로 어떻게 나눌 것인지, 혹은 발생할 수 있는 동시성 문제가 있는지를 고려해야 하는 등 직접 구현하기도 까다롭고 신경쓸 것도 많아짐
        - stream 을 이용하면 위의 내용들을 stream 이 내부적으로 처리해 주기 때문에 보다 쉽게 병렬 처리 표현 가능


- Stream이란
    - 함수형 인터페이스(람다식)을 적용하여 컬렉션과 같은 저장요소를 반복적으로 처리할 수 있는 기능이다

    - Immutable
        스트림은 원본 객체의 값을 사용하기만 할 뿐 변경하지 않는다. 스트림은 최종 처리를 통해 원본과 무관한 새로운 객체를 생성한다.

    - 일회용
        스트림은 생성되고, 중간처리를 거쳐 최종처리까지 완료되면 닫히게 된다.
        이미 닫힌 스트림은 재사용할 수 없으며, 재사용을 시도할 경우 예외가 발생한다.

    - 생성, 중간처리, 최종처리
        스트림의 처리는 생성, 중간처리, 최종처리 3단계로 구분된다.

    - 지연 연산
        - 간단히 말해 결과값이 필요할 때까지 계산을 늦추는 기법이다.
        - 스트림 파이프라인을 실행하게 되면 JVM은 곧바로 스트림 연산을 실행시키지 않고,
          스트림 파이프라인이 어떠한 중간연산과 최종연산으로 구성되어 있는지에 대한 검사한다.
          이러한 검사 결과를 바탕으로 JVM은 사전에 어떠한 방식으로 최적화를 진행할지 미리 계획하고,
          그 계획에 따라 스트림의 개별 요소에 대한 스트림 연산을 수행한다.


- java map flatmap 차이 ??
    - map
        - 단일 스트림 안의 요소를 원하는 특정 형태로 변환 가능

        - .map()은 단일 스트림의 원소를 매핑시킨 후 매핑시킨 값을 다시 스트림으로 변환하는 중간 연산을 담당합니다.
        - 객체에서 원하는 원소를 추출해는 역할을 한다고 말할 수 있습니다.

    - flatmap
        - 스트림의 형태가 배열과 같을 때, 모든 원소를 단일 원소 스트림으로 반환 가능
        - flatMap의 결과로 단일 원소 스트림을 반환하기 때문에 filter 메서드 등으로 바로 체이닝하여 사용 가능

        - 배열 형태의 스트림을 다루기가 map보다 좋다.
        - .flatMap()은 Array나 Object로 감싸져 있는 모든 원소를 단일 원소 스트림으로 반환합니다.
        - map()은 입력한 원소를 그대로 스트림으로 반환하지만 .flatMap()은 입력한 원소를 가장 작은 단위의 단일 스트림으로 반환합니다.

    map 메서드는 스트림의 스트림을 반환하는 반면에 flatMap 메서드는 원소를 단일 원소 스트림을 반환
    특히 스트림의 형태가 배열인 경우 또는 입력된 값을 또 다시 스트림의 형태로 반환하고자 할 때는 flatMap이 유용

    여러 스트림을 하나의 스트림으로 평면화시키는 메서드

    Stream 클래스를 기준으로 설명했지만 Optional 클래스에도 map과 flatMap 메서드가 있습니다. 역할도 동일


- parallelStream   https://twinparadox.tistory.com/627
     병렬 연산을 쉽고 간단하게 처리
     ForkJoinPool 방식을 이용하기 때문에 분할이 잘 이루어질 수 있는 데이터 구조이거나, 작업이 독립적이면서 CPU 사용이 높은 작업에 적합
     하지만, 공유된 thread pool을 사용하기 때문에 심각한 성능장애를 일으킬 수 있습니다.

    세부 설정이나 복잡한 로직 없이 기존에 stream을 쓰듯 사용할 수 있는 편리함까지 제공해주지만, 병렬 처리 결과가 무조건 더 나은 결과를 보장한다고 볼 수는 없다.
    처리 성능에 영향을 미치는 부분들, 분할 및 병합 과정에서의 비용, 멀티 스레드 환경에서의 컨텍스트 스위칭 비용 등에 대해 충분히 고려해야 하기 떄문에 신중해야 한다.
    특정 로직에 대해 성능 개선을 위해 parallelStream을 적용하고자 한다면, 이것이 정말로 성능을 개선시켜줄 수 있는지,
    혹 예상치 못한 장애를 발생시키지는 않는지에 대해 충분히 테스트도 진행하고 적용하는 것이 좋다.


- 자바 어노테이션 ??
    - JDK 1.5 버전 이상에서부터 사용가능하며, 자바 어노테이션은 클래스 파일에 임베드되어 컴파일러에 의해 생성된 이후 JVM에 포함되어 동작.

    - 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공
    - 런타임시 특정 기능을 실행하도록 정보 제공
        - 런타임에 의존성이 주입
            - Reflection 기술을 이용하여 런타임에 객체가 생성되는 시점(클래스 로더에 의해 메모리에 적재 되는 순간)에
              해당 클래스의 필드에 선언 되어있는 어노테이션 정보를 읽어서 해당 필드의 객체를 생성하여 주입해준다.
        - 컴파일 시, 바이트 코드에 특정 코드 추가

    - 자바 빌트인 어노테이션
        - @Override
        - @Deprecated
        - @SuppressWarning
        - @FunctionalInterface ...

    - 메타 어노테이션
        - @Retention
        - @Documented
        - @Target
        - @Inherited
        - @Repeatable


- Wrapper class
    - 기본 자료타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스(wrapper class)라고 합니다.
    - 자동박싱 자동언박싱
        기본타입 값을 직접 박싱, 언박싱하지 않아도 자동적으로 박싱과 언박싱이 일어나는 경우가 있습니다.
        자동 박싱의 포장 클래스 타입에 기본값이 대입될 경우에 발생합니다.
        예를 들어 int타입의 값을 Integer클래스 변수에 대입하면 자동 박싱이 일어나 힙 영역에 Integer객체가 생성됩니다.
    - 래퍼 클래스와 기본자료형과의 비교는 == 연산과 equals연산 모두 가능합니다.
      그 이유는 컴파일러가 자동으로 오토박싱과 언박싱을 해주기 때문입니다.
    - 기본형으로 처리할 수 있는 부분을 wrapper class로 처리하지 말자.
      기본형을 박싱하면 생기는 오버헤드 때문에 성능이 기본형으로 처리하는 경우보다 상당히 떨어진다.


- 원시 타입과 참조 타입의 차이를 설명하라.
    성능 관점
        원시 타입은 스택 영역에 존재한다. 반면 참조 타입은 스택 영역에는 참조 값만 있고, 실제 값은 힙 영역에 존재한다. 참조 타입은 최소 2번 메모리 접근을 해야 하고, 일부 타입의 경우 값을 필요로 할 때 언박싱 과정(ex. Double → double, Integer → int)을 거쳐야 하므로 원시 타입과 비교해서 접근 속도가 느린 편이다.
    메모리 관점
        원시 타입보다 참조 타입이 사용하는 메모리 양이 압도적으로 높다. 이외의 참조 타입은 최근 들어 64 비트의 JVM을 많이 사용하므로 일반적으로 64 bits를 차지한다고 한다.
    NULL 관점
        원시 타입은 null을 담을 수 없지만, 참조 타입은 null을 담을 수 있다. 이것은 원시 타입의 경우, 값이 없으면 디폴트 값을 반환하기 때문이다. (ex. int은 0, boolean은 false)
    제네릭 관점
        원시 타입은 제네릭 타입에서 사용할 수 없지만, 참조 타입은 가능하다.


- 오토박싱과 언박싱은 어떤 차이가 있습니까?
    - 자바의 자료형은 기본 타입(primitive type)과 참조 타입(reference type) 으로 나누어진다.
    - 기본 타입의 데이터를 객체로 표현해야 하는 경우가 종종 생기게 된다.
    - 예를 들어 메소드의 인수로 객체 타입만이 요구되면, 기본 타입의 데이터를 그대로 사용할 수 없기 때문에 어떠한 변환 작업이 필요해 진다.
      또한 멀티스레드 환경에서 동기화 데이터를 사용해야 할 경우 이를 객체화 해야 할 필요성이 생긴다.
    - 기본 타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스

    JDK 1.5 부터는 박싱과 언박싱이 필요한 상황에 자바 컴파일러가 자동으로 처리해주기 시작했다.
    기본타입 값을 직접 박싱, 언박싱하지 않아도 래퍼 클래스 변수에 대입만 하면 자동으로 박싱과 언박싱이 된다.
    편의성을 위해 오토 박싱과 언박싱이 제공되고 있지만, 내부적으로 추가 연산 작업이 거치게 된다.
    따라서, 오토 박싱&언박싱이 일어나지 않도록 동일한 타입 연산이 이루어지도록 구현하자.


- 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object 클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다.
  이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
    - equals()란?
        - equals 메소드는 기본적으로 2개의 객체가 동일한지 검사하기 위해 사용
        - 2개의 객체가 참조하는 것이 동일한지를 확인하는 것이며, 이는 동일성(Identity)을 비교하는 것
        - 동일한 메모리 주소일 경우에만 동일한 객체가 된다.

        - 하지만 프로그래밍을 하다보면 동일한 객체가 메모리 상에 여러 개 띄워져있는 경우가 있다. 해당 객체는 서로 다른 메모리에
          띄워져있으므로 동일한(Identity) 객체가 아니다. 하지만 프로그래밍 상으로는 같은 값을 지니므로 같은 객체로 인식되어야 하는데,
          이러한 동등성(Equality)를 위해 우리는 값으로 객체를 비교하도록 equals 메소드를 오버라이딩해주는 것이다.

    - hashCode()란?
        - 실행 중에(Runtime) 객체의 유일한 integer 값을 반환
        - Object 클래스에서는 heap 에 저장된 객체의 메모리 주소를 반환하도록 되어있다. (항상 그런 것은 아니다.)
        - hashCode 는 HashTable 과 같은 자료구조를 사용할 때 데이터가 저장되는 위치를 결정하기 위해 사용된다.

    - equals 와 hashCode 의 관계
        - 동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다. 그렇기 때문에
          우리가 equals() 메소드를 오버라이드 한다면, hashCode() 메소드도 함께 오버라이드 되어야 한다.
        - Java 프로그램을 실행하는 동안 equals 에 사용된 정보가 수정되지 않았다면, hashCode 는 항상 동일한 정수값을 반환해야 한다.
          (Java 의 프로그램을 실행할 때 마다 달라지는 것은 상관이 없다.)
          두 객체가 equals()에 의해 동일하다면, 두 객체의 hashCode() 값도 일치해야 한다.
          두 객체가 equals()에 의해 동일하지 않다면, 두 객체의 hashCode() 값은 일치하지 않아도 된다.

    - hashCode() Override 의 필요성
        - hashCode 를 equals 와 함께 재정의하지 않으면 코드가 예상과 다르게 작동하는 위와 같은 문제를 일으킨다.
          정확히 말하면 hash 값을 사용하는 Collection(HashSet, HashMap, HashTable)을 사용할 때 문제가 발생
        - hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true 여야 논리적으로 같은 객체라고 판단한다.
          hashCode 메서드가 재정의 되어있지 않으면 Object 클래스의 hashCode 메서드가 사용됨
        - intellij 의 Generate 기능을 사용했더니 Objects.hash 메서드를 호출하는 로직으로 hashCode 메서드가 재정의 됐다.
          Objects.hash 메서드는 hashCode 메서드를 재정의하기 위해 간편히 사용할 수 있는 메서드이지만 속도가 느리다.
          인자를 담기 위한 배열이 만들어지고 인자 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다.
          성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제 없다.
          민감한 경우에는 직접 재정의해주는 게 좋다.

        - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode 가 서로 다른 값을 반환할 필요는 없다.
          단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.
        - HashMap 의 구현은 해시 코드가 다른 엔트리끼리는 동치성 비교 자체를 하지 않도록 최적화 되어 있다.
        - hashCode 를 만드는 해시 함수를 equals 메소드를 재정의할 때 사용한 필드와 같은 필드를 사용하자.
        - 만약 객체는 같은 해시 코드를 가지게 되면 전부 같은 버킷에 해시되므로 해시 테이블은 아주 긴 링크드 리스트가 많이 생기게 될 것
        - 해시 테이블(hash table)의 평균 시간 복잡도는 O(1)이고, 최악의 로직을 가진 해시 테이블의 시간 복잡도는 O(n) 이다.
        - 만약 이 해시 테이블이 해시 충돌(hash collision) 해결을 해시 체이닝(hash chaining) 방식으로 구현했다면,
          실제 링크드 리스트(linked list) 처럼 동작한다.
        - hashCode를 재정의 하지 않았을 경우 생기는 문제점
            - 같은 값을 가진 객체가 서로 다른 해시값을 갖게 될 수 있다.
            - 특히 HashMap의 key 값으로 해당 객체를 사용할 경우 저장된 버킷을 찾을 수 없다.

        * hashCode 메서드는 객체의 주소값을 이용해서 해싱 기법을 통해 해시 코드를 만든 후 반환한다.
          해시코드는 주소값은 아니고, 주소값으로 만든 고유한 숫자값.

        - equals()와 hashcode()를 같이 재정의해야 하는 이유
            만약 equals()와 hashcode() 중 하나만 재정의 하면 어떻게 될까? 위 예에서도 봤듯이 hashcode()를 재정의 하지 않으면 같은 값 객체라도 해시값이 다를 수 있다.
            따라서 HashTable에서 해당 객체가 저장된 버킷을 찾을 수 없다.

            반대로 equals()를 재정의하지 않으면 hashcode()가 만든 해시값을 이용해 객체가 저장된 버킷을 찾을 수는 있지만
            해당 객체가 자신과 같은 객체인지 값을 비교할 수 없기 때문에 null을 리턴하게 된다. 따라서 역시 원하는 객체를 찾을 수 없다.

            동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다.

            key값을 새로 입력할 때 기존의 중복되는 키가 있는지 확인 하는데, 이때 hashCode 를 먼저 비교하고, 둘이 같으면 그 다음에서야 equals 를 이용해 검사한다.
            그래서 equals 를 다른 필드를 비교하도록 재정의하였다면 equals가 제대로 동작하게 하기위해선 hashCode 메소드도 재정의해야 한다.

    - Object 클래스 hashCode()
        - Java에서 사용되는 해시 코드(Hashcode)는 객체를 식별하기 위한 ID입니다. Java의 모든 객체는 JVM에 의해 고유 번호가 생성되며, 이 고유 번호가 해시 코드입니다.
        - 해시 코드는 32 비트 고유한 정수 값으로 객체와 다른 객체를 구별하기 위해 사용되며, 객체의 내부 주소를 정수로 변환된 값입니다.
        - 객체의 내부 주소가 변경되면 해시 코드도 변경된다.
        - Java에서 해시 코드를 기반으로 데이터를 관리하는 이유는 데이터 검색, 추가, 제거하는 작업이 쉬워지며, 시간 복잡도가 O(1)이므로 상당히 빠르게 동작
        - 컴퓨터마다 메모리 구조와 사양이 다르므로 객체가 생성되는 위치가 다릅니다. 위 예제를 다른 컴퓨터에서 실행하면 다른 해시 코드가 반환됩니다.

    - identityHashCode()
        오버라이딩 하기 전 객체 자체의 주소값(해시코드)를 얻어야 할 상황

    - "hashCode" 를 잘못 오버라이딩 했을때   https://devlog-wjdrbs96.tistory.com/243   https://blogshine.tistory.com/397
        서로 다른 객체임에도 같은 버킷에 저장이 되어 충돌이 발생하게 됩니다.
        충돌이 일어나면 버킷 내부에서 원소들은 리스트의 형태로 저장하게 됩니다.
        그래서 이를 보완하기 위해 Java 8부터는 버킷 크기가 특정 임계값을 초과하면 연결된 목록이 트리 맵으로 바뀝니다. 이를 통해 시간복잡도 O(n)에서 O(logn)으로 성능을 올릴 수 있습니다.
        하지만 계속 똑같은 해시코드(hashCode) 값을 반환하는 메소드를 사용하면 어떻게 될까요?
        해시테이블 하나의 버킷 내에 계속 원소들이 쌓여 리스트 형태로 연결될 것입니다. 그러면 해시테이블의 검색 시간복잡도 O(1)의 이점을 누리지 못하고 O(n)으로 늘어나게 됩니다.

    - hashCode를 동일하게 만들어서 동일한 인덱스 버킷에 저장될 수 있도록 해준다.
      equals() 메소드로 다시 비교한다. 이 두 개가 모두 맞아야 동등 객체로 판단한다. 즉, 해시코드 값이 다른 엔트리끼리는 동치성 비교를 시도조차 하지 않는다.


- 자바에서 == 와 Equals() 메서드의 차이는
    - String 변수 생성시 주소할당
        - 리터럴을 이용한 방식 : String s1 = "abcd";
            - 리터럴을 사용하게 되면 string constant pool이라는 영역에 존재하게 되고 new를 통해 String을 생성하면 Heap 영역에 존재하게 됩니다.
            - String을 리터럴로 선언할 경우 내부적으로 String의 intern() 메서드가 호출되게 됩니다.
            - intern() 메서드는 주어진 문자열이 string constant pool에 존재하는지 검색하고 있다면 그 주소값을 반환하고 없다면
              string constant pool에 넣고 새로운 주소값을 반환합니다.

        - new 연산자를 이용한 방식 : String s2 = new String("abcd");

    - 주소값 비교(==)와 값 비교(equals)
        " == " : 비교하고자 하는 두개의 대상의 주소값을 비교
        " String클래스의 equals 메소드 " : 비교하고자 하는 두개의 대상의 값 자체를 비교

        일반적인 타입들 int형, char형등은 Call by Value 형태로 기본적으로 대상에 주소값을 가지지 않는 형태로 사용됩니다.
        하지만 String은 일반적인 타입이 아니라 클래스입니다.
        클래스는 기본적으로 Call by Reference형태로 생성 시 주소값이 부여됩니다.
        그렇기에 String타입을 선언했을때는 같은 값을 부여하더라도 서로간의 주소값이 다를 수가 있습니다.


- String
    String 클래스는 불변 객체이다. 따라서 한 번 할당한 문자열을 변경하는 것은 불가능하며, 더하기 연산을 하여 문자를 이어 붙일 때는 새로운 객체가 생성되어 재할당된다.
    반복적으로 문자열을 이어 붙이다 보면 Heap 영역에서 참조를 잃은 문자열 객체가 계속해서 쌓이게 된다. 물론, 나중에 GC에 의해 수거가 되지만 메모리 관리 측면에서 이러한 코드는 결코 좋은 코드라고 할 수 없다. 또한 계속해서 객체를 생성하므로 연산 속도 측면에서도 성능이 떨어질 수 밖에 없다.


- String Pool
    = 연산자를 통해 값을 String에 대입하면 Heap 영역 내에 있는 String Pool이라는 공간에 문자열이 저장되고, new 연산자를 통해 String을 만들면 String Pool이 아닌 일반 Heap 영역 어딘가에 저장된다. 둘다 Heap 영역에 저장되는 것은 동일한데, String Pool에 값이 저장되면 어떠한 이점이 있는 것일까?
    전자의 방식을 String literal이라고 하는데, String literal로 생성한 객체는 String Pool의 메모리 주소를 가리키게 된다. 그래서 똑같은 String literal 객체가 생성될 경우 같은 값의 주소를 가리키게 되므로 하나의 메모리를 재사용할 수 있다.
    반면 후자는 일반적인 new 연산자를 통해 객체를 생성하는 방식이므로 String Pool의 해당 값이 있더라도 Heap 영역 내 별도의 메모리를 할당하여 주소를 가리키게 된다.

    String 객체를 하나로 두고, 내부 상태를 변경하는 가변 객체로 만드는 것이 좋은데, Java에서는 StringBuilder와 StringBuffer를 지원한다.
    StringBuffer는 단일 synchronized 메소드를 여러 스레드가 사용하는 것은 스레드 안전하지만, 단일 synchronized 메소드 여러 개로 구성된 일반 메소드에서 사용할 때는 스레드 안전하지 않으므로 주의하여 사용해야 한다.


- String Pool이 있으면 무엇이 좋은가?
    = 연산자로 String을 생성할 때, 같은 값이 String Pool에 있다면, 새로운 메모리 할당 없이 주소를 공유하여 사용할 수 있다. 또한, String은 불변 객체이므로 동일한 주소를 여러 객체가 참조하여도 동기화 문제가 발생하지 않으므로 안전하다.


- String 객체 생성    https://readystory.tistory.com/139 (String Constant Pool)
    - new 연산자로 String 객체를 생성하면 JVM 에서 Heap 영역에서 String 객체 생성
    - new 연산자가 아닌 리터럴("")로 String 객체를 생성하면 JVM 은 우선 String Constant Pool 영역을 방문.
      거기서 같은 값을 가진 String 객체를 찾으면 그 객체의 주소 값을 반환하여 참조하게 된다. 찾지 못하면 String Constant Pool 에
      해당 값을 가진 String 객체를 생성하고 그 주소 값을 반환.
    - String Constant Pool 영역은 Heap 영역 내부에서 String 객체를 위해 별도로 관리하는 저장소.
    - String pool을 통해 String을 관리함으로써 Java는 Runtime에서 Heap 영역의 많은 메모리를 절약할 수 있습니다.
      왜냐면 같은 값을 갖는 String에 대해 같은 메모리를 참조하게 할 수 있기 때문입니다.
      불변이기 때문에 멀티 쓰레딩 환경에서 안전(thread-safe)
      다른 객체는 키로 쓰일 때마다 hashCode를 계산하는데 비해 String은 캐싱을 하고 있기 때문에 다른 객체를 Key로 했을 때보다 String을 Key로 했을 때 더 빠른 속도로 사용할 수 있습니다.

    - String 불변 객체에 계속 새로운 문자열을 추가해주게 되는 경우 Heap 영역에 새로운 객체가 생성되어 불필요한 메모리 공간을 차지하며 GC 가 자주 발생해 성능이 저하됨.

    - String은 기본적으로 불변이기 때문에 concat(), toUpperCase(), trim()같은 메서드를 사용할 때도 내부의 필드가 바뀌는 것이 아니라 새로운 String 객체를 생성해서 반환한다.


- string + 연산 최적화   https://velog.io/@dooboocookie/Java-String%EA%B3%BC-String-%EC%97%B0%EA%B2%B0%EC%9D%98-%EC%B5%9C%EC%A0%81%ED%99%94   https://jaehoney.tistory.com/331
    - 대량의 문자열을 결합하는 경우는 '+' 연산자의 성능이 현저히 줄어듬으로 StringBuilder를 권장
    - '+' 연산자는 컴파일 시점에 Java 컴파일러에 따라 최적화됩니다.
    - Java 1.5는 StringBuilder로 최적화되며, Java 9는 StringConcatFactory 를 활용해 바이트 코드 단위의 최적화가 이루어집니다. ??
      jdk 8 까지는 매 반복문 마다 StringBuilder 객체를 생성하는 방식으로 진행되어 성능의 저하가 심하다. jdk 9 이후에는 StringConcatFactory를 사용하여 개선되었다.
    - 결과적으로 현재는 반복문에서 1000회 이상씩 반복문으로 문자열을 생성하는 경우 등이 아니라면, StringBuilder가 String보다 절대적으로 뛰어난 것은 아니며,
      간단 문자열 연결에서는 String이 더 나은 선택이 될 수 있다.


- StringBuilder 와 StringBuffer 의 차이는 무엇일까요?
    - 연산이 많지 않을때는 위에 나열된 어떤 클래스를 사용하더라도 이슈가 발생할 가능성은 거의 없습니다. 그러나 연산횟수가 많아지거나
      멀티쓰레드, Race condition 등의 상황이 자주 발생 한다면 각 클래스의 특징을 이해하고 상황에 맞는 적절한 클래스를 사용해 주셔야 합니다

    - String  vs  StringBuffer/StringBuilder
        String은 불변성을 가지기 때문에 변하지 않는 문자열을 자주 읽어들이는 경우 String을 사용해 주시면 좋은 성능을 기대할 수 있습니다.
        그러나 문자열 추가,수정,삭제 등의 연산이 빈번하게 발생하는 알고리즘에 String 클래스를 사용하면
        힙 메모리(Heap)에 많은 임시 가비지(Garbage)가 생성되어 힙메모리가 부족으로 어플리케이션 성능에 치명적인 영향을 끼치게 됩니다.
          (매번 별 문자열이 업데이트 될때마다 계속해서 메모리 블럭이 추가되게 되고, 일회용으로 사용된 이 메모리들은 후에 Garbage Collector(GC)의 제거 대상이 되어
           빈번하게 Minor GC를 일으켜 Full GC(Major Gc)를 일으킬수 있는 원인이 된다.)


        이를 해결하기 위해 Java에서는 가변(mutable)성을 가지는 StringBuffer / StringBuilder 클래스를 도입했습니다.
        String 과는 반대로 StringBuffer/StringBuilder 는 가변성 가지기 때문에 .append() .delete() 등의 API를 이용하여 동일 객체내에서 문자열을 변경하는 것이 가능합니다.
        따라서 문자열의 추가,수정,삭제가 빈번하게 발생할 경우라면 String 클래스가 아닌 StringBuffer/StringBuilder를 사용하는 것이 좋습니다.

    - StringBuffer vs StringBuilder
        - 가장 큰 차이점은 동기화의 유무
        - StringBuffer 는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다는 점
            참고로 String 도 불변성을 가지기때문에 마찬가지로  멀티쓰레드 환경에서의 안정성(thread-safe)을 가지고 있습니다.
            StringBuffer는 메서드에서 synchronized 키워드를 사용
        - StringBuilder 는 동기화를 지원하지 않기때문에 멀티쓰레드 환경에서 사용하는 것은 적합하지 않지만 동기화를 고려하지 않는 만큼
            단일쓰레드에서의 성능은 StringBuffer 보다 뛰어납니다.

    String          :  문자열 연산이 적고 멀티쓰레드 환경일 경우
    StringBuffer    :  문자열 연산이 많고 멀티쓰레드 환경일 경우
    StringBuilder   :  문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우


- 문자열 분리
    - StringTokenizer는 정규식을 사용할 수 없습니다.
      StringTokenizer 가 성능이 조금 더 좋지만 Legacy 된 이유라고 생각합니다.
      반면 split은 Java 버전이 올라갈수록 개선되고 있으며, 정규식을 미리 컴파일하는 방법으로도 보완할 수 있습니다.
      따라서 극도의 성능이 필요한 예외적인 경우가 아니라면 split 사용을 권장합니다.

    - 구분자를 split는 정규 표현식으로 구분하고, StringTokenizer는 문자로 받는다.
    - split는 결과 값이 문자열 배열이지만, stringtokenizer는 객체이다.
    - split는 빈문자열을 토큰으로 인식하는 반면, StringTokenizer는 빈 문자열을 토큰으로 인식하지 않는다.
    - 성능은 split 보다 StringTokenizer 가 좋다.
        - split은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 StringTokenizer 보다 성능이 떨어진다.
        - 그러나 데이터의 양이 많은 경우가 아니라면 별 문제가 되지 않는다.


- java String 불변객체인 이유   https://devlog-wjdrbs96.tistory.com/247
    - 성능
        자바에서 문자열은 정말 많이 사용됩니다. 그렇기 때문에 자바에서는 상수 풀이라는 것을 만들었습니다.
        문자열 리터럴을 캐싱하고 재사용하면 문자열 풀의 다른 문자열 변수가 동일한 개체를 참조하기 때문에 힙 공간을 많이 절약

    - 동기화
        불변 객체는 값이 바뀔 일이 없기 때문에 멀티스레드 환경에서 Thread-safe 하다는 장점이 있습니다.
        따라서 일반적으로 불변의 개체는 동시에 실행되는 여러 스레드에서 공유할 수 있습니다.
        스레드가 값을 변경하면 동일한 문자열을 수정하는 대신 문자열 풀에 새 문자열이 생성되기 때문

    - 해시코드 캐싱
        문자열 개체는 데이터 구조로 많이 사용되기 때문에 해시맵, 해시테이블, 해시셋 등과 같은 해시 구현에서도 널리 사용됩니다.
        이러한 해시 구현에 따라 작동할 때 버킷을 위해 hashCode() 메서드가 꽤 자주 호출됩니다.
        String의 hashCode() 메서드 구현을 보면 아직 hash 값을 계산한 적이 없을 때 최초 1번만 실제 계산 로직을 수행하고,
        이후부터는 해당 값을 그냥 리턴만 하도록 overriding 되어 있습니다.(계산해놓았던 해시코드를 재사용하는 것입니다.)
        String이 불변이기 때문에 이렇게 caching이 가능하다는 이점을 활용

    - 보안
        문자열은 Java 애플리케이션에서 사용자 이름, 암호, 연결 URL, 네트워크 연결 등과 같은 중요한 정보를 저장하는 데 널리 사용됩니다.
        클래스를 로드하는 동안 JVM 클래스 로더에서도 광범위하게 사용됩니다.
        따라서 String 클래스 보안은 일반적으로 전체 응용 프로그램의 보안에 매우 중요합니다.
        String이 불변 객체가 아니라면 메소드를 호출했던 클라이언트는 String에 대한 참조가 메소드를 호출한 이후에도 남아있습니다.
        이 경우 SQL 주입을 쉽게 수행할 수 있습니다.
        이러한 보안 이슈가 있기 때문에 자바에서는 String을 불변 객체로 만들었습니다.

    1. 캐싱 : String을 불변하게 함으로써 String pool에 각 리터럴 문자열의 하나만 저장하며 다시 사용하거나 캐싱에 이용가능하며 이로 인해 힙 공간을 절약할 수 있다는 장점이 있다.
    2. 보안 : 예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데,
             만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조 값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있다.
    3. 동기화 : 불변함으로써 동시에 실행되는 여러 스레드에서 안정적이게 공유가 가능하다.


- 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유
    https://mangkyu.tistory.com/131?category=872426
    https://devoong2.tistory.com/entry/Java-%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4Immutable-Object-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90#%EB%--%B-%EB%B-%--%--%EC%--%--%ED%--%-C%EC%-D%--%--%EB%B-%--%EA%B-%BD%EC%-D%B-%--%EC%--%--%EA%B-%B-%--%EB%--%-C%EB%AC%B-%EC%--%--%--Cache%-C%--Map%-C%--Set%--%EB%--%B-%EC%-D%--%--%EC%-A%--%EC%--%-C%EB%A-%-C%--%ED%--%-C%EC%-A%A-%ED%--%--%EA%B-%B-%EC%--%--%--%EC%A-%--%ED%--%A-%ED%--%--%EB%-B%A--

    불변 객체란 한번 할당하면 내부 데이터를 변경할 수 없는 객체
    불변객체는 말그대로 변하지않는 객체로 객체가 생성된후 내부 상태가 변하지 않는 객체를 의미한다.
    불변객체는 Setter 메소드를 제공하지 않으며, 내부상태를 제공하는 메소드는 제공하지 않거나 방어적 복사 (defensive-copy)를 통해 제공한다.

    final 예약어는 변수에 사용시 값을 수정할 수 없는 상수로 만들어주고,
    메소드에 사용시 Overriding을 할 수 없고,
    클래스에 사용시 상속이 불가능 하다.

    불변객체 사용시 장점
        - 외부에서 객체에 대해 변경할 수 없기 때문에 안정성이 있다.
            -> 불변객체는 값의 수정이 불가능해 객체의 상태가 변경되지 않아 객체의 신뢰성이 높습니다.
               불변객체를 필드로 사용할 때 방어적 복사가 필요없다.
        -  쓰레드에 안전하여 멀티 쓰레드 환경에서 동기화를 고려하지 않아도 된다.
            -> 멀티 스레드 환경에서 발생하는 주된 문제는 공유자원에 대해 서로 변경하다보니 값이 덮어씌워지는 문제가 있습니다.
               하지만 불변객체는 항상 동일한 값을 보장하므로 동기화를 신경쓸 필요가 없다는 장점이 있습니다.
        - 불변객체는 내부상태가 변경되지 않으므로 Map, Set 등의 요소로 사용하기에 적합하다.
            -> 불변 객체라면 한 번 데이터가 저장된 이후에 다른 작업들을 고려하지 않아도 되므로 사용하는데 용이
        - 불변객체를 한번 메모리에 할당하게 되면 같은 객체를 계속 호출하여도, 새롭게 할당하지 않아도 되므로 GC의 성능을 높힐 수 있다.
            -> 상태의 변경이 필요한 경우 새로운 객체를 생성해서 사용해야되서 성능상 좋지 않을거라 생각할 수 있지만,
               GC는 새롭게 생성된 객체는 금방 죽는다는 가설에 맞춰 설계되어 있어 불변객체를
               새로 생성한다 해서 GC 입장에서는 생명주기가 짧은 객체를 처리하는것은 큰 부담이 되지 않습니다.
               그리고 불변객체 내부의 객체에 대해서는 GC 스캔 대상에 제외됩니다.
               따라서 불변객체를 이용하면 GC의 스캔빈도와 범위가 줄게되어 GC의 성능에 도움이 된다.

    불변객체를 생성하는 방법
        1. setter 메소드를 사용하지 마라
        2. 모든 필드를 final 과 private를 사용해서 선언해라
        3. 클래스를 final 로 선언하여 상속을 통한 변경의 여지 제거
        4. 객체를 생성하기 위한 생성자 혹은 정적 팩토리 메소드를 추가해라
           메소드 오버라이딩을 통해 오작동 or 다형성을 통해서 상속을 받은 신뢰할수 없는 객체인지 알기 쉽지 않습니다.
        5. 인스턴스 필드에 가변객체가 포함된다면 방어적 복사를 이용하여 전달해라

    - 단점
        객체가 가지는 값마다 새로운 객체가 필요합니다. 따라서 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능저하를 발생시킬 수 있습니다.

    - final 이 불변을 의미할까?
        final 을 사용하는 것이 완벽한 불변성을 의미하지는 않는다. final 은 해당 변수의 재할당만을 막아줄 뿐, 참조하고 있는 객체 내부의 상태가 변하지 않았음을 보장해주지는 않는다.
        final 키워드를 사용하면, ‘어디에선가 재할당되지 않았을까?’, '값이 예측하지 못한 곳에서 변하는 상황을 막기 위해 검증 로직을 추가해야하나?' 라는 불안감에서 벗어남.


- 깊은 복사 (Deep Copy) vs 얕은 복사 (Shallow Copy)
    - 얕은 복사 (Shallow Copy) : 원본의 요소와 복사본의 요소가 같은 참조를 가진다
    - 깊은 복사 (Deep Copy) : 복사 시 각 컬렉션이 가지고 있는 모든 요소도 복사하여 원본의 요소와 다른 참조를 가지게 끔 하는 것


- 컬렉션의 방어적 복사   https://studyhardd.tistory.com/65   https://creampuffy.tistory.com/148
    - 자바 API 로는 깊은 복사를 수행할 수 없다는 것을 알게 됐다. 따라서 외부 혹은 내부로부터 변경에 취약하지 않도록 내부 요소들이 불변 객체여야 함
    - 방어적 복사는 생성자를 통해 초기화하거나 내부의 객체를 반환할 때, 새로운 객체로 감싸서 복사해주는 방법이다.
      외부와 내부에서 주소 값을 공유하는 인스턴스의 관계를 끊어주기 위해서 방어적 복사를 사용한다.
      또한, 외부로 값을 노출시킬 때도 관계를 끊어주기 위해서 복사본을 반환해준다.

    1. 주소 복사
        List<Number> copyNumbers = numbers;
        =의 경우 그저 참조변수를 하나 만들어 주소를 넣어주기 때문에 완전히 동일한 컬렉션이다.

    2. = new ArrayList<>()
        List<Number> newNubmers = new ArrayList<>(numbers);
        방어적 복사를 해줌으로써 컬렉션의 주소값이 달라져 원본 컬렉션의 변경에 영향을 받지 않게 된다.
        하지만 중요한 점은 요소의 주소값은 동일하기 때문에 요소의 변경에는 영향을 받게 된다.

    3. .addAll()
        copyNumbers.addAll(numbers);
        new ArrayList<>()와 동일하기 때문에 컬렉션의 주소는 달라지지만 요소의 주소는 같다.
        주로 복사 보단 List끼리 합쳐주기주기 위해서 사용된다.
        그렇기 때문에 인텔리제이에선 친절히 대체할 수 있다고 알려준다!

    4. .stream().collect(Collectiors.toList())
        List<Number> copyNumbers = numbers.stream().collect(Collectors.toList());
        이 또한 new ArrayList<>()와 동일하기 때문에 컬렉션의 주소는 달라지지만 요소의 주소는 같다.
        마찬가지로 인텔리제이에서 알려주게 된다!

    5. Collections.unmodifiableList()
        List<Number> copyNumbers = Collections.unmodifiableList(numbers);
        기본적인 내용의 경우 new ArrayList<>()와 동일하기 때문에 컬렉션의 주소는 달라지지만 요소의 주소는 같다.
        컬렉션을 변경하려고 하면 예외가 발생하여 막혀있지만 원본 컬렉션의 변경이 일어나면 복사한 컬렉션에도 그대로 적용이 되기 때문이다.

    6. List.copyOf()
        List<Number> copyNumbers = List.copyOf(numbers);
        List.copyOf()는 unmodifiableList와 비슷하지만 원본 컬렉션의 변경에도 영향을 받지 않는다.
        즉, 컬렉션의 주소는 다르고 요소의 주소는 같으며 복사된 컬렉션에 대한 변경 시도시 UnsupportedOperationException 발생하며
        원본 컬렉션의 변경에도 영향을 받지 않는다는 것이다.

        그럼 copyOf()만 사용하면 완전한 불변이겠네
        No! 요소의 주소는 같다. 이는 결국 요소의 변경이 일어나면 모두 영향을 받게 된다는 것이다.
        그렇기 때문에 불변 객체, VO가 중요하다는 것이다.
        만약 컬렉션의 요소가 불변임을 보장할 수 있게 된다면 copyOf를 통해 완전한 불변이 가능


- final / finally / finalize 의 차이를 설명해주세요
    - final은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용
    - finally는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록
    - finalize는 Object 클래스에 정의되어 있는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드


- java의 final 키워드
    - final
        - 변수나 메서드 또는 클래스가 ‘변경 불가능’하도록 만든다.

        - 원시(Primitive) 변수에 적용 시 해당 변수의 값은 변경이 불가능하다.
        - 참조(Reference) 변수에 적용 시 참조 변수가 힙(heap) 내의 다른 객체를 가리키도록 변경할 수 없다.
        - 메서드에 적용 시 해당 메서드를 오버라이드할 수 없다.
        - 클래스에 적용 시 해당 클래스의 하위 클래스를 정의할 수 없다.

    - finally
        - try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용한다.

        - finally는 선택적으로 try 혹은 catch 블록 뒤에 정의할 때 사용한다.
        - finally 블록은 예외가 발생하더라도 항상 실행된다. (단, JVM이 try 블록 실행 중에 종료되는 경우는 제외한다.)
        - finally 블록은 종종 뒷마무리 코드를 작성하는 데 사용된다.
        - finally 블록은 try와 catch 블록 다음과, 통제권이 이전으로 다시 돌아가기 전 사이에 실행된다.

    - finalize
        - GC가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.
        - 종료자는 사용하면 안 된다. 예측이 불가능하고 대체로 위험하고 일반적으로 필요하지 않다.


- Try Catch Finally 에 Try 안에서 System.exit(0) 를 한다면 Finally는 실행이 되나요?
    - 안됩니다. System.exit 는 프로그램을 강제로 종료한다는 의미이고 완전히 소프트웨어를 중단하기 때문에 Finally는 실행되지 않습니다.


- try-with-resources에 대해 설명해주세요. ??
    - try-with-resources는 try-catch-finally의 문제점을 보완하기 위해 나온 개념입니다.
    - try( ... ) 안에 자원 객체를 전달하면, try블록이 끝나고 자동으로 자원 해제 해주는 기능을 말합니다.
    - 따로 finally 구문이나 모든 catch 구문에 종료 처리를 하지 않아도 되는 장점이 있습니다.


- Exception 구조
    - Object
        - Throwable
            - Exception
                - Checked Exception
                - Unchecked Exception (RuntimeException)
            - Error


- Checked,Unchecked Exception 차이   https://cheese10yun.github.io/checked-exception/
                            Checked Exception	        Unchecked Exception
    처리 여부	            반드시 예외 처리 해야함	        예외 처리 하지 않아도됨
    트랜잭션 Rollback 여부	Rollback 안됨	            Rollback 진행
    대표 Exception	        IOException, SQLException	NullPointerException, IllegalArgumentException

    - Checked Exception
        - throws로 상위 메서드로 넘기든 자신이 try catch 해서 throw를 던지든 해야 한다.
        - 왜 Checked Exception은 Rollback되지 않는 것일까?
          기본적으로 Checked Exception는 복구가 가능하다는 메커니즘을 가지고 있다.
          기본적으로 복구가 가능하니 네가 복구를 작업을 진행했을 수 있으니까 Rollback은 진행하지 않을게라는 의미가 있다
          복구하는 것이 아니라 일반적인 코드의 흐름으로 제어해야 합니다.

          하지만 우리가 일반적으로 Checked Exception 예외가 발생했을 경우 복구 전략을 갖고 그것을 복구할 수 있는 경우는 그렇게 많지 않습니다.
          유니크해야 하는 이메일 값이 중복돼서 SQLException이 발생하는 경우 어떻게 복구 전략을 가질 수 있을까요?
          Checked Exception을 만나면 더 구체적인 Unchecked Exception을 발생시켜 정확한 정보를 전달하고 로직의 흐름을 끊어야 합니다.

          무책임하게 상위 메서드로 throw를 던지는 행위는 하지 않는 것이 좋습니다. 상위 메서드들의 책임이 그만큼 증가하기 때문입니다.


- Unchecked Exception 과 Checked Exception 의 차이는 무엇인가요?
    - Checked Exception : IDE에서 제공하고 컴파일 타임에 체크할 수 있는 예외를 말합니다. 예를 들어, IO Exception 과 SQL Exception 이 있습니다.
    - UnChecked Exception : 런타임에 체크하는 예외를 말합니다. 예를 들어, NPE, ArrayOutOfIndex , Arithmatic 등이 있습니다.


- 자바에서 Exception Handling 을 어떻게 하나요?
    - try catch 를 통해 예외를 직접 처리하는 방법이 있습니다.
    - throws 를 통해서 caller 에게 책임을 넘기는 방법이 있습니다.


- throw vs throws 의 차이는 무엇인가요?
    - throws : 보통 메서드 이름 옆에 선언하며 Exception Handling 의 책임을 Caller에게 넘기기 위해 사용
               throws 다음에는 Class 이름이 와야 한다. class 이름들은 여러개 선언 가능
    - throw : Exception 객체를 생성하여 예외를 발생시키는 것.
              하나의 예외 객체만 생성가능하며 throw 다음에는 Class 이름이 아니라 객체가 와야 한다.


- 0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?  https://castlejune.tistory.com/23
    - 싱글스레드 프로세스의 경우 프로세스 내에서 단 하나의 스레드만 작업하기 때문에 프로세스의 자원을 가지고 작업하는데 별문제가 없지만,
      멀티스레드 프로세스의 경우 여러 스레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업에 영향을 주게 됩니다. -> 스레드의 동기화
    - ++ 연산은 구체적으로 어떤 행위들로 이루어져 있을까요?
        메모리에서 해당 값을 가져옵니다.
        해당 값에 1을 더합니다.
        메모리에 더한 값을 덮어씌웁니다.
    - 이 문제를 해결하려면 어떻게 해야할까요 ??
        - JVM 은 데이터를 4byte(=32bit)단위로 처리하기 때문에, int 와 int 보다 작은 타입들은 한 번에 읽고 쓰는 것이 가능합니다.
          즉, 단 하나의 명령어로 읽거나 쓰기가 가능하다는 뜻입니다. 하나의 명령어는 더 이상 나눌 수 없는 최소의 작업단위이므로,
          작업의 중간에 다른 스레드가 끼어들 틈이 없습니다. 다만, 크기가 8byte 인 long 과 double 타입의 변수는 하나의 명령어로 값을
          읽거나 쓸수 없기 때문에, 변수의 값을 읽는 과정에 다른 스레드가 끼어들 여지가 있습니다.

        - 스레드는 실행되고 있는 CPU 메모리 영역에 데이터를 캐싱합니다.
          따라서 멀티 코어 프로세서에서 다수의 스레드가 변수 a를 공유하더라도 캐싱된(갱신) 시점에 따라 데이터가 다를 수도 있습니다.
          그리고 캐싱된 데이터가 언제 갱신되는지 정확히 알수 없습니다.

        1. 적절한 동기화 처리
            - 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
            - 스레드가 synchronized 블럭으로 들어갈 때와 나올 때, 캐시와 메모리간의 동기화가 이루어지기 때문에 값의 불일치가 해소됩니다.

        2. volatile 키워드  https://nesoy.github.io/articles/2018-06/Java-volatile  https://jronin.tistory.com/110
            - synchronized 블럭의 임계 영역은 멀티스레드 프로그램의 성능을 좌우하기 때문에 가능하면 임계영역을 최소화해서 효율적인 프로그래밍을 해야합니다.
            - 속도가 더 빠른 대안을 소개하자면 자바에서 volatile 이란 한정자로 변수의 읽기와 쓰기를 원자화 할 수 있습니다.
            - volatile 키워드를 붙이면 해당 변수를 읽어올 때 캐시가 아닌 메모리에서 직접 읽어오게 되는데 그렇기 때문에 스레드 간 안정적인 통신은 보장할 수 있습니다.
            - 매번 변수의 값을 Read 할 때마다 CPU cache 에 저장된 값이 아닌 Main Memory 에서 읽는 것입니다.
            - 주의할 점은 volatile 키워드는 변수의 읽기나 쓰기의 원자화를 보장하지만 배타적 수행과는 상관없습니다!
            - volatile 은 원자적 연산에서만 동기화 보장
            - 값을 읽고 쓰는 비-원자적 연산 작업이 하나의 스레드에서만 일어나고 다른 스레드들에서는 단지 값을 읽는 원자적 연산만 한다면
              위와 같은 문제는 발생하지 않기 때문에 volatile 키워드만으로 충분히 동기화
            - volatile(통신 동기화)만으로 동기화가 되는 상황이라면 synchronized 보다는 volatile 만으로 동기화 처리를 하는 것이 낫습니다.
              왜냐하면 배타적 실행을 위해 락을 획득하고 반환하는 비용이 발생하지 않기 때문입니다.
              만약 배타적 실행 제어가 필요하다면 synchronized 를 사용해야 합니다.
            - 간혹 synchronized 키워드와 volatile 키워드가 같이 사용되는 코드를 볼 수 있습니다.
              자바 1.5이후부터 volatile 키워드가 붙은 변수들은 컴파일 단계에서 재배치-최적화를 하지 않도록 변경되었기 때문에
              Double-checked locking 구문에서 최적화를 하지 않도록 하기 위해 volatile 를 붙이기도 합니다.

            - Java의 원자적 연산과 비원자적 연산 ??   https://sslblog.tistory.com/201
                - 레퍼런스를 할당하고 복사하는 모든 작업은 원자성이 보장됩니다. 원시타입 변수에 값을 쓰고 읽는 모든 작업도 마찬가지
                - 원시타입 중에서도 왜 long과 double만 제외
                    - 32bit 안에서 할당이 이루어지는 다른 원시타입들과 다르게, long과 double로 정의된 변수는 64bit로 할당
                    - 64bit를 쓰고 읽는 대개의 경우는 32bit씩 두 번의 연산으로 나누어 실행
                    - 만약 둘 이상의 스레드가 해당 변수에 읽고 쓰는 작업을 한다면, 한 스레드가 32bit를 읽는 동안
                      나머지 스레드는 나머지 32bit에 대해 쓰기를 실행할 수도 있는 것이죠. 이런 경우엔 읽기를 실행한 스레드는 잘못된 값을 읽어가게 될 것입니다.

            - volatile은 해당 필드에 접근할 때 lock을 걸도록 합니다. 지정한 메서드나 지정한 블록에 thread-safe를 보장하는 synchronized와는 다르게요.
            - 해당 필드의 접근에 대해서만 원자성을 보장합니다. 한 스레드가 하나의 long 변수의 32bit를 쓰는 도중에 다른 스레드가 나머지 32bit를 쓰거나 읽지 못하도록 하는 것

        3. Atomic 변수(java.util.concurrent.atomic)
            - 멀티쓰레드 환경에서 동기화 문제를 synchronized 키워드를 사용하여 락을 걸곤 하는데 이 키워드 없이 동기화 문제를 해결하기 위해 고안된 방법입니다.
            - synchronized 는 특정 스레드가 해당 블럭 전체에 락을 걸기때문에 다른 스레드는 아무런 작업을 하지 못하고 기다리는
              상황(Blocking)이 될 수 있어서 낭비가 심합니다. 그래서 Non-Blocking 하면서 동기화 문제를 해결하기 위한 방법이 Atomic
            - java.util.concurrent.atomic 패키지에는 락 없이도(lock-free) thread-safe 한 프로그래밍을 지원하는 클래스들이 담겨 있습니다.
              성능도 더 우수하다고 알려저 있습니다.
            - volatile 은 동기화의 두 효과 중 스레드 간 통신 쪽만 지원하지만 이 패키지는 원자성(배타적 수행)까지 지원합니다.
              클래스들을 까보니 내부적으로 volatile 키워드를 내포
            - Atomic 의 동작 핵심원리는 CAS 알고리즘(Compared and Swap)   https://javaplant.tistory.com/23
            - CAS 란 변수의 값을 변경하기 전에 기존에 가지고 있던 값이 내가 예상하던 값과 같을 경우에만 새로운 값으로 할당하는 방법입니다.
            - Java 에서 제공하는 Atomic Type 은 이러한 CAS 를 하드웨어(CPU)의 도움을 받아 한 번에 단 하나의 스레드만 변수의 값을 변경할 수 있도록 제공하고 있습니다.

        - 비-원자적 연산에서의 동기화 처리 ??
            1. synchronized
                - 값을 변경하기 위해 읽고-저장하는 작업(비-원자적 연산)은 동시에 하나의 스레드만 처리할 수 있도록 일종의 락을 거는 방법입니다.
                  비-원자적 연산을 원자화시키는 거라고 볼 수 있습니다.
                - synchronized 은 단일 스레드만 진입하도록 하는 배타적 실행 동기화뿐만 아니라 가장 최근의 값(메인 메모리에서)을 가져오는
                  통신 동기화 기능도 같이 수행
            2. concurrent 패키지의 atomic 클래스

        - 동기화에 대한 문제를 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이며 가변 데이터는 단일 스레드에서만 사용하는 것이 좋다.
        - 가변 데이터를 단일 스레드에서만 사용한다면 문서에 남겨 유지보수 정책에서도 지켜지는것이 중요하다.
        - 멀티 스레드 환경에서 한 스레드가 데이터를 수정한 후에 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다.
        - 여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 메서드 모두에 반드시 synchronized 키워드를 붙이거나 가변 데이터에 atomic 변수를 사용한다.
        - 배타적 실행 (한번에 한스레드) 동작이 필요없고, 스레드 간 최신데이터만 읽는 거로도 충분하면 가변 변수에 volatile 키워드만으로도 동기화가 가능하다.

        * Concurrent 패키지
            concurrent 패키지에 존재하는 컬랙션들은 락을 사용할 때 발생하는 성능 저하를 최소한으로 만든다. 락을 여러 개로 분할하여 사용하는
            Lock Striping 기법을 사용하여 동시에 여러 스레드가 하나의 자원에 접근하더라도 동시성 이슈가 발생하지 않도록 도와주는 것이다.

            ConcurrentHashMap 은 내부적으로 여러개의 락을 가지고 해시값을 이용해 이러한 락을 분할하여 사용한다.
            분할 락을 사용하여 병렬성과 성능이라는 두 마리의 토끼를 모두 잡은 컬랙션인 것이다. 내부적으로 여러 락을 사용,
            일반적인 map 을 사용할 때처럼 구현하면 내부적으로 알아서 락을 자동으로 사용해 줄 테니 편리하게 사용할 수 있다.


- 동시성 프로그래밍에서 발생할 수 있는 문제는??   https://steady-coding.tistory.com/554
    동시성 프로그램에서는 CPU 와 RAM 의 중간에 위치하는 CPU Cache Memory 와 병렬성이라는 특징 때문에 가시성 문제, 원자성 문제가 발생할 수 있다.


- synchronized의 문제점은?
    synchronized는 스레드가 해당 블록에 lock을 걸면 lock에 접근하는 스레드들은 Blocking되기 때문에 성능 저하로 이어진다.
    스레드가 Blocking 상태에 들어가면 아무 작업도 하지 못해 자원이 낭비되고, 상태가 변경되는 동안에도 시스템의 자원을 사용하기 때문이다.


- atomic type에 대해 설명
    atomic 변수는 멀티 스레드 환경에서 원자성을 보장하기 위해 나온 개념이다. synchronized와는 다르게 blocking이 아닌 non-blocking하면서
    원자성을 보장하여 동기화 문제를 해결한다.
    atomic의 핵심 동작 원리는 CAS(Compare And Swap) 알고리즘이다.


- CAS 알고리즘에 대해 설명
    CAS 알고리즘은 현재 스레드가 가지고 있는 기존값과 메모리가 가지고 있는 값을 비교해 같은 경우 변경할 값을 메모리에 반영하고 true를 반환한다.
    다른 경우에는 변경값이 반영되지 않고 false를 반환한 다음 재시도를 하는 방식으로 동작한다. CAS 알고리즘을 통해 가시성과 원자성 문제를 해결할 수 있다.


- volatile 키워드에 대해 설명하라
    동시성 프로그래밍에서 발생할 수 있는 문제 중 하나인 가시성 문제를 해결하기 위해 사용되는 키워드이다. 가시성 문제는 여러 개의 스레드가 사용됨에 따라,
    CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다. volatile 키워드를 붙인 공유 자원은 RAM에 직접 읽고 쓰는
    작업을 수행할 수 있도록 해준다.
    가시성이란 공유 데이터를 읽는 경우의 동시성만 보장하는 것


- 자바에서 동기화 문제를 신경 써야 하는 이유는?
    자바 멀티 스레드 환경에서는 스레드끼리 static 영역과 heap 영역을 공유하기 때문에, 공유 자원에 대한 동기화 문제를 신경 써야한다.


- synchronized 키워드에 대해 설명하라
    synchronized 는 lock 을 이용해 동기화를 시키는데 총 4가지 사용법이 있다.

    synchronized method
        동기화를 시키고 싶은 클래스의 메소드에 synchronized 키워드를 붙이면 되고, synchronized method 는 인스턴스 단위의 synchronized 키워드가 붙은 메소드에 대해서만 lock 공유한다.

    static synchronized method
        static synchronized method 는 인스턴스가 아닌 클래스 단위로 lock 을 공유하며, synchronized method 와 동일하게 함수 간의 동기화가 발생한다.

    synchronized block
        synchronized block 은 block 단위로 lock 을 걸며, 2가지 사용 방법이 있다.
            첫번 째는 synchronized 의 인자 값에 this 를 사용하는 방식이다.
            두번 쨰는 synchronized 의 인자 값에 Object 를 사용하는 방식이다.

    static synchronized block
        static synchroinzed method방식과 차이는 lock객체를 지정하고 block으로 범위를 한정지을 수 있다는 점이다. 클래스 단위로 lock을 공유한다는 점은 같다.


- Singleton 객체에 synchronized 키워드를 사용하면 생기는 문제점은?
  Singleton 에 synchronized 메소드가 많을수록 멀티 스레드는 병목현상을 겪게 된다. 쉽게 말하자면 멀티 스레드를 사용하지만 Singleton 을 사용할 때는 싱글 스레드처럼 동작하는 문제가 발생한다.


- 위 문제의 해결 방법은?
    LazyHolder 방식을 사용하면 된다. 이 방법은 JVM 의 클래스 초기화 과정에 보장되는 thread-safe 특성을 이용해 Singleton 의 초기화 책임을 JVM 에게 넘겨 개발자가 직접 동기화 코드를 작성할 때 생기는 문제를 회피할 수 있다. 또한 내부 static class 를 참조하기 전까지 클래스 로딩이 발생하지 않기 때문에 메모리를 효율적으로 사용할 수 있다.


- 동시성 프로그래밍에서 발생할 수 있는 문제는?
    동시성 프로그램에서는 CPU와 RAM의 중간에 위치하는 CPU Cache Memory와 병렬성이라는 특징때문에 가시성 문제, 원자성 문제가 발생할 수 있다.


- 가시성 문제와 원자성 문제에 대해 설명하라.
    가시성 문제
        가시성이란 공유 데이터를 읽는 경우의 동시성만 보장하는 것
        여러 개의 스레드가 사용됨에 따라, CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다.
        가시성을 보장되어야 하는 변수에 volatile 키워드를 붙여줘서 RAM에서 바로 읽도록 해야 한다.
        그러나 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 해서 동시성이 보장되지 않는다.

    원자성 문제
        여러 스레드가 공유 자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미한다.
        따라서 synchronized, atomic 을 통해 원자성을 보장해야 한다.

    동시성
        동시성이란 한 CPU에서 동시에 여러 작업을 하는 것처럼 보이게 만드는 것이다.
        엄청나게 짧은 시간에 컨텍스트 스위치가 일어나며 번갈아 실행되면서 동시에 동작하는 것처럼 보이는 것.


- 스레드 풀이란?
    스레드 풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고, 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 기법이다.


- 스레드 풀을 왜 사용하는가?
  병렬 작업 처리가 많아지면 스레드 개수가 증가되고, 그에 따른 스레드 생성과 스케줄링으로 인해 CPU가 바빠져 메모리 사용량이 늘어난다.
  이는 애플리케이션의 성능 저하로 이어진다.
  스레드 풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고, 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리한다.
  작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다.
  따라서 작업 처리 요청이 폭증해도 작업 큐라는 곳에 작업이 대기하다가 여유가 있는 스레드가 그것을 처리하므로
  스레드의 전체 개수는 일정하며 애플리케이션의 성능도 저하되지 않는다.


- syncronize ??
    - 정의
        synchronized 블록에 들어있는 코드는 한번에 하나의 스레드에서만 실행할 수 있다.
        한 번에 하나의 스레드만 실행할 수 있기에 경쟁 상태를 피하기 위해 사용될 수 있다.

    - 원리
        이는 monitor 라는 것을 통해 구현된다.
        자바 오브젝트는 monitor 와 통신한다.
        스레드는 monitor 를 lock 하거나 unlock 할 수 있다.
        오직 하나의 스레드만 monitor 에 대해 락을 가질 수 있다.
        락을 가지려 하는 다른 스레드들은 락이 풀릴 때까지 블록된다.
        synchronized 블록에서는 호출할 메서드가 있는 오브젝트를 monitor 로 삼고 락을 가진다.

    - 사용법
        인스턴스 메서드에서 사용하기
        스태틱 메서드에서 사용하기
        인스턴스 메서드 내부의 코드 블록에서 사용하기
        스태틱 메서드 내부의 코드 블록에서 사용하기

    - 주의할 점
        - monitor 객체가 될 대상에 String Integer 등 불변 객체를 주지 말자.
            JVM 내부에서 String, Integer 등 특정 객체들에 대해 최적화를 해주기 때문에 이러한 Primitive Wrapper 객체들을
            monitor 객체로 사용하는 경우엔 의도치 않은 결과를 초래할 수 있다.
            this나 new Object()를 사용하는 것은 문제 없다.

        - 읽기, 쓰기를 따로 구분해서 구현하고 싶다면
            만일 한번에 2개의 스레드가 공유된 값을 읽기만 하고 업데이트 하지 않을 것이라면? 이는 thread-safe 하다고 볼 수 있다.
            이 경우에는 synchronized 만으로 구현할 수 없는데 이 때는 ReadWriteLock 클래스를 이용하면 된다.

        - 2개 이상의 스레드가 블록문에 들어오도록 구현하고 싶다면
            N 개의 스레드가 synchronized 블록에 들어오게 하고 싶다면? Semaphore 를 이용해서 구현할 수 있다.

        - 들어오는 스레드의 순서를 정하고 싶다면
            synchronized 블록에 들어오는 스레드의 순서는 따로 정해져있지 않다. Fairness 를 구현해서 정해줄 수 있다.

        - 하나의 스레드만 쓰기 역할을 하고 다른 스레드는 읽게 하고 싶다면?
            volatile variable 을 잘 살펴보면 된다.

    하나의 프로세스가 진행될 때 다른 프로세스가 간섭하지 못하게 해당 프로세스만을 진행하고 수행하도록 하는 것
    메서드 앞에 synchronized를 선언하여 동기화 시키는 방식과, 동기화 블럭을 만들어 동기화를 시키는 방식 총 2가지가 존재
        synchronized this{}라는 블럭을 통해 동기화


- Vector, HashTable, Collections.SynchronziedXXX의 문제점은?
    Vector, HashTable, SynchronziedXxx 클래스는 synchronized 메소드 또는 블록을 사용하며, 하나의 잠금 객체를 공유한다.
    따라서, 컬렉션에 하나의 스레드가 잠금을 획득하는 경우 다른 스레드들은 모든 메소드를 사용하지 못하고 Blocking 상태가 된다.
    이는 애플리케이션 성능 저하의 원인이 될 수 있다.


- SynchronizedMap과 ConcurrentHashMap의 차이점은?
    SynchronziedMap은 읽기와 쓰기 동작 시 인스턴스 자체에 잠금이 걸린다.
    그러나 ConcurrentHashMap은 각 테이블 버킷을 독립적으로 잠그는 방식을 사용한다.
    만약, 빈 버킷에 노드를 삽입할 경우 잠금(Lock) 대신 CAS 알고리즘을 사용하고,
    그 외의 변경은 접근한 버킷에만 잠금이 걸려 스레드 경합을 최소화하며 동시성을 보장해준다.


- ConcurrentHashMap 동작 방식
     ConcurrentHashMap은 각 테이블 버킷을 독립적으로 잠그는 방식을 사용한다.
     만약, 빈 버킷에 노드를 삽입할 경우 잠금(Lock) 대신 CAS 알고리즘을 사용하고,
     그 외의 변경은 접근한 버킷에만 잠금이 걸려 스레드 경합을 최소화하며 동시성을 보장해준다.


- 쓰레드 풀
    - 단순히 스레드만 사용해서 동시에 여러 작업을 실행시킬 수 있는 프로그램을 만들 수 있을까?
        - 문제
            - 스레드 생성비용이 크기 때문에 요청에 대한 응답시간이 늘어난다.
                1. Java 는 One-to-One Threading-model 로 Thread 생성한다.
                2. User Thread(Process 의 스레드) 생성시 OS Thread(OS 레벨의 스레드) 와 연결해야 한다.
                    - User Thread 는 OS Thread 에 대한 User Program 계층에서의 추상화
                3. 새로운 Thread 를 생성할 때 마다 OS Kernel 의 작업이 필요하다.
                4. Thread 는 생성 비용이 많이 든다.
                5. 작업 요청이 들어올 때마다 Thread 를 생성하면 최종적인 요청 처리 시간이 증가한다.

            - Thread 가 너무 많으면 여러가지 문제를 발생시킨다.
                1. Process 의 처리 속도보다 빠르게 요청이 쏟아져 들어오면
                2. 새로운 Thread 가 무제한적으로 계속 생성된다.
                3. Thread 가 많아 질수록 메모리를 차지하고 Context-Switching 이 더 자주 발생한다.
                4. 메모리 문제가 발생할 수 있고, CPU 오버헤드가 증가한다.

    - 그래서 나온 게 Thread Pool
        - Thread 를 허용된 개수 안에서 사용하도록 제한하는 시스템
        - Thread, 작업 큐로 이루어짐.
            1. 스레드풀에 작업 처리 요청
            2. 작업 큐에 작업들이 쌓이게 됨.
            3. 각 스레드로 작업을 보내고, 스레드는 작업을 처리함.
            4. 결과 전달

        - 해결
            - 미리 만들어 놓은 스레드를 재사용할 수 있기 때문에 새로운 스레드를 생성하는 비용을 줄일 수 있다.
            - 사용할 스레드 개수를 제한하기 때문에 무제한적으로 스레드가 생성되는 것을 방지

        => 여러 개의 작업을 동시에 처리하면서도 안정적으로 처리하고 싶을 때 Thread Pool 은 효과적

    => 스레드풀을 설정해야 하는 이유
        - 스레드풀은 응답시간과 TPS 에 영향을 주는 하나의 요소이다.
        - 잘 조정된 스레드풀은 시스템의 성능을 끌어내고 안정적인 어플리케이션 운용을 가능하게 한다.
        - 부적절하게 설정된 스레드풀은 병목 현상, CPU 오버헤드, 메모리 문제를 유발할 수 있다.

    - 어떻게 하면 스레드풀을 잘 설정해서 Server Application 을 효과적으로 구현할 수 있을까?
        - SpringBoot 설정을 통한 Tomcat Thread Pool 설정
            - server.tomcat.threads.max
                - 스레드풀에서 사용할 최대 스레드 개수, 기본 값은 200
                - 서버 어플리케이션이 동시에 처리할 수 있는 요청 개수와 관련있다.
                - 요청에 비해 너무 많게 설정 -> 놀고 있는 스레드가 많아져서 비효율 발생
                - 너무 적게 설정 -> 동시 처리 요청 수가 줄어든다. 평균응답시간, TPS 감소
                -> 기본적으로 스레드가 많아지면 CPU 오버헤드와 메모리에서 문제가 생길 수 있다.

            - server.tomcat.threads.min-spare
                - 스레드풀에서 최소한으로 유지할 스레드 개수, 기본값은 10
                - 너무 많이 설정 -> 스레드풀이 항상 유지해야 할 스레드 수가 너무 많아진다.
                - 적절하게 설정 -> 적은 수의 요청에서 새로운 스레드를 만들 필요없이 요청을 효과적을 처리할 수 있다.
                -> 잘못 설정했을 때 사용하지 않는 스레드가 메모리를 차지하면서 비효율을 발생시킨다.

            - server.tomcat.max-connections
                - 동시에 처리할 수 있는 최대 Connection 의 개수, 기본 값은 8192
                - 사실상 서버의 실질적인 동시 요청 처리 개수
                    - 톰캣의 커넥터 컴포넌트의 방식에 따라서 개수 설정
                        - Blocking IO: 1 Connection 1 Thread
                        - Non-Blocking IO: N Connection 1 Thread
                    - tomcat 8 버전 이후부터는 Non-Blocking IO 방식 사용
                - Non-Blocking IO 에서는 스레드풀을 최대 스레드 개수보다 많은 양의 Connection 을 유지할 수 있다.
                - Non-Blocking IO 에서는 최대 스레드 개수보다 적거나 같은 수의 max-connections 를 설정하는 것은 비효율적인
                  설정이 될 수 있다.

            - server.tomcat.accept-count
                - max-connections 이상의 요청이 들어왔을 때 사용하는 요청 대기열 큐의 사이즈, 기본 값은 100
                - 너무 크게 설정 -> 대기열이 커지면서 메모리 문제 유발
                - 너무 작게 설정 -> 요청이 몰렸을 때 들어오는 요청들을 거절해 버릴 수 있다.
                -> 이 설정을 하는 이유 중 하나는 부적절하거나 잘못된 요청이 한번에 너무 많이 들어와
                   서버에 장애를 발생시키는 것을 방지하기 위함도 있다.


- 잘 운영하고 있던 어플리케이션이 갑자기 Out of Memory Error(OOM)를 내며 프로세스가 종료되었습니다. 어떻게 대처해볼 수 있을까요??   https://baek-kim-dev.site/53
    - Java의 OOM와 Memory Leak
        자바는 Garbage Collection이라는 메모리 관리 방식을 채택하고 있어서, 사용자는 메모리에 큰 관심을 두지 않고도 어플리케이션을 작성할 수 있지만,
        떄로는 메모리 누수 (Memory Leak)에 관심을 가져야 할 때가 있다.

        메모리 누수란 Garbage Collection되어야 할 메모리가 정리되지 못하고 계속 Java의 메모리 공간에 남아있는 현상을 말한다.
        이 Memory Leak이 계속 되면 결국 OOM( Out Of Memory - 메모리 부족)현상이 발생해서 어플리케이션이 더이상 동작하지 못하고
        JVM이 종료되는 최악의 상황이 된다.
        그러므로 상용, 특히 24시간 서비스하는 웹서버등의 경우에는 항상 이 메모리 누수 현상이 발생하지 않는지 관심을 둘 필요가 있다.

        메모리 릭의 양이 아주 작고 메모리는 많은 경우에는 주기적으로 JVM을 재시작 하면서 크게 신경안써도 될 경우도 있지만,
        메모리릭이 빠르게 증가하는 경우에는 반드시 해결해줘야 한다.

    - OOM왜 발생할까?
        크게 보았을 때 OOM가 나는 이유는 단순하다. 메모리를 어플리케이션에서 강참조를 하고 있기 떄문이다. 강참조란 대부분의 일반적인 변수 참조를 말한다.
        예를 들어 static HashMap mapper = new HashMap(); 같은. static같은 정적 메모리로 선언되어있다면 메모리에서 지워지지 않고 계속 남을 것이다.
        의도한 코드가 아닌 경우 릭으로 발전할수 있다.

    - 어떻게 OOM의 원인, 즉 memory leak을 찾을까?
        1) JVM이 OOM exception으로 정지된것을 확인
        2) 정지된 JVM의 메모리 영역을 확인했더니 특정 영역이 Full 로 가득차있고, GC 후 메모리 할당을 받는 것에 실패한 것을 확인.
        3) 영역에 따른 원인을 추정한다.
        4) 코드 레벨에서 바로 수정이 가능한 것인지를 확인한다. 많은 경우 싱글톤이나 static을 잘못 사용했을 확률이 높다.
        5) 쓰레드 생성이나 JNI에서 OOM이 나는 경우에는 OS의 자원 소진일 우려가 있다. 이 경우 외부 자원을 조심스럽게 쓰던지, 외부 자원량을 늘려야 한다.
        6) 프로젝트 규모가 큰 경우거나 외부 라이브러리를 적극적으로 사용한 경우에는 문제의 해결이 쉽지 않다. JVM 옵션과 tool의 도움을 받는다.
            - jvm 시작시에 -verbose:gc옵션을 추가한다. 가비지 콜렉션 로그를 자세히 볼 수 있다.
            - jvm 시작시에 -XX:+HeapDumpOnOutOfMemoryError 추가한다. JVM 정지시에 힙 덤프를 받아 놓을 수 있다.
            - jvm 시작시에  –verbose:class옵션을 추가한다. 클래스 로드, 언로드 상황을 볼 수 있다.
        7) 인텔리제이 프로파일링을 사용해 힙덤프 내역을 분석한다.
           ( Eclipse MAT을 사용해 힙덤프 내역을 분석한다. )

    - heap dump 뜨는 방법 ??
        - jmap명령어를 통해 파일 생성(운영중 힙덤프 뜨는방법)
            1. $JAVA_HOME/bin 으로이동. (환경변수 설정 되어있을경우 2번으로 바로 넘김)
            2. 커맨드 창에 jps -v 입력. pid 확인.
            3. 힙덤프 뜰 경로로 이동
            4. jmap -dump:format=b,file=<파일명>
                ex)jmap -dump:format=b,file=testapp 353
            5. MAT 으로 덤프확인

        - spring actuator를 이용
            - 웹 애플리케이션 경우에만 사용 가능.
            - Warning: Java 애플리케이션에서 STW(Stop The world) 가 발생하므로 운영 중인 서비스에서는 사용하지 않는 것이 좋습니다.


- Heap을 왜 모니터링 해야 하는가?  https://steady-coding.tistory.com/591
  Spring 개발한 웹 애플리케이션을 운영하다 보면, 어떠한 이유로 사용하지 않는 메모리가 쌓이면서 메모리 누수 현상이 발생할 수 있다. 이것은 모니터링을 하지 않는 이상 정확한 이유를 알기 매우 어려우며, 메모리 누수를 방치하면 어느 순간 OOM(Out Of Memory) 에러가 발생할 수 있다. 따라서 주기적으로 Heap 영역을 모니터링하고, 의심되는 상황이 있다면 Heap Dump를 떠서 어떤 객체가 원인이 분석해야 한다.


- Heap Dump는 언제 사용하는가?
  Heap Dump는 메모리 누수 현상 혹은 OOM 에러가 발생했을 때, 어떠한 객체가 원인인지 분석하기 위해 사용된다.


- Heap Dump를 분석하여 OOM을 해결한 사례가 있는가?
  개인의 경험을 이야기할 것. 필자는 엑셀 라이브러리인 XSSF 라이브러리를 사용하다가 OOM 에러가 발생하였음.


- 스레드 모니터링과 스레드 덤프가 왜 필요한가?  https://steady-coding.tistory.com/597
  웹 서버에서는 많은 수의 동시 사용자를 처리하기 위해 수많은 스레드를 사용한다. 두 개 이상의 스레드가 같은 자원을 이용할 때는 필연적으로 스레드 간에 경합(Contention)이 발생한다. 스레드 경합 때문에 데드락과 같은 다양한 문제가 발생할 수 있으며, 이런 문제들을 분석하기 위해서는 스레드 모니터링과 스레드 덤프가 필수이다.


- 직렬화 ??
    - 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술
    - JVM의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술

    - 직렬화를 하려면 우선 Serializable 인터페이스를 implements
    - 직렬화 제외하기 - transient
        - 만약 transient로 직렬화에 포함되지 않은 데이터를 읽을 때는 null로 읽힌다.

    - 객체 쓰기 (ObjectOutputStream)
        - 객체를 쓰려면 stream을 열어야 한다.

    - 객체의 직렬화나 역직렬화에서 클래스는 완전한 동일한 클래스를 통해서 쓰고 읽혀야 한다.

    - InvalidClassException 이라는 예외가 발생함으로 우리는 직렬화 클래스의 버전을 관리해줘야 한다.
    - serialVersionUID를 통해서 버전이 같은 클래스인지 아닌지 판단할 수 있다.


- 직렬화란?
  메모리를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형식으로 변환하는 것이다.
  특별히, 자바 직렬화는 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술을 뜻한다.


- 직렬화가 왜 필요한가?
  디스크에 저장하거나 통신할 때는 값 형식 데이터만 사용할 수 있다. 참조 형식 데이터는 실제 데이터 값이 아닌 힙에 할당되어 있는 메모리 번지 주소를 가지고 있기 때문이다.
  이때 직렬화를 하게 되면 각 주소 값이 가지는 데이터를 전부 끌어 모아서 값 형식 데이터로 변환해 준다. 직렬화가 된 데이터는 언어에 따라서 텍스트 또는 바이너리 등의 형태가 되는데, 이러한 형태가 되었을 때 저장하거나 통신할 때 파싱이 가능한 유의미한 데이터가 된다.


- 역직렬화란?
  디스크에 저장한 데이터를 읽거나, 네트워크 통신으로 받은 데이터를 메모리에 쓸 수 있도록 변환하는 것이다. 특별히, 자바 역직렬화는 바이트로 변환된 데이터를 다시 객체로 변환하는 기술을 뜻한다.


- 자바 직렬화는 언제 쓰는가?
  짧은 만료 시간을 지니는 데이터를 가지고 있는 객체를 직렬화 할 때
  거의 변경되지 않는 데이터를 지닌 객체를 직렬화 할 때


- 자바 직렬화를 사용하는 기술은 무엇이 있는가?
  서블릿 세션
  캐시
  자바 RMI


- 자바 직렬화의 장점은?
  자바 직렬화는 자바 시스템에서 개발에 최적화되어 있다.
  복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화, 역직렬화가 가능하다.
  데이터 타입이 자동으로 맞춰지기 때문에 역직렬화가 되면 기존 객체처럼 바로 사용이 가능하다.


- 자바 직렬화의 단점은?
  직렬화한 객체의 구조와 역직렬화 할 현재 객체의 구조가 다르면 에러가 발생한다.
  타입 체크가 매우 엄격하다.
  타 직렬화에 비해 직렬화 된 데이터의 용량이 크다.


- 직렬화  https://hudi.blog/serialization/
    @RequestBody 와 @ResponseBody 등의 어노테이션을 사용하면 자동으로 객체를 JSON으로 직렬화하고, JSON을 객체로 역직렬화
    내부적으로 JSON 직렬화, 역직렬화를 위해 Jackson 이라는 라이브러리를 사용
    일반적으로 자바에서 직렬화라고 이야기하는 것은 객체를 Byte로 변환하는 과정을 의미
    예전에는 XML 포맷을 사용했지만 최근에는 대부분 JSON 포맷을 사용

    자바는 자바 시스템끼리의 객체 교환을 위해 Serializable 인터페이스를 구현하는 객체를 바이트 스트림으로 직렬화/역직렬화 하는 기능을 제공
    자바에서 제공하는 직렬화는 여러가지 문제(특히 치명적인 보안 이슈)를 안고있다고 하며, 그 대안으로는 책에서는 JSON등의 포맷을 추천한다.


- SerialVersionUID를 선언해야 하는 이유에 대해 설명해주세요.
    - JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 됩니다.
      그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를 사용합니다.
    - 만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있다.


- 리플렉션(Reflection)이란 무엇인지 설명해주세요.
    - 리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API 입니다.
    - 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용됩니다.
    - 프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. intelliJ의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있습니다.

    자바는 클래스와 메소드 자체를 포함해 클래스의 변수, 메소드의 파라미터 타입, 메소드 이름 등의 메타 정보들을 위한 Class, Method 등을 정의해두었다.
    리플렉션을 이용하면 정적으로 고정된 메소드의 코드를 메타정보로 추상화된 Method를 얻어낼 수 있으며 직접 호출 또한 가능하다.

    ex)
    - BeanFactory에서 객체가 호출되면 객체의 인스턴스를 생성하게 되는데 이 때 필요. 즉, 프레임워크에서 유연성있는 동작을 위해 쓰게 됩니다.
    - 스프링에 @autowired 어노테이션에 동작에는 reflection 사용되고 있음.


- 리플렉션이란?
    구체적인 클래스 타입을 알지 못하더라도 그 클래스의 메서드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API
    컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법


- 리플렉션은 언제 사용하는가?
  규모가 작은 콘솔 단계에서는 개발자가 충분히 컴파일 시점에 프로그램에서 사용될 객체와 의존 관계를 모두 파악할 수 있다.
  하지만 프레임워크와 같이 큰 규모의 개발 단계에서는 수많은 객체와 의존 관계를 파악하기 어렵다. 이때 리플렉션을 사용하면
  동적으로 클래스를 만들어서 의존 관계를 맺어줄 수 있다.
  가령, Spring의 Bean Factory를 보면, @Controller, @Service, @Repository 등의 어노테이션만 붙이면
  Bean Factory에서 알아서 해당 어노테이션이 붙은 클래스를 생성하고 관리해 주는 것을 알 수 있다. 개발자는 Bean Factory에 해당 클래스를 알려준 적이 없는데,
  이것이 가능한 이유는 바로 리플렉션 덕분이다. 런타임에 해당 어노테이션이 붙은 클래스를 탐색하고 발견한다면,
  리플렉션을 통해 해당 클래스의 인스턴스를 생성하고 필요한 필드를 주입하여 Bean Factory에 저장하는 식으로 사용이 된다.


- 리플렉션의 단점
    일반적으로 메소드를 호출한다면, 컴파일 시점에 분석된 클래스를 사용하지만 리플렉션은 런타임에 클래스를 분석하므로 속도가 느리다.
    JVM을 최적화할 수 없기 때문이라고 한다. 그리고 이런 특징으로 인해 타입 체크가 컴파일 타임에 불가능하다. 또한 객체의 추상화가 깨진다는 단점도 존재한다.
    따라서 일반적인 웹 애플리케이션 개발자는 사실 리플렉션을 사용할일이 거의 없다. 보통 라이브러리나 프레임워크를 개발할 때 사용된다.
    따라서 정말 필요한 곳에만 리플렉션을 한정적으로 사용해야한다.


- Java SE와 Java EE 애플리케이션 차이
    - JAVA SE (Java Standard Edition)
        - 표준 자바 플랫폼 / 자바 API 집합체(패키지)
        - 자바 표준 에디션은 가장 기본이 되는 에디션입니다.흔히 자바 언어라고 하는 대부분의 패키지가 포함된 에디션이며
          주요 패키지로는 java.lang., java.io., java.util., java.awt., javax.rmi., javax.net. 등이 있습니다.

    - JAVA EE (Java Enterprise Edition)
        - 자바를 이용한 서버측 개발을 위한 플랫폼 / 기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델
        - 기존 SE에서 서버측을 위한 가능이 더 추가되어있습니다.
        - 엔터프라이즈 환경을 위한 도구로 자바로 구현되는 웹프로그래밍에서 가장 많이 사용되는 JSP, Servlet을 비롯하여,
          데이터베이스에 연동하는 JDBC, 그 외에도 JNDI, JTA, EJB 등의 많은 기술들이 포함되어 있습니다.
        - Java EE는 Java SE의 API에 추가로(lib 디렉토리에 포함되어 있는 JAR파일들)의 차이입니다.


- 자바 LTS 버전별 특징
    - 자바 8
        - interface default Method
        - Lambda
        - Stream
        - Optional
        - LocalDateTime
        - Java 8의 Default GC는 Paralle GC

    - 자바 11
        - 자바 파일 실행
            이전 java는 소스를 컴파일하여 class로 뽑은 후 class를 실행했는데 java를 통해 바로 실행할 수 있게 되었다.
        - String, Files 클래스에 메소드 추가
        - default GC 변경 - G1GC

    - 자바 17
        - 텍스트 블록 기능 추가
            기존 String을 여러 줄 작성할 때 사용 가능한 기능, 가독성 있는 코드 지원

        - Record Data class 추가
            immutable 객체를 생성하는 새로운 유형의 클래스로 기존 toString, equals, hashCode Method에 대한 구현을 자동 제공

        - Pattern Matching for switch
            switch 문에서 pattern matching을 사용할 수 있도록 한다.

        - Sealed 클래스 업데이트
            무분별한 상속을 막기 위한 목적으로 등장한 기능으로 지정한 클래스 외 상속을 허용하지 않으며, 지정한 클래스 외 상속 불가능
            sealed 클래스의 경우 클래스의 상속 계층 구조를 미리 선언할 수 있도록 한다.
            이를 통해 클래스의 확장성과 보안성을 높일 수 있다.

        - 향상된 난수 생성기 제공


- 생성자 대신 정적 팩토리 메서드
    - 객체 생성의 역할을 하는 클래스 메서드

    1. 이름을 가질 수 있다.
        정적 팩토리 메서드를 사용하면 메서드 이름에 객체의 생성 목적을 담아 낼 수 있다.

    2. 호출할 때마다 새로운 객체를 생성할 필요가 없다.
        정적 팩토리 메서드와 캐싱구조를 함께 사용하면 매번 새로운 객체를 생성할 필요가 없어진다.

    3. 하위 자료형 객체를 반환할 수 있다.
        생성자의 역할을 하는 정적 팩토리 메서드가 반환값을 가지고 있기 때문에

    4. 객체 생성을 캡슐화할 수 있다.
        정적 팩토리 메서드는 객체 생성을 캡슐화하는 방법이기도 하다.
        DTO와 Entity간에는 자유롭게 형 변환이 가능해야 하는데, 정적 팩토리 메서드를 사용하면 내부 구현을 모르더라도 쉽게 변환할 수 있다.

    - 정적 팩토리 메서드 네이밍 컨벤션
        from : 하나의 매개 변수를 받아서 객체를 생성
        of : 여러개의 매개 변수를 받아서 객체를 생성
        getInstance | instance : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.
        newInstance | create : 새로운 인스턴스를 생성
        get[OtherType] : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.
        new[OtherType] : 다른 타입의 새로운 인스턴스를 생성.


- 정적 팩토리 메서드(Static Factory Method)는 왜 사용할까?
    https://hudi.blog/effective-java-static-factory-method/


- enum 이 뭐냐? 사용하는 이유?   https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%97%B4%EA%B1%B0%ED%98%95Enum-%ED%83%80%EC%9E%85-%EB%AC%B8%EB%B2%95-%ED%99%9C%EC%9A%A9-%EC%A0%95%EB%A6%AC
    - 정의
        enum의 핵심은 이러한 상수를 단순히 정수로 치부하지 말고 객체 지향적으로 객체화해서 관리하자는 취지이다.
        enum은 인터페이스와 같이 독립된 특수한 클래스로 구분한다. 즉, 일종의 객체이기 때문에 힙(heap) 메모리에 저장되며
        각 enum 상수들은 별개의 메모리 주소값을 가짐으로써 완벽히 독립된 상수를 구성할 수 있는 것이다.
        사실 enum 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개하기 때문이다.

    - 장점
        코드가 단순해지며, 가독성이 좋습니다.
        인스턴스 생성과 상속을 방지하여 상수값의 타입안정성이 보장됩니다.
        enum class를 사용해 새로운 상수들의 타입을 정의함으로 정의한 타입이외의 타입을 가진 데이터값을 컴파일시 체크한다.
        키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 알 수 있습니다.
        enum은 데이터의 그룹화 및 관리에 용이
            한 클래스 내에서 관리
            관계를 가시적으로 표현
        enum은 상태와 행위를 한곳에서 관리가 가능
        리팩토링시 변경 범위가 최소화 된다.


- printStackTrace()를 사용하면 안되는 이유 ??
    1. 오류 출력이 실제로 어디로 가는지 알 수 없다.
        System.err 는 System.setErr()를 통해 변경될 수 있으므로 이 오류가 어디에 출력되는 것인지 알 수 없다.
    2. 많은 오버헤드가 발생한다.
        내부에서 동기화를 위한 synchronized, Reflection 호출 등 많은 오버헤드가 발생한다.
    3. 보존 정책을 설정할 수 없다.
        보존 정책을 설정할 수 없으므로 기본적으로 Log 가 Application 생명주기와 함께한다.
    4. 보안성이 떨어진다
        StackTrace 를 통해 메서드 내부 동작 구조가 노출되기 때문에 보안성이 떨어지므로 외부에 노출해선 안된다.


- 자바에서 스레드를 생성하는 방법은 무엇인가요?
    - 자바에서 스레드를 생성하는 방법은 크게 2가지가 있습니다.
        1) Thread 클래스를 상속 받고 run 메소드를 오버라이딩하면 됩니다.
        2) Runnable 인터페이스를 구현하여 run 메서드를 오버라이딩합니다.
           그 다음 아래와 같이 Thread 생성자의 파라미터로 넘겨 start 메소드를 호출하면 됩니다.


- Inner Class(내부 클래스)의 장점에 대해 설명해주세요.
    1. 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
    2. 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
    3. 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다.


- 내부 클래스는  static 클래스로 선언하자
    내부 클래스에서 바깥 외부의 인스턴스를 사용할 일이 없다면 static 클래스로 선언해주어야 한다.
    static이 아닌 내부 인스턴스 클래스는 외부와 연결이 되어 있어 '외부 참조'를 갖게되어
    메모리를 더 먹고, 느리며, 또한 GC 대상에서 제외되는 여러 문제점을 일으키기 때문

    일반적으로 내부 인스턴스 클래스를 만들기 위해서는 먼저 외부 클래스를 초기화한뒤 내부 클래스를 초기화해야 한다.
    이러한 단계 과정 때문에 inner 클래스는 자신을 만들어준 인스턴스에 대한 '외부 참조'를 갖게 된다.
    심지어 내부 클래스가 외부의 멤버를 사용하지 않아도, 숨겨진 외부 참조가 생성되게 된다.
    만일 외부 클래스는 필요가 없어지고 내부 클래스만 남아있을경우,
    필요없어진 외부 클래스를 GC 대상으로 삼아 메모리에서 제거해야 되지만 외부 참조로 내부 클래스와 연결되어 있기 때문에 메모리에서
    제거가 안되고 잔존하게 되고 이는 곧 메모리 누수로 프로그램이 터지게 된다.


- Marker Interface가 무엇인가요?
    - 상수도 없고 메서드도 없는 완전히 비어있는 인터페이스를 의미. 어떤 특별한 행동을 JVM에게 알려주는 역할. 태그 인터페이스
    - 예시)
        Serializable - 객체 직렬화 가능
        Clonnable - 객체의 복제가 가능
        SingleThreadModel - 싱글스레드로 처리함. 만약 서블릿이 이를 구현했다면 싱글스레드로 처리함.
        Remote - RMI에서 사용하는 객체의 경우 원격호출로 사용 가능


- JAVA RMI  가 무엇인가요?
    - RMI 는 Remote Method Invocation 의 약자입니다. 분산된 객체간의 통신을 구현하는 모든 프로토콜을 의미합니다. 쉽게 이야기 하면 JVM 간의 통신입니다.
        1) 원격객체를 RMI Registry 에 등록합니다.
        2) Client가 객체 참조값을 얻어옵니다.
        3) RMI 를 이용하여 Server의 원격객체를 사용합니다.


- java에서 파일을 읽어올 때 왜 스트림을 쓰냐?   https://blog.hexabrain.net/127
    순서가 있는 자료의 흐름을 stream이라고 한다.
    파일로 데이터를 출력하려면 이 데이터들이 순서를 가지고 내보내 져야 한다.
    또, 파일로 부터 데이터를 읽어 오려면 역시 파일의 내용이 순서대로 읽어 와 져야 한다.
    이와 같이 순서 있는 자료의 흐름을 stream이라고 한다.
    자바는 순서 있는 자료의 흐름을 위하여 stream을 제공한다.

    Stream이란, 데이터를 운반하는데 사용되는 연결 통로라고 생각하면 된다. 또한, 데이터가 들어온 순서대로 흘러다니는 단방향 통로
    Java에서는 각종 I/O 장치의 데이터 이동에 사용되는 인스턴스
    stream 형성을 통해 데이터의 흐름을 위한 통로를 만드는 것
    Stream을 통해 데이터는 기본적으로 byte 또는 byte[] 형태로 흐르며 동기적, blocking 방식으로 동작


- java.util.Date vs java.time.LocalDate   https://jake-seo-dev.tistory.com/91
    자바에서 날짜를 지원하는 대표적인 API 는 2가지가 있다.
        java.util.Date: Java 8 이전부터 존재한 API 이다.
        java.time.LocalDate: Java 8 부터 생긴 API 이다.

    API 가 명확해졌다.
        기존 Date 클래스의 경우, Date 라는 이름과 달리 시간까지 포함
        또한 Calendar 클래스의 경우, 월은 0-11 까지의 숫자로 표현하면서 일은 1-31 까지의 숫자로 표현하는 등 일관성이 없다.
        반면, java.time.LocalDate 는 날짜만 다루는 역할을 하고, 시간까지 다루기 위한 java.time.LocalDateTime 이라는 API 가 따로 정의되어 있다.

    유용한 유틸 메서드를 제공한다.
        포맷, 파싱이 더 쉬워졌다. API에서 자체적으로 포맷, 파싱 메서드를 제공한다.
        날짜 더하기, 빼기 기능을 지원한다. API 에서 자체적으로 더하기, 빼기 메서드를 제공한다.

    불변성을 보장하며, 스레드 안전(thread-safe)하다.


- java8 이후에 Date vs localDatetime 클래스들의 차이점은?   https://umanking.github.io/2020/05/09/java-date-time/
    - 자바 1.0 Date 클래스
        1900년을 기준으로 하는 오프셋, 0에서 시작하는 달 인덱스 등 모호한 설계로 유용성이 떨어졌다.
        결과가 직관적이지 않다. 또한 Date클래스의 toString으로 반환되는 문자열을 추가로 활용하기도 어렵다.
        그렇다고 Date클래스가 자체적으로 시간대 정보를 알고 있는 것도 아니다.

    - 자바 1.1 Calendar 클래스
        1900년도에서 시작하는 오프셋은 없앴지만 여전히 달의 인덱스는 0부터 시작
        Date와 Calendar 두 가지 클래스가 등장하면서 개발자들에게 혼란
        DateFormat 같은 일부 기능은 Date 클래스에서만 작동
        DateFormat도 문제가 있다. 스레드에 안전하지 않다. 즉, 두 스레드가 동시에 하나의 포매터로 날짜를 파싱할 때 예기치 못한 결과가 일어날 수 있다.
        Date, Calendar 모두 가변 클래스다. 가변 클래스라는 설계 때문에 유지보수가 아주 어려워진다.

    -> 1900년을 기준으로 하는 오프셋, 0에서 시작하는 달 인덱스 등 모호한 설계로 유용성이 떨어졌다.
       날짜 생성은 Date 객체, 날짜 연산은 Canlender 객체, 최종 결과는 다시 Date객체
       가변 클래스
       일관성 없는 요일 상수
          Calendar.get(Calendar.DAYOFWEEK) : 일요일은 1
          Date.getDay() : 일요일은 0

    - 자바 1.8 LocalDateTime
        시간과 날짜를 표현하는 불변객체
        정적팩토리 메서드로 of 로 인스턴스를 만들 수 있다.
        내장 메서드를 통해서 가독성을 높일 수 있다.


- 메모리 주소만으로 Heap의 인스턴스에 접근할 수 있을까?
    개발자는 객체의 주소를 직접적으로 지정할 수 없다. 오직 간접적으로만 할 수 있다.
    왜냐하면 실제 주소를 알 수 없기 때문이다.
    JVM만이 객체가 메모리에 저장되어 있는 위치를 알고 있으며, 할당 작업을 실행하는 동안 해당 주소를 변수에 할당한다.
    참조 변수에 직접 지정할 수 있는 주소는 null 뿐이다.

    - JVM만이 객체가 메모리에 저장되어 있는 위치를 아는 이유
        자바에선 변수의 메모리 주소를 얻는 것은 무의미하다.
        왜냐하면 JVM은 자유롭게 객체를 구현하고, GC를 이용해 그 객체의 위치를
        이동시키기 때문이다. JVM만이 정확한 메모리 주소를 알고있다.


- Arrays.asList()와 List.of()의 차이 ??
    - Arrays.asList()
        고정된 리스트로써 add/remove 시 UnsupportedOperationException 발생
        입력된 원본 array를 List 인터페이스로 감쌀 뿐이기 때문에 기존 array의 변경이 list에도 반영됨
        가변 리스트(Mutable list)를 반환

    - List.of()
        JAVA 9에서 도입된 메소드
        입력된 array에 대해 불변의(immutable) list를 반환 -> 원본 array의 변경이 생성된 list에 반영되지 않음
        인풋으로 null이 허용되지 않음(입력 시 NullPointerException 발생)

    결론적으로 Arrays.asList()는 Array로부터 생성된 list 안의 element의 변경이 원본 array에도 반영될 수 있기 때문에 찾기 어려운 버그를
    발생시키는 side effects를 초래할 수 있습니다. 따라서 JAVA 9 이상을 사용하는 환경이라면
    되도록 List.of()를 사용하도록 하고, 두 메소드의 차이점도 확실히 알고 사용해야겠습니다.


- 원시 타입을 포장해야 하는 이유 ??
    원시 타입 값을 포장하게 되면, 그 변수가 의미하는 바를 명확히 나타낼 수 있다. 책임 관계 또한 보다 명확해지고 코드의 유지, 보수에도 많은 도움이 된다.


- 정적 팩토리 메서드(Static Factory Method)는 왜 사용할까?
    객체 생성의 역할을 하는 클래스 메서드
    생성자 대신 정적 팩토리 메서드를 고려하라

    1. 이름을 가질 수 있다.
        메서드 이름에 객체의 생성 목적을 담아 낼 수 있다.

    2. 호출할 때마다 새로운 객체를 생성할 필요가 없다.
        enum과 같이 자주 사용되는 요소의 개수가 정해져있다면 해당 개수만큼 미리 생성해놓고 조회(캐싱)할 수 있는 구조로 만들수 있다.

    3. 하위 자료형 객체를 반환할 수 있다.
        하위 자료형 객체를 반환하는 정적 팩토리 메서드의 특징은 상속을 사용할 때 확인할 수 있다.
        이는 생성자의 역할을 하는 정적 팩토리 메서드가 반환값을 가지고 있기 때문에 가능한 특징이다.

    4. 객체 생성을 캡슐화할 수 있다.
        만약 정적 팩토리 메서드를 쓰지 않고 DTO로 변환한다면 외부에서 생성자의 내부 구현을 모두 드러낸 채 해야할 것이다.

    -> 이처럼 정적 팩토리 메서드는 단순히 생성자의 역할을 대신하는 것 뿐만 아니라,
       우리가 좀 더 가독성 좋은 코드를 작성하고 객체지향적으로 프로그래밍할 수 있도록 도와 준다.


- Java에서의 함수형 프로그래밍
    Java 8이 릴리즈되면서, Java에서도 함수형 프로그래밍이 가능해졌다.
    함수형 프로그래밍이란 부수효과를 없애고 순수 함수를 만들어 모듈화 수준을 높이는 프로그래밍 패러다임
    최대한 순수함수를 지향하고, 숨겨진 입출력을 최대한 제거하여 코드를 순수한 입출력 관계로 사용하는 것이 함수형 프로그래밍의 목적이다.

    여태까지 우리는 Java에서 객체지향 프로그래밍을 할 때 '데이터를 어떻게 처리할 지에 대해 명령을 통해 해결'했다.
    함수형 프로그래밍은 선언적 함수를 통해 '무엇을 풀어나가야할지 결정'하는 것

    Java에서 활용할 수 있는 함수형 프로그래밍
        람다식
        stream api
        함수형 인터페이스


- JDK 와 JRE 의 차이
    - JRE
        - JVM + Java class Libraries + Java Class Loader 가 포함된다.
        - JRE 는 자바 어플리케이션을 실행하는데 필요한 요소만 들어있지 자바를 개발하는 데 필요한 툴은 포함되어 있지 않다.
    - JDK
        - JRE 뿐만 아니라 컴파일러, 디버거 등 자바 어플리케이션을 개발하는데 필요한 도구가 포함되어 있다.
        - JAVA9버전 부터는 JRE 자체가 사라졌다. (JDK 안에 다 있으니..)


- Stack vs Heap  https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD%EC%8A%A4%ED%83%9D-%ED%9E%99
    Stack 영역이 클 수록 Heap 영역이 작아지고 Heap 영역이 클 수록 Stack 영역이 작아진다.
    스택 할당 속도와 힙 할당 속도를 비교해보자.
    결론부터 말하자면 스택이 훨씬 빠르다. 스택은 이미 할당 되어있는 공간을 사용하는 것이고 힙은 사용자가 따로 할당해서 사용하는 공간이다.
    다만 스택은 공간이 매우 적기 때문에 모든 응용에서 스택을 사용할 수 는 없다.
    좀 더 자세히 알아보면,
    스택에서 할당의 의미는 이미 생성되어 있는 스택에 대해 포인터의 위치만 바꿔주는 단순한 CPU Instruction(덧셈과 뺄셈 연산, 일반적으로 단일 Instruction)이다.
    반면 힙에서의 할당은 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등 다양한 요소를 고려하기 때무에 더 많은 CPU Instruction이 필요하다.

    힙 메모리는 애플리케이션의 모든 부분에서 사용되며, 반면에 스택 메모리는 하나의 스레드가 실행될 때 사용.

    스택메모리의 생명주기는 매우 짧으며, 힙 메모리는 애플리케이션의 시작부터 끝까지 살아남는다.

    스택 메모리가 가득차면 자바에서는 java.lang.StackOverFlowError를 발생.
    힙 메모리가 가득차면 java.lang.OutOfMemoryError : Java Heap Space 에러를 발생

    스택 메모리 사이즈는 힙 메모리와 비교했을 때 매우 적다. 하지만 스택 메모리는 간단한 메모리 할당 방법(LIFO)를 사용하므로 힙 메모리보다 빠르다.


- 제어자 조합해서 사용할 때 주의할 사항
    1) 메서드에 static과 abstract를 함께 사용할 수 없다.
        static 메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문

    2) 클래스에 abstract와 final을 동시에 사용할 수 없다.
        클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문

    3) abstract메서드의 접근 제어자가 private일 수 없다.
        abstract메서드는 자손클래스에서 구현하기 위해 접근해야 하기 때문

    4) 메서드에 private와 final을 같이 사용할 필요는 없다.
        접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.


- 경쟁 조건의 두 가지 형태: Read-Modify-Write, Check-Then-Act
    https://hudi.blog/read-modify-write-and-check-then-act/

- BigInteger와 BigDecimal
    https://hudi.blog/java-biginteger-bigdecimal/

    - BigInteger와 BigDecimal
        float, double 은 부동소수점 연산을 처리하며, 실수 연산의 근사치가 저장되기때문에 실제 기대 결과와 다른 결과로 연산될 수 있다.
        이런 부동소수점의 특징은 금융 계산 등에서는 이런 오차가 치명적일 수 있다. 따라서 정확한 실수 연산이 필요하다면
        float, double 보다는 BigDecimal 을 사용하는 것이 좋다.
        BigDecimal 은 BigInteger 와는 다르게 원시타입 float 혹은 double 을 생성자에 넣어 생성할 수 있다.

        BigDecimal bigDecimal = new BigDecimal(1.1);
        System.out.println(bigDecimal);
        // 1.100000000000000088817841970012523233890533447265625

        하지만 위 예시처럼 예상과 다른 값을 얻게될 수 있으므로, BigInteger 와 같이 문자열로 객체를 생성하는 것을 추천한다.

        또는 아래와 같이 valueOf 정적 팩토리 메소드를 사용하여 객체를 생성할 수 있다. valueOf 는 내부적으로 toString 을 호출하므로 예상 불가능한 값이 나올 위험이 없다.
        BigDecimal bigDecimal = BigDecimal.valueOf(1.1);
        System.out.println(bigDecimal);
        // 1.1

        원시타입으로 표현할 수 없는 아주 큰 값을 표현하거나, 아주 정밀한 계산이 요구 될 때는 원시타입 대신 BigInteger 와 BigDecimal 을 사용하자. 단, 연산의 불편함과 느린 속도를 감수해야한다.


- 롬복의 동작원리
    Lombok은 컴파일 시점에 바이트코드를 변환하여 원하는 부분을 주입해주는 방식으로 동작한다.

    1. javac는 소스파일을 파싱하여 AST트리를 만든다.
    2. Lombok은 AnnotaionProcessor에 따라 AST 트리를 동적으로 수정하고 새 노드(소스코드)를 추가하고 마지막으로 바이트 코드를 분석 및 생성한다.
       (컴파일 과정에서 생성된 Syntax Tree는 com.sun.source.tree.*에서 public accesss를 제공한다.)
    4. 최종적으로 javac는 Lombok Annotation Processor에 의해 수정된 AST를 기반으로 Byte Code를 생성한다.

- 자바 요약
    https://www.codelatte.io/courses/java_programming_basic

- 탑레벨 클래스
    https://donghyeon.dev/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/2021/03/20/%ED%83%91%EB%A0%88%EB%B2%A8-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%ED%95%9C-%ED%8C%8C%EC%9D%BC%EC%97%90-%ED%95%98%EB%82%98%EB%A7%8C-%EB%8B%B4%EC%9E%90/

- exception
    https://www.youtube.com/watch?v=EZccJBM3t78


- [Java] Multi Thread환경에서 동시성 제어를 하는 방법
    https://deveric.tistory.com/104

- [Java] 많이 헷갈려하는 String constant pool과 Runtime Constant pool, Class file constant pool
    https://deveric.tistory.com/123

- 타입 캐스팅
    https://hudi.blog/java-type-casting/

- Metaspace 영역으로 이관하게 된 이유
    Perm영역에 이 데이터가 저장되던 시점(JDK 7 이하)에는 Class, Metadata 로딩 과정에서 메모리 릭이 발생하였고, Perm 영역의 크기를
    고정적으로 설정해야 했기 때문에 메모리 부족으로 OOM이 터지는 일이 있었습니다. 이 이슈를 개선하기 위해 Constant Pool을 Metaspace영역으로
    이관하였고 OOM을 피할 수 있게 되었습니다. 조금 더 설명하자면 Metaspace영역은 JVM의 Native Memory를 사용하며 JVM이 관리합니다.
    Perm영역과의 결정적인 차이는 메모리가 동적으로 관리되며 필요할 경우 OS에게 요청하여 메모리를 추가 할당할 수 있습니다. 이를 통해 OOM을 개선할 수 있었습니다.

- 스레드(Thread)[4] - 스레드의 상태(state) 제어
    https://deveric.tistory.com/24

- 카카오톡 Java App Server Refactoring 후기
    https://tech.kakao.com/2023/01/19/kakaotalk-java-app-server-refactoring/

********* try-catch 지옥 벗어나기
    https://dev.gmarket.com/24

- Middleware 패턴과 코드 수준에서의 활용
    https://dev.gmarket.com/22

- 자바의 HashMap을 효과적으로 사용하는 법
    https://dev.gmarket.com/18

********* Java의 HashMap에 대하여 딱 이만큼만
    https://dev.gmarket.com/13

********* java 면접 질문
    https://minchoi0912.tistory.com/93

- 생성자 대신 정적 팩터리 메서드를 고려하라
    https://hudi.blog/effective-java-static-factory-method/



----------------------------------------------------------------------------------------------------------------------

- 모던 자바
    https://www.youtube.com/watch?v=veJO12VV-Mg

- new ArrayList<>() vs Arrays.asList()
    https://tecoble.techcourse.co.kr/post/2020-05-18-ArrayList-vs-Arrays.asList/

- 동시성 보장하기 위한 방법
    https://velog.io/@maketheworldwise/ConcurrentHashMap

- IO가 느린 이유가 뭘까? NIO는 뭘까?
    https://velog.io/@maketheworldwise/IO%EA%B0%80-%EB%8A%90%EB%A6%B0-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AD%98%EA%B9%8C-NIO%EB%8A%94-%EB%AD%98%EA%B9%8C



- 자바의 참조형은 Call by Reference 인가??

- 메모리 주소만으로 Heap의 인스턴스에 접근할 수 있을까 ??

- 람다 ??
    - 람다를 사용하기 위한 조건 -> 함수형 인터페이스 ?

- Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요. ??

- 자바 어노테이션 ??

- 불변 객체 장점 -> 가비지 컬렉션의 성능을 높일 수 있다. ??

- java immutable Object ??

- try-with-resources에 대해 설명해주세요. ??

- 이 문제를 해결하려면 어떻게 해야할까요 ??

- Java의 원자적 연산과 비원자적 연산 ??

- 동시성 프로그래밍에서 발생할 수 있는 문제는??

- syncronize??

- 잘 운영하고 있던 어플리케이션이 갑자기 Out of Memory Error(OOM)를 내며 프로세스가 종료되었습니다. 어떻게 대처해볼 수 있을까요??

- 직렬화 ??

- 객체지향의 설계 원칙 (SOLID) ??

- enum 이 뭐냐? 사용하는 이유??

- 객체 조립(Composition), 컴포지션 ??

- private final 과 private static final ??

- 클래스 로딩 정리 ??

- 자바의 참조형은 Call by Reference 인가??

- 마커 인터페이스 ??

- 임계 영역 -> 정의 내 언어로 바꾸기

- 생성자 오버로딩은 동일한 이름을 가진 메소드들의 매개 변수의 타입 또는 개수가 모두 달라야 성립한다. ??

- 람다식
    - 병렬 프로그래밍이 용이하다. ??
    - 재귀로 만들 경우에 부적합하다. ??
    - 람다는 문서화를 할 수 없다??
    - stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다??

동기화 처리를 할 때, 어떤 Entry를 조작하는 경우에 해당 Entry에 대해서만 락을 건다. ??

- java map flatmap 차이 ??

- Wrapper class 쓰는 이유

- Java 1.5는 StringBuilder로 최적화되며, Java 9는 StringConcatFactory 를 활용해 바이트 코드 단위의 최적화가 이루어집니다. ??

- 비-원자적 연산에서의 동기화 처리 ??

- heap dump 뜨는 방법 ??

- Arrays.asList()와 List.of()의 차이 ??

- 원시 타입을 포장해야 하는 이유 ??

- [Java] PermGen 영역 대신 Metaspace가 도입된 Java 8 이후의
    https://kth990303.tistory.com/418

- Atomic 변수, concurrentHashMap


- 자바 웹 애플리케이션 Out of memory 오류 해결기
    https://kim-solshar.tistory.com/66


