- 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object 클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다.
  이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
    - equals()란?
        - equals 메소드는 기본적으로 2개의 객체가 동일한지 검사하기 위해 사용
        - 2개의 객체가 참조하는 것이 동일한지를 확인하는 것이며, 이는 동일성(Identity)을 비교하는 것
        - 동일한 메모리 주소일 경우에만 동일한 객체가 된다.

        - 하지만 프로그래밍을 하다보면 동일한 객체가 메모리 상에 여러 개 띄워져있는 경우가 있다. 해당 객체는 서로 다른 메모리에
          띄워져있으므로 동일한(Identity) 객체가 아니다. 하지만 프로그래밍 상으로는 같은 값을 지니므로 같은 객체로 인식되어야 하는데,
          이러한 동등성(Equality)를 위해 우리는 값으로 객체를 비교하도록 equals 메소드를 오버라이딩해주는 것이다.

    - hashCode()란?
        - 실행 중에(Runtime) 객체의 유일한 integer 값을 반환
        - Object 클래스에서는 heap 에 저장된 객체의 메모리 주소를 반환하도록 되어있다. (항상 그런 것은 아니다.)
        - hashCode 는 HashTable 과 같은 자료구조를 사용할 때 데이터가 저장되는 위치를 결정하기 위해 사용된다.

    - equals 와 hashCode 의 관계
        - 동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다. 그렇기 때문에
          우리가 equals() 메소드를 오버라이드 한다면, hashCode() 메소드도 함께 오버라이드 되어야 한다.
        - Java 프로그램을 실행하는 동안 equals 에 사용된 정보가 수정되지 않았다면, hashCode 는 항상 동일한 정수값을 반환해야 한다.
          (Java 의 프로그램을 실행할 때 마다 달라지는 것은 상관이 없다.)
          두 객체가 equals()에 의해 동일하다면, 두 객체의 hashCode() 값도 일치해야 한다.
          두 객체가 equals()에 의해 동일하지 않다면, 두 객체의 hashCode() 값은 일치하지 않아도 된다.

    - hashCode() Override 의 필요성
        - hashCode 를 equals 와 함께 재정의하지 않으면 코드가 예상과 다르게 작동하는 위와 같은 문제를 일으킨다.
          정확히 말하면 hash 값을 사용하는 Collection(HashSet, HashMap, HashTable)을 사용할 때 문제가 발생
        - hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true 여야 논리적으로 같은 객체라고 판단한다.
          hashCode 메서드가 재정의 되어있지 않으면 Object 클래스의 hashCode 메서드가 사용됨
        - intellij 의 Generate 기능을 사용했더니 Objects.hash 메서드를 호출하는 로직으로 hashCode 메서드가 재정의 됐다.
          Objects.hash 메서드는 hashCode 메서드를 재정의하기 위해 간편히 사용할 수 있는 메서드이지만 속도가 느리다.
          인자를 담기 위한 배열이 만들어지고 인자 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다.
          성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제 없다.
          민감한 경우에는 직접 재정의해주는 게 좋다.

        - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode 가 서로 다른 값을 반환할 필요는 없다.
          단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.
        - HashMap 의 구현은 해시 코드가 다른 엔트리끼리는 동치성 비교 자체를 하지 않도록 최적화 되어 있다.
        - hashCode 를 만드는 해시 함수를 equals 메소드를 재정의할 때 사용한 필드와 같은 필드를 사용하자.
        - 만약 객체는 같은 해시 코드를 가지게 되면 전부 같은 버킷에 해시되므로 해시 테이블은 아주 긴 링크드 리스트가 많이 생기게 될 것
        - 해시 테이블(hash table)의 평균 시간 복잡도는 O(1)이고, 최악의 로직을 가진 해시 테이블의 시간 복잡도는 O(n) 이다.
        - 만약 이 해시 테이블이 해시 충돌(hash collision) 해결을 해시 체이닝(hash chaining) 방식으로 구현했다면,
          실제 링크드 리스트(linked list) 처럼 동작한다.
        - hashCode를 재정의 하지 않았을 경우 생기는 문제점
            - 같은 값을 가진 객체가 서로 다른 해시값을 갖게 될 수 있다.
            - 특히 HashMap의 key 값으로 해당 객체를 사용할 경우  저장된 버킷을 찾을 수 없다.


    - 만약 ORM 을 사용하고 있는 경우라면, hashCode 와 equals 를 오버라이드 하는 메소드 내부에서 Getter 를 사용하기를 권장한다.
      그 이유는 ORM 에 의해 fields 가 Lazy Loaded 되어, getter 를 부르기 전에는 사용이 불가능할 수 있기 때문이다.
    - 단, equals 와 hashCode 는 모두 VO(Value Object)에서만 사용하는 것을 권장합니다.
      값을 나타내는 것 외에 기능을 갖고 있는 인스턴스에서는 문제가 발생할 여지가 많아 웬만해선 사용하지 않는 것을 권장합니다.

- String 객체 생성    https://readystory.tistory.com/139 (String Constant Pool)
    - new 연산자로 String 객체를 생성하면 JVM 에서 Heap 영역에서 String 객체 생성
    - new 연산자가 아닌 리터럴("")로 String 객체를 생성하면 JVM 은 우선 String Constant Pool 영역을 방문.
      거기서 같은 값을 가진 String 객체를 찾으면 그 객체의 주소 값을 반환하여 참조하게 된다. 찾지 못하면 String Constant Pool 에
      해당 값을 가진 String 객체를 생성하고 그 주소 값을 반환.
    - String Constant Pool 영역은 Heap 영역 내부에서 String 객체를 위해 별도로 관리하는 저장소.
    - String pool을 통해 String을 관리함으로써 Java는 Runtime에서 Heap 영역의 많은 메모리를 절약할 수 있습니다.
      왜냐면 같은 값을 갖는 String에 대해 같은 메모리를 참조하게 할 수 있기 때문입니다.
      불변이기 때문에 멀티 쓰레딩 환경에서 안전(thread-safe)
      다른 객체는 키로 쓰일 때마다 hashCode를 계산하는데 비해 String은 캐싱을 하고 있기 때문에 다른 객체를 Key로 했을 때보다 String을 Key로 했을 때 더 빠른 속도로 사용할 수 있습니다.

    - String 최적화   https://madplay.github.io/post/difference-between-string-stringbuilder-and-stringbuffer-in-java
        - JDK 1.5 버전부터는 String도 연산 과정에서 StringBuilder를 사용하도록 변경되었다. 그래서 예전보다는 더 좋아진 성능을 기대해도 된다.
            - 컴파일 한 후에 바이트 코드를 확인해보자. 결과를 확인할 때는 클래스 파일을 역어셈블해주는 javap 명령어에 디어셈블 결과를 출력해주는 -c 옵션을 넣으면 된다.

        - 디컴파일해서 확인해보면 StringBuilder를 사용하도록 개선되었지만 반복문 안에서 문자열을 더하는 연산을 한다면
          StringBuilder가 반복문 횟수만큼 생성되기 때문에 상대적으로 느릴 수밖에 없다.

        - https://velog.io/@tamxt4047/equals-hashCode
        - https://camel-context.tistory.com/52

- StringBuilder 와 StringBuffer 의 차이는 무엇일까요?
    - 연산이 많지 않을때는 위에 나열된 어떤 클래스를 사용하더라도 이슈가 발생할 가능성은 거의 없습니다. 그러나 연산횟수가 많아지거나
      멀티쓰레드, Race condition 등의 상황이 자주 발생 한다면 각 클래스의 특징을 이해하고 상황에 맞는 적절한 클래스를 사용해 주셔야 합니다

    - String  vs  StringBuffer/StringBuilder
        - String 클래스는 불변하기 때문에 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성된
        - 새로운 메모리영역을 가리키게 변경되고 처음 선언했던 "hello"로 값이 할당되어 있던 메모리 영역은 Garbage 로 남아있다가
          GC(garbage collection)에 의해 사라지게 되는 것
        - String 은 불변성을 가지기 때문에 변하지 않는 문자열을 자주 읽어들이는 경우 String 을 사용해 주시면 좋은 성능을 기대
        - 문자열 추가,수정,삭제 등의 연산이 빈번하게 발생하는 알고리즘에 String 클래스를 사용하면 힙 메모리(Heap)에
          많은 임시 가비지(Garbage)가 생성되어 힙메모리가 부족으로 어플리케이션 성능에 치명적인 영향을 끼치게 됩니다.
        - String 과는 반대로 StringBuffer/StringBuilder 는 가변성 가지기 때문에
          .append() .delete() 등의 API 를 이용하여 동일 객체내에서 문자열을 변경하는 것이 가능

    - StringBuffer  vs  StringBuilder
        - 가장 큰 차이점은 동기화의 유무
        - StringBuffer 는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다는 점
            - 참고로 String 도 불변성을 가지기때문에 마찬가지로  멀티쓰레드 환경에서의 안정성(thread-safe)을 가지고 있습니다.
        - StringBuilder 는 동기화를 지원하지 않기때문에 멀티쓰레드 환경에서 사용하는 것은 적합하지 않지만 동기화를 고려하지 않는 만큼
          단일쓰레드에서의 성능은 StringBuffer 보다 뛰어납니다.

    String          :  문자열 연산이 적고 멀티쓰레드 환경일 경우
    StringBuffer    :  문자열 연산이 많고 멀티쓰레드 환경일 경우
    StringBuilder   :  문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우


- 0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?  https://castlejune.tistory.com/23
    - 싱글스레드 프로세스의 경우 프로세스 내에서 단 하나의 스레드만 작업하기 때문에 프로세스의 자원을 가지고 작업하는데 별문제가 없지만,
      멀티스레드 프로세스의 경우 여러 스레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업에 영향을 주게 됩니다. -> 스레드의 동기화
    - ++ 연산은 구체적으로 어떤 행위들로 이루어져 있을까요?
        메모리에서 해당 값을 가져옵니다.
        해당 값에 1을 더합니다.
        메모리에 더한 값을 덮어씌웁니다.
    - 이 문제를 해결하려면 어떻게 해야할까요?
        - JVM 은 데이터를 4byte(=32bit)단위로 처리하기 때문에, int 와 int 보다 작은 타입들은 한 번에 읽고 쓰는 것이 가능합니다.
          즉, 단 하나의 명령어로 읽거나 쓰기가 가능하다는 뜻입니다. 하나의 명령어는 더 이상 나눌 수 없는 최소의 작업단위이므로,
          작업의 중간에 다른 스레드가 끼어들 틈이 없습니다. 다만, 크기가 8byte 인 long 과 double 타입의 변수는 하나의 명령어로 값을
          읽거나 쓸수 없기 때문에, 변수의 값을 읽는 과정에 다른 스레드가 끼어들 여지가 있습니다.

        - 스레드는 실행되고 있는 CPU 메모리 영역에 데이터를 캐싱합니다.
          따라서 멀티 코어 프로세서에서 다수의 스레드가 변수 a를 공유하더라도 캐싱된(갱신) 시점에 따라 데이터가 다를 수도 있습니다.
          그리고 캐싱된 데이터가 언제 갱신되는지 정확히 알수 없습니다.

        1. 적절한 동기화 처리
            - 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
            - 스레드가 synchronized 블럭으로 들어갈 때와 나올 때, 캐시와 메모리간의 동기화가 이루어지기 때문에 값의 불일치가 해소됩니다.
        2. volatile 키워드  https://nesoy.github.io/articles/2018-06/Java-volatile  https://jronin.tistory.com/110
            - synchronized 블럭의 임계 영역은 멀티스레드 프로그램의 성능을 좌우하기 때문에 가능하면 임계영역을 최소화해서 효율적인 프로그래밍을 해야합니다.
            - 속도가 더 빠른 대안을 소개하자면 자바에서 volatile 이란 한정자로 변수의 읽기와 쓰기를 원자화 할 수 있습니다.
            - volatile 키워드를 붙이면 해당 변수를 읽어올 때 캐시가 아닌 메모리에서 직접 읽어오게 되는데 그렇기 때문에 스레드 간 안정적인 통신은 보장할 수 있습니다.
            - 매번 변수의 값을 Read 할 때마다 CPU cache 에 저장된 값이 아닌 Main Memory 에서 읽는 것입니다.
            - 주의할 점은 volatile 키워드는 변수의 읽기나 쓰기의 원자화를 보장하지만 배타적 수행과는 상관없습니다!
            - volatile 은 원자적 연산에서만 동기화 보장
            - 값을 읽고 쓰는 비-원자적 연산 작업이 하나의 스레드에서만 일어나고 다른 스레드들에서는 단지 값을 읽는 원자적 연산만 한다면
              위와 같은 문제는 발생하지 않기 때문에 volatile 키워드만으로 충분히 동기화
            - volatile(통신 동기화)만으로 동기화가 되는 상황이라면 synchronized 보다는 volatile 만으로 동기화 처리를 하는 것이 낫습니다.
              왜냐하면 배타적 실행을 위해 락을 획득하고 반환하는 비용이 발생하지 않기 때문입니다.
              만약 배타적 실행 제어가 필요하다면 synchronized 를 사용해야 합니다.
            - 간혹 synchronized 키워드와 volatile 키워드가 같이 사용되는 코드를 볼 수 있습니다.
              자바 1.5이후부터 volatile 키워드가 붙은 변수들은 컴파일 단계에서 재배치-최적화를 하지 않도록 변경되었기 때문에
              Double-checked locking 구문에서 최적화를 하지 않도록 하기 위해 volatile 를 붙이기도 합니다.

            - Java의 원자적 연산과 비원자적 연산   https://sslblog.tistory.com/201
                - 레퍼런스를 할당하고 복사하는 모든 작업은 원자성이 보장됩니다. 원시타입 변수에 값을 쓰고 읽는 모든 작업도 마찬가지
                - 원시타입 중에서도 왜 long과 double만 제외
                    - 32bit 안에서 할당이 이루어지는 다른 원시타입들과 다르게, long과 double로 정의된 변수는 64bit로 할당
                    - 64bit를 쓰고 읽는 대개의 경우는 32bit씩 두 번의 연산으로 나누어 실행
                    - 만약 둘 이상의 스레드가 해당 변수에 읽고 쓰는 작업을 한다면, 한 스레드가 32bit를 읽는 동안
                      나머지 스레드는 나머지 32bit에 대해 쓰기를 실행할 수도 있는 것이죠. 이런 경우엔 읽기를 실행한 스레드는 잘못된 값을 읽어가게 될 것입니다.

            - volatile은 해당 필드에 접근할 때 lock을 걸도록 합니다. 지정한 메서드나 지정한 블록에 thread-safe를 보장하는 synchronized와는 다르게요.
            - 해당 필드의 접근에 대해서만 원자성을 보장합니다. 한 스레드가 하나의 long 변수의 32bit를 쓰는 도중에 다른 스레드가 나머지 32bit를 쓰거나 읽지 못하도록 하는 것
        3. Atomic 변수(java.util.concurrent.atomic)
            - 멀티쓰레드 환경에서 동기화 문제를 synchronized 키워드를 사용하여 락을 걸곤 하는데 이 키워드 없이 동기화 문제를 해결하기 위해 고안된 방법입니다.
            - synchronized 는 특정 스레드가 해당 블럭 전체에 락을 걸기때문에 다른 스레드는 아무런 작업을 하지 못하고 기다리는
              상황(Blocking)이 될 수 있어서 낭비가 심합니다. 그래서 Non-Blocking 하면서 동기화 문제를 해결하기 위한 방법이 Atomic
            - java.util.concurrent.atomic 패키지에는 락 없이도(lock-free) thread-safe 한 프로그래밍을 지원하는 클래스들이 담겨 있습니다.
              성능도 더 우수하다고 알려저 있습니다.
            - volatile 은 동기화의 두 효과 중 스레드 간 통신 쪽만 지원하지만 이 패키지는 원자성(배타적 수행)까지 지원합니다.
              클래스들을 까보니 내부적으로 volatile 키워드를 내포
            - Atomic 의 동작 핵심원리는 CAS 알고리즘(Compared and Swap)   https://javaplant.tistory.com/23
            - CAS 란 변수의 값을 변경하기 전에 기존에 가지고 있던 값이 내가 예상하던 값과 같을 경우에만 새로운 값으로 할당하는 방법입니다.
            - Java 에서 제공하는 Atomic Type 은 이러한 CAS 를 하드웨어(CPU)의 도움을 받아 한 번에 단 하나의 스레드만 변수의 값을 변경할 수 있도록 제공하고 있습니다.

        - 비-원자적 연산에서의 동기화 처리
            1. synchronized
                - 값을 변경하기 위해 읽고-저장하는 작업(비-원자적 연산)은 동시에 하나의 스레드만 처리할 수 있도록 일종의 락을 거는 방법입니다.
                  비-원자적 연산을 원자화시키는 거라고 볼 수 있습니다.
                - synchronized 은 단일 스레드만 진입하도록 하는 배타적 실행 동기화뿐만 아니라 가장 최근의 값(메인 메모리에서)을 가져오는
                  통신 동기화 기능도 같이 수행
            2. concurrent 패키지의 atomic 클래스

        - 동기화에 대한 문제를 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이며 가변 데이터는 단일 스레드에서만 사용하는 것이 좋다.
        - 가변 데이터를 단일 스레드에서만 사용한다면 문서에 남겨 유지보수 정책에서도 지켜지는것이 중요하다.
        - 멀티 스레드 환경에서 한 스레드가 데이터를 수정한 후에 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다.
        - 여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 메서드 모두에 반드시 synchronized 키워드를 붙이거나 가변 데이터에 atomic 변수를 사용한다.
        - 배타적 실행 (한번에 한스레드) 동작이 필요없고, 스레드 간 최신데이터만 읽는 거로도 충분하면 가변 변수에 volatile 키워드만으로도 동기화가 가능하다.

        * Concurrent 패키지
            concurrent 패키지에 존재하는 컬랙션들은 락을 사용할 때 발생하는 성능 저하를 최소한으로 만든다. 락을 여러 개로 분할하여 사용하는
            Lock Striping 기법을 사용하여 동시에 여러 스레드가 하나의 자원에 접근하더라도 동시성 이슈가 발생하지 않도록 도와주는 것이다.

            ConcurrentHashMap 은 내부적으로 여러개의 락을 가지고 해시값을 이용해 이러한 락을 분할하여 사용한다.
            분할 락을 사용하여 병렬성과 성능이라는 두 마리의 토끼를 모두 잡은 컬랙션인 것이다. 내부적으로 여러 락을 사용,
            일반적인 map 을 사용할 때처럼 구현하면 내부적으로 알아서 락을 자동으로 사용해 줄 테니 편리하게 사용할 수 있다.


- 동시성 프로그래밍에서 발생할 수 있는 문제는?   https://steady-coding.tistory.com/554
    동시성 프로그램에서는 CPU 와 RAM 의 중간에 위치하는 CPU Cache Memory 와 병렬성이라는 특징 때문에 가시성 문제, 원자성 문제가 발생할 수 있다.


- 가시성 문제와 원자성 문제에 대해 설명하라.
    - 가시성 문제
        여러 개의 스레드가 사용됨에 따라, CPU Cache Memory 와 RAM 의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다.
        가시성을 보장되어야 하는 변수에 volatile 키워드를 붙여줘서 RAM 에서 바로 읽도록 해야 한다.
        그러나 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 해서 동시성이 보장되지 않는다.

    - 원자성 문제
        여러 스레드가 공유 자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미한다. 따라서 synchronized, atomic 을 통해 원자성을 보장해야 한다.


- 자바에서 동시성과 관련된 예약어를 모두 말씀해주세요.  https://devwithpug.github.io/java/java-thread-safe/


- Serializable 은 무엇일까요?  https://www.slideshare.net/sunnykwak90/java-serialization-46382579
    - 직렬화 기술 이해
        - 직렬화란 무엇인가?
            - 직렬화는 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷
              (예를 들면 파일 또는 메모리 버퍼, 네트워크 연결 링크를 통해 전송될 수 있는 형태) 으로 변환.
        - 직렬화는 왜 중요한가?
            - 거의 모든 소프트웨어는 네트워크를 통해 데이터를 주고 받으며, 프로그램을 구현하는데 필요한 기반 기술 중에서 빼놓을 수 없게 됨.
            - 직렬화는 네트워크 의존성이 높은 소프트웨어일 경우, 전체 성능을 좌우할 수도 있는 중요한 기술이다.
        - 직렬화 적용 분야
            - 파일 저장소 (File storage)
                - 프로그램 실행 중에 생성된 데이터를 영구 저장소(파일 시스템) 등에 저장한 후, 이후에 프로그램이 다시 실행되었을 때 저장된
                  데이터를 메모리 상에 객체 형태로 복구해 사용한다.
            - 네트워크 통신
                - 네트워크 상에 떨어져 있는 프로그램 간에 데이터를 주고 받기 위해 데이터를 직렬화한 후, 패킷에 담아 전송
            - 데이터베이스
                - 복잡한 형태의 객체를 데이터베이스에 저장할 때 직렬화된 문자열 형태로 테이블의 칼럼에 저장하기도 한다.
            - 웹 환경
                - 웹 서버에서 브라우저(클라이언트)로 구조화된 데이터를 전송할 때 직렬화한 후 JSON 형식 등 전달하는 방식이 점차 많이 사용됨
        - 직렬화 기법 선택 시 고려할 점
            - 단순성(simple)
                - 사용하기가 복잡하지 않아야 한다.
            - 경량(compact)
                - 프레임워크(혹은 라이브러리)의 규모가 작아야 한다.
            - 유연성(flexible)
                - 다양한 데이터 타입을 직렬화할 수 있어야 한다.
            - 버전지원(versioning)
                - 객체의 데이터 구조는 설계 및 개발, 나아가 유지보수 단계에서 변화될 수 있다.
            - 속도(fast)
                - 처리 속도가 빠르면 빠를수록 좋다.
            - 확장성(scalable)
                - 복잡하거나, 거대한 형태의 데이터를 직렬화할 수 있어야 한다.
        - 직렬화 데이터 형식
            - Binary
                - 메모리에 저장된 데이터를 최소한의 가공 혹은 가공 없이 바이트의 연속된 형태로 저장하는 방식
            - JSON(JavaScript Object Notation)
                - 텍스트 형식이므로 사람과 기계 모두 읽기 가능하다. 다양한 프로그래밍 언어에서 읽고 쓸 수 있기 때문에 널리 사용됨
            - XML(Extensible Markup Language)
                - 텍스트 형식이며, JSON 에 비해 복잡하다. JSON 에 대해 가지는 장점은 스키마를 적용할 수 있고 무결성 검사가 가능하다.
            - YAML(YAML Ain't Markup Language)
                - XML 에 비해 사람이 읽고 쓰기 쉽도록 고안된 마크업 언어이다. 문법이 상대적으로 단순하고, 가독성이 높게 설계되어 있다.
        - 왜 성능이 중요한가?
            - CPU 비용
                - 메모리에 존재하는 바이너리 형태의 객체를 디스크 등에 저장할 수 있는 형태(텍스트 등)로 저장하기 위해서는 변환 처리 과정이
                  필요하며, 반대의 처리 또한 필요하다.
            - 메모리 비용
                - 변환 작업을 수행하는 과정에서 임시 버퍼(temporary buffer)를 할당하고, 네트워크를 통한 송수신 과정에서 스트림 처리 등에
                  따른 공간 할당이 필요하다.
            - 네트워크 비용
                - 직렬화를 수행하는 대다수의 프로그램 혹은 시스템은 네트워크를 통해 데이터를 주고 받게 된다. 네트워크 송수신에 있어서 패킷의
                  크기가 커질수록 전체 성능은 떨어진다.

    - 직렬화 프레임워크
        - JDK 의 Serializable 인터페이스
            - 프로그래밍하기 가장 쉽고, Serializable 인터페이스를 이용해 별도의 라이브러리 없이 즉시 사용할 수 있다.
            - 클래스를 릴리즈한 후에는 구현을 변경하기 어려워 유연성을 감소시킨다.
            - C++, 파이썬 등 다른 언어로 구현된 프로그램과 데이터를 교환할 수 없다.
            - 기본 연산자의 취약점으로 인해 불변 값이 손상되거나, 비정상적인 접근이 발생할 수 있다. (invariant corruption and illegal access)
            - 커스터마이징이 불가능하고, 소스 코드를 수정할 수 있어야 한다.
        - Java externalization (직렬화 코드를 직접 구현)
            - 객체를 저장 및 복구하는 Externalization 인터페이스를 구현해 직접 직렬화를 구현한다.
            - 인스턴스의 컨텐츠를 저장하고 복구하는 역할을 수행하는 클래스를 구현해야 한다.
            - 클래스의 구조가 변경될 때 마다, 읽고 쓰는 코드를 수정해야 한다.
        - Google GSON
            - 자바 객체를 JSON 으로 변환하거나 반대의 작업을 수행하는 자바 라이브러리.
            - 직렬화된 객체의 소스 코드를 필요로 하지 않는다.
            - 커스텀 표현을 지원한다.
        - Jackson JSON
            - 고성능, 인공공학적 JSON 프로세서 자바 라이브러리
            - 광범위한 커스터마이징 툴 지원
            - 혼합 어노테이션
            - 실체화된 인터페이스
            - 다양한 데이터 포맷 : JSON, CSV, Smile(binary JSON), XML, YAML
        - BSON for Jackson
            - 바이너리 인코딩된 JSON
            - 몽고 DB 의 주된 데이터 교환 포맷
            - 확장 프로그램 작성 가능
        - Protocol Buffers
            - 구조적인 데이터를 확장 가능하며 효율적인 포맷을 변환하는 방법 제공
            - 구글 내부에서 대부분의 내부 RPC 프로토콜과 파일 포멧에 Protocol Buffers 를 사용 중.
            - Java, C++, Python 지원
        - Kryo
            - 빠르고 효율적인 객체 그래프 직렬화 자바 프레임워크
            - 구글 코드 상의 오픈 소스 프로젝트
            - 자동화된 깊고 얕은 복사/복제
            - 소스 클래스에 대한 코드 작성 요건이 거의 없음


- 잘 운영하고 있던 어플리케이션이 갑자기 Out of Memory Error(OOM)를 내며 프로세스가 종료되었습니다. 어떻게 대처해볼 수 있을까요?
    * https://baek-kim-dev.site/53


- 서비스를 운영하면 모니터링을 해야할 일이 많은데 어떤 툴들을 사용해볼 수 있을까요?

- JIT 컴파일러란 무엇이고, 이것은 왜 필요할까요?

- 힙에 메모리를 할당하는 과정에서 어떤 일들이 벌어지나요?


- printStackTrace()를 사용하면 안되는 이유
    1. 오류 출력이 실제로 어디로 가는지 알 수 없다.
        System.err 는 System.setErr()를 통해 변경될 수 있으므로 이 오류가 어디에 출력되는 것인지 알 수 없다.
    2. 많은 오버헤드가 발생한다.
        내부에서 동기화를 위한 synchronized, Reflection 호출 등 많은 오버헤드가 발생한다.
    3. 보존 정책을 설정할 수 없다.
        보존 정책을 설정할 수 없으므로 기본적으로 Log 가 Application 생명주기와 함께한다.
    4. 보안성이 떨어진다
        StackTrace 를 통해 메서드 내부 동작 구조가 노출되기 때문에 보안성이 떨어지므로 외부에 노출해선 안된다.


- static 의 의미와 사용법
    - new 로 객체를 생성하다보면 메모리를 많이 사용하게 됩니다. 그리고 생성하는 객체가 공통적으로 많이 쓰는 객체라면
      더욱더 전역적으로 하나만 있다면 객체를 새로 생성하지 않더라도 가져다가 쓰기만 하면 될 것입니다. 그래서 static 이 생겨나게 되었습니다.
    - 일반적으로 우리가 만든 Class는 Static 영역에 생성되고, new 연산을 통해 생성한 객체는 Heap영역에 생성됩니다.
    - 객체의 생성시에 할당된 Heap영역의 메모리는 Garbage Collector를 통해 수시로 관리
    - Static 키워드를 통해 Static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리
    - Garbage Collector의 관리 영역 밖에 존재하므로 Static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재하므로 자주 사용하게 되면 시스템의 퍼포먼스에 악영향

    - Static 변수와 static 메소드는 Static 메모리 영역에 존재하므로 객체가 생성되기 이전에 이미 할당이 되어 있습니다. 그렇기 때문에 객체의 생성없이 바로 접근(사용)할 수 있습니다.

    - static을 사용하는 이유에 대해 설명해주세요.
        - static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나
          값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있습니다.
        - 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용합니다.

   ex) Math.round()

    - static 이란?
        정적(static)은 고정된이란 의미를 가지고 있습니다. Static 이라는 키워드를 사용하여 Static 변수와 Static 메소드를 만들 수 있는데
        다른말로 정적필드와 정적 메소드라고도 하며 이 둘을 합쳐 정적 멤버라고 합니다. (클래스 멤버라고도 합니다.)
        정적 필드와 정적 메소드는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버입니다. 그렇기에 클래스 로더가 클래스를 로딩해서
        메소드 메모리 영역에 적재할때 클래스별로 관리됩니다. 따라서 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있습니다.

    - 정적(Static) 멤버 생성
        - Static
            - 주로 클래스들이 할당
            - GC 관여 x
            - 모든 객체가 메모리를 공유
        - Heap
            - 주로 객체들이 할당
            - GC 관여
            - 메모리를 공유하지 않음

        - Static 키워드를 통해 생성된 정적멤버들은 Heap 영역이 아닌 Static 영역에 할당됩니다. Static 영역에 할당된 메모리는
          모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점을 가지지만 Garbage Collector 의 관리 영역 밖에 존재하기에
          Static 영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재하게 됩니다.
          그렇기에 Static 을 너무 남발하게 되면 만들고자 하는 시스템 성능에 악영향을 줄 수 있습니다.

    - 정적(Static) 멤버 선언
        - 필드나 메소드를 생성 시 인스턴스로 생성할것인지 정적으로 생성할것인지에 대한 판단 기준은 공용으로 사용하느냐 아니냐로 내리면 됩니다.
          그냥 생성한다면 자동으로 인스턴스로 생성되며 정적으로 생성하려면 필드와 메소드 선언 시 static 이라는 키워들를 추가적으로 붙이면 됩니다.

        - 정적 메소드는 클래스가 메모리에 올라갈 때 정적 메소드가 자동적으로 생성됩니다. 그렇기에 정적 메소드는 인스턴스를 생성하지 않아도 호출을 할 수 있습니다.
          정적 메소드는 유틸리티 함수를 만드는데 유용하게 사용됩니다.


* [ 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유 ]      https://mangkyu.tistory.com/131?category=872426
    - Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
        멀티 쓰레드 환경에서 동기화 문제가 발생하는 이유는 공유 자원에 동시에 쓰기(Write) 때문이다. 하지만 만약 공유 자원이 불변이라면
        더 이상 동기화를 고려하지 않아도 될 것이다. 왜냐하면 항상 동일한 값을 반환할 것이기 때문이다. 이는 안정성을 보장할 뿐만 아니라 동기화를 하지 않음으로써 성능상의 이점도 가져다준다.

    - 실패 원자적인(Failure Atomic) 메소드를 만들 수 있다.
        가변 객체를 통해 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있고, 불안정한 상태를 갖는 객체는 또 다른 에러를 유발할 수 있다.
        하지만 불변 객체라면 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지할 수 있을 것이다. 그리고 예외가 발생하여도 오류가 발생하지 않은 것 처럼 다음 로직을 처리할 수 있다.

        - 실패 원자적으로 만들기
            1. 불변객체
            2. 매개변수 유효성 검사
                - 작업 수행에 앞서 매개변수의 유효성을 검사하는 것
            3. 복구 코드
                - 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법
                - 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이는데, 자주 쓰이는 방법은 아니다.

    - Cache나 Map 또는 Set 등의 요소로 활용하기에 더욱 적합하다.
        만약 캐시나 Map, Set 등의 원소인 가변 객체가 변경되었다면 이를 갱신하는 등의 부가 작업이 필요할 것이다.
        하지만 불변 객체라면 한 번 데이터가 저장된 이후에 다른 작업들을 고려하지 않아도 되므로 사용하는데 용이하게 작용할 것이다.

    - 부수 효과(Side Effect)를 피해 오류가능성을 최소화할 수 있다.
        - 객체의 수정자(Setter)를 통해 여러 객체들에서 값을 변경한다면 객체의 상태를 예측하기 어려워질 것이다.
        - 불변 객체는 객체의 상태가 유지되기 때문에 안전하게 객체를 다시 사용할 수 있다.

        불변 객체는 기본적으로 값의 수정이 불가능하기 때문에 변경 가능성이 적으며, 객체의 생성과 사용이 상당히 제한된다.
        그렇기 때문에 메소드들은 자연스럽게 순수 함수들로 구성될 것이고, 다른 메소드가 호출되어도 객체의 상태가 유지되기 때문에 안전하게 객체를 다시 사용할 수 있다.
        이러한 불변 객체는 오류를 줄여 유지보수성이 높은 코드를 작성하도록 도와줄 것이다.

    - 다른 사람이 작성한 함수를 예측가능하며 안전하게 사용할 수 있다.
        불변성이 보장된 함수라면 다른 사람이 개발한 함수를 위험없이 이용할 수 있다.

    - 가비지 컬렉션의 성능을 높일 수 있다.
        GC가 수행될 때, 가비지 컬렉터가 컨테이너 객체 하위의 불변 객체들은 Skip할 수 있도록 도와준다.
        왜냐하면 해당 컨테이너 객체(ImmutableHolder)가 살아있다는 것은 하위의 불변 객체들(value) 역시 처음에 할당된 상태로 참조되고 있음을 의미하기 때문이다.
        결국 불변의 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체의 수가 줄어서 스캔해야 하는 메모리 영역과 빈도수 역시 줄어들 것이고, GC가 수행되어도 지연 시간을 줄일 수 있을 것이다.

    - 장점
        - 객체에 대한 신뢰도가 높아진다. 객체가 한번 생성되어서 그게 변하지 않는다면 transaction 내에서 그 객체가 변하지 않기에 믿고 쓸 수 있기 때문이다.
        - 생성자, 접근메소드에 대한 방어 복사가 필요없다.
        - 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있다.

    - 단점
        - 객체가 가지는 값마다 새로운 객체가 필요하다. 따라서 메모리 누수와 새로운 객체를 계속 생성해야 하기 때문에 성능저하를 발생시킬 수 있다.


- 컬렉션의 복사 방법을 정리해봅시다! (unmodifiable view / list)   https://creampuffy.tistory.com/148
    - 방어적 복사! 를 하려면 copyOf를 해야 합니다.
    - 복사본 컬렉션에 대한 요소 추가 / 삭제 시도 시 UOE가 발생한다는 점은 unmodifiableList와 동일합니다.
      그러나 원본 컬렉션에서 요소 추가 / 삭제 가 일어나도, 영향을 받지 않습니다
    - 그럼에도 불구하고 copyOf()로 만들어낸 컬렉션이 완전한 불변이라고 볼 수는 없습니다.
      왜냐하면 copyOf의 반환값으로 전달된 unmodifiable list에서 객체를 꺼내서,
      그 객체 내부의 값을 변경할 경우, 아니면 외부에서 그 객체의 값을 변경할 경우에는
      요소 까지 깊은 복사를 하지는 않았기 때문에 값이 변경되기 때문입니다.
    - 컬렉션의 요소가 되는 값 객체들이 불변을 보장한다면, copyOf와 만나서 완전 불변이 가능

- 자바 어노테이션
    - JDK 1.5 버전 이상에서부터 사용가능하며, 자바 어노테이션은 클래스 파일에 임베드되어 컴파일러에 의해 생성된 이후 JVM에 포함되어 동작.

    - 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공
    - 런타임시 특정 기능을 실행하도록 정보 제공
        - 런타임에 의존성이 주입
            - Reflection 기술을 이용하여 런타임에 객체가 생성되는 시점(클래스 로더에 의해 메모리에 적재 되는 순간)에
              해당 클래스의 필드에 선언 되어있는 어노테이션 정보를 읽어서 해당 필드의 객체를 생성하여 주입해준다.
        - 컴파일 시, 바이트 코드에 특정 코드 추가

    - 자바 빌트인 어노테이션
        - @Override
        - @Deprecated
        - @SuppressWarning
        - @FunctionalInterface ...

    - 메타 어노테이션
        - @Retention
        - @Documented
        - @Target
        - @Inherited
        - @Repeatable


- 람다
    - Java 8 에서는 많은 새로운 기능들이 도입 되었고, 그 중에는 람다와 stream 도입을 통한
      함수형 프로그래밍도 있다. 람다를 통해 함수를 파라미터로 넘길 수 있고 변수에 할당할 수 있으며
      반환 값으로 반환할 수 있는 일급 시민으로써 사용할 수 있게 됨.
      이를 통해 코드 양도 줄이면서도 코드의 재사용성을 크게 높일 수 있다.
    - 람다를 사용하기 위한 조건 -> 함수형 인터페이스
    - 익명 클래스는 단순히 편의를 위해서 클래스 내부에서 사용을 할뿐 컴파일이 되면
      별도의 클래스로 분리되어 나온다.
    - 하지만 람다의 경우 컴파일 해도 별도의 클래스 파일이 생성되지 않으며 람다는 그대로 존재

    - 람다를 사용하면 안되는 경우
        - this 를 사용할 경우
            - 만약 내부에서 this 를 사용해야 하면 람다 대신 익명 클래스 사용해야 함
        - 섀도우 변수 (shadow variable) 를 사용할 경우
            - shadow variable 는 inner scope 내부에 outer scope 에 정의한 똑같은 변수가 있을 경우 shadow 된다.
            - 람다는 변수 shadowing 을 잡아내지 못하고 에러를 띄우므로 익명 클래스 사용해야 함
        - 콘텍스트 오버로딩이 존재할 때
            - 람다는 파라미터나 반환 값 등을 통해서 해당 람다가 어느 익명 메서드의 구현인지를 내부적으로 추론하는데
              모든 요소가 같은 추상 메서드가 2개 이상 존재한다면 에러가 띄우므로 익명 클래스 사용해야 함
        - 람다 코드가 3줄을 넘어갈 때
            - 동작을 파악하는데 시간이 오래 걸리고 복잡한 코드가 나올수 있으므로 지양

    - 람다 표현식의 한계
        - 코드 자체로 동작이 명확하게 설명되지 않거나 람다가 길거나 읽기 어렵다면, 쓰지 않는 방향으로 리팩토링하는 것을 고려
        - 람다식은 기본적으로 익명 구현 객체 기반이기 때문에, 익명 객체 특성상 디버깅 할때 콜 스택(call stack) 추적이 매우 어려운 단점을 가지고 있다.
        - stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다.
        - 람다식을 통해 재귀 함수를 구축하면 실행 조차 안되는 컴파일 에러가 나타난다.


    - 메소드를 간결한 함수 식으로 표현
    - 지금까지 자바에서는 메서드를 하나 표현하려면 클래스를 정의해야 했다. 하지만 람다식으로 표현하면 메서드의 이름과 반환값을 생략할 수 있고
      이를 변수에 넣어 자바 코드가 매우 간결해지는 장점이 있다.
    - 인터페이스를 익명 클래스로 구현한 익명 구현 객체를 짧게 표현한 것
    - 오로지 인터페이스로 선언한 익명 구현 객체만이 람다식으로 표현이 가능하다.
      그리고 람다 표현이 가능한 이러한 인터페이스를 가리켜 함수형 인터페이스라 총칭한다.
    - 함수형 인터페이스란 딱 하나의 추상 메소드가 선언된 인터페이스
    - 사실 컴파일러 스스로 람다 함수식을 보고 추론하여 타입을 유추
        1. 람다식을 받는 메소드의 매개변수의 타입을 본다.
        2. 함수형 인터페이스 정의문을 찾아 추상 메소드 형태를 본다.
        3. 추상 메서드에 정의된 타입에 따라 람다식의 타입을 자동으로 판별해준다.

    - 람다 표현식의 한계
        1. 문서화를 할 수 없다.
            - 람다 자체는 이름이 없는 함수이기 때문에 메서드나 클래스와 다르게 문서화 불가.
        2. 디버깅이 다소 어렵다.
            - 기본적으로 익명 구현 객체 기반이기 때문에, 익명 객체 특성상 디버깅 할때 콜 스택(call stack) 추적이 매우 어려운 단점을 가지고 있다.
        3. stream에서 람다를 사용할 시 for문 보다 성능이 떨어진다
        4. 람다를 남발하면 코드가 지저분해질 수 있다.
        5. 재귀로 만들경우에는 다소 부적합하다.
            - 람다식을 통해 재귀 함수를 구축하면 실행 조차 안되는 컴파일 에러가 나타난다.


- 제네릭


- 인터페이스 vs 추상클래스
    - 인터페이스
        - 다중 구현 지원
        - 인터페이스끼리 다중 상속 지원
        - 상속에 얽메이지 않고, 공통 기능이 필요할 때마다 추상 메서드를 정의해놓고 구현하는 식으로 추상클래스보다 자유롭게 붙였다 땟다 사용 가능
        - 인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점

        - 자유로운 타입 묶음
            - 서로 논리적이지 않고 관련이 적은 클래스끼리 필요에 의해 형제 타입 처럼 묶어 버릴 수 있다.

        - 인터페이스 다형성 이용 설계
            - 추상클래스는 클라이언트에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌이라면,
              인터페이스는 반대로 먼저든 나중이든 그때 그때 필요에 따라 구현해서 자유롭게 붙였다 땟다하는 느낌

    - 추상 클래스
        - 단일 상속만 허용
        - 추상 메소드 외에 일반클래스와 같이 일반적인 필드, 메서드, 생성자를 가질수 있다.
          이러한 특징으로, 추상클래스는 추상화(추상 메서드)를 하면서 중복되는 클래스 멤버들을 통합 및 확장을 할 수 있다.
        - 같은 추상화인 인터페이스와 다른점은, 추상클래스는 클래스간의 연관 관계를 구축하는 것에 초점을 둔다.

        - 중복 멤버 통합
            - 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많아 중복 멤버 통합을 할 때
              상수 밖에 정의 못하는 인터페이스는 불가능

        - 추상클래스의 다형성 이용 설계
            - 클라이언트(ExamConsole)에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌

        - 명확한 계층 구조 추상화
            - 추상클래스나 인터페이스나 추상 메소드를 이용한 구현 원칙을 강제한다는 점은 같지만, 추상클래스는 '클래스로서' 클래스와 의미있는 연관 관계를 구축할때 사용된다
            - 의미있는 연관 관계란, 부모와 자식 간의 논리적으로 묶여있는 관계라고 보면 된다.

    -> 인터페이스 : impements 라는 키워드처럼 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌
       추상 클래스 : extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 느낌

    -> 가장 큰 특징이라고 할 수 있는 추상 클래스의 중복 멤버 통합과 인터페이스의 다중 상속 기능을 같이 사용하는 여러가지 코드 패턴들이 나왔고, 디자인 패턴의 근간이 됨.


- 빌더 패턴(Builder Pattern)을 사용해야 하는 이유
    1. 필요한 데이터만 설정할 수 있음
        - 생성자나 정적 메소드를 이용하는 경우라면 더미 값을 넣어주거나 생성자를 새로 만들어주어야 한다.
    2. 유연성을 확보할 수 있음
        - 빌더 패턴을 이용하면 새로운 변수가 추가되는 등의 상황이 생겨도 기존의 코드에 영향을 주지 않을 수 있다.
    3. 가독성을 높일 수 있음
        - 빌더 패턴을 적용하면 직관적으로 어떤 데이터에 어떤 값이 설정되는지 쉽게 파악하여 가독성을 높일 수 있다.
    4. 변경 가능성을 최소화할 수 있음
        - 값을 할당하는 시점이 객체의 생성뿐이라면 객체에 잘못된 값이 들어왔을 때 그 지점을 찾기 쉬우므로 유지보수성이 훨씬 높아진다.


- string + 연산 최적화
    - 대량의 문자열을 결합하는 경우는 '+' 연산자의 성능이 현저히 줄어듬으로 StringBuilder를 권장
    - '+' 연산자는 컴파일 시점에 Java 컴파일러에 따라 최적화됩니다.
    - Java 1.5는 StringBuilder로 최적화되며, Java 9는 아예 바이트 코드 단위의 최적화가 이루어집니다.
      요즘의 개발 환경은 대부분 Java 8 이상임으로 '+' 연산자의 사용을 권장합니다.


- 문자열 분리
    - StringTokenizer는 정규식을 사용할 수 없습니다.
      StringTokenizer 가 성능이 조금 더 좋지만 Legacy 된 이유라고 생각합니다.
      반면 split은 Java 버전이 올라갈수록 개선되고 있으며, 정규식을 미리 컴파일하는 방법으로도 보완할 수 있습니다.
      따라서 극도의 성능이 필요한 예외적인 경우가 아니라면 split 사용을 권장합니다.

    - 구분자를 split는 정규 표현식으로 구분하고, StringTokenizer는 문자로 받는다.
    - split는 결과 값이 문자열 배열이지만, stringtokenizer는 객체이다.
    - 성능은 split 보다 StringTokenizer 가 좋다.
        - split은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 StringTokenizer 보다 성능이 떨어진다.
        - 그러나 데이터의 양이 많은 경우가 아니라면 별 문제가 되지 않는다.


- 오토박싱과 언박싱은 어떤 차이가 있습니까?
    - 자바의 자료형은 기본 타입(primitive type)과 참조 타입(reference type) 으로 나누어진다.
    - 기본 타입의 데이터를 객체로 표현해야 하는 경우가 종종 생기게 된다.
    - 예를 들어 메소드의 인수로 객체 타입만이 요구되면, 기본 타입의 데이터를 그대로 사용할수 없기 때문에 어떠한 변환 작업이 필요해 진다.
      또한 멀티스레드 환경에서 동기화 데이터를 사용해야 할 경우 이를 객체화 해야 할 필요성이 생긴다.
    - 기본 타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스

    - JDK 1.5 부터는 박싱과 언박싱이 필요한 상황에 자바 컴파일러가 자동으로 처리해주기 시작했다.
    - 기본타입 값을 직접 박싱, 언박싱하지 않아도 래퍼 클래스 변수에 대입만 하면 자동으로 박싱과 언박싱이 된다.
    - 기능적 편의성을 위하여 오토 박싱 / 언박싱을 제공하지만, 다른 타입간의 형 변환은 어플리케이션의 성능에 영향을 미치게 된다.
    - 비록 사소한 차이 일지라도 어플리케이션의 성능 측면에서 봤을때 반드시 필요한 상황이 아니라면 지양 해야 하는 것이 옳다.
    - 코드에 불필요한 auto casting이 반복적으로 이루어지고 있는지 확인하는 것은 대용량 서비스를 개발하는데 있어서 꼼꼼히 파악해야하는 요소


- 자바에서 Exception Handling 을 어떻게 하나요?
    - try catch 를 통해 예외를 직접 처리하는 방법이 있습니다.
    - throws 를 통해서 caller 에게 책임을 넘기는 방법이 있습니다.


- Unchecked Exception 과 Checked Exception 의 차이는 무엇인가요?
    - Checked Exception : IDE에서 제공하고 컴파일 타임에 체크할 수 있는 예외를 말합니다. 예를 들어, IO Exception 과 SQL Exception 이 있습니다.
    - UnChecked Exception : 런타임에 체크하는 예외를 말합니다. 예를 들어, NPE, ArrayOutOfIndex , Arithmatic 등이 있습니다.


- throw vs throws 의 차이는 무엇인가요?
    - throws : 보통 메서드 이름 옆에 선언하며 Exception Handling 의 책임을 Caller에게 넘기기 위해 사용
               throws 다음에는 Class 이름이 와야 한다. class 이름들은 여러개 선언 가능
    - throw : Exception 객체를 생성하여 예외를 발생시키는 것.
              하나의 예외 객체만 생성가능하며 throw 다음에는 Class 이름이 아니라 객체가 와야 한다.


- Try Catch Finally 에 Try 안에서 System.exit(0) 를 한다면 Finally는 실행이 되나요?
    - 안됩니다. System.exit 는 프로그램을 강제로 종료한다는 의미이고 완전히 소프트웨어를 중단하기 때문에 Finally는 실행되지 않습니다.


- Marker Interface가 무엇인가요?
    - 상수도 없고 메서드도 없는 완전히 비어있는 인터페이스를 의미. 어떤 특별한 행동을 JVM에게 알려주는 역할. 태그 인터페이스
    - 예시)
        Serializable - 객체 직렬화 가능
        Clonnable - 객체의 복제가 가능
        SingleThreadModel - 싱글스레드로 처리함. 만약 서블릿이 이를 구현했다면 싱글스레드로 처리함.
        Remote - RMI에서 사용하는 객체의 경우 원격호출로 사용 가능


- JAVA RMI  가 무엇인가요?
    - RMI 는 Remote Method Invocation 의 약자입니다. 분산된 객체간의 통신을 구현하는 모든 프로토콜을 의미합니다. 쉽게 이야기 하면 JVM 간의 통신입니다.
        1) 원격객체를 RMI Registry 에 등록합니다.
        2) Client가 객체 참조값을 얻어옵니다.
        3) RMI 를 이용하여 Server의 원격객체를 사용합니다.


- 자바에서 스레드를 생성하는 방법은 무엇인가요?
    - 자바에서 스레드를 생성하는 방법은 크게 2가지가 있습니다.
        1) Thread 클래스를 상속 받고 run 메소드를 오버라이딩하면 됩니다.
        2) Runnable 인터페이스를 구현하여 run 메서드를 오버라이딩합니다. 그 다음 아래와 같이 Thread 생성자의 파라미터로 넘겨 start 메소드를 호출하면 됩니다.


- main 메서드에 Static 이 생략되면 실행이 되나요?
    - 안됩니다. main 이라는 이름은 JVM에서 약속된 프로그램 시작을 의미하는 메서드입니다. Static이 선언되어 있지 않다면 메모리에 올라가 있지 않은
      상태이므로 JVM 은 main 메서드를 찾아서 실행 할 수 없게 됩니다.
        1) public : JVM이 어디서든 접근가능하도록 함.
        2) static : 메모리에 main 메서드를 올림.
        3) void : main의 반환 타입
        4) main :  JVM의 약속된 이름
        5) String[] args : command line parameter

    - 그렇다면 final 을 선언하면 어떻게 될까요? 메서드에 final 이 선언된다는 의미는 더이상 오버라이딩을 할수 없다는 의미입니다.  따라서 main 메서드를 실행하는 데는 아무 영향이 없습니다.


- 직렬화
    - 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술
    - JVM의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술

    - 직렬화를 하려면 우선 Serializable 인터페이스를 implements
    - 직렬화 제외하기 - transient
        - 만약 transient로 직렬화에 포함되지 않은 데이터를 읽을 때는 null로 읽힌다.

    - 객체 쓰기 (ObjectOutputStream)
        - 객체를 쓰려면 stream을 열어야 한다.

    - 객체의 직렬화나 역직렬화에서 클래스는 완전한 동일한 클래스를 통해서 쓰고 읽혀야 한다.

    - InvalidClassException 이라는 예외가 발생함으로 우리는 직렬화 클래스의 버전을 관리해줘야 한다.
    - serialVersionUID를 통해서 버전이 같은 클래스인지 아닌지 판단할 수 있다.


- SerialVersionUID를 선언해야 하는 이유에 대해 설명해주세요.
    - JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 됩니다.
      그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를 사용합니다.
    - 만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있다.


- 자바 LTS(Long-Term Support) 버전별 특징 (8, 11, 17)
    - Java 8
        - 인터페이스에 디폴트 메소드와 정적 메소드
        - 함수형 인터페이스
        - 람다 표현식
        - Stream API
        - Date and Time API
            - LocalDate, LocalTime, LocalDateTime 등의 라이브러리를 통해 기존보다 훨씬 쉽게 날짜 관련 로직을 작성할 수 있게 되었다.
            - 기존에 사용하던 날짜 관련 클래스인 Date, Calendar 등은 가변 객체이므로 Thread-Safe하지 않다.
        - Optional
        - 배열 정렬의 병렬 처리
            - Arrays.parallelSort() 를 통해 병렬적으로 배열을 정렬
        - Java 8의 Default GC는 Paralle GC

    - Java 11
        - String 클래스에 새로운 메소드 추가
            - strip(): 문자열 앞, 뒤의 공백 제거.
            - stripLeading(): 문자열 앞의 공백 제거.
            - stripTrailing(): 문자열 뒤의 공백 제거.
            - isBlank(): 문자열이 비어있거나, 공백만 포함되어 있을 경우 true를 반환한다.
                - String.trim().isEmpty() 와 결과가 동일함.
            - repeat(n): n개만큼 문자열을 반복하여 붙여서 반환함.

        - Files 클래스에 새로운 메소드 추가
            - writeString: 파일에 문자열을 작성하고 Path로 반환
            - readString: 파일 전체 내용을 읽어서 String으로 반환
            - isSameFile: 두 Path가 같은 파일 체크

        - 컬렉션의 toArray() 메소드를 오버 로딩하는 메소드가 추가
            - 원하는 타입의 배열을 선택하여 반환 가능
                List sampleList = Arrays.asList("Java", "Kotlin");
                String[] sampleArray = sampleList.toArray(String[]::new);

        - 자바 파일 실행
            - javac를 통해 컴파일 하지 않고도, 바로 java 파일을 실행할 수 있게 되었다.
                // Java 11 이전
                $ javac HelloWorld.java
                $ java Helloworld
                Hello Java 8!

                // Java 11 이후
                $ java HelloWorld.java
                Hello Java 11!

            - 이전 java는 소스를 컴파일하여 class로 뽑은 후 class를 실행했는데 java를 통해 바로 실행할 수 있게 되었다.

        - Java 11의 Default GC는 G1 GC

    - Java 17
        - Pattern Matching for switch (Preview)
            - 이제 객체를 전달하여 기능을 전환하고 특정 유형을 확인할 수 있다.
        - Foreign Function & Memory API (Incubator)
            - Java Native Interface(JNI)를 대체
            - 기본 함수를 호출하고 JVM 외부의 메모리에 액세스
        - Sealed Classes (Finalized) (자바 15)
        - RandomGenerator(의사난수 생성기)
        - ZGC 도입 (자바 15)
        - NullPointerException이 어떤 변수에 의해 발생했는지 설명 (자바 14)


- 오버로딩과 오버라이딩
    - 오버로딩
        - 매개변수의 개수나 타입의 순서를 다르게 하면, 하나의 이름으로 메소드를 여러 개 정의하는 것
        - 생성자 오버로딩은 동일한 이름을 가진 메소드들의 매개 변수의 타입 또는 개수가 모두 달라야 성립한다. ??

    - 오버라이딩
        - 정의
            - 상위 클래스가 가지고 있는 메소드를 같은 이름의 메소드를 재정의 하는 것
        - 조건
            - 부모 클래스의 메소드와 동일한 시그니처를 가져야 한다.
            - 접근 제어자는 부모 클래스의 메소드보다 좁은 범위로 변경할 수 없다.
            - 부모 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.

    - 오버라이드한 메소드는 동적으로 선택되고, 오버로딩한 메소드는 정적으로 선택된다


- try-with-resources에 대해 설명해주세요.
    - try-with-resources는 try-catch-finally의 문제점을 보완하기 위해 나온 개념입니다.
    - try( ... ) 안에 자원 객체를 전달하면, try블록이 끝나고 자동으로 자원 해제 해주는 기능을 말합니다.
    - 따로 finally 구문이나 모든 catch 구문에 종료 처리를 하지 않아도 되는 장점이 있습니다.


- 객체지향의 설계원칙
    - SRP - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
    - OCP - 개방-폐쇄 원칙 : 확장에는 열려있고, 수정에는 닫혀있어야 한다.
    - LSP - 리스코프 치환 원칙 : 상위 타입은 항상 하위 타입으로 대체할 수 있어야 한다.
    - ISP - 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한 일수록 좋다. (하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.) SRP와 같은 문제에 대한 두 가지 다른 해결책이다.
    - DIP - 의존관계 역전 원칙 : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라. DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.


- 자바 메모리 영역이 할당되는 시점은 언제인가요?
    - Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
    - Stack 영역 : 컴파일 타임 시 할당
    - Heap 영역 : 런타임시 할당

    ※ 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정
    ※ 런타임 : 컴파일 타임 이후 프로그램이 실행되는 때


- Inner Class(내부 클래스)의 장점에 대해 설명해주세요.
    1. 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
    2. 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
    3. 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다.


- 리플렉션(Reflection)이란 무엇인지 설명해주세요.
    - 리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API 입니다.
    - 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용됩니다.
    - 프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. intelliJ의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있습니다.


- 컬렉션 프레임워크에 대해 설명해주세요.
    - 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.
    - 자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue 인터페이스도 존재합니다.


- Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요. ??
    - hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,
      해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교합니다. 이 두 개가 모두 맞으면 중복 객체입니다.


- final / finally / finalize 의 차이를 설명해주세요
    - final은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용
    - finally는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록
    - finalize는 Object 클래스에 정의되어 있는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드


- stream vs for
    - for 문
        - java 1부터 지원
        - for (초기화; 조건; 후처리)

    - 향상된 for 문
        - java 5부터 지원
        - 가독성 up, 안정성 up

    - stream
        - java 8부터 지원
        - stream 생성 -> 중간 연산 -> 최종 연산

    - 둘 다 다량의 데이터 처리 작업에 사용

    - 차이점
        - 함수 객체 vs 코드 블럭
            - for 문은 코드 블록으로 표현
            - 스트림 파이프라인은 함수 객체로 표현 (람다 or 메서드 참조)
            -> 람다식에는 final 변수만 읽을 수 있기 때문에 지역 변수를 수정할 수 없다.
            -> for 문에서는 할 수 있는 continue, break 로직은 stream 에서는 할 수 없다.

        - 외부 반복 (how) vs 내부 반복 (what)
            - 외부 반복: for 문, 구체적인 구현 로직이 외부에 노출
            - 내부 반복: stream, 로직이 노출되지 x

        - 가독성
            ex) for 문의 경우 if 문의 중첩으로 인해 indent depth 가 깊어져 가독성이 떨어질 수 있으나
                stream 의 경우, 조건들을 filter 의 체이닝 형식을 통해 표현할 수 있기 때문에 보다 간결한 표현 가능

            ex) if 문의 중첩 만 있을 경우, 메서드 추출을 통해서 충분히 indent depth 를 줄여 가독성을 높일 수 있었음.
                하지만, for 문으로 요소를 순회하면서 return 을 하는 경우에는 메서드 추출을 통해 indent depth 를
                줄이는 것이 어려움.
                이런 경우, stream 을 이용하면 depth 를 줄여 가독성을 높일 수 있음.

            - 상황에 따라 stream 이 더 가독성이 안 좋을 수도 있음.

        - 디버깅
            - stream 은 많은 내부 수행 작업과 지연 연산으로 인해 디버깅이 다소 어려울 수 있다.
            - for 문은 예외가 발생하는 stack trace 가 간결하게 출력되서 디버깅에 유리할 수 있다.

        - 병렬 처리
            - for 문의 경우, Runnable 등을 활용해 병렬 처리를 위한 코드를 일일이 작성해야 함.
              로직이 복잡해질 경우 직접 구현하기도 까다롭고 신경쓸 것도 많아짐
              데이터들을 몇 개로 어떻게 나눌 것인지, 혹은 발생할 수 있는 동시성 문제가 있는지를 고려해야 한다.
            - stream 을 이용하면 위의 내용들을 stream 이 내부적으로 처리해 주기 때문에 보다 쉽게 병렬 처리 표현 가능

        - 성능
            - int 배열에서 for 문이 stream 보다 빠른 이유
                - for 는 나온지 오래된 만큼 stream 에 비해 JVM 에서 최적화가 충분히 이루어졌다.

                - stream 을 사용하려면 stream 객체를 생성해야 한다.
                  이 생성 과정에서 여러 작업들이 이루어지고 stream 에서 필요한 다른 객체를 생성하는데 오버헤드가 발생
                - for 는 추가적인 객체 생성 없이 인덱스를 통해서 메모리에 직접 접근을 하기 때문에
                  stream 에 비해 오베헤드가 발생하지 않는다.

            - 향상된 for 문에서는 원시타입 배열에 어떻게 접근 할까?
                - 향상된 for 문에서는 컬렉션을 순회할 때와 마찬가지로 iterator 를 이용할 것이라고 예상할 수 있지만
                  원시타입 배열이 들어온 경우에는 iterator 가 아닌 전통 for 문의 형식으로 바꾸어서 순회.
                  따라서 int 배열에 대한 작업에서는 전통 for 문과 향상된 for 문이 비슷한 성능을 보임

            - List 에서 성능 차이가 미미한 이유
                - int 배열은 요소들이 원시타입인 반면 컬렉션은 Wrapper 타입이 들어오게 된다.
                  그래서 박싱 및 언박싱에 대한 오버헤드가 발생한다. 이 오버헤드는 충분히 크기 때문에
                  컬렉션에 대한 성능은 이 오버헤드에 지배되면서 큰 성능 차이를 보이지 못함.

            => 하지만, 오늘날의 하드웨어는 충분히 빠르기 때문에 소프트웨어에서는 성능보다는 다른 점들을 더욱 신경쓰는 추세.
               유지보수, 가독성 등을 고려하는 것이 더욱 좋을 수 있음.

    - 결론
        - 가독성
            - 추상화된 api 를 제공하고, 보다 What 중심의 코드를 작성할 수 있어 가독성이 더 좋을 수 있다. (개인 차이 존재)

        - 디버깅
            - for 문에 비해 stream 이 디버깅이 어렵다.

        - 병렬 처리
            - 비교적 stream 을 이용한 병렬 처리가 간단하다.

        - 성능
            - for 문이 성능이 더 좋을 수 있다.

        - 스트림을 적용하기 좋은 조건
            - 원소들의 시퀀스를 일관되게 변환한다.
            - 원소들의 시퀀스를 필터링 한다.
            - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.
            - 원소들의 시퀀스를 컬렉션에 모은다.
            - 원소들의 시퀀스를 특정 조건을 만족하는 원소를 찾는다.

        => 어느 하나가 절대적으로 좋은 것이 아닌 각각의 장단점이 있다.
           따라서, 차이를 인지하고 이를 적절히 사용하는 것이 바람직하다.


- 쓰레드 풀
    - 단순히 스레드만 사용해서 동시에 여러 작업을 실행시킬 수 있는 프로그램을 만들 수 있을까?
        - 문제
            - 스레드 생성비용이 크기 때문에 요청에 대한 응답시간이 늘어난다.
                1. Java 는 One-to-One Threading-model 로 Thread 생성한다.
                2. User Thread(Process 의 스레드) 생성시 OS Thread(OS 레벨의 스레드) 와 연결해야 한다.
                    - User Thread 는 OS Thread 에 대한 User Program 계층에서의 추상화
                3. 새로운 Thread 를 생성할 때 마다 OS Kernel 의 작업이 필요하다.
                4. Thread 는 생성 비용이 많이 든다.
                5. 작업 요청이 들어올 때마다 Thread 를 생성하면 최종적인 요청 처리 시간이 증가한다.

            - Thread 가 너무 많으면 여러가지 문제를 발생시킨다.
                1. Process 의 처리 속도보다 빠르게 요청이 쏟아져 들어오면
                2. 새로운 Thread 가 무제한적으로 계속 생성된다.
                3. Thread 가 많아 질수록 메모리를 차지하고 Context-Switching 이 더 자주 발생한다.
                4. 메모리 문제가 발생할 수 있고, CPU 오버헤드가 증가한다.

    - 그래서 나온 게 Thread Pool
        - Thread 를 허용된 개수 안에서 사용하도록 제한하는 시스템
        - Thread, 작업 큐로 이루어짐.
            1. 스레드풀에 작업 처리 요청
            2. 작업 큐에 작업들이 쌓이게 됨.
            3. 각 스레드로 작업을 보내고, 스레드는 작업을 처리함.
            4. 결과 전달

        - 해결
            - 미리 만들어 놓은 스레드를 재사용할 수 있기 때문에 새로운 스레드를 생성하는 비용을 줄일 수 있다.
            - 사용할 스레드 개수를 제한하기 때문에 무제한적으로 스레드가 생성되는 것을 방지

        => 여러 개의 작업을 동시에 처리하면서도 안정적으로 처리하고 싶을 때 Thread Pool 은 효과적

    => 스레드풀을 설정해야 하는 이유
        - 스레드풀은 응답시간과 TPS 에 영향을 주는 하나의 요소이다.
        - 잘 조정된 스레드풀은 시스템의 성능을 끌어내고 안정적인 어플리케이션 운용을 가능하게 한다.
        - 부적절하게 설정된 스레드풀은 병목 현상, CPU 오버헤드, 메모리 문제를 유발할 수 있다.

    - 어떻게 하면 스레드풀을 잘 설정해서 Server Application 을 효과적으로 구현할 수 있을까?
        - SpringBoot 설정을 통한 Tomcat Thread Pool 설정
            - server.tomcat.threads.max
                - 스레드풀에서 사용할 최대 스레드 개수, 기본 값은 200
                - 서버 어플리케이션이 동시에 처리할 수 있는 요청 개수와 관련있다.
                - 요청에 비해 너무 많게 설정 -> 놀고 있는 스레드가 많아져서 비효율 발생
                - 너무 적게 설정 -> 동시 처리 요청 수가 줄어든다. 평균응답시간, TPS 감소
                -> 기본적으로 스레드가 많아지면 CPU 오버헤드와 메모리에서 문제가 생길 수 있다.

            - server.tomcat.threads.min-spare
                - 스레드풀에서 최소한으로 유지할 스레드 개수, 기본값은 10
                - 너무 많이 설정 -> 스레드풀이 항상 유지해야 할 스레드 수가 너무 많아진다.
                - 적절하게 설정 -> 적은 수의 요청에서 새로운 스레드를 만들 필요없이 요청을 효과적을 처리할 수 있다.
                -> 잘못 설정했을 때 사용하지 않는 스레드가 메모리를 차지하면서 비효율을 발생시킨다.

            - server.tomcat.max-connections
                - 동시에 처리할 수 있는 최대 Connection 의 개수, 기본 값은 8192
                - 사실상 서버의 실질적인 동시 요청 처리 개수
                    - 톰캣의 커넥터 컴포넌트의 방식에 따라서 개수 설정
                        - Blocking IO: 1 Connection 1 Thread
                        - Non-Blocking IO: N Connection 1 Thread
                    - tomcat 8 버전 이후부터는 Non-Blocking IO 방식 사용
                - Non-Blocking IO 에서는 스레드풀을 최대 스레드 개수보다 많은 양의 Connection 을 유지할 수 있다.
                - Non-Blocking IO 에서는 최대 스레드 개수보다 적거나 같은 수의 max-connections 를 설정하는 것은 비효율적인
                  설정이 될 수 있다.

            - server.tomcat.accept-count
                - max-connections 이상의 요청이 들어왔을 때 사용하는 요청 대기열 큐의 사이즈, 기본 값은 100
                - 너무 크게 설정 -> 대기열이 커지면서 메모리 문제 유발
                - 너무 작게 설정 -> 요청이 몰렸을 때 들어오는 요청들을 거절해 버릴 수 있다.
                -> 이 설정을 하는 이유 중 하나는 부적절하거나 잘못된 요청이 한번에 너무 많이 들어와
                   서버에 장애를 발생시키는 것을 방지하기 위함도 있다.


- 접근제어자를 사용하는 이유
    - 객체를 사용하는 입장에서 객체 내부적으로 사용하는 변수나 메소드에 접근함으로써 개발자가 의도하지 못한 오동작을 일으키기도 합니다.
      이러한 문제로부터 객체의 로직을 보호하기 위해서는 멤버에 따라서 외부의 접근을 허용하거나 차단해야 할 필요
    - 사용자에게 객체를 조작할 수 있는 수단만을 제공함으로써 결과적으로 객체의 사용에 집중할 수 있도록 돕기 위함
    -> 의도치 않은 실수를 줄이기 위함과 정보 은닉의 목적


- interface와 abstract class
    - 인터페이스
        - 생성자를 가질 수 없어 객체화가 불가능
        - 디폴트 메서드 + 추상메서드로 구성
        - 다중 상속이 가능

    - 추상클래스
        - 생성자를 가지기 때문에 객채화가 가능
        - 필드를 가질 수 있다
        - 다중 상속 불가

    -> 인터페이스를 사용하는 이유를 협업이라고 하기도한다. 하나의 규격을 만들어 놓으면 A개발자가 kbPaymentServiceImpl 개발을 / B개발자가 lgPaymentServiceImpl 개발을 협업이 가능하다.


- 캡슐화와(Encapsulation) 은닉화(Information Hiding)
    - 캡슐화
        - 관련된 요소들을 묶음으로써 캡슐 내부와 외부를 구별 짓는 장치
        - 객체 외부에서는 개체 내부 정보를 직접 접근하거나 조작할 수 없고,
          외부에서 접근할 수 있도록 정의된 오퍼레이션을 통해서만 관련 데이터에 접근할 수 있다 ex). getter ,setter

        - 객체의 세부내용이 외부에 은폐(정보은닉)되어, 변경이 발생할 때 오류발생이 적어짐
        - 각 객체가 가지고 있는 데이터들은 해당 객체 속에 숨어 있기 때문에 외부 객체에서 볼 수 없다.
        - 객체들 간의 메시지를 주고 받을 때 각 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 간결해지고, 객체간의 결합도가 낮아짐

    - 정보은닉
        - 캡슐내의 요소들에 대한 세부 구현사항을 외부에 숨기는 장치
        - 정보 은닉은 private 키워드를 활용해서 외부에서 클래스 내부의 정보에 접근하지 못하도록 하는 기능

        - 정보은닉은 캡슐화 되어 있는 데이터와 함에 대해서 외부에서 해당 함수가 어떻게 구현되어 있는지에 대한 세부 사항을 숨기는 것이다.
        - 캡슐화가 되어 있다고 해서 반드시 정보은닉이 되는 것은 아니다.


- enum 이란


- 자바에서 == 와 Equals() 메서드의 차이는
    - String 변수 생성시 주소할당
        - 리터럴을 이용한 방식 : String s1 = "abcd";
            - 리터럴을 사용하게 되면 string constant pool이라는 영역에 존재하게 되고 new를 통해 String을 생성하면 Heap 영역에 존재하게 됩니다.
            - String을 리터럴로 선언할 경우 내부적으로 String의 intern() 메서드가 호출되게 됩니다.
            - intern() 메서드는 주어진 문자열이 string constant pool에 존재하는지 검색하고 있다면 그 주소값을 반환하고 없다면
              string constant pool에 넣고 새로운 주소값을 반환합니다.

        - new 연산자를 이용한 방식 : String s2 = new String("abcd");

    - 주소값 비교(==)와 값 비교(equals)
        " == " : 비교하고자 하는 두개의 대상의 주소값을 비교
        " String클래스의 equals 메소드 " : 비교하고자 하는 두개의 대상의 값 자체를 비교

        일반적인 타입들 int형, char형등은 Call by Value 형태로 기본적으로 대상에 주소값을 가지지 않는 형태로 사용됩니다.
        하지만 String은 일반적인 타입이 아니라 클래스입니다.
        클래스는 기본적으로 Call by Reference형태로 생성 시 주소값이 부여됩니다.
        그렇기에 String타입을 선언했을때는 같은 값을 부여하더라도 서로간의 주소값이 다를 수가 있습니다.


- Java SE와 Java EE 애플리케이션 차이
    - JAVA SE (Java Standard Edition)
        - 표준 자바 플랫폼 / 자바 API집합체(패키지)
        - 자바 표준 에디션은 가장 기본이 되는 에디션입니다.흔히 자바 언어라고 하는 대부분의 패키지가 포함된 에디션이며
          주요 패키지로는 java.lang., java.io., java.util., java.awt., javax.rmi., javax.net. 등이 있습니다.

    - JAVA EE (Java Enterprise Edition)
        - 자바를 이용한 서버측 개발을 위한 플랫폼 / 기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델
        - 기존 SE에서 서버측을 위한 가능이 더 추가되어있습니다.
        - 엔터프라이즈 환경을 위한 도구로 자바로 구현되는 웹프로그래밍에서 가장 많이 사용되는 JSP, Servlet을 비롯하여,
          데이터베이스에 연동하는 JDBC, 그 외에도 JNDI, JTA, EJB 등의 많은 기술들이 포함되어 있습니다.
        - Java EE는 Java SE의 API에 추가로(lib 디렉토리에 포함되어 있는 JAR파일들)의 차이입니다.


- java의 final 키워드
    - final
        - 변수나 메서드 또는 클래스가 ‘변경 불가능’하도록 만든다.

        - 원시(Primitive) 변수에 적용 시 해당 변수의 값은 변경이 불가능하다.
        - 참조(Reference) 변수에 적용 시 참조 변수가 힙(heap) 내의 다른 객체를 가리키도록 변경할 수 없다.
        - 메서드에 적용 시 해당 메서드를 오버라이드할 수 없다.
        - 클래스에 적용 시 해당 클래스의 하위 클래스를 정의할 수 없다.

    - finally
        - try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용한다.

        - finally는 선택적으로 try 혹은 catch 블록 뒤에 정의할 때 사용한다.
        - finally 블록은 예외가 발생하더라도 항상 실행된다. (단, JVM이 try 블록 실행 중에 종료되는 경우는 제외한다.)
        - finally 블록은 종종 뒷마무리 코드를 작성하는 데 사용된다.
        - finally 블록은 try와 catch 블록 다음과, 통제권이 이전으로 다시 돌아가기 전 사이에 실행된다.

    - finalize
        - GC가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.
        - 종료자는 사용하면 안 된다. 예측이 불가능하고 대체로 위험하고 일반적으로 필요하지 않다.


- 리플렉션이란
    - 구체적인 Class Type을 알지 못해도, 그 클래스의 메서드, 변수들에 접근 할 수 있도록 해주는 JAVA API
    - gc의 대상이 되지 않은 영역 Method Area 영역을 뒤져서 클래스에 대한 정보를 가져온다.
       (Method Area에는 Static 변수들을 비롯한, 생성자 , Method, SuperClass등 의 정보가 올라가게됩니다.)

    ex)
    - BeanFactory에서 객체가 호출되면 객체의 인스턴스를 생성하게 되는데 이 때 필요. 즉, 프레임워크에서 유연성있는 동작을 위해 쓰게 됩니다.
    - 스프링에 @autowired 어노테이션에 동작에는 reflection 사용되고 있음.


- Wrapper class
    - 기본 자료타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스(wrapper class)라고 합니다.
    - 자동박싱 자동언박싱
        기본타입 값을 직접 박싱, 언박싱하지 않아도 자동적으로 박싱과 언박싱이 일어나는 경우가 있습니다.
        자동 박싱의 포장 클래스 타입에 기본값이 대입될 경우에 발생합니다.
        예를 들어 int타입의 값을 Integer클래스 변수에 대입하면 자동 박싱이 일어나 힙 영역에 Integer객체가 생성됩니다.
    - 래퍼 클래스와 기본자료형과의 비교는 == 연산과 equals연산 모두 가능합니다.
      그 이유는 컴파일러가 자동으로 오토박싱과 언박싱을 해주기 때문입니다.
    - 기본형으로 처리할 수 있는 부분을 wrapper class로 처리하지 말자.
      기본형을 박싱하면 생기는 오버헤드 때문에 성능이 기본형으로 처리하는 경우보다 상당히 떨어진다.


- OOP 의 4가지 특징
    - 추상화(Abstraciton)
        공통의 속성이나 기능을 묶어 이름을 붙이는 것을 추상화라고 할 수 있다.

        객체 지향적 관점에서 클래스를 정의하는 것을 추상화라고 할 수 있다. 예를 들어 사자, 고양이, 강아지가 있을 때 우리는 이것을 각각 객체라고 하며,
        이 객체들의 공통점인 동물이라고 표현할 수 있는데 이때 동물로 묶는 행위를 추상화라고 한다.

    - 캡슐화(encapsulation)
        특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶는 것을 캡슐화라고 한다.

        쉽게 말해 모듈화를 의미한다. 이러한 캡슐화를 통해 정보를 객체 안에 포함시키고, 그 정보에 대한 직접 접근은 허용하지 않는 대신,
        필요에 따라 확인할 수 있는 인터페이스를 외부에 공개함으로써 정보 은닉 효과도 자연스럽게 따라온다.

    - 상속(inherutance)
        상위 개념의 특징을 하위 개념이 물려받는 것을 상속이라 한다.

        상속에서 주의해야할 점은 계층도, 조직도 관점(가족 관계도와 같은)에서 이해하면 안된다는 점이다. 분류도 관점에서 이해해야한다.
        하위 클래스는 상위클래스의 역할을 대신할 수 있으면서 고유의 역할도 수행할 수 있어야 한다. 아버지와 아들을 예시로 들면 아들은
        아버지의 역할을 할 수 있으면서 아들 고유의 역할도 수행할 수 있어야 하지만 그렇지 못하다. 이와 같은 부분에서 상속을 사용할 때는 주의해야 한다.
        상속은 코드의 재사용성을 높이고 확장성을 높여준다.

    - 다형성(polymorphism)
        같은 모양의 코드가 다른 행위를 하는 것을 나타낸다. 자바에서는 Overriding, Overloading 이 그 방법이다.

        - Overriding 오버라이딩
            오버라이딩은 Method 재정의라고 할 수 있다. 슈퍼 클래스의 메서드 이름, 매개 변수, 같은 반환 값이지만 내부 로직을 새롭게 재정의하는 개념이다.
        - Overloading 오버로딩
            오버로딩은 같은 이름의 Method 이지만 매개 변수의 개수, 리턴 타입과 같은 부분이 다름으로 여러 개의 같은 이름 메서드를 정의하는 것을 말한다.


- java의 main 메서드가 static인 이유
    - 프로그램 실행시 먼저 static 영역 메모리에 적재된다.
    - main 메소드 같은 경우는 객체를 생성하지 않아도 자동으로 실행되어 작업을 수행해야하는 부분이기 때문에 static으로 선언
    - public 접근 제어자는 JVM이 main 함수가 어디에 있건 접근 가능하기 위해서
    - (String args[]) 는 매개변수로 문자열 배열을 줄 수 있음


- JVM 구조
    - JVM MEMORY영역에 Heap영역과 Native Memory영역에 jdk8에서 변화가 있다.

    - jdk7 vs jdk8 HEAP
        - JDK 8부터 Permanent Heap 영역이 제거되고 Metaspace 영역이 추가되었다.
        - Perm은 JVM에 의해 크기가 강제되던 영역이다.(JVM이 관리하는 영)
        - Metaspace는 Native memory 영역으로, OS가 자동으로 크기를 조절한다.(OS 판단하여 메모리를 조절)
        - 기존과 비교해 Perm영역에서 사용하던 메모리를 사용할 수 있게 되어 메모리 부족에 대한 부담이 감소한다.

    - Perm영역의 역할은
        - Perm 영역은 보통 Class의 Meta 정보나 Method의 Meta 정보,
        - Static 변수와 상수 정보들이 저장되는 공간으로 흔히 메타데이터 저장 영역이라고도 한다.
        - 이 영역은 Java 8 부터는 Native 영역으로 이동하여 Metaspace 영역으로 변경되었다.
        - 기존 Perm 영역에 존재하던 Static Object는 Heap 영역으로 옮겨져서 GC의 대상이 최대한 될 수 있도록 하였다.


- 제네릭이란, 왜 쓰는지 어디에 써 봤는지 알려주세요
    - 제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다.
    - 자바5 이전에는 실수로 엉뚱한 타입의 객체를 넣어두면 런타임에 형변환 오류가 나는 문제가 있었다.
    - 제네릭일 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려준다.
    - 컴파일 과정에서 오류를 차단 할 수 있다는 것이다. (안전하고 명확한 프로그래밍이 가능)


- 객체(Object) VS 인스턴스(Instance)
    - 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
    - 객체를 클래스의 인스턴스라고도 부른다 => ‘인스턴스화하여 레퍼런스를 할당한’ 객체를 인스턴스라고 말하지만,
      이는 원본(추상적인 개념)으로부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.


- 객체지향프로그래밍의 특징
    - 객체지향 프로그래밍 이란 캡슐화, 추상화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고,
      유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것 입니다.


- Call by Reference와 Call by Value의 차이
    - 자바의 메소드(함수) 호출 방식
        - Call by value는 메서드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값(value)을 복사하여 보낸다.
        - Call by reference는 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 참조값, 혹은 주소, 포인터(Address)를 복사하여 보낸다.


- 자바의 참조형은 Call by Reference 인가?
    - 자바는 기본형 타입 변수와 참조형 타입 변수가 있는데 둘 다 call by value 방식으로 메소드에서 받아진다
      대신 기본형 타입은 그 값을 복사 해서 주지만 참조형 타입은 값의 래퍼런스(주소)가 저장되는 것이므로 그 값의 래퍼런스가 복사 되어진다
    - 참조가 아닌 각각의 필드 값을 Getter/Setter를 이용해서 바꾸면 예외적으로 이런 경우에는 두개의 값이 변경됩니다.
      이런 예외적인 부분 때문에 참조형이 Call by Reference라는 오해를 받게 된다고 생각한다.
      왜 이런 부분이 가능할까요? 자바가 함수의 인자로 전달해주는 것은 어떤 것을 참조 하고 있는지에 대한 (복사된) 참조 값을 전달하기 때문이다.
      (접근제어자로 막혀있지 않은 한) 자바에서 객체를 컨트롤 하는 행위는 어떤 장소이든 간에 그 객체를 참조하는 참조값만 알고 있다면 가능하다.


- 제네릭(Generic)
    - 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
    - 제네릭으로 배열을 생성할 수는 없다.
    - static 변수에도 제네릭을 사용할 수 없다. static 변수는 인스턴스에 종속되지 않는 클래스변수로써 모든 인스턴스가 공통된 저장공간을 공유하게 되는 변수이다.
      하지만, static 메서드에는 제네릭을 사용할 수 있다.
    - static 변수의 경우에 제네릭을 사용하면 여러 인스턴스에서 어떤 타입으로 공유되어야 할지 지정할 수가 없어서 사용할 수 없다. static 변수는 값 자체가 공유되기 때문이다.
      값 자체가 공유되려면 타입에 대한 정보도 있어야 한다.
    - 하지만, static 메서드의 경우 메서드의 틀만 공유된다고 생각하면 된다. 그리고 그 틀 안에서 지역변수처럼 타입 파라미터가 다양하게 오가는 형태로 사용될 수 있는 것이다.


- 제네릭을 사용하는 이유
    - 제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때 마다 형변환을 해야 했다. jdk 1.5 부터는 제네릭을 사용하면 컬렉션에 담을 수 있는 타입을 컴파일러에게 알려주며,
      컴파일러가 알아서 형변환 코드를 추가한다. 또한 엉뚱한 객체를 넣는 코드가 있다면 컴파일 타임에 차단해준다.
    - 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있다. 실행 시(런타임 시) 타입 에러가 나는것보다는 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지하는 것이 좋다.
    - 제네릭 코드를 사용하면 타입을 국한하기 떄문에 요소를 찾아올 때 타입 변환을 할 필요가 없어 프로그램 성능이 향상된다.


- 제네릭 장점
    - 컴파일러의 검사력 (컴파일 시 체크)
    - 형변환이 필요없고, 타입안정성이 보장된다.
    - 코드의 재사용성이 높아진다.


- 제네릭 싱글톤 팩토리
    불변 객체를 여러 타입으로 활용할 수 있게 만들어야 할 때가 있는데, 이때는 제네릭 싱글톤 팩토리를 만들면 된다. Collections.reverseOrder[Comparator]이 좋은 예다
    만약 제네릭을 쓰지 않았다면 요청 타입마다 형변환하는 정적 팩토리를 만들었어야 할 것이다. (타입별로 정적메소드가 1개씩..)


- 제네릭 와일드 카드
    - 제네릭타입<?> : 타입 파라미터를 대치하는 것으로 모든 클래스나 인터페이스타입이 올 수 있다.
    - 제네릭타입<? extends 상위타입> : 와일드카드의 범위를 특정 객체의 하위 클래스만 올 수 있다.
    - 제네릭타입<? super 하위타입> : 와일드카드의 범위를 특정 객체의 상위 클래스만 올 수 있다.


- 예외 처리 방법
    - 예외 처리 방법 : 예외 복구, 예외 처리 회피, 예외 전환 방법
      (try ~ catch문 안에 throw 예외던지기 / 메소드() throws Exception 등)
    - throw는 예외를 발생시키는 명령이다. throw 뒤에는 예외 정보를 가지고 있는 예외 클래스가 위치한다.
      자바 가상 머신은 이 클래스를 기준으로 어떤 catch 구문을 실행할 것인지를 결정한다. 또 실행되는 catch 구문에서는 예외 클래스를 통해서
      예외 상황의 원인에 대한 다양한 정보를 얻을 수 있다. 이 정보를 바탕으로 문제를 해결하게 된다.


- 메소드() throws Exception
    - 강제로 Exception을 자신을 호출한 상위메소드에 책임 전가
    - 메소드 뒤에 throws ~~ 를 사용하고 싶지 않으면 그냥 서비스 구현하는 곳에서에서 try catch 쓰면 된다(catch문에 예외 발생 시 처리 로직 구현하거나.. 단, 책임을 전가하지는 않는다)
    - exception이 발생할 여지가 있는곳에 try catch문을 작성함으로서 예외가 발생하더라도 구동중이던 어플리케이션이 중간에 멈추지않게끔 하는게 예외처리인데
      메서드에서 throws Exception을 해주게되면 해당 메서드 내에서 예외가 발생하면 자신이 처리하는게 아니고 자신을 호출한 상위메서드로 예외를 던지게 된다.


- Stream이란
    - 함수형 인터페이스(람다식)을 적용하여 컬렉션과 같은 저장요소를 반복적으로 처리할 수 있는 기능이다

    - Stream은 Immutable 하다. 다시 말해 원본의 데이터를 변경하지 않는다.
    - Stream의 연산은 layz 하다. 즉 필요 할 때만 연산함으로 효율적인 처리가 가능하다.
    - Stream은 재사용이 불가능하다.
    - Stream 생성, 중개연산, 최종연산 세 단계로 구분된다.


- Lambda란
    - 함수형 프로그래밍 언어에서 사용되는 개념으로 익명 함수라고도 합니다. 메서드를 하나의 '식(expression)'으로 표현한 것이다. 메서드를 람다식으로
      표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명 함수(anonymous function)'이라고도 한다.

    - 배경
        인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스를 이용하는데 일회성으로 사용하는 구현 클래스를 계속 선언하는 것은
        비효율적이기 때문에 익명 클래스나 람다를 이용하여 구현 클래스를 선언합니다.

    - 함수 객체
        특정 동작을 목적으로 추상 메서드를 하나만 담은 인터페이스나 추상 클래스를 함수 객체라합니다.


- HashMap vs HashTable vs ConcurrentHashMap의 차이를 설명하시오.
    - HashMap
        동기화(thread-safe) 보장 안됨
        null 허용

    - HashTable  ConcurrentHashMap
        동기화(thread-safe) 보장
        null 허용하지 않는다.
        성능은 ConcurrentHashMap가 더 우수하다.
        HashTable ConcurrentHashMap는 구현방식이 다르다.


- java immutable Object
    - 불변객체는 재할당은 가능하지만, 한번 할당하면 내부 데이터를 변경할 수 없는 객체

    - 장점
        - 객체에 대한 신뢰도가 높아집니다. 객체가 한번 생성되어서 그게 변하지 않는다면 transaction 내에서 그 객체가 변하지 않기에 우리가 믿고 쓸 수 있기 때문입니다.
        - 생성자, 접근메소드에 대한 방어 복사가 필요없습니다.
        - 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있습니다.

    - 단점
        - 객체가 가지는 값마다 새로운 객체가 필요합니다. 따라서 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능저하를 발생시킬 수 있습니다.

    - 불변 class를 만드는 방법
        - 모든 class field 변수는 final로 선언
        - 모든 class field 변수의 setter 메서드 선언 X
        - class를 상속하지 못하도록 선언 (class를 final로 선언하거나 생성자를 private로 선언)
        - 모든 field 변수가 final이 아닐때 즉 가변객체타입의 field 변수가 있을 경우 그 가변객체 타입의 field변수에 대해 직접적으로 접근하지 못하도록
        - copy 객체를 생성하여 새로운 인스턴스를 반환하도록 방어적 복사본 전략을 사용


- java map flatmap 차이
    - map
        - .map()은 단일 스트림의 원소를 매핑시킨 후 매핑시킨 값을 다시 스트림으로 변환하는 중간 연산을 담당합니다.
        - 객체에서 원하는 원소를 추출해는 역할을 한다고 말할 수 있습니다.

    - flatmap
        - 배열형태의 스트림을 다루기가 map보다 좋다.
        - .flatMap()은 Array나 Object로 감싸져 있는 모든 원소를 단일 원소 스트림으로 반환합니다.
        - map()은 입력한 원소를 그대로 스트림으로 반환하지만 .flatMap()은 입력한 원소를 가장 작은 단위의 단일 스트림으로 반환합니다.


- heap dump 뜨는 방법
    - jmap명령어를 통해 파일 생성(운영중 힙덤프 뜨는방법)
        1. $JAVA_HOME/bin 으로이동. (환경변수 설정 되어있을경우 2번으로 바로 넘김)
        2. 커맨드 창에 jps -v 입력. pid 확인.
        3. 힙덤프 뜰 경로로 이동
        4. jmap -dump:format=b,file=<파일명>
            ex)jmap -dump:format=b,file=testapp 353
        5. MAT 으로 덤프확인

    - spring actuator를 이용
        - 웹 애플리케이션 경우에만 사용 가능.
        - Warning: Java 애플리케이션에서 STW(Stop The world) 가 발생하므로 운영 중인 서비스에서는 사용하지 않는 것이 좋습니다.



- Object 클래스 hashCode()
    - Java에서 사용되는 해시 코드(Hashcode)는 객체를 식별하기 위한 ID입니다. Java의 모든 객체는 JVM에 의해 고유 번호가 생성되며, 이 고유 번호가 해시 코드입니다.
    - 해시 코드는 32 비트 고유한 정수 값으로 객체와 다른 객체를 구별하기 위해 사용되며, 객체의 내부 주소를 정수로 변환된 값입니다.
    - 객체의 내부 주소가 변경되면 해시 코드도 변경된다.
    - Java에서 해시 코드를 기반으로 데이터를 관리하는 이유는 데이터 검색, 추가, 제거하는 작업이 쉬워지며, 시간 복잡도가 O(1)이므로 상당히 빠르게 동작
    - 컴퓨터마다 메모리 구조와 사양이 다르므로 객체가 생성되는 위치가 다릅니다. 위 예제를 다른 컴퓨터에서 실행하면 다른 해시 코드가 반환됩니다.


- 메모리 주소만으로 Heap의 인스턴스에 접근할 수 있을까?
    - 접근할 수 없다
        - 개발자는 객체의 주소를 직접적으로 지정할 수 없다
            - JVM만이 객체가 메모리에 저장되어 있는 위치를 알고 있으며, 할당 작업을 실행하는 동안 해당 주소를 변수에 할당한다.

        - JVM만이 객체가 메모리에 저장되어 있는 위치를 아는 이유
            - 자바에선 변수의 메모리 주소를 얻는 것은 무의미하다.
            - 왜냐하면 JVM은 자유롭게 객체를 구현하고, GC를 이용해 그 객체의 위치를 이동시키기 때문


- HashMap 은 어떻게 구현되어있길래 키와 값을 빠르게 매핑할 수 있을까?   https://velog.io/@dailyzett/HashMap
    - HashMap은 해싱함수를 통해 인덱스 산출
    - 인덱스를 통한 접근으로 시간복잡도 O(1)의 빠른 성능
    - key는 무한하지만 인덱스는 한정되이 있어 충돌 불가피
    - 충돌을 줄이기 위해 HashMap은 버킷 사이즈 조절
    - 충돌이 일어날 시, 충돌 수가 적으면 LinkedList 방식으로 충돌된 객체들을 관리하다가, 임계점을 넘으면 Red-Black Tree 방식으로 객체들을 저장
    - 시간 복잡도는 Linked List 가 O(n), Red-Black Tree 가 O(logN) 이다.

    - key 의 적당한 갯수는?
        - 그렇다면 요소가 몇 개가 들어갈 지도 모르는 상황에서 키는 몇 개를 생성해야 할까?
            HashMap<Integer, String> map = new HashMap<>();

            Integer.MAX_VALUE 의 값은 2,147,483,647 이다. 아무리 데이터가 많다 해도 정수의 최댓값까지 모든 요소가 가득 차 있을 수는 없다.
            이 경우 할당된 메모리의 많은 부분이 사용되지 않은 상태가 되므로 공간이 낭비되고 검색 효율도 나빠진다.

            그래서 HashMap은 버킷(bucket)에 요소를 저장하고 이러한 버킷의 수를 용량(capacity) 라고 한다.
            bucket 을 우리말로 번역하면 양동이가 되는데 요소를 담는 양동이라고 생각하면 편하다

            Map 컬렉션에 값을 넣을 때 키의 hashCode() 메서드는 값이 저장될 버킷을 결정하는 데 사용된다. 그리고 값을 검색하기 위해 HashMap 은
            hashCode()를 사용하여 동일 방식으로 버킷을 계산한다. 그런 다음 해당 버킷에서 찾은 객체를 순회해서 키의 equals() 메서드를 이용해 정확히 일치하는 항목을 찾는다.

            정리하면, HashMap 은 모든 요소를 순회하는 것이 아니라 키를 기반으로 값의 위치를 계산한다.

    - 해시 충돌
        기본적으로 동일한 키에 동일한 해시가 있어야 되지만 다른 키에 동일한 해시가 있을 수 있다.
        다른 키이면서 동일한 해시인 경우 해당 키에 속한 값은 동일한 bucket에 저장된다.

        버킷 내부에서 값은 List에 저장되고 모든 요소를 순회하여 검색한다. 이 때의 시간 복잡도는 O(N)이 된다.
        Java 8 부터 버킷 한 개에 8개 이상의 값이 포함되는 경우 List 에서 balanced tree 로 변경되는데 시간 복잡도는 O(logN) 이다.


- 클래스변수, 인스턴스변수, 지역 변수
    https://2018-start.tistory.com/44

- java volatile vs atomic
    https://mygumi.tistory.com/112

- java String 불변객체인 이유
    https://devlog-wjdrbs96.tistory.com/247

- Java Development Kit (JDK) 버전별 변화( 8 ~ 17까지)
    https://catsbi.oopy.io/d7f0502c-5ec3-4b8b-a99b-5f61c1097093

- Checked,Unchecked Exception 차이
    https://cheese10yun.github.io/checked-exception/


- hashtable vs concurrentHashMap의 차이점

- Java Collection의 구현체 (java collection에 대한 종류와 특징)

- check exception , uncheck exception의 차이를 아냐

- 생성자 대신 정적 팩토리 메서드

- 제네릭이란? 제네릭을 쓰면서 얻은 이점

- 싱글톤 설명

- syncronize

- enum 이 뭐냐? 사용하는 이유?

- lazeholder

- 멀티쓰레드 프로그래밍을 해본 적 있는지

- java에서 파일을 읽어올 때 왜 스트림을 쓰냐?

- 동기화를 언제써야 하는지 (관련된 라이브러리 써본거 없냐?)

- 인터페이스 다중상속을 사용하는 경우(사용하는 이유)

- OOP 에 대해 설명해달라

- java8 이후에 Date vs localDatetime 클래스들의 차이점은?

- java stream paralled 사용시 주의사항

- stream에 lazy란?

- static 클래스, static 변수, static 메소드 차이

- java8에 @FunctionalInterface이란

- 자바에서 공유객체 처리 어떻게 하는지

- 맵과 플랫맵 차이가 머고 왜쓰나

********* 자바 면접 질문
    https://f-lab.kr/blog/java-backend-interview-1




