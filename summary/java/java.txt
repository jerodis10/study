- 멀티 쓰레드 프로그래밍을 개발할 때 주의해야 할 점
    - 공유 데이터를 사용하는 코드 영역인 임계구역에서 서로 다른 쓰레드가 간섭하지 않도록 쓰레드를 동기화 시켜 신뢰성 있는 데이터와 로직이
      산출(?)될 수 있게끔 코드를 작성해야합니다. 락을 거는 행위는 성능에 영향을 미치고 데드락을 유발할 수도 있으니 조심해야 합니다.

- 쓰레드를 구현하기 위한 인터페이스, 클래스
    Runnable 인터페이스를 사용하여 람다 혹은 내부크래스로 run() 메서드 구현
    새로운 클래스를 정의하고 Thread 클래스를 상속받은 후 run() 메서드 구현

    다른 클래스를 상속받지 않아도 될 때 => Thread 클래스 상속 후 구현
    Thread 클래스에 존재하는 다른 메소드들도 사용하고 싶을 때 => Thread 클래스 상속 후ㄱ 구현
    그외는 Runnable 구현

- 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object 클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다.
  이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
    - equals()란?
        - equals 메소드는 기본적으로 2개의 객체가 동일한지 검사하기 위해 사용
        - 2개의 객체가 참조하는 것이 동일한지를 확인하는 것이며, 이는 동일성(Identity)을 비교하는 것
        - 동일한 메모리 주소일 경우에만 동일한 객체가 된다.

        - 하지만 프로그래밍을 하다보면 동일한 객체가 메모리 상에 여러 개 띄워져있는 경우가 있다. 해당 객체는 서로 다른 메모리에
          띄워져있으므로 동일한(Identity) 객체가 아니다. 하지만 프로그래밍 상으로는 같은 값을 지니므로 같은 객체로 인식되어야 하는데,
          이러한 동등성(Equality)를 위해 우리는 값으로 객체를 비교하도록 equals 메소드를 오버라이딩해주는 것이다.

    - hashCode()란?
        - 실행 중에(Runtime) 객체의 유일한 integer 값을 반환
        - Object 클래스에서는 heap 에 저장된 객체의 메모리 주소를 반환하도록 되어있다. (항상 그런 것은 아니다.)
        - hashCode 는 HashTable 과 같은 자료구조를 사용할 때 데이터가 저장되는 위치를 결정하기 위해 사용된다.

    - equals 와 hashCode 의 관계
        - 동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다. 그렇기 때문에
          우리가 equals() 메소드를 오버라이드 한다면, hashCode() 메소드도 함께 오버라이드 되어야 한다.
        - Java 프로그램을 실행하는 동안 equals 에 사용된 정보가 수정되지 않았다면, hashCode 는 항상 동일한 정수값을 반환해야 한다.
          (Java 의 프로그램을 실행할 때 마다 달라지는 것은 상관이 없다.)
          두 객체가 equals()에 의해 동일하다면, 두 객체의 hashCode() 값도 일치해야 한다.
          두 객체가 equals()에 의해 동일하지 않다면, 두 객체의 hashCode() 값은 일치하지 않아도 된다.

    - hashCode() Override 의 필요성
        - hashCode 를 equals 와 함께 재정의하지 않으면 코드가 예상과 다르게 작동하는 위와 같은 문제를 일으킨다.
          정확히 말하면 hash 값을 사용하는 Collection(HashSet, HashMap, HashTable)을 사용할 때 문제가 발생
        - hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true 여야 논리적으로 같은 객체라고 판단한다.
          hashCode 메서드가 재정의 되어있지 않으면 Object 클래스의 hashCode 메서드가 사용됨
        - intellij 의 Generate 기능을 사용했더니 Objects.hash 메서드를 호출하는 로직으로 hashCode 메서드가 재정의 됐다.
          Objects.hash 메서드는 hashCode 메서드를 재정의하기 위해 간편히 사용할 수 있는 메서드이지만 속도가 느리다.
          인자를 담기 위한 배열이 만들어지고 인자 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다.
          성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제 없다.
          민감한 경우에는 직접 재정의해주는 게 좋다.

        - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode 가 서로 다른 값을 반환할 필요는 없다.
          단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.
        - HashMap 의 구현은 해시 코드가 다른 엔트리끼리는 동치성 비교 자체를 하지 않도록 최적화 되어 있다.
        - hashCode 를 만드는 해시 함수를 equals 메소드를 재정의할 때 사용한 필드와 같은 필드를 사용하자.
        - 만약 객체는 같은 해시 코드를 가지게 되면 전부 같은 버킷에 해시되므로 해시 테이블은 아주 긴 링크드 리스트가 많이 생기게 될 것
        - 해시 테이블(hash table)의 평균 시간 복잡도는 O(1)이고, 최악의 로직을 가진 해시 테이블의 시간 복잡도는 O(n) 이다.
        - 만약 이 해시 테이블이 해시 충돌(hash collision) 해결을 해시 체이닝(hash chaining) 방식으로 구현했다면,
          실제 링크드 리스트(linked list) 처럼 동작한다.

    - 만약 ORM 을 사용하고 있는 경우라면, hashCode 와 equals 를 오버라이드 하는 메소드 내부에서 Getter 를 사용하기를 권장한다.
      그 이유는 ORM 에 의해 fields 가 Lazy Loaded 되어, getter 를 부르기 전에는 사용이 불가능할 수 있기 때문이다.

    - HashMap 내부 구현
        - 해싱함수를 통해 인덱스를 산출
        - 인덱스를 통한 접근으로 시간복잡도 O(1)의 빠른 성능
        - key 는 무한하지만 인덱스는 한정되어 있어 충돌은 불가피
        - 충돌을 줄이기 위해 HashMap 은 버킷의 사이즈를 조절
        - 충돌이 일어날 시, 충돌 수가 적으면 LinkedList 방식으로 충돌된 객체들을 관리하다가 임계점을 넘으면 Red-Black Tree 방식으로
          객체들을 저장
        - https://lordofkangs.tistory.com/78

    - https://velog.io/@tamxt4047/equals-hashCode
    - https://camel-context.tistory.com/52


- StringBuilder 와 StringBuffer 의 차이는 무엇일까요?

- System.out.println 메소드는 현업에서 절대 쓰지 말라고하는 메소드인데요. 그 이유가 무엇일까요?

- ArrayList 는 내부적으로 어떻게 구현되어있을까요?

- 스레드는 왜 써야하는 것일까요?

- 0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?

- 자바에서 동시성과 관련된 예약어를 모두 말씀해주세요.

- Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.

- Serializable 은 무엇일까요?

- GC란 무엇이고, 왜 써야할까요?

- 잘 운영하고 있던 어플리케이션이 갑자기 Out of Memory Error(OOM)를 내며 프로세스가 종료되었습니다. 어떻게 대처해볼 수 있을까요?

- 서비스를 운영하면 모니터링을 해야할 일이 많은데 어떤 툴들을 사용해볼 수 있을까요?

- JIT 컴파일러란 무엇이고, 이것은 왜 필요할까요?

- 힙에 메모리를 할당하는 과정에서 어떤 일들이 벌어지나요?