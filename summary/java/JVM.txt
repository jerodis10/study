- 자바 가상 머신 JVM (Java Virtual Machine)
    - JVM 이란 무엇인가
        - 자바 프로그램 실행환경을 만들어 주는 소프트웨어
          자바 코드를 컴파일하여 .class 바이트 코드로 만들면 이 코드가 JVM 에서 실행된다.
          JVM 은 자바 실행 환경 JRE (Java Runtime Environment) 에 포함되어 있다.
          현재 사용하는 컴퓨터의 운영체제에 맞는 자바 실행 환경이 설치되어 있다면 자바 가상 머신이 설치되어 있다는 뜻.

    - 실행하는 방법
        - C언어 와 자바 컴파일 과정 차이
            - C언어
                - C/C++ 소스를 컴파일하고 나면 OS 상에서 바로 실행될 수 있는 실행 파일이 생성된다.
                  그러나 이렇게 생성된 실행 파일에는 OS에 종속적인 코드가 있으며, OS가 바뀌면 다시 소스를 컴파일하고 링크해야 한다.
            - java
                - 링크 과정 없이 컴파일러가 바로 바이트코드를 생성
                  이렇게 생성된 바이트 코드는 각자의 플랫폼에 설치되어 있는 자바 가상 머신(JVM)이 운영체제에 맞는 실행 파일로 바꿔준다.
                  컴파일된 클래스파일(바이트코드)이 JVM 에서 실행되어 OS에 종속적인 코드를 갖지 않으므로 OS가 달라져도 다시 컴파일할 필요없이 OS에 맞는 JVM 만 설치하면 된다.
                -> Java 는 플랫폼에 종속적이지 않지만 JVM 은 플랫폼에 종속적이다.

    - 바이트코드란 무엇인가
        - 바이트코드란 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법.
          흔히 코드를 작성하는 파일인 .java 파일을 컴파일 후 생기는 .class 파일 안의 내용.
        - JVM 안에서
          .class 파일에 대한 interpret 이 수행이 되는데, 소스 코드 전체를 한번에 번역하는 컴파일러와는 달리 소스 코드를 한 행씩
          중간 코드를 변역 후 실행한다. OS에 독립적인 장점을 얻었지만 중간과정이 추가됨으로써 느리다는 비판을 받아왔지만
          JIT Compiler 가 등장함으로써 한계를 극복.

    - JIT Compiler
        - JVM 은 바이트코드를 명령어 단위로 읽어서 해석하는데, Interpreter 방식과 JIT 컴파일 방식 두 가지 방식을 혼합하여 사용합니다.
          Interpreter 방식은 바이트코드를 한 줄씩 해석, 실행하는 방식입니다. 초기 방식으로, 속도가 느리다는 단점이 있습니다.
          이렇게 느린 속도를 보완하기 위해 나온 것이 JIT(Just In Time) 컴파일 방식입니다.
        - 바이트코드를 JIT 컴파일러를 이용해 프로그램을 실제 실행하는 시점(바이트코드를 실행하는 시점)에 각 OS에 맞는 Native Code 로 변환하여 실행 속도를 개선하였습니다.
          하지만, 바이트코드를 Native Code 로 변환하는 데에도 비용이 소요되므로, JVM 은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고,
          인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 컴파일 방식으로 명령어를 실행합니다.
        - 또한, JIT 컴파일러는 같은 코드를 매번 해석하지 않고, 실행할 때 컴파일을 하면서 해당 코드를 캐싱해버립니다. 이후에는 바뀐 부분만 컴파일하고, 나머지는 캐싱된 코드를 사용합니다.

        - JDK > JRE > JVM > JIT

    - JVM 구성 요소
        - ClassLoader System
            - 자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 런타임에서야 모든 코드가 자바 가상 머신과 연결된다.
              이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 클래스 로더.
            - 클래스 로더는 .class 파일을 묶어서 JVM 이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Area 로 적재.

            - Runtime 시점에 Runtime Data Area 의 Method Area 에 .class 파일들을 검사 후 로드하고 링크를 통해 배치하는 작업을 수행

        - Runtime Data Area
            - 런타임 데이터 영역은 JVM 의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역.
            - OS가 관리하는 메인메모리인 RAM 의 일부 영역을 JVM 이 필요한 만큼 OS 로부터 할당받는다. OS 로부터 받은 메모리 공간을
              Runtime Data Area 라고 부르며 5개의 영역으로 용도별로 나누어서 관리한다.
                - 모든 스레드가 공유해서 사용 (GC의 대상)
                    - 힙 영역 (Heap Area)
                        - new 키워드로 생성된 객체와 배열이 생성되는 영역
                        - 주기적으로 GC가 제거하는 영역
                    - 메서드 영역(Method Area)
                        - 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보와 같은 각종 필드 정보들과 메서드 정보 등이 생성되는 영역
                - 스레드(Thread) 마다 하나씩 생성
                    - 스택 영역(Stack Area)
                        - 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값 등이 생성되는 영역
                    - PC 레지스터 (PC Register)
                        - 프로그램 카운터, 즉 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역
                    - 네이티브 메서드 스택(Native Method Stack)
                        - 자바 이외의 언어(C, C++, 어셈블리 등)로 작성된 네이티브 코드를 실행할 때 사용되는 메모리 영역

        - Execution Engine
            - 바이트 코드를 네이티브 코드로 변환시켜주고, GC 를 실행

            - Interpreter : 바이트코드 명령어를 하나씩 읽어 해석하고 실행
            - JIT Compiler : 런타임시에 JVM 과 상호작용하여 적절한 바이트코드 시퀀스를 기계어로 컴파일을 실행
            - Garbage Collector : 참조되지 않는 객체를 우선적으로 메모리에서 제거하여 메모리 공간을 확보하는
                                  Garbage Collection 을 실행시켜주는 주체

    - 자바 가상 머신(JVM)의 동작 방식
        1. 자바로 개발된 프로그램을 실행하면 JVM 은 OS 로부터 메모리를 할당합니다.
        2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트코드(.class)로 컴파일합니다.
        3. Class Loader 를 통해 JVM Runtime Data Area 로 로딩합니다.
        4. Runtime Data Area 에 로딩 된 .class 들은 Execution Engine 을 통해 해석합니다.
        5. 해석된 바이트 코드는 Runtime Data Area 의 각 영역에 배치되어 수행하며 이 과정에서 Execution Engine 에 의해 GC의 작동과 스레드 동기화가 이루어집니다.


    - JDK 와 JRE 의 차이
        - JRE
            - JVM + Java class Libraries + Java Class Loader 가 포함된다.
            - JRE 는 자바 어플리케이션을 실행하는데 필요한 요소만 들어있지 자바를 개발하는 데 필요한 툴은 포함되어 있지 않다.
        - JDK
            - JRE 뿐만 아니라 컴파일러, 디버거 등 자바 어플리케이션을 개발하는데 필요한 도구가 포함되어 있다.
            - JAVA9버전 부터는 JRE 자체가 사라졌다. (JDK 안에 다 있으니..)


- 가비지 컬렉션 (Garbage Collection)
    - 가비지 컬렉션이란?
        - 자바의 메모리 관리 방법 중의 하나로 JVM 의 Heap 영역에서 동적으로 할당했던 메모리 영역 중 필요 없게 된 메모리 영역을 주기적으로 삭제하는 프로세스

        - 장점
            - C나 C++에서는 이러한 가비지 컬렉션이 없어 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야 하는 반면
              Java 는 JVM 에 탑재되어 있는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에서 대해
              완벽하게 관리하지 않아도 되어 오롯이 개발에만 집중할 수 있다.
            - 해제된 메모리에 접근 x
            - 해제한 메모리에 재접근하는 이중 해제 x
        - 단점
            - 개발자가 메모리가 언제 해제되는지 정확하게 알 수 없다.
            - 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생한다.
               (GC를 실행하는 스레드를 제외한 모든 스레드는 작업을 멈추게 됨.)

    - 가비지 컬렉션의 대상이 되는 객체들
        - 객체들은 실질적으로 Heap 영역에서 생성되고 Method Area 이나 Stack Area 등 Root Area 에서는 Heap Area 에 생성된 객체의 주소만 참조하는 형식으로 구성됩니다.
          이렇게 생성된 Heap Area 의 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인하여 Heap Area 객체의 메모리 주소를 가지고 있는 참조 변수가
          삭제되는 현상이 발생하면 위의 그림에서의 빨간색 객체와 같이 Heap 영역에서 어디서든 참조하고 있지 않은 객체들이 발생하게 됩니다.
          이러한 객체들을 Unreachable 하다고 하며 주기적으로 가비지 컬렉터가 제거해줍니다.
          Reachable : 객체가 참조되고 있는 상태
          Unreachable  : 객체가 참조되고 있지 않은 상태 (GC의 대상이 됨)

    - GC의 대상이 되는 Heap 영역
        - Heap Area 는 효율적인 GC를 위해 위와 같이 Eden, Survival 으로 구성된 Young Generation, 그리고 Old Generation 으로 나뉩니다.

    - 가비지 컬렉션 동작 과정
        1. 객체가 처음 생성되고 Heap 영역의 Eden 에 age-bit 0으로 할당됩니다. 이 age-bit 는 Minor GC 에서 살아남을 때마다 1씩 증가하게 됩니다.
        2. 시간이 지나 Heap Area 의 Eden 영역에 객체가 다 쌓이게 되면 Minor GC가 한번 일어나게 되고 참조 정도에 따라 Survivor0 영역으로 이동하거나 회수됩니다.
        3. 계속해서 Eden 영역에는 신규 객체들이 생성됩니다. 이렇게 또 Eden 영역에 객체가 다 쌓이게 되면
           Young Generation(Eden+Survivor) 영역에 있는 객체들을 비어있는 Survival 인 Survival1 영역에 이동하고 살아남은 모든 객체들은 age 가 1씩 증가합니다.
        4. 또다시 Eden 영역에 신규 객체들로 가득 차게 되면 다시한번 minor GC가 일어나고 Young Generation(Eden+Survivor) 영역에 있는 객체들을
           비어있는 Survivor 인 Survival0으로 이동시킨 뒤 age 를 1 증가시킵니다. 이 과정을 계속 반복합니다.
        5. 이 과정을 반복하다 보면 age bit 가 특정 숫자 이상으로 되는 경우가 발생합니다. 이때 JVM 에서 설정해놓은 age bit 에 도달하게 되면
           오랫동안 쓰일 객체라고 판단하고 Old generation 영역으로 이동시킵니다. 이 과정을 프로모션(Promotion)이라고 합니다.
        6. 시간이 지나 Old 영역에 할당된 메모리가 허용치를 넘게 되면, Old 영역에 있는 모든 객체들을 검사하여 참조되지 않는 객체들을 한꺼번에 삭제하는 GC가 실행됩니다.
           이렇게 Old generation 영역의 메모리를 회수하는 GC를 Major GC 라고 합니다. 이 때 major gc 가 발생하면서 Mark And Sweep 방식을 통해 필요 없는 메모리를 비워준다.
           Major GC는 시간이 오래 걸리는 작업이고 이때 GC를 실행하는 스레드를 제외한 모든 스레드는 작업을 멈추게 됩니다. 이를 'Stop-the-World' 라 합니다.
           이 작업이 너무 잦으면 프로그램 성능에 문제가 될 수 있습니다.

        -> GC 설계자들이 어플리케이션을 분석해보니 대부분의 객체가 수명이 짧은 것을 발견. GC 도 결국 비용인데, 메모리의
           특정 부분만을 탐색하며 해제하면 더 효율적. 어차피 대다수의 객체가 금방 사라지니 Young Generation 안에서 최대한 처리되도록 함.

    - GC 알고리즘
        - GC 는 어떻게 해제할 동적 메모리 영역들을 알아서 판단할까?
            - Reference Counting
                Heap 영역에 선언된 객체들이 각각 reference count 라는 별도 숫자를 가지고 있다.
                reference count 는 몇 가지 방법으로 해당 객체에 접근할 수 있는지를 뜻함.
                해당 객체에 접근할 수 있는 방법이 하나도 없다면 즉, reference count 가 0에 다다르면 가비지 컬렉션의 대상이 됨
                Heap Space 내부에서 순환 참조 하고 있을 경우 Memory leak 이 발생
            - Mark And Sweep
                Reference Counting 의 순환 참조 문제를 해결할 수 있다.
                루트에서부터 해당 객체에 접근 가능한지를 해제의 기준으로 삼는다.
                루트부터 그래프 순회를 통해 연결된 객체들을 찾아내고 연결이 끊어진 객체들은 지우는 방식
                메모리 파편화를 막는 Compaction. Mark And Sweep 에서 Compaction 은 필수는 아님.
                자바와 자바스크립트가 Mark And Sweep 방식으로 메모리 관리를 한다.
                의도적으로 GC 를 실행시켜야 한다.
                어플리케이션 실행과 GC 실행이 병행된다.

    - GC 방식
        - Parallel GC
            - 여러 개의 쓰레드로 GC 를 실행. 이에 따라 Serial GC 보다 Stop The World 시간이 더 짧음
            - 멀티코어 환경에서 어플리케이션 처리 속도를 향상하기 위해 사용
            - Java 8 의 default GC 방식

        - G1 GC
            - G1 (가비지 퍼스트)
            - Heap 을 일정 크기의 Region 으로 잘게 나누어 어떤 영역은 Young Generation, 어떤 영역은 Old Generation 으로 활용
            - 런타임에 G1 GC 가 필요에 따라 영역별 Region 개수를 튜닝함. 그에 따라 Stop the world 를 최소화할 수 있음
            - Java 9 부터 default GC 방식

            - 전체 Old Generation 혹은 Young Generation 통째로 Compaction 을 할 필요 없고, 해당 Generation 의 일부분 Region 에 대해서만 Compaction 을 하면 된다.
            - Garbage 로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로 GC 빈도가 줄어든다.

    - JVM GC 튜닝 맛보기
        - GC 튜닝은 성능 개선의 최종 단계. 객체 생성 자체를 줄이려는 코드 레벨에서의 개선이 선행되어야 한다.
        - JVM GC 튜닝의 목표
            - Old Generation 으로 넘어가는 객체 최소화하기
            - Major GC 시간을 짧게 유지하기
            -> Major GC 를 적게 발생시키거나 빠른 시간 내에 끝내는 것이 목표
        - 한정된 Heap 영역에 Young Generation 과 Old Generation 을 각각 얼마만큼 할당하는 것이 적당한지를 판단해야 한다.
          메모리가 너무 크다면 GC 가 가끔 일어나겠지만 오래 걸릴 것이고, 메모리가 너무 작다면 GC 는 자주 일어나겠지만 금방 끝날 것.
          어플리케이션의 구조 및 특성에 따라 판단해야 함.
        - GC 튜닝 과정
            - 현재 GC 상태 모니터링하기
            - 어플리케이션 성격에 알맞은 GC 방식과 메모리 크기 설정
            - 적용하기

        - JVM 메모리 모니터링
            - JDK 설치 시 기본으로 제공되는 jstat 이라는 툴 활용 가능
            - jstat gcutil 명령어로 현재 실행중인 프로세스에 대해 gc 와 관련된 정보 확인 가능
                ex) jstat -gcutil -t 8844 1000 10
            - jstat gccapacity 명령을 통해 프로세스가 heap 영역을 얼마나 사용 중인지 정확한 수치 확인 가능
                ex) jstat -gccapacity -t 8844 1000 10


- JVM과 JRE, JDK의 차이
     - JVM : java virtual machine, 프로그램을 구동하는 실행자 역할
     - JRE : java runtime environment,  자바 프로그램을 실행할 수 있는 환경, Class Roader , Bytecode Verifier , java virtual machine
             Class Roader란 컴파일된 클래스 파일을 메모리로 로드하는 역할을 하며 Bytecode verifier 는 실행되기 직전 코드를 검증하는 역할을 하고
             JVM은 최종적으로 실행하는 역할입니다. 이렇게 3가지를 JRE라고 부릅니다.
     - JDK : java Development Kit, JDK 는 JRE 에 어떤 toolset 같은 것들이 추가된 것. 예를 들어 컴파일러
             컴파일러는 javac 명령어로 class 파일로 컴파일 할 수 있으며 디버깅 기능도 제공


- GC란 무엇이고, 왜 써야할까요?
    * Java Garbage Collection  https://d2.naver.com/helloworld/1329
    * Garbage Collection 모니터링 방법  https://d2.naver.com/helloworld/6043
    * Garbage Collection 튜닝  https://d2.naver.com/helloworld/37111

    - 힙과 스택의 참조가 끊어진 Object의 메모리를 정리하는 일을 Garbage Collection

    - 개발자가 GC 튜닝을 하는 궁극적인 목표는 무엇일까요?
        - GC 튜닝을 꼭 해야 할까?
            - GC 튜닝이 필요 없다는 이야기는 운영 중인 Java 기반 시스템의 옵션과 동작이 다음과 같다는 의미이다.
                - -Xms 옵션과 -Xmx 옵션으로 메모리 크기를 지정했다.
                - server 옵션이 포함되어 있다.
                - 시스템에 Timeout 로그와 같은 로그가 남지 않는다.
            - 다시 말하면, 메모리 크기도 지정하지 않고 Timeout 로그가 수도 없이 출력된다면 여러분의 시스템에서 GC 튜닝을 하는 것이 좋다.
            - 그런데 한 가지 꼭 명심해야 하는 점이 있다. GC 튜닝은 가장 마지막에 하는 작업이라는 것이다.

            - GC 튜닝을 하는 이유가 무엇인지 근본적인 원인을 생각해 보자. Java 에서 생성된 객체는 가비지 컬렉터(Garbage Collector)가
              처리해서 지운다. 생성된 객체가 많으면 많을수록 가비지 컬렉터가 가 처리해야 하는 대상도 많아지고, GC를 수행하는 횟수도 증가한다.
              즉, 여러분이 운영하고 만드는 시스템이 GC를 적게 하도록 하려면 객체 생성을 줄이는 작업을 먼저 해야 한다.

            - String 대신 StringBuilder 나 StringBuffer 를 사용하는 것을 생활화하는 것부터가 시작이라고 보면 된다. 그리고,
              로그를 최대한 적게 쌓도록 하는 것이 좋다. 하지만 어쩔 수 없는 현실도 있다. 경험상 XML 과 JSON 파싱은 메모리를 가장 많이 사용한다.
              아무리 String 을 최대한 사용 안 하고 Log 처리를 잘 하더라도, 10~100 MB 짜리 XML 이나 JSON 를 파싱하면 엄청난
              임시 메모리를 사용한다. 그렇다고 XML 과 JSON 을 사용하지 않기는 어렵다.

            - 만약 애플리케이션 메모리 사용도 튜닝을 많이 해서 어느 정도 만족할 만한 상황이 되었다면, 본격적으로 GC 튜닝을 시작하면 된다.
              필자는 GC 튜닝의 목적을 두 가지로 나눈다. Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 것이다.

    - G1GC 부터는 GC 튜닝에 크게 손이 가진 않는데, G1GC는 어떻게 만들었길래 개발자가 튜닝을 이전보다 덜 해도 되는걸까요?
    - 리전으로 구성된 구조가 왜 튜닝의 수고를 덜어주는걸까요?
        * https://imp51.tistory.com/entry/G1-GC-Garbage-First-Garbage-Collector-Tuning
        * https://steady-coding.tistory.com/590

        - Java process 엔진이 대용량의 실시간 처리를 요구할 때, 성능은 JVM 의 GC 시간에 의존적일 수 밖에 없다. 특히 64bit 환경에서는
          메모리 제약 사항이 없어졌다고 볼 수 있기 때문에 large heap memory 를 cleaning 하는 시간을 단축하는 것이 전체 성능을
          개선하는 중요 key 라고 할 수 있다. 전통적인 Serial, Parallel 그리고 CMS 로는 이 성능을 충족하기에는 매우 어려운 것이 현실이다.
          그렇다고 사용 JVM 인 azul 을 쓰기에도 비용의 제약사항이 있다.
        - Java 9 버전부터 기본 GC 방식으로 채택되었다.
        - 전통적인 Garbage Collector(Serial, Parallel 및 CMS)는 세개의 메모리 영역의 구조를 갖는데 비해 G1은 다른 접근 방식을 갖는다.
          G1 GC의 경우 Heap 은 같은 크기의 heap region 으로 분활하며,
          이전 Garbage Collector 와 마찬가지로 특정 region 별로 역할을 부여하여 특정한 object 만이 거주하도록 하였다.
        - 전체 Old Generation 혹은 Young Generation 통째로 Compaction 을 할 필요 없고,
          해당 Generation 의 일부분 Region 에 대해서만 Compaction 을 하면 된다.
        - Garbage 로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로 GC 빈도가 줄어든다.
        - 더 알아보면 좋을 GC의 종류 : ZGC, Shenandoah


- 컴파일러와 인터프리터 차이점


- static 메모리에 언제 적재되냐? (클래스 로더됬을때 제일처음에)


- java 7과 8에서 jvm이 바뀐 것


- 현재 서비스에 사용하는 GC알고리즘은? GC알고리즘에 대해 아는대로 말해주세요

- GC에 대해 설명

- GC 옵션 아는 것들 설명

- 서버 메모리를 충분히 늘렸는데 그래도 메모리가 부족하다면 어떤 GC 옵션을 주면 될까?