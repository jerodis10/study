- 자바 가상 머신 JVM (Java Virtual Machine)
    - JVM 이란 무엇인가
        - 자바 프로그램 실행환경을 만들어 주는 소프트웨어
          자바 코드를 컴파일하여 .class 바이트 코드로 만들면 이 코드가 JVM 에서 실행된다.
          JVM 은 자바 실행 환경 JRE (Java Runtime Environment) 에 포함되어 있다.
          현재 사용하는 컴퓨터의 운영체제에 맞는 자바 실행 환경이 설치되어 있다면 자바 가상 머신이 설치되어 있다는 뜻.

    - 실행하는 방법
        - C언어 와 자바 컴파일 과정 차이
            - C언어
                - C/C++ 소스를 컴파일하고 나면 OS 상에서 바로 실행될 수 있는 실행 파일이 생성된다.
                  그러나 이렇게 생성된 실행 파일에는 OS에 종속적인 코드가 있으며, OS가 바뀌면 다시 소스를 컴파일하고 링크해야 한다.
            - java
                - 링크 과정 없이 컴파일러가 바로 바이트코드를 생성
                  이렇게 생성된 바이트 코드는 각자의 플랫폼에 설치되어 있는 자바 가상 머신(JVM)이 운영체제에 맞는 실행 파일로 바꿔준다.
                  컴파일된 클래스파일(바이트코드)이 JVM 에서 실행되어 OS에 종속적인 코드를 갖지 않으므로 OS가 달라져도
                  다시 컴파일할 필요없이 OS에 맞는 JVM 만 설치하면 된다.
                -> Java 는 플랫폼에 종속적이지 않지만 JVM 은 플랫폼에 종속적이다.

    - JIT Compiler
        인터프리터는 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행
        JIT Compiler Interpreter의 단점을 보완하기 위해 도입된 방식으로 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여
        Native Code로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드로 직접 실행하는 방식
        하나씩 인터프리팅하여 실행하는 것이 아니라, 컴파일된 네이티브 코드를 실행하는 것이기 때문에 전체적인 실행 속도는 인터프리팅 방식보다 빠르다.
        하지만 바이트코드를 Native Code로 변환하는 데에도 비용이 소요되므로, JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고
        인터프리터 방식을 사용하다 일정 기준이 넘어가면 JIT 컴파일 방식으로 명령어를 실행하는 식으로 진행한다.

        - JDK > JRE > JVM > JIT

    - JVM 구성 요소
        - ClassLoader System
            - JVM 내로 클래스 파일(*.class)을 동적으로 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
            - 즉, 로드된 바이트 코드(.class)들을 엮어서 JVM의 메모리 영역인 Runtime Data Area에 배치한다.
            - 클래스를 메모리에 올리는 로딩 기능은 한번에 메모리에 올리지 않고, 어플리케이션에서 필요한 경우 동적으로 메모리에 적재하게 된다.

        - Runtime Data Area
            - 런타임 데이터 영역은 JVM 의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역.
            - OS가 관리하는 메인메모리인 RAM 의 일부 영역을 JVM 이 필요한 만큼 OS 로부터 할당받는다. OS 로부터 받은 메모리 공간을
              Runtime Data Area 라고 부르며 5개의 영역으로 용도별로 나누어서 관리한다.
                - 모든 스레드가 공유해서 사용 (GC의 대상)
                    - 힙 영역 (Heap Area)
                        - JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역
                        - new 연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입 등 Reference Type이 저장되는 곳
                        - 가비지 컬렉션에 대상이 되는 공간
                    - 메서드 영역(Method Area)
                        - JVM이 시작될 때 생성되는 공간으로 바이트 코드(.class)를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간
                        - JVM이 동작하고 클래스가 로드될 때 적재되서 프로그램이 종료될 때까지 저장 된다.
                        - Class Area 나 Static Area 로도 불리운다.
                        - 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보와 같은 각종 필드 정보들과 메서드 정보 등이 생성되는 영역
                - 스레드(Thread) 마다 하나씩 생성
                    - 스택 영역(Stack Area)
                        - int, long, boolean 등 기본 자료형을 생성할 때 저장하는 공간으로, 임시적으로 사용되는 변수나 정보들이 저장되는 영역
                        - 메서드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성되고 메서드 안에서 사용되는 값들을 저장하고,
                          호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.
                          그리고 메서드 수행이 끝나면 프레임별로 삭제된다.
                        - [ 스택 프레임(stack frame) ]
                          메소드가 호출될 때마다 프레임이 만들어지며, 현재 실행중인 메소드 상태 정보를 저장하는 곳이다
                          메서드 호출 범위가 종료되면 스택에서 제거된다.
                          스택 프레임에 쌓이는 데이터는 메서드의 매개변수, 지역변수, 리턴값, 연산시 결과값 등이 있다.
                    - PC 레지스터 (PC Register)
                        - 쓰레드가 시작될 때 생성되며, 현재 수행중인 JVM 명령어 주소를 저장하는 공간
                        - JVM 명령의 주소는 쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 가지고 있다.
                    - 네이티브 메서드 스택(Native Method Stack)
                        - 자바 코드가 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
                        - 자바 이외의 언어(C, C++, 어셈블리 등)로 작성된 네이티브 코드를 실행할 때 사용되는 메모리 영역

        - Execution Engine
            - 실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다.
            - 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다.
            - 이 수행 과정에서 실행 엔진은 인터프리터와 JIT 컴파일러 두 가지 방식을 혼합하여 바이트 코드를 실행한다.

            - Interpreter : 바이트코드 명령어를 하나씩 읽어 해석하고 실행
            - JIT Compiler : 런타임시에 JVM 과 상호작용하여 적절한 바이트코드 시퀀스를 기계어로 컴파일을 실행
            - Garbage Collector : 참조되지 않는 객체를 우선적으로 메모리에서 제거하여 메모리 공간을 확보하는
                                  Garbage Collection 을 실행시켜주는 주체

    - 자바 가상 머신(JVM)의 동작 방식
        1. 자바로 개발된 프로그램을 실행하면 JVM 은 OS 로부터 메모리를 할당합니다.
        2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트코드(.class)로 컴파일합니다.
        3. Class Loader 를 통해 JVM Runtime Data Area 로 로딩합니다.
        4. Runtime Data Area 에 로딩된 .class 들은 Execution Engine 을 통해 해석합니다.
        5. 해석된 바이트 코드는 Runtime Data Area 의 각 영역에 배치되어 수행하며 이 과정에서 Execution Engine 에 의해
           GC의 작동과 스레드 동기화가 이루어집니다.


- 가비지 컬렉션 (Garbage Collection)
    - 가비지 컬렉션이란?
        - 자바의 메모리 관리 방법 중의 하나로 JVM 의 Heap 영역에서 동적으로 할당했던 메모리 영역 중 필요 없게 된 메모리 영역을 주기적으로 삭제하는 프로세스

        - 장점
            - C나 C++에서는 이러한 가비지 컬렉션이 없어 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야 하는 반면
              Java 는 JVM 에 탑재되어 있는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에서 대해
              완벽하게 관리하지 않아도 되어 오롯이 개발에만 집중할 수 있다.
            - 해제된 메모리에 접근 x
            - 해제한 메모리에 재접근하는 이중 해제 x
        - 단점
            - 개발자가 메모리가 언제 해제되는지 정확하게 알 수 없다.
            - 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생한다. Stop-The-World

    - 가비지 컬렉션의 대상이 되는 객체들
        - 객체들은 실질적으로 Heap 영역에서 생성되고 Method Area 이나 Stack Area 등 Root Area 에서는 Heap Area 에 생성된 객체의 주소만 참조하는 형식으로 구성됩니다.
          이렇게 생성된 Heap Area 의 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인하여 Heap Area 객체의 메모리 주소를 가지고 있는 참조 변수가
          삭제되는 현상이 발생하면 위의 그림에서의 빨간색 객체와 같이 Heap 영역에서 어디서든 참조하고 있지 않은 객체들이 발생하게 됩니다.
          이러한 객체들을 Unreachable 하다고 하며 주기적으로 가비지 컬렉터가 제거해줍니다.
          Reachable : 객체가 참조되고 있는 상태
          Unreachable  : 객체가 참조되고 있지 않은 상태 (GC의 대상이 됨)

    - GC의 대상이 되는 Heap 영역
        객체는 대부분 일회성되며, 메모리에 오랫동안 남아있는 경우는 드물다.
        이러한 특성을 이용해 JVM 개발자들은 보다 효율적인 메모리 관리를 위해,
        객체의 생존 기간에 따라 물리적인 Heap 영역을 나누게 되었고 Young 과 Old 총 2가지 영역으로 설계하였다.

        Heap Area 는 효율적인 GC를 위해 위와 같이 Eden, Survival 으로 구성된 Young Generation, 그리고 Old Generation 으로 나뉩니다.
        Young Generation : 생명 주기가 짧은 객체를 GC 대상으로 하는 영역.
        Eden : new를 통해 새로 생성된 객체가 위치. 정기적인 쓰레기 수집 후 살아남은 객체들은 Survivor로 이동
        Survivor 0 / Survivor 1 : 각 영역이 채워지게 되면, 살아남은 객체는 비워진 Survivor로 순차적으로 이동
        Old Generation : 생명 주기가 긴 객체를 GC 대상으로 하는 영역. Youn Generation에서 마지막까지 살아남은 객체가 이동

    - 가비지 컬렉션 청소 방식
        가비지 컬렉션(GC)가 어떻게 Reachable과 Unreachable을 판단할 것인지, GC가 Unreachable한 객체를 어떤 방식으로 청소를 하는지 알아보자.

        Mark And Sweep
            다양한 GC에서 사용되는 객체를 솎아내는 내부 알고리즘
            가비지 컬렉션이 동작하는 아주 기초적인 청소 과정
            가비지 컬렉션이 될 대상 객체를 식별(Mark)하고 제거(Sweep)하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)을 수행하게 된다.
                Mark 과정 : 먼저 Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
                Sweep 과정 : 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거한다.
                Compact 과정 : Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다.
                              (가비지 컬렉터 종류에 따라 하지 않는 경우도 있음)
            이렇게 Mark And Sweep 방식을 사용하면 루트로부터 연결이 끊긴 순환 참조되는 객체들을 모두 지울수 있다.

    - 가비지 컬렉션 동작 과정
        1. 처음 생성된 객체는 Young Generation 영역의 일부인 Eden 영역에 위치
        2. 객체가 계속 생성되어 Eden 영역이 꽉차게 되고 Minor GC가 실행
        3. Mark 동작을 통해 reachable 객체를 탐색
        4. Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동
        5. Eden 영역에서 사용되지 않는 객체(unreachable)의 메모리를 해제(sweep)
        6. 살아남은 모든 객체들은 age값이 1씩 증가 (age 값이란 Survivor 영역에서 객체의 객체가 살아남은 횟수를 의미)
        7. 또다시 Eden 영역에 신규 객체들로 가득 차게 되면 다시한번 minor GC 발생하고 mark 한다
        8. marking 한 객체들을 비어있는 Survival 1으로 이동하고 sweep
        9. 다시 살아남은 모든 객체들은 age가 1씩 증가
        10. 이러한 과정을 반복
        11. 객체의 age가 임계값(여기선 8로 설정)에 도달하게 되면, 이 객체들은 Old Generation 으로 이동된다. 이를 promotion 이라 부른다.
        12. 위의 과정이 반복되어 Old Generation 영역의 공간(메모리)가 부족하게 되면 Major GC가 발생되게 된다.

        Major GC는 Old 영역은 데이터가 가득 차면 GC를 실행하는 단순한 방식이다.
        Old 영역에 할당된 메모리가 허용치를 넘게 되면, Old 영역에 있는 모든 객체들을 검사하여 참조되지 않는 객체들을 한꺼번에 삭제하는 Major GC가 실행되게 된다.
        하지만 Old Generation은 Young Generation에 비해 상대적으로 큰 공간을 가지고 있어, 이 공간에서 메모리 상의 객체 제거에 많은 시간이 걸리게 된다.
        예를들어 Young 영역은 일반적으로 Old 영역보다 크키가 작기 때문에 GC가 보통 0.5초에서 1초 사이에 끝난다.
        그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지 않는다.
        하지만 Old 영역의 Major GC는 일반적으로 Minor GC보다 시간이 오래걸리며, 10배 이상의 시간을 사용한다.
        바로 여기서 Stop-The-World 문제가 발생하게 된다.
        Major GC가 일어나면 Thread가 멈추고 Mark and Sweep 작업을 해야 해서 CPU에 부하를 주기 때문에 멈추거나 버벅이는 현상이 일어나기 때문이다.
        따라서 자바 개발진들은 끊임 없이 가비지 컬렉션 알고리즘을 발전 시켜왔다.
        또한 GC 튜닝이 필요한 이유이다.

    - GC 알고리즘
        JVM이 메모리를 자동으로 관리해주는 것은 개발자의 입장에서 상당한 메리트이다.
        하지만 문제는 GC를 수행하기 위해 Stop The World가 발생되고 이 때문에 애플리케이션이 중지되는 문제점이 발생하게 됬다.
        또한 자바가 발전됨에 따라 Heap의 사이즈가 커지면서 애플리케이션의 지연(Suspend) 현상이 두드러지게 되었고,
        이를 최적화 위해 다양한 Garbage Collection(가비지 컬렉션) 알고리즘이 개발 되었다.

        - Serial GC
            서버의 CPU 코어가 1개일 때 사용하기 위해 개발된 가장 단순한 GC
            GC를 처리하는 쓰레드가 1개 (싱글 쓰레드) 이어서 가장 stop-the-world 시간이 길다
            Minor GC 에는 Mark-Sweep을 사용하고, Major GC에는 Mark-Sweep-Compact를 사용한다.
            보통 실무에서 사용하는 경우는 없다 (디바이스 성능이 안좋아서 CPU 코어가 1개인 경우에만 사용)

        - Parallel GC
            Java 8의 디폴트 GC
            Serial GC와 기본적인 알고리즘은 같지만, Young 영역의 Minor GC를 멀티 쓰레드로 수행 (Old 영역은 여전히 싱글 쓰레드)
            Serial GC에 비해 stop-the-world 시간 감소

        - CMS GC (Concurrent Mark Sweep)
            어플리케이션의 쓰레드와 GC 쓰레드가 동시에 실행되어 stop-the-world 시간을 최대한 줄이기 위해 고안된 GC
            단, GC 과정이 매우 복잡해짐.
            GC 대상을 파악하는 과정이 복잡한 여러단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다
            메모리 파편화 문제
            CMS GC는 Java9 버젼부터 deprecated 되었고 결국 Java14에서는 사용이 중지

        - G1 GC (Garbage First)
            Java 9+ 버전의 디폴트 GC로 지정
            기존의 GC 알고리즘에서는 Heap 영역을 물리적으로 고정된 Young / Old 영역으로 나누어 사용하였지만,
            G1 gc는 아예 이러한 개념을 뒤엎는 Region이라는 개념을 새로 도입하여 사용.
            전체 Heap 영역을 Region이라는 영역으로 체스같이 분할하여 상황에 따라 Eden, Survivor, Old 등 역할을 고정이 아닌 동적으로 부여
            Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 원리
            이전의 GC들처럼 일일히 메모리를 탐색해 객체들을 제거하지만,
            메모리가 많이 차있는 영역(region)을 인식하는 기능을 통해 메모리가 많이 차있는 영역을 우선적으로 GC 한다.

            CMS GC를 대체하기 위해 jdk 7 버전에서 최초로 release된 GC
            4GB 이상의 힙 메모리, Stop the World 시간이 0.5초 정도 필요한 상황에 사용 (Heap이 너무작을경우 미사용 권장)

        - ZGC (Z Garbage Collector)
            Java 15에 release
            G1의 Region 처럼,  ZGC는 ZPage라는 영역을 사용하며, G1의 Region은 크기가 고정인데 비해, ZPage는 2mb 배수로 동적으로 운영됨.
            (큰 객체가 들어오면 2^ 로 영역을 구성해서 처리)
            ZGC가 내세우는 최대 장점 중 하나는 힙 크기가 증가하더도 'stop-the-world'의 시간이 절대 10ms를 넘지 않는다는 것
            대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해 디자인 된 GC


- JVM 구조
    - JVM MEMORY영역에 Heap영역과 Native Memory영역에 jdk8에서 변화가 있다.

    - jdk7 vs jdk8 HEAP
        - JDK 8부터 Permanent Heap 영역이 제거되고 Metaspace 영역이 추가되었다.
        - Perm은 JVM에 의해 크기가 강제되던 영역이다.(JVM이 관리하는 영역)
        - Metaspace는 Native memory 영역으로, OS가 자동으로 크기를 조절한다.(OS 판단하여 메모리를 조절)
        - 메모리에서의 영역확보의 상한을 크게 인식할 필요가 없게 되었다.

    - Perm영역의 역할은
        - Perm 영역은 보통 Class의 Meta 정보나 Method의 Meta 정보,
        - Static 변수와 상수 정보들이 저장되는 공간으로 흔히 메타데이터 저장 영역이라고도 한다.
        - 이 영역은 Java 8 부터는 Native 영역으로 이동하여 Metaspace 영역으로 변경되었다.
        - 기존 Perm 영역에 존재하던 Static Object는 Heap 영역으로 옮겨져서 GC의 대상이 최대한 될 수 있도록 하였다.


- 바이트코드란 무엇인가 ??
    - 바이트코드란 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법.
      흔히 코드를 작성하는 파일인 .java 파일을 컴파일 후 생기는 .class 파일 안의 내용.
    - JVM 안에서
      .class 파일에 대한 interpret 이 수행이 되는데, 소스 코드 전체를 한번에 번역하는 컴파일러와는 달리 소스 코드를 한 행씩
      중간 코드를 변역 후 실행한다. OS에 독립적인 장점을 얻었지만 중간과정이 추가됨으로써 느리다는 비판을 받아왔지만
      JIT Compiler 가 등장함으로써 한계를 극복.


- GC 옵션
    - Xms  ->  JVM 시작 시 힙 영역 크기
    - Xmx  ->  최대 힙 영역 크기
    - XX:NewRatio  ->  New 영역과 Old 영역의 비율
    - XX:NewSize  ->  New 영역의 크기
    - XX:SurvivorRatio  ->  Eden 영역과 Survivor 영역의 비율
    - XX:+Use~~  -> GC 방식
        - XX:G1HeapRegionSize  ->  G1GC에서 사용하는 Region 별도 지정
        - XX:MaxGcPauseMillis  ->  최대 GC Pause 시간에 대한 목표치 설정
        - XX:initiatingHeapOccupancyPercent  ->  Concurrent GC를 시작하는 메모리 사용량 비율 지정

    이 중에서 가장 자주 사용되는 옵션은 -Xms, -Xmx, -XX:NewRatio 옵션이다.
    특히 -Xms과 -Xmx는 필수로 지정해야 하는 옵션이다. 그리고 NewRatio 옵션을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생한다.


- 컴파일러와 인터프리터 차이점

- static 메모리에 언제 적재되냐? (클래스 로더됬을때 제일처음에)

- java 7과 8에서 jvm이 바뀐 것

- 현재 서비스에 사용하는 GC알고리즘은? GC알고리즘에 대해 아는대로 말해주세요

- GC에 대해 설명

- GC 옵션 아는 것들 설명

- 서버 메모리를 충분히 늘렸는데 그래도 메모리가 부족하다면 어떤 GC 옵션을 주면 될까?

- 바이트코드란 무엇인가 ??

- 가상 컴퓨터 ??
