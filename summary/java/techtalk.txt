- 추상클래스/인터페이스
    1. Java 8 이후의 Interface 의 특징
    2. Interface 를 써야 하는 이유
    3. Skeletal Implementation 이란
    4. Interface 사용시 주의점


    1. Java 8 이후의 Interface 의 특징
        - 인스턴스를 생성할 수 없고 상수만 가질 수 있다.
        - 메서드 body 가 없는 추상 메서드를 가진다.
        - 디폴트 메소드, static 메서드만 가질 수 있다. (JDK 1.8 이상)
            - 디폴트 메서드
                - 인터페이스에서 메서드 body 를 가지는 메서드.
                - 반드시 override 할 필요는 없음. 접근 제어자는 public
                - 이미 작성된 인터페이스에서 기능을 추가하려고 할 때 디폴트 메서드 없이는 구현체 클래스들이 전부 override 를 해야하지만,
                  디폴트 메서드가 있다면 그런 작업 없이 하위호환이 가능

    2. Interface 를 써야 하는 이유
        - 다중 상속이 가능하다.
          ex) singer -> songWriter -> singerSongWriter 로 구현하면 다중 상속 필요 없지 않나?
              singer -> songWriter 상속 관계 때문에 songWriter 생성 시 불필요한 singer 의 메서드나 필드가 상속된다.
              즉, 독자적인 songWriter 를 생성할 수 없다.
              따라서, singer 와 songWriter 에서 가져오고 싶은 속성을 singerSongWriter 에 가져와야 한다.
              => 추상클래스만으로 표현하다보면 조합적 폭발이 발생
          * 다이아몬드 문제: 다중 상속 시, 부모 클래스에 같은 시그니처의 메서드가 있을 때 어떤 메서드를 상속받아야 하는지 판별할 수 없는 문제
                          그러나, 추상메서드는 구체적인 선언부가 없기 때문에 모호함이 발생하지 않는다.

        - 공통의 조상을 갖지 않는 두 클래스에 관계를 맺을 수 있다.
        - 사용자 입장에서는 내부적 구조에 대한 이해 없이 약속된 행위가 보장된다.
        - 추상 클래스도 이런 다형성 구현이 가능하지만, 상속관계에 있는 클래스끼리만 가능. 따라서, 인터페이스가 좀 더 유연하게 다형성 적용 가능

        - 추상 클래스 써야 할 때
            1. 굉장히 밀접하게 관련된 클래스끼리 코드를 공유해야 할 때
            2. 추상 클래스의 하위 구현체 클래스들이 공통된 필드나 메서드를 많이 공유하고, 접근제어자가 public 이 아닌 경우
            3. Non-static 혹은 non-final 의 필드로 객체의 상태를 바꿔야 하는 경우

        - 인퍼페이스 써야 할 때
            1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
            2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
            3. 다중 상속이 필요한 때

    3. Skeletal Implementation 이란
        ex) Java Collection 의 AbstractList, AbstractMap 등

        -