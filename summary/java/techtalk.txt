- 추상클래스/인터페이스
    1. Java 8 이후의 Interface 의 특징
    2. Interface 를 써야 하는 이유
    3. Skeletal Implementation 이란
    4. Interface 사용시 주의점


    1. Java 8 이후의 Interface 의 특징
        - 인스턴스를 생성할 수 없고 상수만 가질 수 있다.
        - 메서드 body 가 없는 추상 메서드를 가진다.
        - 디폴트 메소드, static 메서드만 가질 수 있다. (JDK 1.8 이상)
            - 디폴트 메서드
                - 인터페이스에서 메서드 body 를 가지는 메서드.
                - 반드시 override 할 필요는 없음. 접근 제어자는 public
                - 이미 작성된 인터페이스에서 기능을 추가하려고 할 때 디폴트 메서드 없이는 구현체 클래스들이 전부 override 를 해야하지만,
                  디폴트 메서드가 있다면 그런 작업 없이 하위호환이 가능

    2. Interface 를 써야 하는 이유
        - 다중 상속이 가능하다.
          ex) singer -> songWriter -> singerSongWriter 로 구현하면 다중 상속 필요 없지 않나?
              singer -> songWriter 상속 관계 때문에 songWriter 생성 시 불필요한 singer 의 메서드나 필드가 상속된다.
              즉, 독자적인 songWriter 를 생성할 수 없다.
              따라서, singer 와 songWriter 에서 가져오고 싶은 속성을 singerSongWriter 에 가져와야 한다.
              => 추상클래스만으로 표현하다보면 조합적 폭발이 발생
          * 다이아몬드 문제: 다중 상속 시, 부모 클래스에 같은 시그니처의 메서드가 있을 때 어떤 메서드를 상속받아야 하는지 판별할 수 없는 문제
                          그러나, 추상메서드는 구체적인 선언부가 없기 때문에 모호함이 발생하지 않는다.

        - 공통의 조상을 갖지 않는 두 클래스에 관계를 맺을 수 있다.
        - 사용자 입장에서는 내부적 구조에 대한 이해 없이 약속된 행위가 보장된다.
        - 추상 클래스도 이런 다형성 구현이 가능하지만, 상속관계에 있는 클래스끼리만 가능. 따라서, 인터페이스가 좀 더 유연하게 다형성 적용 가능

        - 추상 클래스 써야 할 때
            1. 굉장히 밀접하게 관련된 클래스끼리 코드를 공유해야 할 때
            2. 추상 클래스의 하위 구현체 클래스들이 공통된 필드나 메서드를 많이 공유하고, 접근제어자가 public 이 아닌 경우
            3. Non-static 혹은 non-final 의 필드로 객체의 상태를 바꿔야 하는 경우

        - 인퍼페이스 써야 할 때
            1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
            2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
            3. 다중 상속이 필요한 때

    3. Skeletal Implementation 이란
        ex) Java Collection 의 AbstractList, AbstractMap 등

        - 추상 골격 클래스는 private, protected 가 가능하므로 override 한 메서드의 내부 메서드들을 클라이언트가 접근하지 못하도록
          막을 수 있다. 그러나, 직접 interface 를 구현하게 되면 접근 제어자가 모두 public 이기 때문에 이와 같은 은닉이 힘들다.
          또한 디폴트 메서드에서는 하위 구현체 클래스에 대한 상태, 즉 필드에 대한 참조가 이루어질 수 없다.

        - 디폴트 메서드의 도입 원인을 생각하면, 이미 존재하는 인터페이스의 하위 호환성을 위해서이다.
          따라서, 새로 인터페이스를 만드는 시점에서 디폴트 메서드를 쓴다면 디폴트 메서드 도입 취지와는 맞지 않다.

    4. Interface 사용시 주의점
        ex) Java 8에서 Collection 에 추가된 removeIf 디폴트 메서드
        - 멀티 쓰레드 환경인 SynchronizedCollection 에서는?
            - 런타임 에러 -> removeIf 를 override 하자 (lock 을 설정하여)
                        -> 원래의 디폴트 메서드를 목적에 맞게 재정의해서 해결

        - 디폴트 메서드 override 시 다이아몬드 문제가 일어나지 않나?
            - 디폴트 메서드 다중 상속 시, 약간의 우선순위로 해결
                1. 구현하는 클래스나 슈퍼클래스
                2. 상속받는 인터페이스
                3. 명시적 사용

        => 디폴트 메서드는 런타임 에러를 일으킬 수 있다.
           이미 구현된 인터페이스에 디폴트 메서드를 추가하는 것은 신중히 해야 한다.
           디폴트 메서드를 추가하려면 릴리즈 전에 반드시 테스트를 거쳐야 한다.

- stream vs for
    - for 문
        - java 1부터 지원
        - for (초기화; 조건; 후처리)

    - 향상된 for 문
        - java 5부터 지원
        - 가독성 up, 안정성 up

    - stream
        - java 8부터 지원
        - stream 생성 -> 중간 연산 -> 최종 연산

    - 둘 다 다량의 데이터 처리 작업에 사용

    - 차이점
        - 함수 객체 vs 코드 블럭
            - for 문은 코드 블록으로 표현
            - 스트림 파이프라인은 함수 객체로 표현 (람다 or 메서드 참조)
            -> 람다식에는 final 변수만 읽을 수 있기 때문에 지역 변수를 수정할 수 없다.
            -> for 문에서는 할 수 있는 continue, break 로직은 stream 에서는 할 수 없다.

        - 외부 반복 (how) vs 내부 반복 (what)
            - 외부 반복: for 문, 구체적인 구현 로직이 외부에 노출
            - 내부 반복: stream, 로직이 노출되지 x

        - 가독성
            ex) for 문의 경우 if 문의 중첩으로 인해 indent depth 가 깊어져 가독성이 떨어질 수 있으나
                stream 의 경우, 조건들을 filter 의 체이닝 형식을 통해 표현할 수 있기 때문에 보다 간결한 표현 가능

            ex) if 문의 중첩 만 있을 경우, 메서드 추출을 통해서 충분히 indent depth 를 줄여 가독성을 높일 수 있었음.
                하지만, for 문으로 요소를 순회하면서 return 을 하는 경우에는 메서드 추출을 통해 indent depth 를
                줄이는 것이 어려움.
                이런 경우, stream 을 이용하면 depth 를 줄여 가독성을 높일 수 있음.

            - 상황에 따라 stream 이 더 가독성이 안 좋을 수도 있음.

        - 디버깅
            - stream 은 많은 내부 수행 작업과 지연 연산으로 인해 디버깅이 다소 어려울 수 있다.
            - for 문은 예외가 발생하는 stack trace 가 간결하게 출력되서 디버깅에 유리할 수 있다.

        - 병렬 처리
            - for 문의 경우, Runnable 등을 활용해 병렬 처리를 위한 코드를 일일이 작성해야 함.
              로직이 복잡해질 경우 직접 구현하기도 까다롭고 신경쓸 것도 많아짐
              데이터들을 몇 개로 어떻게 나눌 것인지, 혹은 발생할 수 있는 동시성 문제가 있는지를 고려해야 한다.
            - stream 을 이용하면 위의 내용들을 stream 이 내부적으로 처리해 주기 때문에 보다 쉽게 병렬 처리 표현 가능

        - 성능
            - int 배열에서 for 문이 stream 보다 빠른 이유
                - for 는 나온지 오래된 만큼 stream 에 비해 JVM 에서 최적화가 충분히 이루어졌다.

                - stream 을 사용하려면 stream 객체를 생성해야 한다.
                  이 생성 과정에서 여러 작업들이 이루어지고 stream 에서 필요한 다른 객체를 생성하는데 오버헤드가 발생
                - for 는 추가적인 객체 생성 없이 인덱스를 통해서 메모리에 직접 접근을 하기 때문에
                  stream 에 비해 오베헤드가 발생하지 않는다.

            - 향상된 for 문에서는 원시타입 배열에 어떻게 접근 할까?
                - 향상된 for 문에서는 컬렉션을 순회할 때와 마찬가지로 iterator 를 이용할 것이라고 예상할 수 있지만
                  원시타입 배열이 들어온 경우에는 iterator 가 아닌 전통 for 문의 형식으로 바꾸어서 순회.
                  따라서 int 배열에 대한 작업에서는 전통 for 문과 향상된 for 문이 비슷한 성능을 보임

            - List 에서 성능 차이가 미미한 이유
                - int 배열은 요소들이 원시타입인 반면 컬렉션은 Wrapper 타입이 들어오게 된다.
                  그래서 박싱 및 언박싱에 대한 오버헤드가 발생한다. 이 오버헤드는 충분히 크기 때문에
                  컬렉션에 대한 성능은 이 오버헤드에 지배되면서 큰 성능 차이를 보이지 못함.

            => 하지만, 오늘날의 하드웨어는 충분히 빠르기 때문에 소프트웨어에서는 성능보다는 다른 점들을 더욱 신경쓰는 추세.
               유지보수, 가독성 등을 고려하는 것이 더욱 좋을 수 있음.

    - 결론
        - 가독성
            - 추상화된 api 를 제공하고, 보다 What 중심의 코드를 작성할 수 있어 가독성이 더 좋을 수 있다. (개인 차이 존재)

        - 디버깅
            - for 문에 비해 stream 이 디버깅이 어렵다.

        - 병렬 처리
            - 비교적 stream 을 이용한 병렬 처리가 간단하다.

        - 성능
            - for 문이 성능이 더 좋을 수 있다.

        - 스트림을 적용하기 좋은 조건
            - 원소들의 시퀀스를 일관되게 변환한다.
            - 원소들의 시퀀스를 필터링 한다.
            - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.
            - 원소들의 시퀀스를 컬렉션에 모은다.
            - 원소들의 시퀀스를 특정 조건을 만족하는 원소를 찾는다.

        => 어느 하나가 절대적으로 좋은 것이 아닌 각각의 장단점이 있다.
           따라서, 차이를 인지하고 이를 적절히 사용하는 것이 바람직하다.