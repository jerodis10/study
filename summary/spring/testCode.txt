- 테스트
    - Rest-assured 와 Spring MVC Test Integration 을 이용해서 HTTP API 를 통합 테스트

    유지보수 기간의 생산성을 높여주고 새로 프로젝트에 투입될 사람에게도 이득을 주는 테스트
    프로젝트 오픈 일정 직전까지의 코드 변경과 버그 발견에 도움을 주는 테스트
    오늘 당장 프로그램을 목표한 곳까지 작성하는 일을 더 빨리 마치게 해주는 테스트

    실제로 테스트로 인한 긍정적인 경험을 쌓아가다 보면 더 넓은 범위와 다양한 기법으로 테스트 코드를 작성하는데 동기유발이 됩니다.

    처음에는 테스트가 쉬운 Utility 클래스에 대한 테스트부터 작성했습니다. 전에도 간단한 유틸리티에 대한 테스트는 main 메서드 안에서 하기도 했는데,
    그런 코드를 JUnit 안으로 옮기니 반복해서 실행하고 결과를 확인하기에 훨씬 편해졌습니다. 그 이후에는 Spring framework 의 통합테스트 기능을
    이용한 테스트를 작성하기 시작했습니다. 특히 테스트 코드에서 DB에 입력한 데이터를 자동으로 롤백시키는 기능이 DB와 연동된 테스트를 할 때 유용했었습니다.
    이후에 더 정교한 테스트를 하려다 보니 테스트용 객체를 만드는 프레임워크인 Mockito 를 사용하게 되었습니다. 테스트 코드를 먼저 작성하는 기법도 사용할 수 있게 되었습니다.

    - 왜 Test 코드를 작성하는가?
     https://dingdingmin-back-end-developer.tistory.com/entry/Springboot-Test-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-1
     https://mangkyu.tistory.com/242
        - Test 코드를 작성하지 않고 결과를 검증하는 과정은 비용이 많이 든다.
            - Test 코드 사용 X
                검증 코드 작성
                애플리케이션 실행
                PostMan 혹은 브라우저 Request 요청
                log 혹은 print 로 결과 검증
                원하지 않는 결과 발생 시 애플리케이션 종료
                다시 코드 작성
            - Test 코드를 사용
                Test 코드 작성
                Test 코드 실행
                결과 검증
                Test 코드 수정
                -> 애플리케이션을 실행, 종료할 필요가 없습니다. 따라서 비용이 줄어들고, Test 코드를 통해서 명확한 결과 검증이 가능합니다.

        - Spring 은 계층 구조로 일반적으로 아래와 같이 구성돼 있습니다.
            Controller : 클라이언트 요청을 받고 클라이언트에게 결과를 반환 (Presentation Layer)
            Service : 비즈니스 로직을 실행하고 결과 반환(Service Layer)
            Repository : database 에 쿼리를 이용해서 CRUD 를 하는 계층(Data Access Layer)
            Domain : Entity 클래스

            -> 그렇기에 애플리케이션을 실행해서 Test 를 진행한다면, 어느 계층에서 잘못된 코드가 있는지 파악하는데 많은 비용이 듭니다.
             하지만 Test 코드를 통해서 계층별로 Test 를 진행한다면 어느 부분이 잘못된 지 파악을 쉽게 할 수 있습니다.

    - SpringBoot Test
        - Spring Initializer 통해서 프로젝트를 생성하면 spring-boot-starter-test dependency 가 자동으로 추가됩니다. 저희는 이것을 이용해서 Test 코드를 작성하면 됩니다.

        - spring-boot-test-starter 구성요소
            1. spring-boot-test: 테스트에 필요한 핵심 기능 라이브러리
            2. spring-boot-test-autoconfigure: 테스트 진행 위한 Configuration 라이브러리

        - Junit 이란?
            1. Java 에서 독립된 단위 테스트를 지원해주는 프레임워크
            2. Assert(검증)을 이용해서 결과를 기댓값과 실제 값을 비교
            3. @Test 어노테이션마다 독립적으로 테스트가 진행

        - JUnit 만으로도 단위 테스트를 충분히 작성할 수 있다. 하지만 JUnit 에서 제공하는 assertEquals()와 같은 메소드는
          AssertJ가 주는 메소드에 비해 가독성이 떨어진다. 그렇기 때문에 순수 Java 애플리케이션에서 단위 테스트를 위해 JUnit5와 AssertJ 조합이 많이 사용된다.
        - @Test 는 해당 메소드가 단위 테스트임을 명시하는 어노테이션이다. JUnit 은 테스트 패키지 하위의 @Test 어노테이션이 붙은 메소드를
          단위 테스트로 인식하여 실행시킨다. 이 상태로 실행하면 테스트 이름이 함수 이름이 default 로 지정되는데, 우리는 @DisplayName 어노테이션을 사용하여 읽기 좋은 다른 이름을 부여할 수 있다.

        - 단위 테스트와 통합 테스트
            - 단위(unit) 테스트: 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위 테스트 -> 쉽게 말하면 하나의 기능 혹은 메서드라고 이해하면 됩니다.
                - 장점
                    새로운 기능에 대해서 빠르게 작성 가능
                    Test 코드 자체가 하나의 문서
                    시간과 비용의 절감
                - 단점
                    독립적인 테스트이므로 다른 객체와 상호작용 처리를 위해서 가짜 객체 정의 필요함
                    가짜 객체의 답변 작성 필요함
                    실제 운영 환경과 다른 답변을 내놓을 수 있는 가능성이 있음

            - 통합(integration) 테스트: 모듈을 통합화는 과정에서 모듈 간의 호환성을 확인하는 테스트 -> unit 이 하나였다면 반대로 여러 개의 계층이 테스트에 참여한 것이라고 생각하면 쉬울 거 같습니다.
                - 장점
                    실제 객체를 사용하므로 가짜 객체 사용하지 않아 정의하지 않아도 됨
                    실제 운영 환경과 같은 값을 도출 가능함
                - 단점
                    테스트 하나의 많은 비용이 들어감
                    어느 계층에서 발생한 문제인지 파악하기 힘듦

            -> 단위 테스트, 통합 테스트 모두 장단점이 명확합니다. 하지만 통합 테스트의 경우 비용을 절감할 수 있는 방법이 없습니다.
              단위 테스트는 단점들을 개선해 나갈 수 있습니다. 그래서 좋은 단위 테스트 작성에 대해서 알아보겠습니다.

        - 좋은 단위 테스트
            - 1개의 테스트는 1개의 기능에 대해서만 테스트
            - 테스트 주체와 협력자를 구분하기. ( 여기서 주체는 테스트를 할 객체이며, 협력자는 테스트를 진행하기 위해 정의하는 가짜 객체입니다.)
            - Given, when, then 으로 명확하게 작성하기
                Given: 테스트를 진행할 행위를 위한 사전 준비
                when: 테스트를 진행할 행위
                then: 테스트를 진행한 행위에 대한 결과 검증

        - AssertJ 라이브러리
            - Assertions 는 assertJ 라이브러리를 사용합니다. Junit jupiter 를 사용하지 않는 이유는 assertJ의 가독성이 좋기 때문입니다.
                1. assertThat 은 값 검증에 쓰입니다.
                    assertThat(실제값). isEqualTo(기댓값)
                    assertThat(실제 객체). isInstanceOf(객체 예상 타입)
                    assertThat(실제값). isNull()
                    등등 실제 값, 값의 타입을 비교하는 여러 연산자들과 쓰이는 메서드입니다.
                2. asserThatThrownBy는 예외 발생 검증에 쓰입니다.
                    asserThatThrownBy( () -> 예외를 발생시킬 로직). isInstanceOf(예외 클래스)
                    예외가 발생한다면 테스트를 통과하고 발생하지 않는다면 실패하는 메서드입니다.

        - Domain Test
            가장 단위가 작은 Member 객체에 대해서 단위 테스트입니다. 도메인에 대한 테스트가 가장 비용이 적게 듭니다.
            @Test 어노테이션이 반드시 필요하며, 반환하는 것이 없도록 void 여야 합니다.
            @DisplayName 을 통해서 테스트 진행 시 나오는 테스트명을 정할 수 있습니다.
            ex)
                Builder 를 이용해서 멤버를 생성했을 때 올바르게 생성됐는지 테스트
                Member 의 나이를 바꿨을 때 올바르게 바뀌는지 테스트

        - Jpa 를 사용하는 Repository Test
            @DataJpaTest: Jpa 를 사용하는 Repository 에 대한 검증을 수행할 때 사용하는 어노테이션입니다.
                - @DataJpaTest 는 @Transaction 을 포함하고 있어서 1개 의 테스트가 끝나면 Rollback 해 다른 테스트에게 영향을 미치지 않습니다.
                    JPA 관련된 설정만 로드한다. 그렇기 때문에 @Entity 클래스를 스캔하여 스프링 데이터 JPA 저장소를 구성한다.
                    기본적으로 인메모리 데이터베이스를 이용함.
                    데이터소스의 설정이 정상적인지, JPA 를 사용하서 데이터를 제대로 생성, 수정, 삭제하는지 등의 테스트가 가능함.
                    테스트가 끝날 때마다 자동으로 테스트에 사용한 데이터를 롤백
                - @DataJpaTest 로 검증할 수 있는 목록은 아래와 같습니다.
                    - DataSource 에 대한 설정
                    - CRUD 가 제대로 동작하는지
                - @Entity 가 있는 엔티티 클래스들을 스캔하며 테스트를 위한 TestEntityManager 를 사용해 JPA 레포지토리들을 설정해준다.
                  마찬가지로 @Component 나 @ConfigurationProperties 빈들은 스캔되지 않는다.
                - 앞서 설명하였듯 스프링은 테스트에 @Transactional 이 있으면 테스트가 끝난 후 자동으로 트랜잭션을 롤백한다.
                  @DataJpaTest 에는 @Transactional 어노테이션이 들어있어서 기본적으로 모든 테스트가 롤백된다. 만약 롤백을 원하지 않는다면 @Rollback(false)를 추가하면 된다.
                - 또한 만약 H2와 같은 내장 데이터베이스가 클래스 패스에 존재한다면 내장 데이터베이스가 자동 구성된다. spring-boot-test 의존성에는 기본적으로 H2가 들어있으므로
                  별다른 설정을 주지 않는다면 H2로 설정된다. 내장 데이터베이스로 설정되기를 원하지 않는다면 다음과 같이 AutoConfigureTestDatabase 의 replace 속성을 NONE 으로 주면 된다.
                        @AutoConfigureTestDataBase : 데이터 소스를 어떤 걸로 사용할지에 대한 설정
                            - Replace.Any : 기본적으로 내장된 데이터소스를 사용
                            - Replace.NONE : @ActiveProfiles 기준으로 프로파일이 설정됨
                        @AutoConfigurationDatabase 에 Replace.NONE 설정을 주면 실제 DB로 검증할 수 있습니다. 따로 명시하지 않을 시 내장된 임베디드 DB를 사용합니다.

            @RunWith(SpringRunner.class)
            @DataJpaTest
            @ActiveProfiles("test")
            @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
            public class BookJpaTest {

                @Autowired
                private BookRepository bookRepository;

                @Test
                public void book_save_test() {
                    final Book book = new Book("title", 1000D);
                    final Book saveBook = bookRepository.save(book);
                    assertThat(saveBook.getId(), is(notNullValue()));
                }

                @Test
                public void book_save_and_find() {
                    final Book book = new Book("title", 1000D);
                    final Book saveBook = bookRepository.save(book);
                    final Book findBook = bookRepository.findById(saveBook.getId()).get();
                    assertThat(findBook.getId(), is(notNullValue()));
                }
            }


        - Service 계층 Test
            Service 계층은 Repository 객체를 Spring 에게 주입받고 있습니다.
            따라서 Service 계층의 Test 는 주체가 Service 객체이며, 협력자는 Repository 객체입니다.
            그렇기에 Repository 는 가짜 객체로서 응답을 설정해줘야 합니다.
            Junit5 기능을 사용하고, Test 에서 가짜 객체를 사용하기 때문에 @ExtendWith(SpringExtension.class)를 붙여줘야 합니다.

            @ExtendWith(SpringExtension.class)
            public class MemberServiceTest {

                // Test 주체
                MemberService memberService;

                // Test 협력자
                @MockBean
                MemberRepository memberRepository;


                // Test를 실행하기 전마다 MemberService에 가짜 객체를 주입시켜준다.
                @BeforeEach
                void setUp(){
                    memberService = new MemberServiceImpl(memberRepository);
                }
            }

            @BeforeEach: Test 를 실행하기 전 항상 실행하도록 하는 어노테이션입니다. 여기서는 가짜 객체를 주입하는 데 사용됐습니다.
            @MockBean: 가짜 객체를 만드는 역할을 합니다. 물론 가짜 객체이므로 응답을 정의해줘야 합니다. Test 의 협력자 역할을 합니다.
            MemberService: Test 의 주체로서 가짜 객체를 주입받고, 자신의 로직을 실행하고 결과를 가지고 검증을 합니다.


            @Test
            @DisplayName("멤버 생성 성공")
            void createMemberSuccess(){
                /*
                given
                 */
                Member member3 = Member.builder().name("hi3").age(10).build();
                ReflectionTestUtils.setField(member3,"id",3l);

                Mockito.when(memberRepository.save(member3)).thenReturn(member3); // 가짜 객체 응답 정의
                /*
                when
                 */
                Long hi3 = memberService.createMember("hi3", 10);
                /*
                then
                 */
                assertThat(hi3).isEqualTo(3L);
            }

            Member 생성을 성공하는 Test 입니다.
            ReflectionTestUtils.setField() : test 를 진행하면서 private 로 선언된 필드 값을 넣어줄 수 있습니다.
            Mockito.when(가짜 객체의 로직 실행). thenReturn(실행되면 이것을 반환한다.)라고 말할 수 있습니다.


            @Test
            @DisplayName("멤버 생성시 member1 과 이름이 같아서 예외 발생")
            void createMemberFail(){
                /*
                given
                 */
                Member member1 = Member.builder().name("hi1").age(10).build();
                Mockito.when(memberRepository.findByName("hi1")).thenReturn(Optional.of(member1));

                /*
                when then
                 */
                assertThatThrownBy(() -> memberService.createMember("hi1",10)).isInstanceOf(IllegalStateException.class);
            }


        - Controller 계층
            - @WebMvcTest: Mvc 를 위한 테스트로서 컨트롤러가 설계대로 동작하는지에 대해 검증하는데 필요한 어노테이션입니다.
              아래 보이시는 것과 같이 Controller 를 구체적으로 적을 수 있고, ControllerAdvice, Filter 등을 포함과 제외시킬 수 있어
              Security 에 대한 Test 도 가능합니다.

              해당 어노테이션을 사용하면, @Controller, @ControllerAdvice, @JsonComponent 와 Filter, WebMvcConfiguer,
              HandlerMethodArgumentResolver 만 로드되기 때문에 전체 테스트보다는 가볍다. ( 물론, classes 를 이용하여 일부 빈만 등록하면 괜찮지만.... )

              내장된 서블릿 컨테이너가 랜덤 포트로 실행된다. @WebMvcTest 는 애플리케이션 컨텍스트를 만들 때 컨트롤러와 연관된 빈들만을 제한적으로 찾아서 등록한다.
              그러므로 일반적인 @Component 나 @ConfigurationProperties 빈들은 스캔되지 않는다.

              추가적인 설정이 필요하면 @Import 를 사용할 수 있고, @MockBean 이나 @SpyBean 역시 사용할 수 있다.
              또한 @WebMvcTest 는 컨트롤러 테스트이므로 @WebMvcTest 내부에 @AutoConfigureMockMvc 가 들어있다.
              그러므로 @Autowired 로 MockMvc 를 주입받을 수 있으며, 만약 웹플럭스를 이용중이라면 @WebFluxTest 를 사용하면 된다.

              @WebMvcTest 에는 특정 컨트롤러만을 빈으로 등록하도록 제한할 수 있다.

                  @WebMvcTest(UserController.class)
                  class UserControllerTest {

                  }

                  이를 통해 특정 컨트롤러만 테스트 가능하도록 하는데, 해당 컨트롤러가 의존하는 빈이 있다면 @MockBean 이나 @SpyBean 을 사용해주어야 한다.
                  문제는 이렇게 특정 컨트롤러만을 빈으로 띄우고 @MockBean 과 @SpyBean 으로 특정 빈을 바꾸는 것은 새로운 애플리케이션 컨택스트를 필요로 한다.
                  그래서 애플리케이션 컨텍스트의 수를 증가시키므로 주의해야 한다.



              @WebMvcTest(MemberController.class)
              public class MemberControllerTest {

                  @Autowired
                  MockMvc mvc;

                  @MockBean
                  MemberServiceImpl memberService;

              }

            - Test 의 주체는 MemberController 입니다. 따라서 WebMvcTest 에 선언을 해줍니다.
              MemberService 는 협력자이므로 @MockBean 을 등록해주고, Test 에 응답을 정의합니다.
              MockMvc 는 실제로 서블릿 컨테이너를 사용하지 않고, 테스트용으로 Mvc 기능을 사용할 수 있게 해주는 역할을 합니다.
              테스트 때 생성되는 WebApplicationContext 에서 주입받습니다.


            @Test
            @DisplayName("리스트 반환받기")
            void getList() throws Exception {
                /*
                given
                 */
                List<MemberResponseDto.ListDto> list = List.of(new MemberResponseDto.ListDto("asd", 10)
                        , new MemberResponseDto.ListDto("fsd", 12));
                Mockito.when(memberService.findAll()).thenReturn(list);

                /*
                when then
                 */
                mvc.perform(MockMvcRequestBuilders.get("/members").contentType(MediaType.APPLICATION_JSON))
                        .andDo(MockMvcResultHandlers.print())
                        .andExpect(MockMvcResultMatchers.status().isOk())
                        .andExpect(MockMvcResultMatchers.jsonPath("$[1].name").value("fsd"))
                        .andExpect(MockMvcResultMatchers.jsonPath("$[0].name").value("asd"));
            }

            협력자인 MemberService 의 findAll() 호출 시 반환하는 list 를 정의합니다.
            mvc.perform(MockMvcRequestBuilders.get(). contentType(): 컨트롤러에게 요청을 보내는 역할을 합니다. uri 를 만들고, contentType 을 지정합니다.
            andDo(): 요청에 대한 처리를 합니다. MockMvcResultHandler.print()를 인자로 넣었으므로 요청과 응답에 대한 것들을 콘솔에 출력해줍니다.
            andExpect(): 검증하는 로직입니다. MockMvcResultMatcher.status()는 HTTP 상태 코드를 검증하고, jsonPath 는 Json 로 넘어온 것들에 대한 값을 검증할 수 있습니다.
            jsonPath("$. name"). value("fsd"): 단일 객체에 대한 값 검증
            jsonPath("$[1]. name"). value("asd): 리스트를 반환받았을 때 지정하여 검증


        - REST 관련 테스트 - @RestClientTest
            - Rest 통신의 JSON 형식이 예상대로 응답을 반환하는지 등을 테스트 함
            - @RestClientTest : 테스트 대상이 되는 빈을 주입받음
              @Rule
              MockRestServiceServer : 클라이언트와 서버 사이의 REST 테스트를 위한 객체. 내부에서 RestTemplate 을 바인딩하여
              실제로 통신이 이루어지게끔 구성할 수 있음. 이 코드에서는 목 객체와 같이 실제 통신이 이루어지지는 않지만 지정한 경로에 예상되는 반환값을 명시함.

            @RunWith(SpringRunner.class)
            @RestClientTest(BookRestService.class)
            public class BookRestServiceTest {

                @Rule
                public ExpectedException thrown = ExpectedException.none();

                @Autowired
                private BookRestService bookRestService;

                @Autowired
                private MockRestServiceServer server;

                @Test
                public void rest_test() {

                    server.expect(requestTo("/rest/test"))
                            .andRespond(
                                    withSuccess(new ClassPathResource("/test.json", getClass()), MediaType.APPLICATION_JSON));

                    Book book = bookRestService.getRestBook();

                    assertThat(book.getId(), is(notNullValue()));
                    assertThat(book.getTitle(), is("title"));
                    assertThat(book.getPrice(), is(1000D));

                }
            }


        - Json 의 직렬화, 역직렬화 테스트 - @JsonTest
            - Gson, Jackson 의 테스트를 제공함.

            @RunWith(SpringRunner.class)
            @JsonTest
            public class BookJsonTest {

                @Autowired
                private JacksonTester<Book> json;

                @Test
                public void json_test() throws IOException {

                    final Book book = new Book("title", 1000D);

                    String content= "{\n" +
                            "  \"id\": 0,\n" +
                            "  \"title\": \"title\",\n" +
                            "  \"price\": 1000\n" +
                            "}";


                    assertThat(json.parseObject(content).getTitle()).isEqualTo(book.getTitle());

                    assertThat(json.write(book)).isEqualToJson("/test.json");
                }
            }


    - 통합 테스트
        단위 테스트와는 다르게 실제 spring 을 실행했을 때와 같은 운영환경에서 잘 동작하는지 확인하는 테스트입니다. 전체적인 플로우를 확인하므로 Spring 에 쓰이는 Bean 들이 등록됩니다.
        @SpringBootTest: 통합 테스트를 진행하기 위한 어노테이션입니다.
        (주의 @Transaction 을 포함하고 있지 않기 때문에 Repository 계층까지 사용된다면 @Transaction 도 붙여서 Rollback 을 실행해줘야 합니다.)
        스프링을 실제 띄워서 컨테이너를 띄우거나 DI를 하여 스프링과 동일한 환경에서 테스트할 수 있고, 단순 자바 코드로서 테스트가 아닌 DB 연동 등 통합 테스트에 자주 사용한다.
        @SpringBootTest 는 모든 빈들을 스캔하고 애플리케이션 컨텍스트를 생성하여 테스트를 실행한다.
        @SpringBootTest 의 어노테이션에는 다양한 값을 줄 수 있는데, 이를 살펴보면 다음과 같다.
            value 와 properties: 애플리케이션 실행에 필요한 프로퍼티를 key=value 형태로 추가할 수 있음
            args: 애플리케이션의 arguments 로 값을 전달할 수 있음
            classes: 애플리케이션을 로딩할 때 사용되는 컴포넌트 클래스들을 정의할 수 있음
            webEnvironment: 웹 테스트 환경을 설정할 수 있음
                - webEnvironment 는 enum 이며 총 4가지 값을 가지고 있는데, 각각의 기능과 특징을 정리하면 다음과 같다.
                    MOCK
                        웹 기반의 애플리케이션 컨텍스트를 생성하지만 MOCK 환경으로 제공하여 내장 서버가 시작되지 않음
                        웹 환경이 클래스패스에 없다면 웹이 아닌 애플리케이션 컨텍스트를 생성함
                        웹 기반의 Mock 테스트를 위해 @AutoConfigureMockMvc 또는 @AutoConfigureWebTestClient 와 함께 사용할 수 있음
                    RANDOM_PORT
                        웹 기반의 애플리케이션 컨텍스트를 생성하여 실제 웹 환경을 제공함
                        내장 서버도 실행되며 사용하지 않는 랜덤 포트를 listen 함
                    DEFINED_PORT
                        웹 기반의 애플리케이션 컨텍스트를 생성하고 실제 웹 환경을 제공함
                        내장 서버도 실행되며 지정한 포트(default 8080)를 listen 함
                    NONE
                        SpringApplication 로 애플리케이션 컨텍스트를 생성함
                        하지만 mock 이나 다른 것들을 포함해 어떠한 웹 환경도 제공하지 않음

                - webEnvironment 의 기본값은 MOCK 이므로 실제 웹 서버가 실행되지는 않는다. 또한 스프링은 @Transactional 이 있으면 테스트가 끝나고 트랜잭션을 롤백하는데,
                  RANDOM_PORT 나 DEFINED_PORT 를 사용하면 별도의 쓰레드에서 실제 서버가 구동되어 롤백되지 않는다. 그래서 테스트가 격리되지 않아 실패할 수 있는데,
                  이와 관련해서는 이 포스팅을 참고해 해결하도록 하자. 또한 RANDOM_PORT 나 DEFINED_PORT 를 사용하면 TestRestTemplate 이 의존성으로 추가되므로 API 호출이 필요할 때 이용할 수 있다.

                - @SpringBootTest 는 기본적으로 모든 빈을 탐색하고 등록한다. 그래서 특정 계층만 테스트가 필요한 상황에서 @SpringBootTest 를 사용하면
                  불필요하게 무거워지고 시간이 오래 걸린다. 그래서 스프링은 특정 부분만 테스트할 수 있는 슬라이스 테스트(SliceTest)를 위한 어노테이션들을 제공하는데,
                  이에 대해 알아보도록 하자. 물론 슬라이스 테스트도 스프링 컨텍스트를 구성하므로 통합 테스트이다.

       public class MemberServiceTest {
           @Autowired
           MemberService memberService;

           @Autowired
           MemberRepository memberRepository;
       }

       단위 테스트보다 쉽게 진행할 수 있습니다. SpringContainer 를 만들기 때문에 Bean 있어 따로 가짜 객체를 정의하지 않아도 됩니다.


    - 단위 테스트 VS 통합 테스트
        - 프로젝트를 진행하며, 테스트 코드가 적다면, 통합 테스트로 진행해도 많은 영향을 끼치진 않습니다. 하지만 애플리케이션이 커지면서,
          테스트 코드가 점점 많아진다면 통합 테스트 비용이 많이 발생할 것입니다.
          통합 테스트는 모든 빈을 등록하여 테스트를 진행한다. 그렇기 때문에 애플리케이션 규모가 크면 테스트가 많이 느려진다.

        - 단위 테스트의 경우 계층마다 나눠서 작성하기 때문에 오류가 발생해서 검증이 실패한다면, 그 부분만 수정하면 됩니다.
          반면에 통합 테스트는 어느 계층에서 오류가 발생한 지 색출하는데 오랜 시간이 걸립니다.

        -> 단위 테스트, 통합 테스트 모두 장단점이 존재합니다.
           단위 테스트의 단점은 테스트를 작성하는 노하우 등으로 커버가 가능합니다. 하지만 통합 테스트의 무거운 테스트로 인해서 발생하는 비용은 커버가 불가능합니다

        * @RunWith : 해당 어노테이션을 사용하면 JUnit 의 러너를 사용하는게 아니라 지정된 SpringRunner 클래스를 사용한다.
            @RunWith(SpringRunner.class)

    - 애플리케이션 컨텍스트 캐싱
        - 스프링 부트가 제공하는 테스트는 모두 애플리케이션 컨텍스트를 구성해주어야 한다. 하지만 모든 테스트마다 이를 구성하려면 비용이 커지므로
          스프링은 테스트 시에 내부적으로 스프링 컨텍스트를 캐싱해두고 동일한 설정이라면 재사용한다.
          그러므로 다음과 같이 애플리케이션 컨텍스트 설정에 변경을 주는 기능들은 테스트 시에 새로운 컨텍스트를 생성하도록 요구한다.
            @MockBean, @SpyBean
            @TestPropertySource
            @ConditionalOnX
            @WebMvcTest 에 컨트롤러 지정
            @Import
            기타 등등

    - 여기서 주의해야 할 점은 슬라이스 테스트가 단위 테스트는 아니라는 점이다. 해당 어노테이션으로 테스트를 진행하면 테스트를 위한 애플리케이션 컨텍스트가 준비된다.
      즉, 스프링이 준비되므로 해당 테스트들은 통합 테스트에 해당한다.
      추가로 위에서 언급한 슬라이스 테스트 어노테이션 외에도 @JsonTest, @RestClientTest, @DataJdbcTest 등도 있다.
      만약 json 관련 테스트를 위해 gson 이나 objectMapper 등의 의존성이 필요하다면 @JsonTest 를, RestTemplate 이 필요하다면 @RestClientTest 를 사용할 수 있다.
      또한 Datasource 와 JdbcTemplate 만 필요하다면 @JdbcTest 를 이용하면 된다.

    - JUnit5에 추가된 내용
        1. @DisplayName : method 명으로 표현하기 부족했다면 해당 어노테이션을 유용하게 사용할 수 있다.
        2. Lifecycle Method
            @BeforeClass, @AfterClass -> @BeforeAll, @AfterAll
            @Before, @After -> @BeforeEach, @AfterEach
        3. 중첩된 테스트 클래스 - @Nested
            @DisplayName("조회 테스트")
            @Nested
            class ReviewServiceTest {
            	@DisplayName("여러 seq로 조회")
                @ParameterizedTest(name = "seq {0} 조회")
                @ValueSource(longs = { 1L, 2L })
                void getBySeq(Long seq){
                	Review review = reviewService.getByReviewSeq(seq);
                    assertThat(review).isNotNull();
                }
            }

    - 스프링부트 테스트를 위한 의존성
        - 스프링부트는 서블릿 기반의 웹 개발을 위한 spring-boot-starter-web, 유효성 검증을 위한 spring-boot-starter-validation 등
          spring-boot-starter 의존성을 제공하고 있다. 테스트를 위한 spring-boot-starter-test 역시 존재하는데, 다음과 같은 라이브러리들이 포함된다.
            - JUnit 5: 자바 애플리케이션의 단위 테스트를 위한 사실상의 표준 테스트 도구
            - Spring Test & Spring Boot Test: 스프링 부트 애플리케이션에 대한 유틸리티 및 통합 테스트 지원
            - AssertJ: 유연한 검증 라이브러리
            - Hamcrest: 객체 Matcher 를 위한 라이브러리
            - Mockito: 자바 모킹 프레임워크
            - JSONassert: JSON 검증을 위한 도구
            - JsonPath: JSON 용 XPath

        - 스프링부트는 spring-boot-test-autoconfigure 를 통해 특정 어노테이션을 붙여주면 해당 테스트를 위한 설정들을 자동으로 제공해준다.
          대표적으로 다음과 같은 어노테이션들을 제공하고 있다.
            - @SpringBootTest
            - @WebMvcTest
            - @DataJpaTest
            - @RestClientTest
            - @JsonTest
            - @JdbcTest
            - 기타 등등

        - @MockBean
            만약 @MockBean 으로 선언한 빈이 없다면 Mock 객체를 빈으로 등록하지만, 동일한 타입과 이름의 빈이 존재하면 해당 빈은 Mock 빈으로 대체된다.

    - 단위 테스트(Unit Test) 작성의 필요성
        - 단위 테스트의 문제점과 Stub
            어떤 객체가 자체적으로 모든 일을 처리한다면 문제가 없겠지만, 일반적인 애플리케이션에서는 1개의 기능을 처리하기 위해 다른 객체들과 메세지를 주고 받아야 한다.
            하지만 앞서 설명하였듯 단위 테스트는 해당 모듈에 대한 독립적인 테스트이기 때문에 다른 객체와 메세지를 주고 받는 경우에 문제가 발생한다.
            그렇기 때문에 다른 객체 대신에 가짜 객체(Mock Object)를 주입하여 어떤 결과를 반환하라고 정해진 답변을 준비시켜야 하는데, 이를 stub 이라고 한다.
            예를 들어 데이터베이스에 새로운 데이터를 추가하는 코드를 테스트한다고 하면, 가짜 데이터베이스(Mock Database)를 주입하여
            insert 처리 시에 반드시에 1을 반환하도록 해주는 것이 stub 이다.

        - 좋은 단위 테스트의 특징
            1개의 테스트 함수에 대해 assert 를 최소화하라
            1개의 테스트 함수는 1가지 개념 만을 테스트하라

        - FIRST 라는 5가지 규칙
            1. Fast: 테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한다.
            2. Independent: 각각의 테스트는 독립적이며 서로 의존해서는 안된다.
            3. Repeatable: 어느 환경에서도 반복 가능해야 한다.
            4. Self-Validating: 테스트는 성공 또는 실패로 bool 값으로 결과를 내어 자체적으로 검증되어야 한다.
            5. Timely: 테스트는 적시에 즉, 테스트하려는 실제 코드를 구현하기 직전에 구현해야 한다.

        * 개인적으로 단위 테스트의 가장 큰 장점은 내가 개발한 것들을 빠르게 검증받는 것이라고 생각합니다. 단위 테스트를 통해 내가 개발한 코드를 바로 검증받고,
          테스트를 통과하지 못하면 코드를 수정해 또 다시 빠르게 검증받는 것입니다. 이렇게 테스트를 작성하고 수시로 실행하며 검증하면서 버그를 잡고 개발 비용을 줄어나갈 때 테스트의 가치를 느낄 수 있었습니다.
          물론 프로토타입 또는 PoC 성향의 프로젝트라면 단위 테스트를 작성하지 않을 수도 있습니다. 반면에 신규로 개발된 프로젝트이거나
          계속해서 기능이 추가되고 유지보수가 필요한 프로젝트라면 단위 테스트를 작성하는게 좋을 것 같습니다. 만약 해당 프로젝트가
          이미 구현되어있는 상태라도 늦게나마 단위 테스트를 작성하는 것은 이후에 작업하는데 도움을 줄 것입니다!

    - Mockito 소개 및 사용법
        - Mockito 란?
            Mockito 는 개발자가 동작을 직접 제어할 수 있는 가짜(Mock) 객체를 지원하는 테스트 프레임워크이다.
            일반적으로 Spring 으로 웹 애플리케이션을 개발하면, 여러 객체들 간의 의존성이 생긴다. 이러한 의존성은 단위 테스트를 작성을 어렵게 하는데,
            이를 해결하기 위해 가짜 객체를 주입시켜주는 Mockito 라이브러리를 활용할 수 있다. Mockito 를 활용하면 가짜 객체에 원하는 결과를
            Stub 하여 단위 테스트를 진행할 수 있다. 물론 Mock 을 하지 않아도 된다면 하지 않는 것이 가장 좋다.

        - Mockito 사용법
            1. Mock 객체 의존성 주입
                @Mock: Mock 객체를 만들어 반환해주는 어노테이션
                @Spy: Stub 하지 않은 메소드들은 원본 메소드 그대로 사용하는 어노테이션
                @InjectMocks: @Mock 또는 @Spy 로 생성된 가짜 객체를 자동으로 주입시켜주는 어노테이션
            2. Stub 로 결과 처리
                의존성이 있는 객체는 가짜 객체(Mock Object)를 주입하여 어떤 결과를 반환하라고 정해진 답변을 준비시켜야 한다. Mockito 에서는 다음과 같은 stub 메소드를 제공한다.
                    doReturn(): Mock 객체가 특정한 값을 반환해야 하는 경우
                    doNothing(): Mock 객체가 아무 것도 반환하지 않는 경우(void)
                    doThrow(): Mock 객체가 예외를 발생시키는 경우
            3. Mockito 와 Junit 의 결합
                Mockito 도 테스팅 프레임워크이기 때문에 JUnit 과 결합되기 위해서는 별도의 작업이 필요하다.
                기존의 JUnit4에서 Mockito 를 활용하기 위해서는 클래스 어노테이션으로 @RunWith(MockitoJUnitRunner.class)를 붙여주어야 연동이 가능했다.
                하지만 SpringBoot 2.2.0부터 공식적으로 JUnit5를 지원함에 따라, 이제부터는 @ExtendWith(MockitoExtension.class)를 사용해야 결합이 가능하다.


    - Spring 컨트롤러 단위 테스트 작성 예시
        @ExtendWith(MockitoExtension.class)
        class UserControllerTest {

            @InjectMocks
            private UserController userController;

            @Mock
            private UserService userService;

        }

        이제 의존성 주입을 해주어야 한다. 먼저 테스트 대상인 UserController 에는 가짜 객체 주입을 위한 @InjectMocks 를 붙여주어야 한다.
        그리고 UserService 에는 가짜 Mock 객체 생성을 위해 @Mock 어노테이션을 붙여주면 된다.


    ***** 또한 테스트 코드는 앞서 설명한 given-when-then 구조로 흔히 작성되는데, 단위 테스트 내에 주석으로 이 단계를 명시해주면
    읽기 좋은 테스트 코드를 작성할 수 있다. (IntelliJ를 사용중이라면 live template 를 직접 설정해 빠르게 작성할 수 있다.)




    - 올바른 단위 테스트 작성 - 독립적인 테스트
        https://mangkyu.tistory.com/159

    - 단위 테스트(Unit Test) 작성의 필요성 (1/3)
        https://mangkyu.tistory.com/143

    - JUnit 을 활용한 Java 단위 테스트 코드 작성법 (2/3)
        https://mangkyu.tistory.com/144

    - JUnit 과 Mockito 기반의 Spring 단위 테스트 코드 작성법 (3/3)
        https://mangkyu.tistory.com/145

    * TDD 로 멤버십 삭제 및 포인트 적립 API 구현 예제 - (5/5)
        https://mangkyu.tistory.com/186

    * Writing Your F.I.R.S.T Unit Tests
        https://galid1.tistory.com/772

    * Mock Object 란
        https://medium.com/@SlackBeck/mock-object%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-85159754b2ac


    슬라이스 테스트 vs 단위 테스트 ??

    doReturn ? when? verify?
    @InjectMocks ?



