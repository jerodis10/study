- Spring Framework에 대해 설명해주세요.
    - 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크

    - 경량 컨테이너로서 자바 객체를 직접 관리
        각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
    - 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
        컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 다라 스프링에서 사용자의 코드를 호출한다.
    - 의존성 주입(DI, Dependency Injection)을 지원
        각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
    - 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
        트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.


- 스프링이란?
    - Java 기반의 엔터프라이즈 Application 개발을 빠르고 편하게 할 수 있도록 도와주는 경량 프레임워크.

    - 왜 '경량' 프레임워크인가?
        초기 서버사이드 처리는 직접 쓰레드, 소켓연결 등을 개발자들이 직접 처리했고, 개발자 마다 구현하는 방법이 다 달라 협업에 불편함이 많았다.
        정형화, 표준화 된 방법을 찾기 시작하면서 등장한 것이 Framework이다.
        EJB가 나왔지만 분산환경 처리에 특화된 EJB는 너무 무거운데다 불편한 점이 많았고, 이런 EJB에 반기를 들고 탄생한 '경량화'된 Java 엔터프라이즈용 Framework이 Spring인 것이다.

    - 왜 스프링을 사용하는가?
        스프링은 Framework이고, Framework은 개발자들이 좀 더 쉽고 편리하게 애플리케이션을 개발할 수 있도록 미리 갖춰진 구조를 말한다.
        Framework이 없었다면 개발자들은 처음부터 끝까지 직접 모든 구조를 만들어내야 할 것이다.
        스프링은 Application 개발에 필요한 하부 구조를 포괄적으로 제공함에 따라 개발자들의 실력의 간극을 메꿔줄 수 있는 데다가
        올바른 형태의 코드만 넣어준다면 일정 수준의 성능과 안정성을 보장해 줄 수 있다. 그 틀과 구조 위에서 개발자들은
        핵심 비즈니스 로직에만 집중할 수 있어서 생산성 또한 향상된다.


- Spring과 SpringBoot의 차이점
    (1) 내장 톰캣
        - 내장 톰캣을 사용하기 때문에 따로 톰캣을 설치하거나 매번 버전을 관리해 주지 않아도 된다.
    (2) starter를 통한 dependency를 자동화
        - 기존의 Spring에서는 dependency들의 호환되는 버전을 직접 설정
        - 스프링 부트에서는 이 starter를 통해 종속된 모든 라이브러리를 알맞게 찾아서 함께 가져오기 때문에 의존성이나 호환버전에 대해 신경 쓸 필요가 없다.
    (3) XML
        - View Resolver, 데이터 액세스 등의 xml 설정을 하지 않아도 된다.
    (4) jar
        - jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.
    (5) AutoConfigurator
        - 공통적으로 필요한 설정을 어노테이션을 이용하여 대신할 수 있다.
    (6) Spring Initializr
        - pring Initilizr를 사용하면 실행 환경이나 의존성 관리 등의 인프라 부분을 신경 쓸 필요 없이 바로 코딩을 시작할 수 있게끔 환경을 제공


- 스프링 부트
    - 의존성 관리
        스프링 부트는 starter- 를 통해서 의존성관리를 한다.

    - 자동 설정
        - @ComponentScan을 통해서 @Component, @Serveice, @Repository .. 와 같은 컴포넌트 기반을 스캐닝해서 우리가 정의한 빈들을 등록한다.
        - @EnableAutoConfiguration을 통해서, META-INF 하위에 있는 spring.factories 파일에 정의된 클래스들에 의해서 빈으로 등록된다.
          (@ConditionalOnMissingBean 같은 경우, 빈으로 등록되어있지 않은 경우, 저기에서 정의한 대로 빈으로 등록한다.)

    - 내장 웹서버
        메인 애플리케이션으로 띄울 수 있고, jar로 패키징된 파일 하나로 만들고, 해당 jar를 실행해서도 애플리케이션을 띄울 수 있다.
        여러 가지 설정을 할 수 있다.
            server.port = 0 (random)
            spring.main.web-application-type=none -> 내장 웹서버로 실행하지 않음
            https 설정, http2.0 설정


- Web Server와 WAS의 차이점
    - Web Server
        - HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능

        - 정적인 컨텐츠 제공
          WAS를 거치지 않고 바로 자원을 제공한다.

        - 동적인 컨텐츠 제공을 위한 요청 전달
          클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)한다.

        ex) Apache Server, Nginx 등

        - 사용 이유
            - WAS가 해야 할 일의 부담을 줄이기 위해서
                - WAS 앞에 웹 서버를 둬서 웹 서버에서는 정적인 문서만 처리하도록 하고, WAS는 애플리케이션의 로직만 수행하도록 기능을 분배하여 서버의 부담을 줄이기 위한 것
            - WAS의 환경설정 파일을 외부에 노출시키지 않도록 하기 위해서
                - 웹 서버와 WAS에 접근하는 포트가 다르기 때문에, WAS에 들어오는 포트에는 방화벽을 쳐서 보안을 강화할 수도 있다.


    - WAS(Web Application Server)
        - 정의
            - DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
            - “웹 컨테이너(Web Container)” 혹은 “서블릿 컨테이너(Servlet Container)”라고도 불린다.
            - Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다. 즉, WAS는 JSP, Servlet 구동 환경을 제공한다.

        - 역할
            - WAS = Web Server + Web Container
            - Web Server 기능들을 구조적으로 분리하여 처리하고자 하는 목적으로 제시
                - 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용

        - 주요 기능
            1) 프로그램 실행 환경과 DB 접속 기능 제공
            2) 여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능
            3) 업무를 처리하는 비즈니스 로직 수행

        - 예) Tomcat, JBoss, Jeus, Web Sphere 등

    - WAS와 Web Server를 따로 두는 이유
        - 기능을 분리하여 서버 부하 방지
            - WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트에 제공하는 것이 좋다.
        - 물리적으로 분리하여 보안 강화
            - SSL에 대한 암복호화 처리에 Web Server를 사용
        - 여러 대의 WAS를 연결 가능
            - Load Balancing을 위해서 Web Server를 사용할 수 있다.
            - 특히 대용량 웹 애플리케이션의 경우(여러 개의 서버 사용) Web Server와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응
        - 여러 웹 애플리케이션 서비스 가능
            - 예를 들어, 하나의 서버에서 PHP Application과 Java Application을 함께 사용하는 경우가 있다.
        - 접근 허용 IP관리 및 2대 이상의 서버에서의 세션 관리 등도 Web Server에서 처리하면 효율적

        -> 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 분리한다.

    - 왜 Tomcat이 아닌 Apache Tomcat이라고 부를까?
        - 정적 컨텐츠를 처리하는 웹 서버에는 Apache가 있고, 동적 컨텐츠를 처리하는 WAS 서버는 Tomcat이 있다.
        - Tomcat 5.5 버전부터 정적 컨텐츠를 처리하는 기능이 추가되었는데, 이 기능이 순수 Apache를 사용하는 것에 비해 성능적 차이가 전혀 없으며
          Tomcat이 Apache의 기능을 포함하고 있기 때문에 Apache Tomecat이라고 부르고 있다.


- 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.
    - 객체에 대한 제어권이 개발자에게 있는 것이 아닌, 스프링 컨테이너에게 있는 것. 인스턴스의 생성부터 소멸까지의 라이프싸이클 관리 등을 컨테이너가 대신 해준다.
    - 일반적으로 프로그램의 흐름은 main()메서드처럼 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고, 생성하고, 오브젝트의 메서드를 호출하고,
      그 메서드 안에서 다음에 사용할 것을 결정하는 식의 작업이 반복되는데, 스프링프레임워크에서는 애플리케이션 코드가 프레임워크에 의해 사용되어지는 구조
      애플리케이션 컨텍스트가 빈의 생성과 관계설정 같은 제어를 담당한다.

    - 제어의 역전(IoC)란 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다.
    - 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고
      컨테이너에 등록한 객체들을 '빈'이라고 합니다.


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것. 이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있습니다.

    - 제어의 역행(IOC)으로 특정 객체에 필요한 다른 객체를 외부에서 결정해서 연결시키는 것.
    - 설정만 해준다면(applicationContext.xml) 스프링은 그 설정 정보를 참고해서 객체를 생성,관리하고 그 관계를 맺어준다.
    - 핵심은 개발자가 new 연산자 등을 통해 객체를 생성할 필요가 없다는 것이다(제어의 역행-IoC).
    - 개발자 입장에서는 스프링 컨테이너에게 그 참조변수만 일러준다면(@Autowired나 setter주입 등) 스프링이 알아서 객체를 생성해주고, 관계를 맺어준다. 이를 의존성 주입 이라고 한다.

    - 의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3 가지 방법이 있습니다. 이 중 Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법입니다.
        1. 순환 참조를 방지
            - 생성자 주입 방식은 필드나 수정자 주입과는 빈을 주입하는 순서가 다르기 때문
            - 필드/수정자 주입은 먼저 빈을 생성한 후, 주입하려는 빈을 찾아 주입.
            - 하지만 생성자 주입은 먼저 생성자 인자에 사용되는 빈을 찾거나 빈 팩토리에서 만든다.
              그 후에 찾은 인자 빈으로 주입하려는 빈의 생성자를 호출
            - 객체 생성 시점에 빈을 주입하기 때문에 서로 참조하는 객체가 생성되지 않은 상태에서 그 빈을 참조하기 때문에 오류가 발생

            - 생성자를 통한 의존성 주입의 장점은 객체 생성 시점에서 순환 참조가 일어나기 때문에 스프링 애플리케이션이 실행되지 않습니다.
            - (앱 구동 단계에서 오류를 찾을 수 있다.)
            - 컨테이너가 빈을 생성하는 시점에서 객체생성에 사이클 관계가 생기기 때문입니다.
        2. final 선언 가능
            - 런타임에 객체 불변성 보장
        3. 테스트 코드 작성 용이
            - 스프링 컨테이너 도움 없이 테스트 코드를 더 편리하게 작성 가능
            - 테스트하고자 하는 클래스에 필드/수정자 주입으로 빈이 주입되어 있으면, Mockito를 이용해 목킹한 후 테스트 해아함.
            - 하지만 생성자 주입은 단순히 원하는 객체를 생성한 후, 생성자에 넣어주면 된다.
            - 생성자 주입이 아닌 다른 주입으로 작성된 코드는 순수한 자바 코드로 단위 테스트를 작성하는 것이 어렵다.
              필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는
              필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양
              Mock 객체를 만들어야 하는데 DI 컨테이너에 의존하는 바람에 독립적으로 인스턴스화가 불가능한 문제가 발생한다.
              DI 컨테이너에서 관리되는 클래스는 특정 컨테이너에 의존하지 않고 POJO여야 한다.
              스프링 컨테이너가 생성해서 주입해주는 방식이기 때문에
              반면 생성자 주입을 사용하면 객체를 생성할 때 원하는 구현체를 넘겨주면 되고, 구현체를 넘겨주지 않으면 객체 생성 자체가 불가능

        4. NPE 방지
            의존관계가 설정되지 않으면 객체 생성 불가. 컴파일 타임에 인지 가능


- Bean Factory(빈팩토리)/Application Context(애플리케이션 컨텍스트)란?
    - 빈 팩토리
        - 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트.
        - 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당하지만
          보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다.

    - 애플리케이션 컨텍스트
        - IoC 방식을 따라 만들어진 일종의 빈 팩토리.
        - 빈 팩토리를 확장한 IoC 컨테이너로, 빈을 등록하고 관리하는 기본 기능은 빈 팩토리와 동일하나 스프링이 제공하는 각종 부가 서비스를 추가로 제공


- 스프링 컨테이너(Spring Container)란?
    - 빈의 생성,관계설정,생명주기 등을 관장하는 컨테이너.

    - 객체(빈)관리의 관점에서 Application Context를 스프링 컨테이너라고 부른다.
    - Application Context는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데,
      그러한 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용되고, 이를 통틀어서 스프링 컨테이너라고 볼 수 있다.


- 빈(Bean)이란?
    - 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트.

    - 스프링 빈은, 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 IoC가 적용된 오브젝트를 가리키는 말이다.
    - 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니고, 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
    - POJO와 설정(Configuration. xml이나 어노테이션)을 Spring의 컨테이너에 주입시키면 Bean으로 등록되고 사용할 수 있다.


- POJO
    어느 곳에 종속되지 않은 순수한 자바 객체.

    과거에 자바로 웹 애플리케이션을 만들기 위해 Servlet클래스를 상속받아 구현했어야 했다. 서블릿 컨테이너 안에서 서블릿으로 존재하기 위해서는 그 구현이 강제되었던 것이다.
    그렇게 강제된 구현으로 만들어진 서블릿 객체는 서블릿 컨테이너 환경에서 사용되어질 수 있다. 이는 그 환경에 종속 되어 있기에 POJO라고 할 수 없다.
    어느 곳에 종속되지 않는다는 의미는, 해당 클래스를 사용하기 위해 외부 환경(like 프레임워크)이 필요하고, 해당 환경이 특정 인터페이스를 구현할 것을 강요하는 등의 제약에서 자유롭다는 것을 의미한다.
    (따라서 단순히 외부 구동환경과 무관한 다른 클래스의 상속 또는 구현은 상관 없다.)
    즉, 다시말해 POJO는 외부환경(like Spring MVC)을 걷어내도 정상적으로 작동이 되어야 한다는 것이다.
    Spring은 개발자가 직접 위와같이 Servlet클래스를 작성하지 않고 POJO만으로 웹 애플리케이션을 구축할 수 있다는 것이 특징이다.(개발자가 비즈니스로직만 신경 쓸 수 있다)

    스프링에서 생성되어 관리되는 POJO 기반의 객체를 Spring Bean이라고 합니다.
    여기서 POJO는 단순 getter, setter만으로 구성되어 있으며 단순히 new를 통해서 생성 가능한 형태를 말합니다.
    핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있고, 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스입니다.


- Bean Scope
    - 스프링 빈(Spring Bean)이란?
        - 스프링 IoC 컨테이너에 의해서 관리되고 애플리케이션의 핵심을 이루는 객체들을 스프링 빈
        - 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서,
          강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있는데 대표적으로 프로토타입 스코프가 있다.
          프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할때마다 매번 새로운 오브젝트를 만들어 준다. 스코프는 xml과 어노테이션 설정으로 가능하다.

    - Scope의 종류
        - Singleton
            - 스프링 빈은 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때까지 1개의 객체로 유지
        - Prototype
            - 요청이 오면 항상 새로운 인스턴스를 생성하여 반환하고 이후에 관리하지 않음
            - 프로토타입을 받은 클라이언트가 객체를 관리해야 함
                - 스프링 컨테이너는 프로토타입 스프링 빈의 생성과 의존관계 주입까지만 관여하고 이후의 과정은 관여하지 않는다.
                    (이후는 해당 빈을 호출한 사용자에 의해서 종료된다.)
                  스프링 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 처리.
                  @PreDestroy같은 종료 메서드가 호출 되지 않는다.
        - Web
            - Request: 각각의 요청이 들어오고 나갈 때까지 유지되는 scope (HTTP Request의 생명주기와 같음)
            - Session: 세션이 생성되고 종료될 때까지 유지되는 scope (HTTP Session의 생명주기와 같음)
            - Application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 scope

    - 왜 스프링 빈은 기본적으로 싱글톤일까?
        Spring Framework의 핵심은 스프링 컨테이너. 이 컨테이너는 객체를 갖고 있다가 필요할때 주입한다. 왜 그렇게 동작할까?
        서버는 많은 사람들이 사용하고 그 사용자들이 이용할 비즈니스 로직은 대부분 동일하다.
        동일한 비즈니스 로직(빈)이 이용하는 사람들마다 하나씩 생성된다면 서버는 부하에 걸리기 쉽고 애초에 동일한 로직이
        여러개 생성될 필요가 없기 때문에 스프링에서는 빈들을 싱글톤으로 관리한다.

    - 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
        - 싱글톤 스프링 빈 내부에 의존관계로 주입되는 스프링 빈이 프로토타입인 경우
            - 프로토타입 스코프의 스프링 빈이 새로 생성되기는 했지만 싱글톤 빈과 함께 사용되기 때문에 계속 유지된다.
            - 싱글톤 빈과 함께 사용하면서 프로토타입 빈이 자기의 스코프를 지키고 매번 새롭게 생성하기 위해서는 어떻게 해야 할까?

            - 의존관계를 외부에서 주입(DI) 받는 것이 아닌 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색)이라 한다.
            - ObjectProvider의 getObject()를 호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
            - 스프링의 의존성이 마음에 들지 않으면 JSR-330 자바 표전을 사용하는 방법이 있다.

    - 프로토타입 빈을 언제 사용해야 하는가?
        - 여러 인스턴스를 검색해야 하는 경우
        - 인스턴스를 지연 혹은 선택적으로 찾아야 하는 경우
        - 순환 종속성을 깨기 위해서
        - 스코프에 포함된 인스턴스로부터 더 작은 범위의 인스턴스를 찾아 추상화 하기 위해서 사용한다.


- 스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요.
    - 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료

    - 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리
        1. 인터페이스( InitializingBean, DisposableBean )
        2. 설정 정보에 초기화 메소드, 종료 메소드 지정
        3. @PostConstruct, @PreDestroy 어노테이션 지원


- spring bean 생명주기
    1. 빈 객체 생성
    2. BeanNameAware.setBeanName()
        의 id/name 속성에 지정된 값 전달
            - 스프링에서 관리되는 bean 내부에서 id나 name이 무엇으로 지정되어 있는지 확인하는 경우 BeanNameAware Interface를 구현한다.
            - 이때 그림의 노란색 부분처럼 bean생성과 property 의존성 주입을 완료한 이후, init method를 수행하기 전 시점에 호출된다.
    3. BeanFactoryAware.setBeanFactory()
        - bean객체에 bean을 관리하는 BeanFactory 객체 전달
    4. BeanPostProcessor의 초기화 전처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 되기전 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
    5. 커스텀 init - method
        - @PostConstruct
    6. InitializingBean.afterPropertiesSet()
    7. BeanPostProcessor의 초기화 후처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 된 후 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
        - postProcessAfterInitialization
    8. 빈 객체 사용
    9. DisposableBean.destroy()
    10. 커스텀 destroy - method 2_8_ii


- Servlet
    - Servlet 정의
        - 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램이 서블릿
        - 서블릿은 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해주는 기술

    - Servlet 특징
        - 서블릿 등장 이전에는 CGI (Common Gateway Interface) 기술이 있었는데 이는 요청 당 프로세스를 생성함
            - 서블릿은 CGI에 비해서 작동이 빠르고, 플랫폼에 독립적이며, 보안이 좋고, 이식성이 강함
        - html을 사용하여 요청에 응답
        - 서블릿 객체는 싱글톤으로 관리
            - 고객의 요청이 올 때마다 생성하는 것은 비효율적이기 때문
            - 서블릿 컨테이너가 종료되면 서블릿도 종료

    - 서블릿 컨테이너(Servlet Container)
        - 정의
            - 서블릿을 관리해주며 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하며 post, get여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.
                - HttpServletRequest
                    - http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의
                      정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있다.
                - HttpServletResponse
                    - WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여
                      서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송한다.

        - 특징
            - java thread를 사용해서 서블릿을 호출
            - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함

        - 주요 기능
            - 서블릿의 생명주기를 관리
                - 서블릿 컨테이너가 기동 되는 순간 서블릿 클래스를 로딩해서 인스턴스화하고, 초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작한다.
                  그리고 서블릿의 생명이 다하는 순간 가비지 컬렉션을 통해 메모리에서 제거한다.

            - 통신 지원
                - 클라이언트의 Request를 받아주고 Response를 보낼 수 있게 웹 서버와 소켓을 만들어서 통신을 해준다.
                - 블릿 컨테이너는 이렇게 소켓을 만들고 listen, accept 등의 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해주고 개발자로서 비즈니스 로직에 더욱 집중할 수 있게 만들어준다.

            - 멀티스레딩 관리
                - 해당 서블릿의 요청이 들어오면 스레드를 생성해서 작업을 수행한다.

            - 선언적인 보안관리


- 서블릿의 동작 방식에 대해 설명해주세요.
    1. 사용자(Client)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다.
    2. 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
    3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
    4. 해당 서블릿에서 service메소드를 호출한 후 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
    5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다.
    6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.


- MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.
    1. 클라이언트는 URL을 통해 요청을 전송한다.
    2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
    3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
    4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
    5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
    6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
    7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
    8. 데이터가 추가된 뷰를 반환한다.


- @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요.
    - @RequestBody
        - 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할
        - 값을 주입하지 않고 값을 변환 시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다.

    - @RequestParam
        - 1개의 HTTP 요청 파라미터를 받기 위해 사용.
        -  필수 여부 설정 가능

    - @ModelAttribute
        - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자,Getter,Setter를 통해 주입하기 위해 사용
        - 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter,Setter가 없으면 변수들이 저장되지 않는다.


- AOP
    - AOP 가 무엇일까
        - Aspect Oriented Programming
        - 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 반복 작업을 줄이고 핵심 비즈니스 로직 개발에만 집중할 수 있음

        - 사용 목적에 따라
            - 프록시 패턴: 클라이언트가 타깃에 접근하는 방법 제어
            - 데코레이터 패턴: 타깃에 부가적인 기능 부여

    - AOP 의 용어들
        - Target Object
            - 부가 기능을 부여할 대상
            - 먼저 Target Object는 횡단기능(Advice)이 적용될 객체(Object)를 뜻한다.
            - 이 객체는 핵심 모듈(비즈니스 클래스)이라 할 수 있다. Spring AOP에선 Advice를 받는 객체라 하여 Adviced Object라는 용어로 쓰이기도 한다.
            - Spring AOP에선 실제 적용할 객체 대신 Runtime Proxy를 사용하여 구현되기 때문에, Target Object는 항상 Proxy Object다.
        - Aspect
            - 부가 기능을 정의한 Advice 와 어드바이스를 어디에 적용할 지 결정하는 Pointcut 을 함께 가짐.
        - Advice
            - 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.
            - Advice는 JoinPoint에 적용할 횡단 코드를(공통코드) 의미한다. 어떤 부가 기능 ? Before , AfterReturing , AfterThrowing , After , Around
        - JoinPoint
            - 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
            - JoinPoint는 Target Object안에서 횡단기능(Advice)이 적용될 수 있는 여러 위치를 뜻한다. 어디에 적용할 것인가? 메서드 , 필드 , 객체 , 생성자등
        - Pointcut: 어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

    - AOP 구현 방법
        - 컴파일 시점에 코드에 공통 기능 삽입
        - 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
            - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
              좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            (런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.)

    - Spring 에서 AOP 를 구현한 방법
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
            - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
            - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
            - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용

    - target 에 여러 AOP 가 동시에 적용되어도, 스프링의 AOP 는 target 마다 하나의 프록시만 생성한다.

    - 동적 프록시
        - JDK 동적 프록시
            - 인터페이스를 기반으로 동적 프록시

        - CGLIB
            - 구체 클래스만 가지고 동적 프록시

        - 프록시 팩토리
            - 실제객체의 인터페이스의 유무에 무관하게 프록시객체를 생성 가능
            - 둘을 개념적으로 추상화 한 것

        - 빈후처리기
            - 프록시객체를 빈으로 등록해야 하므로 수동 빈 등록만 가능하고 Config 에서 모든 빈마다 프록시객체를 생성해줘야하는 번거로움이 있다.
            - 객체를 빈으로 등록하기 직전에 프록시객체로 바꿔줄 수 있는 빈 후처리기
            - 자동빈 등록도 프록시가 적용 가능하며, 일일이 프록시객체를 생성할 필요 없다.

            - 자동 프록시 생성기는 2가지 일을 한다.
                1. @Aspect 를 보고 어드바이저( Advisor )로 변환해서 저장한다.
                2. 어드바이저를 기반으로 프록시를 생성한다.


- spring aop vs aspectj
    - spring aop
        - 런타임 위빙 만 사용할 수 있다
        - 덜 강력 함 – 메서드 수준 위빙 만 지원
        - Spring 컨테이너가 관리하는 Bean에서만 구현 가능
        - AspectJ보다 훨씬 느림
            Runtime weaving: Aspect 가 대상 객체의 Proxy(JDK 동적 Proxy 나 CGLIB 의 Proxy)를 실행시 Weaving 된다

    - aspectj
        - 런타임때 아무것도 안한다. Aspect를 코드에 Weaving하기 위해, AspectJ compiler(ajc)라는 컴파일러를 도입한다.
        - 컨파일 시점 위빙
        - 더욱 강력 함 – 필드, 메서드, 생성자, 정적 이니셜 라이저, 최종 클래스 / 메서드 등을 엮을 수 있다
        - 모든 도메인 개체에서 구현 가능
        - 모든 포인트 컷 지원
        - 애플리케이션이 실행되기 전에 (런타임 전에) Aspect가 코드로 직접 짜여짐


- jdk dynamic proxy vs CGLIB(code Generator Library)
    - Spring AOP는 프록시 기반으로 JDK Dynamic Proxy와 CGLIB을 활용하여 AOP 제공하고 있습니다.
    - JDK Dynamic Proxy는 인터페이스를 구현하여 Proxy를 생성
    - CGLib은 클래스를 상속받아 Proxy를 생성
    - 성능의 차이
        - 성능의 차이의 근본적인 이유는 CGLib은 타깃에 대한 정보를 제공 받기 때문입니다.
        - 따라서 CGLib은 제공받은 타깃 클래스에 대한 바이트 코드를 조작하여 Proxy를 생성


- AOP가 Proxy 방식이라 발생할 수 있는 단점(self invocation)
    - 같은 객체의 자신의 메소드 외의 다른 메소드를 호출 시 AOP 적용되지 않는 것
    - self-invocation 해결 방법
        - AopContext 이용
        - 자기 자신을 빈으로 등록 후, 메소드 호출
        - AspectJ Weaving 방식으로 변경


- Filter vs Interceptor vs AOP
    - Filter
        - 필터에서는 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리
        - Filter는 다음 체인으로 넘기는 ServletRequest/ServletResponse 객체를 조작할 수 있다는 점에서 Interceptor보다 훨씬 강력한 기술
        - 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리되므로 DispatcherServlet으로 가기 전에 요청을 처리하는 것

        ex) 보안 관련 공통 작업
            모든 요청에 대한 로깅 또는 감사
            이미지/데이터 압축 및 문자열 인코딩

    - 인터셉터(Interceptor)
        - 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트 내부에서 Controller에 관한 요청과 응답에 대해 처리
        - 스프링의 모든 빈 객체에 접근할 수 있다.
        - 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다.
        - 필터와 다르게 HttpServletRequest나 HttpServletResponse 등과 같은 객체를 제공받으므로 객체 자체를 조작할 수는 없다.

        ex) 인증/인가 등과 같은 공통 작업
            API 호출에 대한 로깅 또는 감사
            Controller로 넘겨주는 정보(데이터)의 가공

        - Filter의 doFilter 메서드는 매개변수로 ServletRequest와 ServletResponse를 받고 Interceptor의 preHandle이나 postHandle은 HttpServletRequest를 받는다.
        - ServletRequest는 기본적인 클라이언트 요청에 관한 모든 정보를 가지고 있다. 그리고 이 인터페이스는 다시 HttpServletRequest로 확장하여
          HTTP 프로토콜 상에서 할 수 있는 일들이 포함되어져 있다.
          이 HttpServletReqeust는 서블릿의 service의 매개변수의 하나로 서블릿 프로그래머가 클라이언트의 요청에 관한 작업들을 핸들할 수 있도록하는 중요한 역할을 담당하고 있다.

    - AOP
        - Interceptor와 Filter와 달리 메소드 전 후의 지점에 자유롭게 설정이 가능하며 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.
        - 로깅, 트랜잭션, 에러 처리 등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용


- Filter vs Interceptor vs AOP
    - Interceptor와 Filter는 Servlet 단위에서 실행된다. <> 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.

    - Filter(필터)
        요청과 응답을 거른뒤 정제하는 역할
        서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러가지 체크를 수행할 수 있다.
        또한 자원의 처리가 끝난 후 응답내용에 대해서도 변경하는 처리를 할 수가 있다.
        보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS방어 등의 요청에 대한 처리로 사용된다.

    - Interceptor(인터셉터)
        요청에 대한 작업 전/후로 가로챈다.
        필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다.
        하지만 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에
        스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.
        스프링의 모든 빈 객체에 접근할 수 있다.
        로그인 체크, 권한체크, 프로그램 실행시간 계산작업 로그확인 등의 업무처리

    - AOP
        OOP를 보완하기 위해 나온 개념
        객체 지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.
        주로 '로깅', '트랜잭션', '에러 처리'등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용합니다.
        Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다.
        Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다.

        AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이다.
        Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다.
        반면 HandlerInterceptor는 Filter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다.


- Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.
    - Spring Filter
        - 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리
        - Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공
        ex) 보안 및 인증/인가 관련 작업
            모든 요청에 대한 로깅 또는 검사
            이미지/데이터 압축 및 문자열 인코딩
            Spring과 분리되어야 하는 기능

    - Interceptor
        - 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작
        - Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
        ex) 세부적인 보안 및 인증/인가 공통 작업
            API 호출에 대한 로깅 또는 검사
            Controller로 넘겨주는 정보(데이터)의 가공


- @Transactional의 동작 원리에 대해 설명해주세요.
    - @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며,
      Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행합니다.


- @Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다.
      즉, A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않은 일반 코드가 수행됩니다.


- @Transactional 이 동작하지 않을 때
    - @Transactional을 선언한 함수 내부에 try-catch구문
        에러를 밖으로 던져야 하는데 내부적으로 잡아버리니 함수는 성공 처리된다.
        성공으로 처리되기 때문에 트랜잭션이 롤백되지 않는다.

    - @Transactional을 선언한 함수를 같은 클래스에서 호출할 경우
        @Transactional은 스프링 AOP기반으로 동작하기 때문에 같은 클래스 내부의 함수를 호출한 경우 동작하지 않는다.

    - @Transactional이 걸린 함수가 private인 경우
        사실 private 로 선언되었다는 것은 같은 클래스 내부의 함수에서 호출된다는 말이므로 위의 2번과 같은 내용이다.

    - @Transactional이 걸린 함수 내부에서 CheckedException이 발생한 경우
        Checked Exception는 복구가 가능하다는 메커니즘을 가지고 있기 때문에 Rollback 이 아닌 일반적인 코드 흐름으로 제어해야 함


- A 라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때,
  @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.
      그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다.


- 선언적 트랜잭션 속성
    - propagation
        - 트랜잭션 전파란 트랜잭션 경계에서 이미 진행중인 트랜잭션이 있을 경우 어떻게 동작할지 결정하는 것

        - REQUIRED (디폴트)
            - 이미 시작된 트랜잭션이 있으면 그 트랜잭션에 참여
            - 모든 트랜잭션 매니저가 지원합니다.
            - 해당 메서드를 호출한 곳에서 별도의 트랜잭션이 설정되어 있지 않다면 트랜잭션을 새로 시작
            - 부모 트랜잭션이 존재하면 포함되어 동작

        - SUPPORTS
            - 진행 중인 트랜잭션이 있으면 REQUIRED 처럼 참여하고 트랜잭션이 없으면 트랜잭션 없이 메서드를 실행
            - 해당 경계 안에서 Connection 객체나 하이버네이트의 Session 등은 공유 가능

        - MANDATORY
            - 진행 중인 트랜잭션이 있으면 참여하고 없으면 예외가 발생. 혼자서는 트랜잭션을 시작할 수 없고 메서드를 실행할 수도 없다.
            - 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용

        - REQUIRES_NEW
            - 항상 새로운 트랜잭션을 시작한다. 진행중인 트랜잭션이 있으면 잠시 보류시키고 새로운 트랜잭션으로 실행
            - 새로운 트랜잭션 안에서 예외가 발생해도 호출한 곳으로 롤백이 전파되지 않는다
            - 부모 트랜잭션이 존재하면 2개의 트랜잭션이 완전 독립적으로 동작

        - NOT_SUPPORTED
            - 이미 시작된 트랜잭션이 있으면 보류하고 자신의 메서드를 실행하는, 트랜잭션을 사용하지 않는 설정
              진행중인 트랜잭션이 있으면 보류하고 자신의 메서드 실행
            - 트랜잭션을 사용하지 않는다.
            - 부모 트랜잭션이 존재하면 보류시키고 트랜잭션 사용을 정지시킨다

        - NEVER
            - 트랜잭션을 사용하지 않도록 강제. 진행중인 트랜잭션이 없다면 자신의 메서드를 실행하지만 트랜잭션이 있다면 예외 발생

        - NESTED
            - 이미 진행 중인 트랜잭션 있으면 그 안에 새로운 트랜잭션을 만드는 설정.
            - 트랜잭션1 내부에 메서드 2를 트랜잭션 2로 삽입
            - 이렇게 중첩된 트랜잭션 2는 부모인 트랜잭션1의 커밋/롤백에는 영향을 받지만,
              트랜잭션2의 커밋/롤백에는 트랜잭션1이 영향을 받지 않는다.
            - 부모 트랜잭션의 커밋과 롤백에 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않는다
                예시) 메인작업을 진행하며 이와 관련된 로그를 DB에 저장
                     메인 작업이 실패 -> 로그 작업 롤백
                     로그를 저장하는 작업이 실패 -> 메인 작업의 트랜잭션은 롤백 X
            - 모든 트랜잭션 매니저에 적용 가능하진 않다.


- 트랜잭션 전파 방식
    - 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성

    - REQUIRED: 현재 진행중인 트랜잭션이 있으면 그것을 사용하고, 없으면 생성한다. [DEFAULT 값]
    - MANDATORY: REQUIRED와 비슷. 현재 진행중인 트랜잭션이 있으면 그것을 사용하고, 없으면 Exception 발생. 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용
    - REQUIRES_NEW: 항상 새로운 트랜잭션을 시작.
    - SUPPORTS: 이미 진행중인 트랜잭션이 있으면 그것을 사용. 없으면 그냥 트랜잭션 없이 진행.
    - NOT_SUPPORTED: 트랜잭션 사용하지 않게 한다. 이미 진행중인 트랜잭션이 있으면 보류
    - NEVER: 트랜젝션을 사용하지 않도록 강제한다. 이미 진행중인 트랜잭션도 존재하면 안됨. 있다면 예외 발생


- REQUIRES_NEW는 부모 트랜잭션에서 완전 독립적인 트랜잭션을 생성하는가 ?
    - 새롭게 생긴 자식 트랜잭션에서 Exception이 발생하면 부모 트랜잭션까지 전파된다.
      왜냐면 스프링에서 트랜잭션은 thread-local을 기반으로 동작한다.
      TransactionSynchronizationManager는 관련 리소스들을 쓰레드 로컬에 보관하고있다. 트랜잭션 매니저는 이녀석을 이용해서 리소스를 사용한다.
      REQUIRES_NEW는 별도의 새로운 트랜잭션(커넥션도 실제 다르다)을 만들 뿐, 쓰레드는 동일하다.

    - 그럼 어떤 경우에 REQUIRES_NEW 전파 레벨을 사용하는 것이 좋을까?
        - 부모 트랜잭션에서 Exception이 발생해도 자식 트랜잭션은 커밋이 되어야 하는 경우
        - 부모 트랜잭션에서 자식 트랜잭션을 try - catch 하고 싶은 경우
            - 부모 트랜잭션 커밋, 자식 트랜잭션 롤백


- 트랜잭션 read only에 동작 방식
    - Oracle
        - Read Only 트랜잭션을 이용할 경우 이 트랜잭션이 시작되기 이전에 커밋된 데이터만 접근할 수 있으며, 트랜잭션 실행되는 동안 커밋되는 데이터는 결과에 반영되지 않는다.
        - 해당 트랜잭션 시에 지원하는 DML은 SELECT(조회) 구문뿐이다.
        → 해당 트랜잭션 내에서 일관적인 데이터를 얻도록(데이터 일관성) 보장한다. 즉 성능 이점만을 위함이 아니다.


- Read only Transaction을 사용하는 일반적인 이유
    - 해당 설정을 사용한 트랜잭션은 데이터(테이블, 칼럼)에 대하여 Lock을 적용할 필요가 없고 접근할 수 있는 데이터가 (스냅샷, 튜플 등) 변경되지 않기 때문에, 일관적인 데이터를 읽어오고 제공할 수 있다.
    - 해당 속성의 경우 일반적으로 트랜잭션 ID를 부여하지 않아도 되기에 불필요한 ID 설정에 대한 오버헤드가 발생하지 않기 때문에 성능의 이점을 볼 수 있다.
    - 추가적으로 읽기-쓰기 트랜잭션을 위해 구성되는 별도 스냅샷의 총 수가 줄어든다.


- 스프링에서 어떤 exception에서 롤백처리를 하냐?
    - 스프링의 Transcational 어노테이션은 기본 정책이 Unchecked Exception과 Errors 이다.
      즉, Checked Exception일 경우 Transactional 어노테이션이 작동하지 않는다.
      컴파일 시 체크할 수 있는 예외에 대한 처리를 호출자에게 강제할 수 있어야 한다.
    - 아무것도 설정하지 않으면, 스프링은 아래와 같이 인식한다.
      @Transactional(rollbackFor = {RuntimeException.class,Error.class})
    - Checked Exception에서 Rollback을 발생시키려면
      rollbackFor라는 옵션을 이용해 모든 예외에 대해서 rollback을 처리.
      Checked Exception을 try-catch문으로 더 구체적인 Unchecked Exception으로 처리.


- @autowired , @Resouce , @inject
    - @Inject 와 @Resource 는 JSR 에 실려있는 자바 기존의 어노테이션. 반면 @Autowired 는 스프링에서 등장한 어노테이션.
      따라서 프로젝트를 스프링이 아닌 다른 프레임워크로 바꿔야 한다면 @Inject 나 @Resource 를 써야 한다.
    - 연결 방식은 @Autowired 와 @Inject 는 타입에 맞춰서 하는 반면, @Resource 는 이름에 맞춰서 연결.

    @Autowired
        - 타입 -> 이름 -> @Qualifier -> 실패
        - 멤버변수, setter메소드, 생성자, 일반 메소드에 적용가능

    @Inject
        - 타입 -> @Qualifier-> 이름 -> 실패
        - 멤버변수, setter 메소드, 생성자, 일반 메소드에 적용 가능

    @Resource
        - 이름 -> 타입 -> @Qualifier -> 실패
        - 멤버변수 , setter 메소드


- 모델1 방식이란?
    - JSP에 비즈니스 로직과 화면영역을 함께 구현하는 방식. (비즈니스 로직과 화면을 분리하지 않은 방식)
    - 비즈니스 로직이 복잡하지 않거나 소규모 프로젝트일 경우 빠르고 쉽게 개발할 수 있다는 장점이 있지만,
      출력을 위한 뷰 코드와 로직처리를 위한 자바 코드가 함께 섞여있기 때문에 JSP코드 자체가 복잡하고, 분업에 용이하지 않으며 유지보수가 어렵다.


-  모델2 방식이란?
    - 화면과 비즈니스 로직이 분리되어있는 방식.
    - 화면출력을 위한 뷰 코드는 JSP에서, 로직 처리를 위한 자바코드는 Servlet에서 처리하도록 분리하기 때문에 분업이 용이하고 유지보수가 쉽다.


- MVC패턴이란?
    - 데이터를 의미하는 Model, JSP와 같이 실질적으로 보여지는 페이지의 View, 그리고 클라이언트의 Request를 처리하고 View와 Model사이의
      중간 통신 역할을 하는 Controller의 3가지 형태로 구분하여 소프트웨어를 개발하는 방법론.
    - 모델2 방식은 MVC패턴을 따른 것이다.


- @compent로도 빈 설정을 할 수있는데 @service ,@repositorty를 나눠서 사용하는지
    - 레이어 역할을 분리하기 위해

    - 컴포넌트 클래스들에 @Component를 붙일 수 있지만, @Repository, @Service, @Controller를 붙인다면
    - 도구들이 클래스들을 처리하는데 더 적합하도록 할 수 있고 관점(aspects)에 더 연관성을 부여할 수 있다.
    - 스프링에서도 @Component보다는 @Repository, @Service, @Controller를 권장하고 있었던 것이었다.


- @bean , @Auwired등은 어떻게 동작하냐
    - https://kellis.tistory.com/70


- lcoal Thread란
    - ThreadLocal은 thread-local 변수를 제공하는 클래스이다.
    - 여기서 thread-local 변수란 말그대로 thread 내부에서 사용되는 지역변수를 의미한다.
    - 가령 메소드에서 사용하는 변수나 데이터는 파라미터 혹은 메소드 scope 내에서 정의하고 사용하게 되는데,
    - Thread Local을 사용하게 되면, 굳이 변수를 파라미터 같은 곳에 넣지 않아도 공유 및 사용이 가능하게 된다.
    - 그래서 앞서 언급한 SecurityContextHolder은 ThreadLocal을 통해 파라미터로 Principal을 주입 받지 않더라도,
    - 현재 SecurityContextHolder에 ThreadLocal로 저장된 Principal을 꺼내와 사용할 수 있게 되는 것이다.
    - ThreadLocal 변수를 선언하면 각 스레드가 별도의 변수처럼 사용할 수 있다.
    - 스레드가 종료되기 전까지 변수를 사용할 수 있다.
    - 스레드풀을 통해 스레드를 재사용하는 경우 이전에 사용했던 값을 공유할 수 있다. (이해하고 목적에 맞게


- Spring Rest Docs VS Swagger
    - Spring Rest Docs
        - 프로덕션 코드에 영향이 없다.
        - 테스트 코드가 성공해야 문서 작성이 가능하다.
            => Controller에 정의되어 있는 Request Body나 Response Body 등의 API 스펙 정보와 일치하는 API 문서가 만들어진다는 것이다.
               따라서 API 스펙 정보와 API 문서 내의 정보의 불일치로 인해 발생하는 문제를 방지해준다.
        - 문서를 위한 테스트 코드를 관리해야 한다.
            - 개발 시에 테스트 케이스 작성은 필수이므로, 딱히 단점이 아니라고 생각할 수도 있다.
            - 하지만, 개발 도중에 API가 수시로 변경되는 상황에서는 변경사항에 대해 테스트 코드까지 일일이 수정하는 작업은 번거로울 수 있으므로,
              이러한 상황에선 Swagger를 사용하는 편이 더 적합하다고 볼 수 있다.
            - 테스트가 성공하는 올바른 프로덕션 코드에 대해서만 문서를 작성할 수 있다.
              API 스펙과 항상 일치하는 문서를 작성할 수 있다.

    - Swagger
        - 문서상에 api를 테스트할 수 있는 기능이 있다.
        - 테스트 코드가 없으므로 적용이 쉽다.

        - 프로덕션 코드에 어노테이션 추가해야한다. (라이브러리가 바뀌는 등의 경우 불편하다.)
        - 프로덕션 코드와 동기화가 안될 수 있다.
        - 프로젝트의 규모가 커질수록 프로덕션 코드의 유지보수성이 떨어지고, 변경점이 늘어난다.
        - API 문서의 목적은 개발하는 스펙을 정의하는것이라 생각합니다. Swagger는 API 동작을 테스트하는 용도에 더 특화

        - API 스펙이 변경되더라도 어노테이션을 변경하지 않으면 API 문서는 수정되지 않는다. 즉, 문서와 실제 API 스펙이 일치함을 보장할 수 없다.

    - AsciiDoc VS Markdown (문서화 도구)
        - Markdown은 문법이 굉장이 편하다.
          Slate를 사용하면 import 기능을 사용할 수 있지만 결과물이 우리가 생각한 doc파일과는 다르며 별도 설정을 해야하는 번거로움이 있습니다.
        - AsciiDoc은 문법은 조금 불편하지만 include가 가능하기 때문에 html을 작성하는 것처럼 재활용이 가능
          자동생성된 스니펫과 자신이 원하는 문서를 결합해서 사용할 수 있습니다.

    - MockMvc(@WebMvcTest) vs Rest Assured(@SpringBootTest)
        - 보통 문서를 작성할 때 서비스 계층은 Mocking을 하여 작성합니다. Rest Assured는 BDD 스타일로 직관적이지만 별도의 구성없이는 @SpringBootTest로 수행해야합니다.
          그러면 전체 컨테스트를 로드하여 빈을 주입하기에 속도가 많이 느립니다. 반면에 MockMvc는 @WebMvcTest로 수행이 가능합니다.
          그래서 Controller Layer만 테스트 하기에 속도가 빠릅니다. 만약 통합테스트를 한다면 Rest Assured가 좋은 선택일것 같지만
          Spring Rest Docs로 문서를 작성하는데에는 MockMvc가 더 나은 선택이라 생각됩니다.
        - @WebMvcTest는 @SpringBootTest와 다르게 프레젠테이션 레이어의 빈들만 로드한다. 나머지 계층은 Mocking을 한다.
          이렇게 독립적으로 하나의 계층만을 테스트 하는 기법을 슬라이스 테스트라고 한다.

    - Rest Docs 적용해보기
        1. Spring TEST에 의해 성공한 케이스들에 대한 snippet이 자동으로 생성된다.
        2. 문서를 직접 작성하고 코드들에 대한 정보는 아까 생성된 snippet을 include하여 추가하여 완성한다.

    - Spring Rest Docs의 API 문서 생성 흐름
        - 테스트 코드 작성 -> test 태스크(task) 실행 -> API 문서 스니펫(.doc 파일) 생성 -> API 문서 생성 -> API 문서를 HTML로 변환

    - 관련 용어
        스니핏(snippet) : 문서/코드의 일부 조각을 의미한다.

        스니핏은 테스트 케이스 하나 당 하나의 스니핏이 생성되며, 여러개의 스니핏을 모아서 하나의 API 문서를 생성할 수 있다.
        Asciidoc : Spring Rest Docs를 통해 생성되는 텍스트 기반 문서 포맷.

        주로 기술 문서 작성을 위해 설계된 가벼운 마크업 언어이다.
        Asciidoctor : AsciiDoc 포맷의 문서를 파싱해서 HTML 5, 매뉴얼 페이지, PDF 등의 문서를 생성하는 툴.


- Spring WebFlux
    - Non-Blocking IO
        - 우리가 보통 사용하던 Spring MVC + RDBMS 패턴은 Blocking IO 방식이다.
        - Blocking IO 방식이라는 것은 요청을 처리하기 전까지는 다른 작업을 수행할 수 없는 상태라는 것을 말한다.
        - 동시에 여러 요청을 처리하기 위해서는 Thread 수를 늘려서 하는 방법이 존재하기는 하지만 오버헤드가 발생한다.
        - 이를 개선하기 위해서 나온 기술이 Non-Blocking IO 방식인 Spring WebFlux이다.
        - Spring WebFlux는 동시에 처리되어야 할 많은 요청에 대해 효율적으로 처리해 줄 수 있다.

    - 비동기
        - 스레드 풀을 이용한 동기식 호출 방식은 코드가 간단하고 순차적으로 동작하기 때문에 개발자가 코드를 직관적이고 빠르게 작성할 수 있다.
        - 동기식 호출 방식에서는 상대편의 응답이 올 때까지 스레드는 기다려야(blocking)한다.
        - 응답이 빨리 오면 그 기다림은 길지 않겠지만 만약 응답이 늦게 오면 서버가 요청에 대한 응답을 기다리는 데 스레드를 모두 소진해서 추가 요청을 처리할 수 없는 상태가 될 수 있다.
        - 특히 MSA에서는 타임아웃이 발생할 정도의 지연이 발생하면 순식간에 다른 모듈로 전파되어 전체 시스템이 마비되는 등의 악영향을 끼칠 수 있다.
        - 쓰레드가 서버로 요청을 하고 나서 꼭 응답을 기다리면서 아무 것도 하지 않고 대기해야 할까?
        - 쓰레드가 응답을 기다리지 않고 다른 일을 처리하다가 응답이 왔을 때 해당 일을 처리한다면 응답만 기다리면서 불필요하게 리소스를 점유하는 일은 없을 것이다.
        - 이러한 요구 사항에서 나온 것이 이벤트 루프를 이용한 비동기 프로그래밍이다.
        - 이벤트 루프를 활용하면 요청을 보내고 응답이 올 때까지 무작정 기다리는 대신 자신에게 할당된 다른 여러 소켓의 요청을 순차적으로 빠르게 처리한다.
        - 이제 우리의 서버와 클라이언트의 스레드는 더이상 blocking되지 않는다.
        - Spring 생태계에서도 버전 5부터 도입된 WebFlux를 통해 비동기 프로그래밍을 본격적으로 도입하고 있다.
        - 순차적으로 처리되는 방식이 아니라 디버깅이 힘들고 개발이 어렵다.


- spring boot xml로 설정했는지 java cofig로 했는데 config로 하는거랑, xml로 설정하는 것중 머가 더 편한지 편하면 왜 편하지 머가 다른지?
    Spring 프레임워크는 3.1부터 기존의 XML 설정에 더해 Java 기반의 설정까지 지원하기 시작하였다.
    초기에는 XML로 설정들을 관리할 것을 권하였지만, 이제는 다음과 같은 이유로 Java 기반의 설정을 권장하고 있다.

    1. 더 많은 정보를 얻을 수 있다.
        @Component
        public class UserFactory {
        }

        위의 코드는 @Component이라는 간단한 어노테이션만 추가되었을 뿐이다. 하지만 우리는 이를 통해 해당 어노테이션이 클래스에 적용가능하며,
        어노테이션이 붙은 클래스의 메타 정보들(패키지, 클래스 이름, 접근 제한자, 상속/구현 등) 까지 얻을 수 있다. 또한 해당 클래스는 정상적으로 빈 등록이 되어 있음을 파악할 수 있다.
        반면에 XML은 모든 설정을 명시적으로 나타내야 하며, 간단한 클래스를 지정하는 것도 상당히 번거롭다. 그리고 얻을 수 있는 정보의 양도 제한적이다.
        왜냐하면 XML은 단순 텍스트이기 때문에 해당 클래스가 다른 클래스와 어떤 관계를 갖는지 등을 알 수 없기 때문이다.

        < bean id="userFactory" class="org.mangkyu.user.UserFactory" />

        또한 우리는 해당 클래스만을 보고 빈(Bean)이 정상적으로 설정되었는지 파악하기가 어려울 것이다.
        빈의 등록정보를 파악하기 위해서는 또 다시 XML 파일을 찾아봐야 할 것이다.

    2. 설정의 변경이 용이하다.
        IDE를 통해 클래스의 위치나 이름을 바꾸는 것은 상당히 간단하다. 반면에 XML로 되어있는 설정은 단순 테스트로 되어있기 때문에 변경이 번거로우며 안전하지 못하다.
        물론 최근에 IDE가 이를 많이 지원하고 있지만, 그래도 문제를 유발할 수 있는 텍스트를 다루는 것 보다는 Java 파일을 다루는 것이 좋을 것이다.

    3. 컴파일 에러를 얻을 수 있다.
        빈 등록과 같은 설정을 진행하다 보면 빈의 클래스 이름이나 메소드 등을 작성할 때 오타가 나거나 타입이 맞지 않는 것 등을 컴파일러가 미리 잡아줄 수 있다.
        하지만 XML로 작성했을 때는 컴파일러가 이를 잡아주지 못할 뿐더러, 문제가 생겼을 경우에 원인을 찾는게 상당히 까다로워 질 수 있다.


- 모델1 vs 모델2
    - MVC1
        웹 브라우저의 요청을 JSP 페이지가 받아서 처리 하는 구조
        JSP 페이지에 비지니스 로직을 처리 하기 위한 코드와 웹 브라우저에 결과를 보여주기 위한 출력 관리 코드가 뒤섞여 있는 구조
        JSP 페이지 안에서 모든 정보를 표현(view)하고 저장(model)하고 처리(control)되므로 재사용이 힘들고, 읽기도 힘들어 가독성이 떨어진다.

        모든 클라이언트 요청과 응답을 JSP가 담당하는 구조
        단순한 페이지 작성으로 쉽개 구현 가능하다. 중소형 프로젝트에 적합
        웹 애플리케이션이 복잡해지면 유지보수 문제가 발생된다.

    - MVC2
        MVC1 구조와 달리 웹 브라우저의 요청을 하나의 서블릿이 받게 됨
        MVC 모델 2은 모델 1에서 유지보수가 힘들다는 단점을 보완하기 위해 나온 모델이다.
        기존에 뷰와 컨트롤러의 역할을 모두 수행하던 JSP는 뷰의 역할만 하게 하고, 대신 컨트롤러 역할을 Servlet이 수행한다.

        클라이언트의 요청처리와 응답처리, 비지니스 로직 처리하는 부분을 모듈화시킨 구조
        처리작업의 분리로 인해 유지보수와 확장이 용이하다. (Html과 Java 코드가 분리되어 확장에 용이하고 유지보수가 수월해진다.)
        구조 설계를 위한 시간이 많이 소요되므로 개발 기간이 증가한다.


- AOP에 대한 사실과 오해 그런데 트랜잭션을 사알짝 곁들인..
    - public 이외의 메서드는 AOP가 걸리지 않는다.
        - 실제 인텔리제이에서 private 메서드에 @Transactional 을 선언하면 위와 같이 컴파일 에러를 띄워줍니다.
        - 왜 private 메서드에는 @Transactional이 붙을 수 없을까요?
            스프링 aop에서 프록시는 크게 JDK Dynamic proxy또는 CGLIB으로 작동합니다. 그리고 spring boot 1.4 버전 이후부터는 default로 CGLIB을 사용합니다.
            CGLIB은 동적으로 상속을 통해 프록시를 생성합니다. 따라서 private 메서드는 상속이 불가능하기 때문에 프록시로 만들어지지 않는것
        - protected일 때 또한 정상 동작하지 않습니다.
            분명히 인텔리제이로 확인을 해보면 컴파일 에러는 나오지 않는다.
            JDK Dynamic proxy는 인터페이스를 기반으로 동작합니다. 따라서 protected 메서드에서는 프록시가 동작할 수 없는 것이죠.
            그래서 스프링에서는 일관된 AOP적용을 위해서 protected로 선언된 메서드 또한 트랜잭션이 걸리지 않도록 한 것입니다.
            즉, 프록시 설정에 따라 트랜잭션이 적용되었다 안되었다 하는 변칙적인 결과를 막기 위함

    - 같은 클래스내에서 트랜잭션이 걸린 메소드를 호출하면 트랜잭션이 작동하지 않는다.
        Spring AOP에서 프록시의 동작 과정을 보면 프록시를 통해 들어오는 외부 메서드 호출을 인터셉트 하여 작동합니다.
        프록시 내부에서 호출하게 됩니다. 따라서 proxy가 인터셉트하지 못해서 트랜잭션이 동작하지 않는것입니다.

        - 그렇다면 내부 메서드에서 호출은 AOP적용이 불가능하다?
            - AspectJ
                타겟 내에서 타겟의 다른 메서드를 호출할 때, 런타임에 실제 트랜잭션이 작동하지 않는다고 합니다. 즉, 런타임 시점에 작동은 안 하지만 이것을 컴파일 시점에 적용하면 된다는 것이죠.
                AspectJ는 스프링AOP와 다르게 컴파일 시점에 위빙이 이루어집니다. 따라서 AspectJ를 사용하면 self-invocation문제를 해결할수 있는 것

            - AopContext
                AopContext의 currentProxy() 메서드는 현재 AOP proxy를 반환
                @EnableAspectJAutoProxy(exposeProxy = true) 옵션을 적용해서 작동

            - 자기 자신을 호출하는 방법
                내부에서 프록시를 호출하면 인터셉터가 작동하지 않으므로 외부에서 호출하는 방식으로 해결하는 것
                    @Resource
                    @Autowired
                    @Inject

                외부에서 내부 빈으로 호출을 하므로 아래와 같이 aop가 정상 동작

                *주의: 해당 방식은 2.6 보다 낮은 버전에서 가능합니다. 스프링 부트 2.6 버전부터는 기본적으로 순환 참조를 금지하도록 변경되었습니다.
                만약 2.6 버전 이상에서 실습해보고 싶으시다면 아래의 설정을 추가하시면 됩니다.
                    spring:
                      main:
                        allow-circular-references: true


- ControllerAdvice는 AOP로 구현되어 있을까? ControllerAdvice의 동작 과정 살펴보기
    - ControllerAdvice의 동작 과정
        1. 디스패처 서블릿이 에러를 catch함
            스프링에서 모든 요청을 가장 먼저 받는 곳은 디스패처 서블릿이다. 그러다보니 에러가 발생하면 에러 처리가 시작되는 곳 역시 디스패처 서블릿인데,
            디스패처 서블릿의 핵심 메소드인 doDispatch에는 다음과 같이 모든 Exception과 Throwable을 catch하고 있다.

        2. 해당 에러를 처리할 수 있는 처리기(HandlerExceptionResolver)가 에러를 처리함
            HandlerExceptionResolver의 구현체 중에서 ControllerAdvice는 ExceptionHandlerExceptionResolver에 의해 처리된다.

        3. 컨트롤러의 ExceptionHandler로 처리가능한지 검사함
            ExceptionHandler는 Controller에 구현할 수도 있고, ControllerAdvice에도 구현할 수 있다.
            ControllerAdvice에 구현하는 것은 전역적인 반면에 Controller에 구현하는 것은 지역적이다.
            그러므로 Controller에 있는 ExceptionHandler가 우선 순위를 갖도록 먼저 컨트롤러의 ExceptionHandler를 검사한다.

        4. ControllerAdvice의 ExceptionHandler로 처리가능한지 검사함
            컨트롤러에서 갖는 ExceptionHandler로 처리가 불가능하다면 등록된 모든 ControllerAdvice 빈을 검사한다.

        5. ControllerAdvice의 ExceptionHandler 메소드를 invoke하여 예외를 반환함
            스프링은 리플렉션 API를 이용해 ExceptionHandler의 구현 메소드를 호출해 처리한 에러를 반환한다.

    - ControllerAdvice는 AOP로 구현되어 있을까?
        AOP가 적용된 것은 아니다. AOP를 적용하였으면 JDK 동적 프록시나 CGLib등을 이용해 프록시를 적용했어야 한다. 또한 AOP가 갖는 개념들이 있어야 하지만 그러한 부분 존재하지 않는다.
        ControllerAdvice는 단지 중앙 집중형으로 요청을 처리하는 디스패처 서블릿 단에서 에러 처리를 도와주는 스프링의 빈일 뿐이며 AOP로 구현된 것은 아니다.


- 스프링 첫 요청이 처리되는데 오래 걸리는 이유
    1. 스프링의 서블릿 초기화 작업들
        - 디스패처 서블릿과 서블릿의 생명 주기
            스프링에는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임하는 디스패처 서블릿이 있다.

            초기화: 요청이 들어오면 서블릿이 웹 컨테이너에 등록되어 있는지 확인하고, 없으면 초기화를 진행함
            요청 처리: 요청이 들어오면 각각의 HTTP 메소드에 맞게 요청을 처리함
            소멸: 웹 컨테이너가 서블릿에 종료 요청을 하여 종료 시에 처리해야하는 작업들을 처리함

            여기서 우리가 주목해서 봐야하는 부분은 초기화 단계이다.
            클라이언트로부터 요청이 오면 웹 컨테이너는 먼저 서블릿이 초기화 되었는지를 확인한다. 만약 서블릿이 이미 할당되어 있다면 바로 요청을 처리하지만
            그렇지 않다면 init() 메소드를 호출해 초기화를 진행하고 할당한다. SpringBoot에서는 스프링 컨테이너가 웹 컨텍스트까지 제어 가능하므로
            이미 디스패처 서블릿이 할당은 되어 있고, 초기화는 되어있지 않은 상태이다.
            init() 메소드는 첫 요청이 왔을 때 한번만 실행되기 때문에 서블릿의 쓰레드에서 공통적으로 필요로 하는 작업들이 진행되며,
            이러한 이유로 스프링은 첫 요청을 처리하는데 많은 시간을 필요로 하는 것이다.

        - 서블릿 초기화에서 진행되는 작업들
            스프링은 Lazy-Init 전략을 사용해 애플리케이션을 빠르게 구동하도록 하고 있어서, 디스패처 서블릿에 해당 도구들이 설정되지 않은 상태로 띄워지게 된다.
            그리고 서블릿 초기화 시에 애플리케이션 컨택스트로부터 해당 타입의 빈을 찾아서 디스패처 서블릿에 설정(Set)해준다. 그래야 요청을 정상적으로 처리할 수 있기 때문이다.
            이러한 작업들이 서블릿 초기화 시점에 처리되는데, 사실 이러한 부분은 성능에 많은 영향을 주지는 않는다. 오히려 JVM의 JIT 컴파일러에 의한 영향이 훨씬 크다.

    2. JIT 컴파일러의 웜업(Warm-Up)
        - 자바 언어의 동작 방식
            컴파일 언어는 컴파일 과정에서 바로 기계어를 만들어낸다. 그리고 컴파일 시에 코드 최적화까지 진행하여 처리 성능이 상당히 뛰어나다.
            대신 생성된 기계어가 빌드 환경(CPU 아키텍처)에 종속적이라서, 플랫폼이 바뀐다면 다시 빌드해야 하는 문제가 있다.

            하지만 자바는 이러한 플랫폼 종속적인 문제를 해결하고자 JVM을 도입하였고, 그래서 동작 과정이 조금 다르다.
            자바는 먼저 작성된 소스 코드를 바이트 코드로 컴파일하는데, 바이트 코드는 주로 JAR 또는 WAR로 아카이브하여 활용하게 된다.
            JVM은 아카이빙된 파일을 구동하는데, 실시간으로 바이트 코드를 기계어로 번역하면 CPU가 해당 기계어를 처리한다.
            이러한 구조 덕분에 Java는 플랫폼에 종속되지 않게 되었지만, 코드를 실행할 때 바이트 코드를 기계어로 번역하는 작업 때문에 성능이 느려졌다.
            그래서 이러한 문제를 해결하고자 JIT 컴파일러를 도입하여 사용하고 있다.

        - JIT 컴파일러(Just In Time Compiler)의 웜업(Warm-Up) 문제
            자바는 성능 문제를 해결하고자 적시에 기계어를 만들어낸다는 의미의 JIT(Just In Time) 컴파일러를 도입하여 사용하고 있다.
            JIT 컴파일러는 핫스팟이라고도 불리는데, JDK 1.3부터 반영되어 있다.
            JIT 컴파일러는 바이트 코드를 기계어로 번역하는 과정에서 캐시를 활용한다. 그래서 이미 번역된 기계어를 재사용할 수 있도록 하며,
            그에 더해 런타임 환경에 맞춰 코드도 최적화함으로써 성능을 향상시킨다.
            하지만 문제는 애플리케이션이 시작될 때에는 캐싱된 기계어가 없다는 것이고, 그래서 스프링에서 첫 요청이 오래걸리는 것이다.
            만약 요청이 많은 서비스에서 캐싱된 기계어가 없는 상태라면 배포 직후에는 응답 지연이 발생하여 문제가 발생할 수 있다.
            그래서 애플리케이션 시작 후에 강제로 로직을 호출하여 기계어를 캐싱해두는 작업이 필요한데, 이를 warm-up 이라고 한다. 트래픽이 많은 서비스라면 warm-up 작업은 반드시 고려되어야 한다.
            참고로 위에서 설명한 서블릿 초기화 보다는 JIT 컴파일러 부분이 훨씬 성능에 크게 영향을 미친다.

    3. 첫 요청이 느린 문제의 해결 방법
        스프링 애플리케이션이 실행된 후에 핵심 로직들을 강제로 호출시켜 warm-up 하면 된다. warm-up 후에 해당 서버를 투입시키는 것


- SpringBoot 실행 후에 초기화 코드를 넣는 방법
    - 커맨드라인 파라미터를 위한 CommandLineRunner
        - CommandLineRunner를 구현하는 클래스 생성
            CommandLineRunner는 스프링 부트 1.0에 추가된 함수형 인터페이스로써 스프링 애플리케이션이 구동된 후에 실행되어야 하는 빈을 정의하기 위해 사용된다.
            CommandLineRunner는 파라미터로 String 타입의 가변 인자를 받고 있으며 인터페이스 이름 그대로 커맨드 라인으로 받은 스트링 타입의 인자를 파라미터로 받아서 사용하기 위해 만들어졌다.
            CommandLineRunner는 이를 구현하는 클래스를 정의하고 빈이 등록하면 애플리케이션이 구동된 후에 자동으로 run 메소드가 실행된다.

        - CommandLineRunner를 람다식으로 구현
            우리가 필요로 하는 작업은 애플리케이션 실행 후에 1회 초기화 작업인데, 위와 같이 클래스로 만드는 것은 무거우며 번거롭다.
            CommandLineRunner는 함수형 인터페이스이므로 다음과 같이 main 클래스에 @Bean과 함께 람다식으로 구현하여 간소화할 수 있다.
                @SpringBootApplication
                public class TestingApplication {

                    public static void main(String[] args) {
                        SpringApplication.run(TestingApplication.class, args);
                    }

                    @Bean
                    public CommandLineRunner commandLineRunner() {
                        return args -> System.out.println("MangKyu");
                    }
                }

            @Bean은 @Configuration이 있는 클래스 안에서만 동작하는데, @SpringBootApplication이 갖고 있는 @SpringBootConfiguration 안에
            @Configuration이 존재하므로 메인 클래스 역시 빈으로 등록이 되어 가능한 것이다.

    - 다양한 파라미터를 위한 ApplicationRunner
        ApplicationRunner 역시 마찬가지로 함수형 인터페이스로써 스프링 애플리케이션이 구동된 후에 실행되어야 하는 빈을 정의하기 위한 인터페이스
        목적 자체는 동일하지만 ApplicationRunner는 CommandLineRunner와 달리 다양한 종류의 파라미터를 받아서 실행하는 경우에 사용할 수 있다.
        CommandLineRunner는 스프링 부트 1.0에 추가된 반면에 ApplicationRunner는 스프링 부트 2.0에 추가되었다.
        ApplicationRunner도 비슷하게 이 인터페이스를 구현하는 클래스를 등록할수도 있고 람다식으로 직접 사용할 수도 있다.
            @SpringBootApplication
            public class TestingApplication {

                public static void main(String[] args) {
                    SpringApplication.run(TestingApplication.class, args);
                }

                @Bean
                public ApplicationRunner applicationRunner() {
                    return args -> System.out.println("MangKyu");
                }
            }

    - 이벤트 수신을 위한 EventListener
        - 이벤트 리스너 등록 및 이벤트 발행
            스프링은 초기부터 애플리케이션 컨텍스트 내부에서 특정 타입의 이벤트를 던지고, 이를 리슨하는 리스너에게 전달해주는 메커니즘을 사용하고 있었다.
            그리고 우리가 이를 애플리케이션 레벨에서 이용할 수도 있는데, 특정 타입의 이벤트를 수신하기 위해서는 해당 리스너를 구현해 빈으로 등록해두면 된다.
                @SpringBootApplication
                public class TestingApplication {

                    public static void main(String[] args) {
                        ConfigurableApplicationContext context = SpringApplication.run(TestingApplication.class, args);
                        context.addApplicationListener(event -> System.out.println("MangKyu"));
                        context.publishEvent(new ApplicationEvent(context) {
                        });
                    }
                }

        - @EventListener를 사용한 이벤트 리스너 등록
            하지만 위와 같이 이벤트 리스너를 직접 구현하는 방식은 상당히 번거롭다. 그래서 스프링 4.2부터는 @EventListener 어노테이션이 추가되었는데,
            @EventListener를 스프링 빈 안에 구현해두면 리스너가 동작하게 된다.
            스프링은 애플리케이션이 준비되었을 때 ApplicationReadyEvent 타입의 이벤트를 발행하므로, 애플리케이션이 준비되었을 때 어떤 코드를 실행하기 위해서는 다음과 같이 이용할 수 있다.
                @SpringBootApplication
                public class TestingApplication {

                    public static void main(String[] args) {
                        SpringApplication.run(TestingApplication.class, args);
                    }

                    @EventListener(ApplicationReadyEvent.class)
                    public void init() {
                        System.out.println("MangKyu");
                    }

                    @EventListener
                    public void init(ApplicationReadyEvent event) {
                        System.out.println("MangKyu");
                    }
                }

            앞서 @EventListener는 스프링 빈 안에 넣어야 한다고 했는데, 앞서 살펴보았듯 메인 클래스 역시 스프링 빈으로 등록되므로
            메인 클래스 안에서 @EventListener 사용이 가능하다. 또한 @EventListener는 여러 타입의 메세지를 받을 수 있는데,
            특정 타입의 메세지를 받기 위해서는 @EventListener 어노테이션에 이벤트 타입을 넣어주면 되며, 만약 해당 타입이 파라미터로 필요하다면
            어노테이션에 적어줄 필요 없이 파라미터로만 명시해주어도 된다.
            스프링은 ApplicationReadyEvent 타입의 이벤트를 1회만 발행하는데, 위의 코드에서는 수신하는 리스너가 2개가 존재한다.
            이벤트 리스너는 기본적으로 멀티 캐스팅 관계이므로 동일한 타입의 여러 리스너가 등록되었다면 모든 리스너가 이벤트를 받게 된다.

        - 커스텀 이벤트와 커스텀 이벤트 리스너의 구현
            ApplicationListener의 제네릭 타입으로 ApplicationEvent 하위의 이벤트 클래스를 주면 해당 타입의 이벤트만을 받도록 구현할 수 있다.
            또한 직접 리스너 어노테이션을 구현할수도 있는데, 이를 코드로 작성하면 다음과 같다.
                @SpringBootApplication
                public class TestingApplication {

                    public static void main(String[] args) {
                        ConfigurableApplicationContext context = SpringApplication.run(TestingApplication.class, args);
                        context.publishEvent(new MangKyuEvent(context, "MangKyuEvent"));
                    }

                    static class MangKyuEvent extends ApplicationEvent {

                        private final String message;

                        public MangKyuEvent(Object source, String message) {
                            super(source);
                            this.message = message;
                        }
                    }

                    @Target(ElementType.METHOD)
                    @Retention(RetentionPolicy.RUNTIME)
                    @EventListener
                    @interface MangKyuListener {

                    }

                    @MangKyuListener
                    public void mangKyuEvent(MangKyuEvent mangKyuEvent) {
                        System.out.println(mangKyuEvent.message);
                    }

                }

            이러한 이벤트를 발행하고 리스너를 통해 수신하는 개발 방식은 빈들 사이의 관계를 끊어 느슨하게 함으로써 결합도를 낮출 수 있다.
            또한 이를 중심으로 개발하는 설계 등을 이벤트 주도 설계(Event Driven Architecture) 등이라고도 한다.

            스프링 부트에서는 애플리케이션의 시점에 따라 이벤트를 발행하기 위해 ApplicationEvent를 상속받는 SpringApplicationEvent 추상클래스를 구현해두었고,
            다음과 같은 구현체들 역시 만들어두었다.
                - ApplicationStartingEvent
                    애플리케이션이 실행되고나서 가능한 빠른 시점에 발행됨
                    Environment와 ApplicationContext는 준비되지 않았지만 리스너들은 등록이 되었음
                    이벤트 발행 source로 SpringApplication이 넘어오는데, 이후 내부 상태가 바뀌므로 내부 상태의 변경은 최소화해야 함
                - ApplicationContextInitializedEvent
                    애플리케이션이 시작되고 애플리케이션 컨텍스트가 준비되었으며 initializer가 호출되었음
                    하지만 빈 정보들은 불러와지기 전에 발행됨
                - ApplicationEnvironmentPreparedEvent
                    애플리케이션이 실행되고 Environment가 준비되었을 때 발행됨
                - ApplicationPreparedEvent
                    애플리케이션이 시작되고 애플리케이션 컨텍스트가 완전히 준비되었지만 refresh 되기 전에 발행됨
                    빈 정보들은 불러와졌으며 Environment 역시 준비가 된 상태임
                - ApplicationStartedEvent:
                    애플리케이션 컨텍스트가 refesh 되고나서 발행됨
                    ApplicationRunner와 CommandLineRunner가 실행되기 전의 시점임
                - ApplicationReadyEvent:
                    애플리케이션이 요청을 받아서 처리할 준비가 되었을 때 발행됨
                    이벤트 발행 source로 SpringApplication이 넘어오는데, 이후에 초기화 스텝이 진행되므로 내부 변경은 최소화해야 함
                - ApplicationFailedEvent
                    애플리케이션이 실행에 실패했을 때 발행됨

            위의 3가지 중에서 편한 방법을 이용하면 애플리케이션 실행 시에 warm-up을 시킴으로써 첫 요청이 느린 문제를 해결할 수 있다.
            물론 이벤트 리스너는 비지니스 로직에서 불필요하게 연관관계가 복잡해지는 문제들을 해결하기 위해서도 사용할 수 있다.
            이러한 경우에 만약 트랜잭션과 연관된 작업이라면 @TransactionalEventListener를 사용해주면 된다.


- 의존성(Dependency)이란? 컴파일타임 의존성과 런타임 의존성의 차이 및 비교
    - 의존성(Dependency)이란?
        - 의존성(Dependency)이란?
            객체의 세계에서 협력은 필수적이며, 객체가 협력한다는 것은 객체 간의 의존성이 존재한다는 것
            여기서 의존성이란 파라미터나 리턴값 또는 지역변수 등으로 다른 객체를 참조하는 것을 의미

        - 의존성 전이, 의존성(Dependency)이 위험한 이유
            의존성은 객체 간의 협력을 위해 필수적이다. 하지만 의존성은 위험하므로 의존성은 최소화되어야 한다.
            왜냐하면 한 객체가 다른 객체에 의존한다는 것은 다른 객체가 변할 때 변경이 전파될 수 있다는 것을 의미. 이를 의존성 전이
            이러한 것들은 불필요한 변경이므로 개방 폐쇠 원칙을 준수하도록 의존성 전이를 최소화해야 한다.
            의존성 전이를 최소화하기 위해서는 컴파일 타임 의존성이 아닌 런타임 의존성을 가져야 한다.

    - 컴파일타임 의존성과 런타임 의존성
        - 컴파일타임 의존성
            코드를 컴파일하는 시점에 결정되는 의존성이며, 클래스 사이의 의존성에 해당
            일반적으로 추상화된 클래스나 인터페이스가 아닌 구체 클래스에 의존하면 컴파일타임 의존성을 갖게된다.
            컴파일타임 의존성은 결합도가 높다.
            소프트웨어 세계에서 결합도는 낮을수록 좋은데, 결합도를 낮추고 바람직한 의존성을 갖기 위해서는 결국 런타임 의존성을 가져야 한다.

        - 런타임 의존성
            코드(애플리케이션)를 실행하는 시점에 결정되는 의존성이며, 객체 사이의 의존성에 해당
            일반적으로 추상화된 클래스나 인터페이스에 의존할 때 런타임 의존성을 갖게 된다.
            런타임 의존성은 추상클래스 또는 인터페이스에 의존하므로 컴파일 시점에 어느 객체에 의존하는지 알지 못한다.
            컴파일 시점에는 딱 비밀번호를 암호화해야 한다는 것만 알고 있을 뿐, 실행될 때 어떠한 객체를 주입받아서 어떤 PasswordEncoder와 결합되는지 알 수 있다.
            이러한 이유로 런타임 의존성은 결합도가 낮으며 다른 객체들과 협력할 가능성을 열어두므로 변경에 유연한 설계를 갖는다.

    - 컴파일타임 의존성과 런타임 의존성 차이 및 비교 정리
        - 컴파일타임 의존성
            - 코드를 컴파일하는 시점에 결정되는 의존성
            - 클래스 사이의 의존성
            - 결합도가 높으며 변경에 유연하지 못함

        - 런타임 의존성
            - 코드(애플리케이션)를 실행하는 시점에 결정되는 의존성
            - 객체 사이의 의존성
            - 결합도가 낮으며 변경에 유연함


- spring di는 -> di에 사용된 디자인 패턴은 -> 디자인패턴의 예시설명
    - 전략 패턴?

- 주입이랑 spring aop차이를 아냐

- spring의 핵심기능에 대해 말해주세요.

- spring에서 사용한 최신버전은?

- spring aop 동작 원리

- 다이나믹 프록시랑 cglib proxy 차이점은? cglib proxyj는 클래스기반만 가능한가?

- 의존 역전 법칙은 스프링에 어떤 연관이 있냐?

- 스프링 IOC, DI

- IOC가 왜 스프링 장점인지

- 트랜잭션 처리 어떻게 하는지

- 트랜잭션 프로파게이션?(전파레벨)