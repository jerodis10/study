- Spring과 SpringBoot의 차이점
    (1) 내장 톰캣
        - 내장 톰캣을 사용하기 때문에 따로 톰캣을 설치하거나 매번 버전을 관리해 주지 않아도 된다.
    (2) starter를 통한 dependency를 자동화
        - 기존의 Spring에서는 dependency들의 호환되는 버전을 직접 설정
        - 스프링 부트에서는 이 starter를 통해 종속된 모든 라이브러리를 알맞게 찾아서 함께 가져오기 때문에 의존성이나 호환버전에 대해 신경 쓸 필요가 없다.
    (3) XML
        - View Resolver, 데이터 액세스 등의 xml 설정을 하지 않아도 된다.
    (4) jar
        - jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.
    (5) AutoConfigurator
        - 공통적으로 필요한 설정을 어노테이션을 이용하여 대신할 수 있다.
    (6) Spring Initializr
        - pring Initilizr를 사용하면 실행 환경이나 의존성 관리 등의 인프라 부분을 신경 쓸 필요 없이 바로 코딩을 시작할 수 있게끔 환경을 제공


- Spring Framework에 대해 설명해주세요.
    - 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크

    - 경량 컨테이너로서 자바 객체를 직접 관리
        각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
    - 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
        컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 다라 스프링에서 사용자의 코드를 호출한다.
    - 의존성 주입(DI, Dependency Injection)을 지원
        각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
    - 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
        트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.


- 스프링이란?
    - Java 기반의 엔터프라이즈 Application 개발을 빠르고 편하게 할 수 있도록 도와주는 경량 프레임워크.

    - 왜 '경량' 프레임워크인가?
        초기 서버사이드 처리는 직접 쓰레드, 소켓연결 등을 개발자들이 직접 처리했고, 개발자 마다 구현하는 방법이 다 달라 협업에 불편함이 많았다.
        정형화, 표준화 된 방법을 찾기 시작하면서 등장한 것이 Framework이다.
        EJB가 나왔지만 분산환경 처리에 특화된 EJB는 너무 무거운데다 불편한 점이 많았고, 이런 EJB에 반기를 들고 탄생한 '경량화'된 Java 엔터프라이즈용 Framework이 Spring인 것이다.

    - 왜 스프링을 사용하는가?
        스프링은 Framework이고, Framework은 개발자들이 좀 더 쉽고 편리하게 애플리케이션을 개발할 수 있도록 미리 갖춰진 구조를 말한다.
        Framework이 없었다면 개발자들은 처음부터 끝까지 직접 모든 구조를 만들어내야 할 것이다.
        스프링은 Application 개발에 필요한 하부 구조를 포괄적으로 제공함에 따라 개발자들의 실력의 간극을 메꿔줄 수 있는 데다가
        올바른 형태의 코드만 넣어준다면 일정 수준의 성능과 안정성을 보장해 줄 수 있다. 그 틀과 구조 위에서 개발자들은
        핵심 비즈니스 로직에만 집중할 수 있어서 생산성 또한 향상된다.


- 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.
    - 객체에 대한 제어권이 개발자에게 있는 것이 아닌, 스프링 컨테이너에게 있는 것. 인스턴스의 생성부터 소멸까지의 라이프싸이클 관리 등을 컨테이너가 대신 해준다.
    - 일반적으로 프로그램의 흐름은 main()메서드처럼 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고, 생성하고, 오브젝트의 메서드를 호출하고,
      그 메서드 안에서 다음에 사용할 것을 결정하는 식의 작업이 반복되는데, 스프링프레임워크에서는 애플리케이션 코드가 프레임워크에 의해 사용되어지는 구조
      애플리케이션 컨텍스트가 빈의 생성과 관계설정 같은 제어를 담당한다.

    - 제어의 역전(IoC)란 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다.
    - 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고
      컨테이너에 등록한 객체들을 '빈'이라고 합니다.


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것. 이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있습니다.

    - 제어의 역행(IOC)으로 특정 객체에 필요한 다른 객체를 외부에서 결정해서 연결시키는 것.
    - 설정만 해준다면(applicationContext.xml) 스프링은 그 설정 정보를 참고해서 객체를 생성,관리하고 그 관계를 맺어준다.
    - 핵심은 개발자가 new 연산자 등을 통해 객체를 생성할 필요가 없다는 것이다(제어의 역행-IoC).
    - 개발자 입장에서는 스프링 컨테이너에게 그 참조변수만 일러준다면(@Autowired나 setter주입 등) 스프링이 알아서 객체를 생성해주고, 관계를 맺어준다. 이를 의존성 주입 이라고 한다.

    - 의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3 가지 방법이 있습니다. 이 중 Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법입니다.
        1. 순환 참조를 방지
            - 생성자 주입 방식은 필드나 수정자 주입과는 빈을 주입하는 순서가 다르기 때문
            - 필드/수정자 주입은 먼저 빈을 생성한 후, 주입하려는 빈을 찾아 주입.
            - 하지만 생성자 주입은 먼저 생성자 인자에 사용되는 빈을 찾거나 빈 팩토리에서 만든다.
              그 후에 찾은 인자 빈으로 주입하려는 빈의 생성자를 호출
            - 객체 생성 시점에 빈을 주입하기 때문에 서로 참조하는 객체가 생성되지 않은 상태에서 그 빈을 참조하기 때문에 오류가 발생

            - 생성자를 통한 의존성 주입의 장점은 객체 생성 시점에서 순환 참조가 일어나기 때문에 스프링 애플리케이션이 실행되지 않습니다.
            - (앱 구동 단계에서 오류를 찾을 수 있다.)
            - 컨테이너가 빈을 생성하는 시점에서 객체생성에 사이클 관계가 생기기 때문입니다.
        2. final 선언 가능
            - 런타임에 객체 불변성 보장
        3. 테스트 코드 작성 용이
            - 스프링 컨테이너 도움 없이 테스트 코드를 더 편리하게 작성 가능
            - 테스트하고자 하는 클래스에 필드/수정자 주입으로 빈이 주입되어 있으면, Mockito를 이용해 목킹한 후 테스트 해아함.
            - 하지만 생성자 주입은 단순히 원하는 객체를 생성한 후, 생성자에 넣어주면 된다.
            - 생성자 주입이 아닌 다른 주입으로 작성된 코드는 순수한 자바 코드로 단위 테스트를 작성하는 것이 어렵다.
              필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는
              필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양


- Bean Factory(빈팩토리)/Application Context(애플리케이션 컨텍스트)란?
    - 빈 팩토리
        - 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트.
        - 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당하지만
          보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다.

    - 애플리케이션 컨텍스트
        - IoC 방식을 따라 만들어진 일종의 빈 팩토리.
        - 빈 팩토리를 확장한 IoC 컨테이너로, 빈을 등록하고 관리하는 기본 기능은 빈 팩토리와 동일하나 스프링이 제공하는 각종 부가 서비스를 추가로 제공


- 스프링 컨테이너(Spring Container)란?
    - 빈의 생성,관계설정,생명주기 등을 관장하는 컨테이너.

    - 객체(빈)관리의 관점에서 Application Context를 스프링 컨테이너라고 부른다.
    - Application Context는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데,
      그러한 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용되고, 이를 통틀어서 스프링 컨테이너라고 볼 수 있다.


- 빈(Bean)이란?
    - 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트.

    - 스프링 빈은, 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 IoC가 적용된 오브젝트를 가리키는 말이다.
    - 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니고, 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
    - POJO와 설정(Configuration. xml이나 어노테이션)을 Spring의 컨테이너에 주입시키면 Bean으로 등록되고 사용할 수 있다.


- POJO
    어느 곳에 종속되지 않은 순수한 자바 객체.

    과거에 자바로 웹 애플리케이션을 만들기 위해 Servlet클래스를 상속받아 구현했어야 했다. 서블릿 컨테이너 안에서 서블릿으로 존재하기 위해서는 그 구현이 강제되었던 것이다.
    그렇게 강제된 구현으로 만들어진 서블릿 객체는 서블릿 컨테이너 환경에서 사용되어질 수 있다. 이는 그 환경에 종속 되어 있기에 POJO라고 할 수 없다.
    어느 곳에 종속되지 않는다는 의미는, 해당 클래스를 사용하기 위해 외부 환경(like 프레임워크)이 필요하고, 해당 환경이 특정 인터페이스를 구현할 것을 강요하는 등의 제약에서 자유롭다는 것을 의미한다.
    (따라서 단순히 외부 구동환경과 무관한 다른 클래스의 상속 또는 구현은 상관 없다.)
    즉, 다시말해 POJO는 외부환경(like Spring MVC)을 걷어내도 정상적으로 작동이 되어야 한다는 것이다.
    Spring은 개발자가 직접 위와같이 Servlet클래스를 작성하지 않고 POJO만으로 웹 애플리케이션을 구축할 수 있다는 것이 특징이다.(개발자가 비즈니스로직만 신경 쓸 수 있다)

    스프링에서 생성되어 관리되는 POJO 기반의 객체를 Spring Bean이라고 합니다.
    여기서 POJO는 단순 getter, setter만으로 구성되어 있으며 단순히 new를 통해서 생성 가능한 형태를 말합니다.
    핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있고, 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스입니다.


- Bean Scope
    - 스프링 빈(Spring Bean)이란?
        - 스프링 IoC 컨테이너에 의해서 관리되고 애플리케이션의 핵심을 이루는 객체들을 스프링 빈
        - 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서,
          강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있는데 대표적으로 프로토타입 스코프가 있다.
          프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할때마다 매번 새로운 오브젝트를 만들어 준다. 스코프는 xml과 어노테이션 설정으로 가능하다.

    - Scope의 종류
        - Singleton
            - 스프링 빈은 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때까지 1개의 객체로 유지
        - Prototype
            - 요청이 오면 항상 새로운 인스턴스를 생성하여 반환하고 이후에 관리하지 않음
            - 프로토타입을 받은 클라이언트가 객체를 관리해야 함
                - 스프링 컨테이너는 프로토타입 스프링 빈의 생성과 의존관계 주입까지만 관여하고 이후의 과정은 관여하지 않는다.
                    (이후는 해당 빈을 호출한 사용자에 의해서 종료된다.)
                  스프링 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 처리.
                  @PreDestroy같은 종료 메서드가 호출 되지 않는다.
        - Web
            - Request: 각각의 요청이 들어오고 나갈 때까지 유지되는 scope (HTTP Request의 생명주기와 같음)
            - Session: 세션이 생성되고 종료될 때까지 유지되는 scope (HTTP Session의 생명주기와 같음)
            - Application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 scope

    - 왜 스프링 빈은 기본적으로 싱글톤일까?
        Spring Framework의 핵심은 스프링 컨테이너. 이 컨테이너는 객체를 갖고 있다가 필요할때 주입한다. 왜 그렇게 동작할까?
        서버는 많은 사람들이 사용하고 그 사용자들이 이용할 비즈니스 로직은 대부분 동일하다.
        동일한 비즈니스 로직(빈)이 이용하는 사람들마다 하나씩 생성된다면 서버는 부하에 걸리기 쉽고 애초에 동일한 로직이
        여러개 생성될 필요가 없기 때문에 스프링에서는 빈들을 싱글톤으로 관리한다.

    - 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
        - 싱글톤 스프링 빈 내부에 의존관계로 주입되는 스프링 빈이 프로토타입인 경우
            - 프로토타입 스코프의 스프링 빈이 새로 생성되기는 했지만 싱글톤 빈과 함께 사용되기 때문에 계속 유지된다.
            - 싱글톤 빈과 함께 사용하면서 프로토타입 빈이 자기의 스코프를 지키고 매번 새롭게 생성하기 위해서는 어떻게 해야 할까?

            - 의존관계를 외부에서 주입(DI) 받는 것이 아닌 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색)이라 한다.
            - ObjectProvider의 getObject()를 호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
            - 스프링의 의존성이 마음에 들지 않으면 JSR-330 자바 표전을 사용하는 방법이 있다.

    - 프로토타입 빈을 언제 사용해야 하는가?
        - 여러 인스턴스를 검색해야 하는 경우
        - 인스턴스를 지연 혹은 선택적으로 찾아야 하는 경우
        - 순환 종속성을 깨기 위해서
        - 스코프에 포함된 인스턴스로부터 더 작은 범위의 인스턴스를 찾아 추상화 하기 위해서 사용한다.


- 스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요.
    - 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료

    - 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리
        1. 인터페이스( InitializingBean, DisposableBean )
        2. 설정 정보에 초기화 메소드, 종료 메소드 지정
        3. @PostConstruct, @PreDestroy 어노테이션 지원


- spring bean 생명주기
    1. 빈 객체 생성
    2. BeanNameAware.setBeanName()
        의 id/name 속성에 지정된 값 전달
            - 스프링에서 관리되는 bean 내부에서 id나 name이 무엇으로 지정되어 있는지 확인하는 경우 BeanNameAware Interface를 구현한다.
            - 이때 그림의 노란색 부분처럼 bean생성과 property 의존성 주입을 완료한 이후, init method를 수행하기 전 시점에 호출된다.
    3. BeanFactoryAware.setBeanFactory()
        - bean객체에 bean을 관리하는 BeanFactory 객체 전달
    4. BeanPostProcessor의 초기화 전처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 되기전 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
    5. 커스텀 init - method
        - @PostConstruct
    6. InitializingBean.afterPropertiesSet()
    7. BeanPostProcessor의 초기화 후처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 된 후 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
        - postProcessAfterInitialization
    8. 빈 객체 사용
    9. DisposableBean.destroy()
    10. 커스텀 destroy - method 2_8_ii


- Servlet
    - Servlet 정의
        - 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램이 서블릿
        - 서블릿은 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해주는 기술

    - Servlet 특징
        - 서블릿 등장 이전에는 CGI (Common Gateway Interface) 기술이 있었는데 이는 요청 당 프로세스를 생성함
            - 서블릿은 CGI에 비해서 작동이 빠르고, 플랫폼에 독립적이며, 보안이 좋고, 이식성이 강함
        - html을 사용하여 요청에 응답
        - 서블릿 객체는 싱글톤으로 관리
            - 고객의 요청이 올 때마다 생성하는 것은 비효율적이기 때문
            - 서블릿 컨테이너가 종료되면 서블릿도 종료

    - 서블릿 컨테이너(Servlet Container)
        - 정의
            - 서블릿을 관리해주며 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하며 post, get여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.
                - HttpServletRequest
                    - http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의
                      정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있다.
                - HttpServletResponse
                    - WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여
                      서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송한다.

        - 특징
            - java thread를 사용해서 서블릿을 호출
            - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함

        - 주요 기능
            - 서블릿의 생명주기를 관리
                - 서블릿 컨테이너가 기동 되는 순간 서블릿 클래스를 로딩해서 인스턴스화하고, 초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작한다.
                  그리고 서블릿의 생명이 다하는 순간 가비지 컬렉션을 통해 메모리에서 제거한다.

            - 통신 지원
                - 클라이언트의 Request를 받아주고 Response를 보낼 수 있게 웹 서버와 소켓을 만들어서 통신을 해준다.
                - 블릿 컨테이너는 이렇게 소켓을 만들고 listen, accept 등의 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해주고 개발자로서 비즈니스 로직에 더욱 집중할 수 있게 만들어준다.

            - 멀티스레딩 관리
                - 해당 서블릿의 요청이 들어오면 스레드를 생성해서 작업을 수행한다.

            - 선언적인 보안관리


- 서블릿의 동작 방식에 대해 설명해주세요.
    1. 사용자(Client)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다.
    2. 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
    3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
    4. 해당 서블릿에서 service메소드를 호출한 후 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
    5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다.
    6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.


- MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.
    1. 클라이언트는 URL을 통해 요청을 전송한다.
    2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
    3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
    4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
    5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
    6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
    7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
    8. 데이터가 추가된 뷰를 반환한다.


- @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요.
    - @RequestBody
        - 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할
        - 값을 주입하지 않고 값을 변환 시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다.

    - @RequestParam
        - 1개의 HTTP 요청 파라미터를 받기 위해 사용.
        -  필수 여부 설정 가능

    - @ModelAttribute
        - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자,Getter,Setter를 통해 주입하기 위해 사용
        - 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter,Setter가 없으면 변수들이 저장되지 않는다.


- AOP
    - AOP 가 무엇일까
        - Aspect Oriented Programming
        - 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 반복 작업을 줄이고 핵심 비즈니스 로직 개발에만 집중할 수 있음

        - 사용 목적에 따라
            - 프록시 패턴: 클라이언트가 타깃에 접근하는 방법 제어
            - 데코레이터 패턴: 타깃에 부가적인 기능 부여

    - AOP 의 용어들
        - Target Object
            - 부가 기능을 부여할 대상
            - 먼저 Target Object는 횡단기능(Advice)이 적용될 객체(Object)를 뜻한다.
            - 이 객체는 핵심 모듈(비즈니스 클래스)이라 할 수 있다. Spring AOP에선 Advice를 받는 객체라 하여 Adviced Object라는 용어로 쓰이기도 한다.
            - Spring AOP에선 실제 적용할 객체 대신 Runtime Proxy를 사용하여 구현되기 때문에, Target Object는 항상 Proxy Object다.
        - Aspect
            - 부가 기능을 정의한 Advice 와 어드바이스를 어디에 적용할 지 결정하는 Pointcut 을 함께 가짐.
        - Advice
            - 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.
            - Advice는 JoinPoint에 적용할 횡단 코드를(공통코드) 의미한다. 어떤 부가 기능 ? Before , AfterReturing , AfterThrowing , After , Around
        - JoinPoint
            - 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
            - JoinPoint는 Target Object안에서 횡단기능(Advice)이 적용될 수 있는 여러 위치를 뜻한다. 어디에 적용할 것인가? 메서드 , 필드 , 객체 , 생성자등
        - Pointcut: 어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

    - AOP 구현 방법
        - 컴파일 시점에 코드에 공통 기능 삽입
        - 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
            - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
              좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            (런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.)

    - Spring 에서 AOP 를 구현한 방법
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
            - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
            - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
            - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용

    - target 에 여러 AOP 가 동시에 적용되어도, 스프링의 AOP 는 target 마다 하나의 프록시만 생성한다.

    - 동적 프록시
        - JDK 동적 프록시
            - 인터페이스를 기반으로 동적 프록시

        - CGLIB
            - 구체 클래스만 가지고 동적 프록시

        - 프록시 팩토리
            - 실제객체의 인터페이스의 유무에 무관하게 프록시객체를 생성 가능
            - 둘을 개념적으로 추상화 한 것

        - 빈후처리기
            - 프록시객체를 빈으로 등록해야 하므로 수동 빈 등록만 가능하고 Config 에서 모든 빈마다 프록시객체를 생성해줘야하는 번거로움이 있다.
            - 객체를 빈으로 등록하기 직전에 프록시객체로 바꿔줄 수 있는 빈 후처리기
            - 자동빈 등록도 프록시가 적용 가능하며, 일일이 프록시객체를 생성할 필요 없다.

            - 자동 프록시 생성기는 2가지 일을 한다.
                1. @Aspect 를 보고 어드바이저( Advisor )로 변환해서 저장한다.
                2. 어드바이저를 기반으로 프록시를 생성한다.


- spring aop vs aspectj
    - spring aop
        - 런타임 위빙 만 사용할 수 있다
        - 덜 강력 함 – 메서드 수준 위빙 만 지원
        - Spring 컨테이너가 관리하는 Bean에서만 구현 가능
        - AspectJ보다 훨씬 느림
            Runtime weaving: Aspect 가 대상 객체의 Proxy(JDK 동적 Proxy 나 CGLIB 의 Proxy)를 실행시 Weaving 된다

    - aspectj
        - 런타임때 아무것도 안한다. Aspect를 코드에 Weaving하기 위해, AspectJ compiler(ajc)라는 컴파일러를 도입한다.
        - 컨파일 시점 위빙
        - 더욱 강력 함 – 필드, 메서드, 생성자, 정적 이니셜 라이저, 최종 클래스 / 메서드 등을 엮을 수 있다
        - 모든 도메인 개체에서 구현 가능
        - 모든 포인트 컷 지원
        - 애플리케이션이 실행되기 전에 (런타임 전에) Aspect가 코드로 직접 짜여짐


- jdk dynamic proxy vs CGLIB(code Generator Library)
    - Spring AOP는 프록시 기반으로 JDK Dynamic Proxy와 CGLIB을 활용하여 AOP 제공하고 있습니다.
    - JDK Dynamic Proxy는 인터페이스를 구현하여 Proxy를 생성
    - CGLib은 클래스를 상속받아 Proxy를 생성
    - 성능의 차이
        - 성능의 차이의 근본적인 이유는 CGLib은 타깃에 대한 정보를 제공 받기 때문입니다.
        - 따라서 CGLib은 제공받은 타깃 클래스에 대한 바이트 코드를 조작하여 Proxy를 생성


- AOP가 Proxy 방식이라 발생할 수 있는 단점(self invocation)
    - 같은 객체의 자신의 메소드 외의 다른 메소드를 호출 시 AOP 적용되지 않는 것
    - self-invocation 해결 방법
        - AopContext 이용
        - 자기 자신을 빈으로 등록 후, 메소드 호출
        - AspectJ Weaving 방식으로 변경


- Filter vs Interceptor vs AOP
    - Filter
        - 필터에서는 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리
        - Filter는 다음 체인으로 넘기는 ServletRequest/ServletResponse 객체를 조작할 수 있다는 점에서 Interceptor보다 훨씬 강력한 기술
        - 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리되므로 DispatcherServlet으로 가기 전에 요청을 처리하는 것

        ex) 보안 관련 공통 작업
            모든 요청에 대한 로깅 또는 감사
            이미지/데이터 압축 및 문자열 인코딩

    - 인터셉터(Interceptor)
        - 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트 내부에서 Controller에 관한 요청과 응답에 대해 처리
        - 스프링의 모든 빈 객체에 접근할 수 있다.
        - 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다.
        - 필터와 다르게 HttpServletRequest나 HttpServletResponse 등과 같은 객체를 제공받으므로 객체 자체를 조작할 수는 없다.

        ex) 인증/인가 등과 같은 공통 작업
            API 호출에 대한 로깅 또는 감사
            Controller로 넘겨주는 정보(데이터)의 가공

        - Filter의 doFilter 메서드는 매개변수로 ServletRequest와 ServletResponse를 받고 Interceptor의 preHandle이나 postHandle은 HttpServletRequest를 받는다.
        - ServletRequest는 기본적인 클라이언트 요청에 관한 모든 정보를 가지고 있다. 그리고 이 인터페이스는 다시 HttpServletRequest로 확장하여
          HTTP 프로토콜 상에서 할 수 있는 일들이 포함되어져 있다.
          이 HttpServletReqeust는 서블릿의 service의 매개변수의 하나로 서블릿 프로그래머가 클라이언트의 요청에 관한 작업들을 핸들할 수 있도록하는 중요한 역할을 담당하고 있다.

    - AOP
        - Interceptor와 Filter와 달리 메소드 전 후의 지점에 자유롭게 설정이 가능하며 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.
        - 로깅, 트랜잭션, 에러 처리 등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용


- Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.
    - Spring Filter
        - 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리
        - Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공
        ex) 보안 및 인증/인가 관련 작업
            모든 요청에 대한 로깅 또는 검사
            이미지/데이터 압축 및 문자열 인코딩
            Spring과 분리되어야 하는 기능

    - Interceptor
        - 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작
        - Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
        ex) 세부적인 보안 및 인증/인가 공통 작업
            API 호출에 대한 로깅 또는 검사
            Controller로 넘겨주는 정보(데이터)의 가공


- @Transactional의 동작 원리에 대해 설명해주세요.
    - @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며,
      Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행합니다.


- @Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다.
      즉, A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않은 일반 코드가 수행됩니다.


- @Transactional 이 동작하지 않을 때
    - @Transactional을 선언한 함수 내부에 try-catch구문
        에러를 밖으로 던져야 하는데 내부적으로 잡아버리니 함수는 성공 처리된다.
        성공으로 처리되기 때문에 트랜잭션이 롤백되지 않는다.

    - @Transactional을 선언한 함수를 같은 클래스에서 호출할 경우
        @Transactional은 스프링 AOP기반으로 동작하기 때문에 같은 클래스 내부의 함수를 호출한 경우 동작하지 않는다.

    - @Transactional이 걸린 함수가 private인 경우
        사실 private 로 선언되었다는 것은 같은 클래스 내부의 함수에서 호출된다는 말이므로 위의 2번과 같은 내용이다.

    - @Transactional이 걸린 함수 내부에서 CheckedException이 발생한 경우
        Checked Exception는 복구가 가능하다는 메커니즘을 가지고 있기 때문에 Rollback 이 아닌 일반적인 코드 흐름으로 제어해야 함


- A 라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때,
  @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.
      그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다.


- 선언적 트랜잭션 속성
    - propagation
        - 트랜잭션 전파란 트랜잭션 경계에서 이미 진행중인 트랜잭션이 있을 경우 어떻게 동작할지 결정하는 것

        - REQUIRED (디폴트)
            - 이미 시작된 트랜잭션이 있으면 그 트랜잭션에 참여
            - 모든 트랜잭션 매니저가 지원합니다.
            - 해당 메서드를 호출한 곳에서 별도의 트랜잭션이 설정되어 있지 않다면 트랜잭션을 새로 시작
            - 부모 트랜잭션이 존재하면 포함되어 동작

        - SUPPORTS
            - 진행 중인 트랜잭션이 있으면 REQUIRED 처럼 참여하고 트랜잭션이 없으면 트랜잭션 없이 메서드를 실행
            - 해당 경계 안에서 Connection 객체나 하이버네이트의 Session 등은 공유 가능

        - MANDATORY
            - 진행 중인 트랜잭션이 있으면 참여하고 없으면 예외가 발생. 혼자서는 트랜잭션을 시작할 수 없고 메서드를 실행할 수도 없다.
            - 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용

        - REQUIRES_NEW
            - 항상 새로운 트랜잭션을 시작한다. 진행중인 트랜잭션이 있으면 잠시 보류시키고 새로운 트랜잭션으로 실행
            - 새로운 트랜잭션 안에서 예외가 발생해도 호출한 곳으로 롤백이 전파되지 않는다
            - 부모 트랜잭션이 존재하면 2개의 트랜잭션이 완전 독립적으로 동작

        - NOT_SUPPORTED
            - 이미 시작된 트랜잭션이 있으면 보류하고 자신의 메서드를 실행하는, 트랜잭션을 사용하지 않는 설정
              진행중인 트랜잭션이 있으면 보류하고 자신의 메서드 실행
            - 트랜잭션을 사용하지 않는다.
            - 부모 트랜잭션이 존재하면 보류시키고 트랜잭션 사용을 정지시킨다

        - NEVER
            - 트랜잭션을 사용하지 않도록 강제. 진행중인 트랜잭션이 없다면 자신의 메서드를 실행하지만 트랜잭션이 있다면 예외 발생

        - NESTED
            - 이미 진행 중인 트랜잭션 있으면 그 안에 새로운 트랜잭션을 만드는 설정.
            - 트랜잭션1 내부에 메서드 2를 트랜잭션 2로 삽입
            - 이렇게 중첩된 트랜잭션 2는 부모인 트랜잭션1의 커밋/롤백에는 영향을 받지만,
              트랜잭션2의 커밋/롤백에는 트랜잭션1이 영향을 받지 않는다.
            - 부모 트랜잭션의 커밋과 롤백에 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않는다
                예시) 메인작업을 진행하며 이와 관련된 로그를 DB에 저장
                     메인 작업이 실패 -> 로그 작업 롤백
                     로그를 저장하는 작업이 실패 -> 메인 작업의 트랜잭션은 롤백 X
            - 모든 트랜잭션 매니저에 적용 가능하진 않다.


- 트랜잭션 전파 방식
    - 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성

    - REQUIRED: 현재 진행중인 트랜잭션이 있으면 그것을 사용하고, 없으면 생성한다. [DEFAULT 값]
    - MANDATORY: REQUIRED와 비슷. 현재 진행중인 트랜잭션이 있으면 그것을 사용하고, 없으면 Exception 발생. 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용
    - REQUIRES_NEW: 항상 새로운 트랜잭션을 시작.
    - SUPPORTS: 이미 진행중인 트랜잭션이 있으면 그것을 사용. 없으면 그냥 트랜잭션 없이 진행.
    - NOT_SUPPORTED: 트랜잭션 사용하지 않게 한다. 이미 진행중인 트랜잭션이 있으면 보류
    - NEVER: 트랜젝션을 사용하지 않도록 강제한다. 이미 진행중인 트랜잭션도 존재하면 안됨. 있다면 예외 발생


- REQUIRES_NEW는 부모 트랜잭션에서 완전 독립적인 트랜잭션을 생성하는가 ?
    - 새롭게 생긴 자식 트랜잭션에서 Exception이 발생하면 부모 트랜잭션까지 전파된다.
      왜냐면 스프링에서 트랜잭션은 thread-local을 기반으로 동작한다.
      TransactionSynchronizationManager는 관련 리소스들을 쓰레드 로컬에 보관하고있다. 트랜잭션 매니저는 이녀석을 이용해서 리소스를 사용한다.
      REQUIRES_NEW는 별도의 새로운 트랜잭션(커넥션도 실제 다르다)을 만들 뿐, 쓰레드는 동일하다.

    - 그럼 어떤 경우에 REQUIRES_NEW 전파 레벨을 사용하는 것이 좋을까?
        - 부모 트랜잭션에서 Exception이 발생해도 자식 트랜잭션은 커밋이 되어야 하는 경우
        - 부모 트랜잭션에서 자식 트랜잭션을 try - catch 하고 싶은 경우
            - 부모 트랜잭션 커밋, 자식 트랜잭션 롤백


- 트랜잭션 read only에 동작 방식
    - Oracle
        - Read Only 트랜잭션을 이용할 경우 이 트랜잭션이 시작되기 이전에 커밋된 데이터만 접근할 수 있으며, 트랜잭션 실행되는 동안 커밋되는 데이터는 결과에 반영되지 않는다.
        - 해당 트랜잭션 시에 지원하는 DML은 SELECT(조회) 구문뿐이다.
        → 해당 트랜잭션 내에서 일관적인 데이터를 얻도록(데이터 일관성) 보장한다. 즉 성능 이점만을 위함이 아니다.


- Read only Transaction을 사용하는 일반적인 이유
    - 해당 설정을 사용한 트랜잭션은 데이터(테이블, 칼럼)에 대하여 Lock을 적용할 필요가 없고 접근할 수 있는 데이터가 (스냅샷, 튜플 등) 변경되지 않기 때문에, 일관적인 데이터를 읽어오고 제공할 수 있다.
    - 해당 속성의 경우 일반적으로 트랜잭션 ID를 부여하지 않아도 되기에 불필요한 ID 설정에 대한 오버헤드가 발생하지 않기 때문에 성능의 이점을 볼 수 있다.
    - 추가적으로 읽기-쓰기 트랜잭션을 위해 구성되는 별도 스냅샷의 총 수가 줄어든다.


- 스프링에서 어떤 exception에서 롤백처리를 하냐?
    - 스프링의 Transcational 어노테이션은 기본 정책이 Unchecked Exception과 Errors 이다.
      즉, Checked Exception일 경우 Transactional 어노테이션이 작동하지 않는다.
      컴파일 시 체크할 수 있는 예외에 대한 처리를 호출자에게 강제할 수 있어야 한다.
    - 아무것도 설정하지 않으면, 스프링은 아래와 같이 인식한다.
      @Transactional(rollbackFor = {RuntimeException.class,Error.class})
    - Checked Exception에서 Rollback을 발생시키려면
      rollbackFor라는 옵션을 이용해 모든 예외에 대해서 rollback을 처리.
      Checked Exception을 try-catch문으로 더 구체적인 Unchecked Exception으로 처리.


- @autowired , @Resouce , @inject
    - @Inject 와 @Resource 는 JSR 에 실려있는 자바 기존의 어노테이션. 반면 @Autowired 는 스프링에서 등장한 어노테이션.
      따라서 프로젝트를 스프링이 아닌 다른 프레임워크로 바꿔야 한다면 @Inject 나 @Resource 를 써야 한다.
    - 연결 방식은 @Autowired 와 @Inject 는 타입에 맞춰서 하는 반면, @Resource 는 이름에 맞춰서 연결.

    @Autowired
        - 타입 -> 이름 -> @Qualifier -> 실패
        - 멤버변수, setter메소드, 생성자, 일반 메소드에 적용가능

    @Inject
        - 타입 -> @Qualifier-> 이름 -> 실패
        - 멤버변수, setter 메소드, 생성자, 일반 메소드에 적용 가능

    @Resource
        - 이름 -> 타입 -> @Qualifier -> 실패
        - 멤버변수 , setter 메소드


- 모델1 방식이란?
    - JSP에 비즈니스 로직과 화면영역을 함께 구현하는 방식. (비즈니스 로직과 화면을 분리하지 않은 방식)
    - 비즈니스 로직이 복잡하지 않거나 소규모 프로젝트일 경우 빠르고 쉽게 개발할 수 있다는 장점이 있지만,
      출력을 위한 뷰 코드와 로직처리를 위한 자바 코드가 함께 섞여있기 때문에 JSP코드 자체가 복잡하고, 분업에 용이하지 않으며 유지보수가 어렵다.


-  모델2 방식이란?
    - 화면과 비즈니스 로직이 분리되어있는 방식.
    - 화면출력을 위한 뷰 코드는 JSP에서, 로직 처리를 위한 자바코드는 Servlet에서 처리하도록 분리하기 때문에 분업이 용이하고 유지보수가 쉽다.


- MVC패턴이란?
    - 데이터를 의미하는 Model, JSP와 같이 실질적으로 보여지는 페이지의 View, 그리고 클라이언트의 Request를 처리하고 View와 Model사이의
      중간 통신 역할을 하는 Controller의 3가지 형태로 구분하여 소프트웨어를 개발하는 방법론.
    - 모델2 방식은 MVC패턴을 따른 것이다.


- @compent로도 빈 설정을 할 수있는데 @service ,@repositorty를 나눠서 사용하는지
    - 레이어 역할을 분리하기 위해

    - 컴포넌트 클래스들에 @Component를 붙일 수 있지만, @Repository, @Service, @Controller를 붙인다면
    - 도구들이 클래스들을 처리하는데 더 적합하도록 할 수 있고 관점(aspects)에 더 연관성을 부여할 수 있다.
    - 스프링에서도 @Component보다는 @Repository, @Service, @Controller를 권장하고 있었던 것이었다.


- @bean , @Auwired등은 어떻게 동작하냐
    - https://kellis.tistory.com/70


- lcoal Thread란
    - ThreadLocal은 thread-local 변수를 제공하는 클래스이다.
    - 여기서 thread-local 변수란 말그대로 thread 내부에서 사용되는 지역변수를 의미한다.
    - 가령 메소드에서 사용하는 변수나 데이터는 파라미터 혹은 메소드 scope 내에서 정의하고 사용하게 되는데,
    - Thread Local을 사용하게 되면, 굳이 변수를 파라미터 같은 곳에 넣지 않아도 공유 및 사용이 가능하게 된다.
    - 그래서 앞서 언급한 SecurityContextHolder은 ThreadLocal을 통해 파라미터로 Principal을 주입 받지 않더라도,
    - 현재 SecurityContextHolder에 ThreadLocal로 저장된 Principal을 꺼내와 사용할 수 있게 되는 것이다.
    - ThreadLocal 변수를 선언하면 각 스레드가 별도의 변수처럼 사용할 수 있다.
    - 스레드가 종료되기 전까지 변수를 사용할 수 있다.
    - 스레드풀을 통해 스레드를 재사용하는 경우 이전에 사용했던 값을 공유할 수 있다. (이해하고 목적에 맞게


- Spring Rest Docs VS Swagger
    - Spring Rest Docs
        - 프로덕션 코드에 영향이 없다.
        - 테스트 코드가 성공해야 문서 작성이 가능하다.
            => Controller에 정의되어 있는 Request Body나 Response Body 등의 API 스펙 정보와 일치하는 API 문서가 만들어진다는 것이다.
               따라서 API 스펙 정보와 API 문서 내의 정보의 불일치로 인해 발생하는 문제를 방지해준다.
        - 문서를 위한 테스트 코드를 관리해야 한다.
            - 개발 시에 테스트 케이스 작성은 필수이므로, 딱히 단점이 아니라고 생각할 수도 있다.
            - 하지만, 개발 도중에 API가 수시로 변경되는 상황에서는 변경사항에 대해 테스트 코드까지 일일이 수정하는 작업은 번거로울 수 있으므로,
              이러한 상황에선 Swagger를 사용하는 편이 더 적합하다고 볼 수 있다.
            - 테스트가 성공하는 올바른 프로덕션 코드에 대해서만 문서를 작성할 수 있다.
              API 스펙과 항상 일치하는 문서를 작성할 수 있다.

    - Swagger
        - 문서상에 api를 테스트할 수 있는 기능이 있다.
        - 테스트 코드가 없으므로 적용이 쉽다.

        - 프로덕션 코드에 어노테이션 추가해야한다. (라이브러리가 바뀌는 등의 경우 불편하다.)
        - 프로덕션 코드와 동기화가 안될 수 있다.
        - 프로젝트의 규모가 커질수록 프로덕션 코드의 유지보수성이 떨어지고, 변경점이 늘어난다.
        - API 문서의 목적은 개발하는 스펙을 정의하는것이라 생각합니다. Swagger는 API 동작을 테스트하는 용도에 더 특화

        - API 스펙이 변경되더라도 어노테이션을 변경하지 않으면 API 문서는 수정되지 않는다. 즉, 문서와 실제 API 스펙이 일치함을 보장할 수 없다.

    - AsciiDoc VS Markdown (문서화 도구)
        - Markdown은 문법이 굉장이 편하다.
          Slate를 사용하면 import 기능을 사용할 수 있지만 결과물이 우리가 생각한 doc파일과는 다르며 별도 설정을 해야하는 번거로움이 있습니다.
        - AsciiDoc은 문법은 조금 불편하지만 include가 가능하기 때문에 html을 작성하는 것처럼 재활용이 가능
          자동생성된 스니펫과 자신이 원하는 문서를 결합해서 사용할 수 있습니다.

    - MockMvc(@WebMvcTest) vs Rest Assured(@SpringBootTest)
        - 보통 문서를 작성할 때 서비스 계층은 Mocking을 하여 작성합니다. Rest Assured는 BDD 스타일로 직관적이지만 별도의 구성없이는 @SpringBootTest로 수행해야합니다.
          그러면 전체 컨테스트를 로드하여 빈을 주입하기에 속도가 많이 느립니다. 반면에 MockMvc는 @WebMvcTest로 수행이 가능합니다.
          그래서 Controller Layer만 테스트 하기에 속도가 빠릅니다. 만약 통합테스트를 한다면 Rest Assured가 좋은 선택일것 같지만
          Spring Rest Docs로 문서를 작성하는데에는 MockMvc가 더 나은 선택이라 생각됩니다.
        - @WebMvcTest는 @SpringBootTest와 다르게 프레젠테이션 레이어의 빈들만 로드한다. 나머지 계층은 Mocking을 한다.
          이렇게 독립적으로 하나의 계층만을 테스트 하는 기법을 슬라이스 테스트라고 한다.

    - Rest Docs 적용해보기
        1. Spring TEST에 의해 성공한 케이스들에 대한 snippet이 자동으로 생성된다.
        2. 문서를 직접 작성하고 코드들에 대한 정보는 아까 생성된 snippet을 include하여 추가하여 완성한다.

    - Spring Rest Docs의 API 문서 생성 흐름
        - 테스트 코드 작성 -> test 태스크(task) 실행 -> API 문서 스니펫(.doc 파일) 생성 -> API 문서 생성 -> API 문서를 HTML로 변환

    - 관련 용어
        스니핏(snippet) : 문서/코드의 일부 조각을 의미한다.

        스니핏은 테스트 케이스 하나 당 하나의 스니핏이 생성되며, 여러개의 스니핏을 모아서 하나의 API 문서를 생성할 수 있다.
        Asciidoc : Spring Rest Docs를 통해 생성되는 텍스트 기반 문서 포맷.

        주로 기술 문서 작성을 위해 설계된 가벼운 마크업 언어이다.
        Asciidoctor : AsciiDoc 포맷의 문서를 파싱해서 HTML 5, 매뉴얼 페이지, PDF 등의 문서를 생성하는 툴.


- Spring WebFlux
    - Non-Blocking IO
        - 우리가 보통 사용하던 Spring MVC + RDBMS 패턴은 Blocking IO 방식이다.
        - Blocking IO 방식이라는 것은 요청을 처리하기 전까지는 다른 작업을 수행할 수 없는 상태라는 것을 말한다.
        - 동시에 여러 요청을 처리하기 위해서는 Thread 수를 늘려서 하는 방법이 존재하기는 하지만 오버헤드가 발생한다.
        - 이를 개선하기 위해서 나온 기술이 Non-Blocking IO 방식인 Spring WebFlux이다.
        - Spring WebFlux는 동시에 처리되어야 할 많은 요청에 대해 효율적으로 처리해 줄 수 있다.

    - 비동기
        - 스레드 풀을 이용한 동기식 호출 방식은 코드가 간단하고 순차적으로 동작하기 때문에 개발자가 코드를 직관적이고 빠르게 작성할 수 있다.
        - 동기식 호출 방식에서는 상대편의 응답이 올 때까지 스레드는 기다려야(blocking)한다.
        - 응답이 빨리 오면 그 기다림은 길지 않겠지만 만약 응답이 늦게 오면 서버가 요청에 대한 응답을 기다리는 데 스레드를 모두 소진해서 추가 요청을 처리할 수 없는 상태가 될 수 있다.
        - 특히 MSA에서는 타임아웃이 발생할 정도의 지연이 발생하면 순식간에 다른 모듈로 전파되어 전체 시스템이 마비되는 등의 악영향을 끼칠 수 있다.
        - 쓰레드가 서버로 요청을 하고 나서 꼭 응답을 기다리면서 아무 것도 하지 않고 대기해야 할까?
        - 쓰레드가 응답을 기다리지 않고 다른 일을 처리하다가 응답이 왔을 때 해당 일을 처리한다면 응답만 기다리면서 불필요하게 리소스를 점유하는 일은 없을 것이다.
        - 이러한 요구 사항에서 나온 것이 이벤트 루프를 이용한 비동기 프로그래밍이다.
        - 이벤트 루프를 활용하면 요청을 보내고 응답이 올 때까지 무작정 기다리는 대신 자신에게 할당된 다른 여러 소켓의 요청을 순차적으로 빠르게 처리한다.
        - 이제 우리의 서버와 클라이언트의 스레드는 더이상 blocking되지 않는다.
        - Spring 생태계에서도 버전 5부터 도입된 WebFlux를 통해 비동기 프로그래밍을 본격적으로 도입하고 있다.
        - 순차적으로 처리되는 방식이 아니라 디버깅이 힘들고 개발이 어렵다.


- 주입이랑 spring aop차이를 아냐

- spring boot xml로 설정했는지 java cofig로 했는데 config로 하는거랑, xml로 설정하는 것중 머가 더 편한지 편하면 왜 편하지 머가 다른지?

- spring의 핵심기능에 대해 말해주세요.

- spring에서 사용한 최신버전은?

- spring di는 -> di에 사용된 디자인 패턴은 -> 디자인패턴의 예시설명

- string이 불변한 이유는?

- spring aop 동작 원리

- 다이나믹 프록시랑 cglib proxy 차이점은 cglib proxyj는 클래스기반만 가능한가?

- solid에 의존 역전 법칙에 대해 아느냐?

- 의존 역전 법칙은 스프링에 어떤 연관이 있냐?

- 스프링 IOC, DI

- IOC가 왜 스프링 장점인지

- 트랜잭션 처리 어떻게 하는지

- 트랜잭션 프로파게이션?(전파레벨)

- state 패턴과 싱글톤 패턴의 설명요구

- spring boot 부트동작원리 설명?

- dispatcherServlet 리다이렉트,포어딩?

- 싱글톤 패턴은 어떤 패턴인가, 어떤 상황에 사용하는가

- 전략 패턴 템플릿 메소드 패턴