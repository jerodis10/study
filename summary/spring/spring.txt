- 싱글턴 패턴

- Bean Scope
    - 스프링 빈(Spring Bean)이란?
        - 스프링 IoC 컨테이너에 의해서 관리되고 애플리케이션의 핵심을 이루는 객체들을 스프링 빈

    - Scope의 종류
        - Singleton
            - 스프링 빈은 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때까지  1개의 객체로 유지
        - Prototype
            - 요청이 오면 항상 새로운 인스턴스를 생성하여 반환하고 이후에 관리하지 않음
            - 프로토타입을 받은 클라이언트가 객체를 관리해야 함
                - 스프링 컨테이너는 프로토타입 스프링 빈의 생성과 의존관계 주입까지만 관여하고 이후의 과정은 관여하지 않는다.
                    (이후는 해당 빈을 호출한 사용자에 의해서 종료된다.)
                  스프링 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 처리.
                  @PreDestroy같은 종료 메서드가 호출 되지 않는다.
        - Web
            - Request: 각각의 요청이 들어오고 나갈 때까지 유지되는 scope
            - Session: 세션이 생성되고 종료될 때까지 유지되는 scope
            - Application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 scope

    - 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
        - 싱글톤 스프링 빈 내부에 의존관계로 주입되는 스프링 빈이 프로토타입인 경우
            - 프로토타입 스코프의 스프링 빈이 새로 생성되기는 했지만 싱글톤 빈과 함께 사용되기 때문에 계속 유지된다.
            - 싱글톤 빈과 함께 사용하면서 프로토타입 빈이 자기의 스코프를 지키고 매번 새롭게 생성하기 위해서는 어떻게 해야 할까?

            - 의존관계를 외부에서 주입(DI) 받는 것이 아닌 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색)이라 한다.
            - ObjectProvider의 getObject()를 호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
            - 스프링의 의존성이 마음에 들지 않으면 JSR-330 자바 표전을 사용하는 방법이 있다.

    - 프로토타입 빈을 언제 사용해야 하는가?
        - 여러 인스턴스를 검색해야 하는 경우
        - 인스턴스를 지연 혹은 선택적으로 찾아야 하는 경우
        - 순환 종속성을 깨기 위해서
        - 스코프에 포함된 인스턴스로부터 더 작은 범위의 인스턴스를 찾아 추상화 하기 위해서 사용한다.


***** 이벤트 기반 아키텍처 구축
    https://techblog.woowahan.com/7835/
    https://www.youtube.com/watch?v=b65zIH7sDug&t=1035s

***** CQRS
    https://www.youtube.com/watch?v=fg5xbs59Lro

***** MSA
    https://www.youtube.com/watch?v=BnS6343GTkY

***** domain
    https://www.youtube.com/watch?v=kmUneexSxk0

DDD
    https://www.youtube.com/watch?v=6w7SQ_1aJ0A&list=PL42XJKPNDepYXyKefvicxlA2fz1aThVs5&index=37

백엔드 운영과 개발 기법
    https://www.youtube.com/watch?v=2hCbY_mpqSg&list=PL42XJKPNDepYXyKefvicxlA2fz1aThVs5&index=3

***** MVC vs WebFlux 차이점
    https://pearlluck.tistory.com/726

* @ModelAttribute
    https://minchul-son.tistory.com/546

* @ModelAttribute, @RequestParam
    https://zzang9ha.tistory.com/298

* PUT vs PATCH
    https://tecoble.techcourse.co.kr/post/2020-08-17-put-vs-patch/

***** 생성자 주입의 장점
    https://velog.io/@mooh2jj/%EC%83%9D%EC%84%B1%EC%9E%90-%EC%A3%BC%EC%9E%85%EC%9D%98-%EC%9E%A5%EC%A0%90-RequiredArgsConstructor-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0

***** IoC, DI
    https://velog.io/@mooh2jj/Spring-Ioc-DI

***** 객체지향을 위한 SOLID 원칙
    https://velog.io/@mooh2jj/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-SOLID%EB%A5%BC-%ED%8C%8C%ED%9B%BC%EC%B3%90%EB%B3%B4%EC%9E%90

****** 스프링 Immutable으로 Properties 설정하기
    https://cheese10yun.github.io/immutable-properties/

***** ConstraintValidator을 이용해서 효과적인 검증
    https://cheese10yun.github.io/ConstraintValidator/

***** Spring Actuator 기초 설정
    https://cheese10yun.github.io/spring-actuator/

***** Rest Docs vs Swagger
    https://cheese10yun.github.io/spring-rest-docs/

***** MSA 이해
    https://nozee.tistory.com/entry/1%EC%9E%A5
    https://nozee.tistory.com/entry/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B0%9C%EB%B0%9C-3-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98
    https://nozee.tistory.com/entry/2-MSA%EC%9D%98-%EC%9D%B4%ED%95%B4

***** 읽기와 쓰기 분리: CQRS 패턴
서비스의 서능 향상을 위해 서비스 인스턴스를 스케일 아웃해서 여러 개로 실행한 경우 데이터 읽기/수정 작업으로 인한 리소스 교착상태가 발생할 수 있다.
이 문제를 해결하는 방법이 CQRS패턴인데 Command Query Reponsibility Segregation 즉 명령 조회 책임 분리를 의미한다. 기존의 일반적이었던 동일한 저장소에 데이터를 넣고 입력, 조회, 수정, 삭제를 모두 처리하는 방식에 도전하는 방식이다.
일반적인 비즈니스 모델에서는 입력, 수정, 삭제가 조회보다 적게 쓰이고 조회 요청이 훨씬 많이 사용된다. 그런데 서비스 내에 이러한 모든 기능을 넣어 두면 조회 요청 빈도가 증가함에 따라 다른 명령 기능도 함께 확장해야 하므로 효율적이지 않다.
따라서 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리할 수도 있고, 더 나아가 아예 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비할 수 있다.
API 조합과 CQRS
'주문 이력' 서비스는 제품 서비스가 제공하는 제품 정보, 주문 서비스의 주문 정보, 고객 서비스의 특정 고객 정보, 배송 서비스의 배송 정보가 모두 다 필요하다. 따라서 각 기능을 제공하는 마이크로서비스를 조합하는 상위 마이크로서비스를 만들어 조합된 기능을 제공할 수 있다.
그렇지만 이러한 구조는 상위 서비스가 하위 서비스에 의존하는 결과를 가져온다. 하위 서비스 중 하나라도 실패할 경우 상위 서비스에 영향을 준다.
다른 방법으로는 주문 이력 서비스를 제공하는 마이크로서비스가 독자적인 저장소를 갖도록 만든다. 원청 정보를 보여한 서비스에서 정보가 변경되는 순간 그 내역을 이벤트로 발생시켜 주문 이력서에 내용을 공유하여 준다.

***** 문자열 유효성 검증 유틸 메소드 StringUtils.hasText(String)
    https://creampuffy.tistory.com/120

****** POST vs PUT (Collection, Store)
    https://creampuffy.tistory.com/170

***** Spring 의존성 주입 방법 중 생성자 주입을 사용해야 하는 이유
    https://creampuffy.tistory.com/156

***** 외부 툴 변경에 휘둘리지 않는 서버 코드 작성기
    https://blog.gangnamunni.com/post/dependency-inversion-principle/

***** 트랜잭션은 도메인 모델이 아니다
    https://blog.gangnamunni.com/post/isolate-transaction-from-domain-model

***** Spring Rest Docs 적용
    https://leejonghyun89.tistory.com/7
    https://velog.io/@bagt/API-%EB%AC%B8%EC%84%9C%ED%99%94%EC%99%80-Spring-Rest-Docs


***** Spring Rest Docs VS Swagger
    - Spring Rest Docs
        - 프로덕션 코드에 영향이 없다.
        - 테스트 코드가 성공해야 문서 작성이 가능하다.
            => Controller에 정의되어 있는 Request Body나 Response Body 등의 API 스펙 정보와 일치하는 API 문서가 만들어진다는 것이다.
               따라서 API 스펙 정보와 API 문서 내의 정보의 불일치로 인해 발생하는 문제를 방지해준다.
        - 문서를 위한 테스트 코드를 관리해야 한다.
            - 개발 시에 테스트 케이스 작성은 필수이므로, 딱히 단점이 아니라고 생각할 수도 있다.
            - 하지만, 개발 도중에 API가 수시로 변경되는 상황에서는 변경사항에 대해 테스트 코드까지 일일이 수정하는 작업은 번거로울 수 있으므로,
              이러한 상황에선 Swagger를 사용하는 편이 더 적합하다고 볼 수 있다.

    - Swagger
        - 문서상에 api를 테스트할 수 있는 기능이 있다.
        - 테스트 코드가 없으므로 적용이 쉽다.

        - 프로덕션 코드에 어노테이션 추가해야한다. (라이브러리가 바뀌는 등의 경우 불편하다.)
        - 프로덕션 코드와 동기화가 안될 수 있다.
        - API 문서의 목적은 개발하는 스펙을 정의하는것이라 생각합니다. Swagger는 API 동작을 테스트하는 용도에 더 특화

    - AsciiDoc VS Markdown (문서화 도구)
        - Markdown은 문법이 굉장이 편하다.
          Slate를 사용하면 가능하다고 하지만 결과물이 우리가 생각한 doc파일과는 다르며 별도 설정을 해야하는 번거로움이 있습니다.
        - AsciiDoc은 문법은 조금 불편하지만 include가 가능하기 때문에 html을 작성하는 것처럼 재활용이 가능
          자동생성된 스니펫과 자신이 원하는 문서를 결합해서 사용할 수 있습니다.

    - MockMvc(@WebMvcTest) vs Rest Assured(@SpringBootTest)
        - 보통 문서를 작성할 때 서비스 계층은 Mocking을 하여 작성합니다. Rest Assured는 BDD 스타일로 직관적이지만 별도의 구성없이는 @SpringBootTest로 수행해야합니다.
          그러면 전체 컨테스트를 로드하여 빈을 주입하기에 속도가 많이 느립니다. 반면에 MockMvc는 @WebMvcTest로 수행이 가능합니다.
          그래서 Controller Layer만 테스트 하기에 속도가 빠릅니다. 만약 통합테스트를 한다면 Rest Assured가 좋은 선택일것 같지만
          Spring Rest Docs로 문서를 작성하는데에는 MockMvc가 더 나은 선택이라 생각됩니다.

    - Rest Docs 적용해보기
        1. Spring TEST에 의해 성공한 케이스들에 대한 snippet이 자동으로 생성된다.
        2. 문서를 직접 작성하고 코드들에 대한 정보는 아까 생성된 snippet을 include하여 추가하여 완성한다.

    - Spring Rest Docs의 API 문서 생성 흐름
        - 테스트 코드 작성 -> test 태스크(task) 실행 -> API 문서 스니핏(.doc 파일) 생성 -> API 문서 생성 -> API 문서를 HTML로 변환

    - 관련 용어
        스니핏(snippet) : 문서/코드의 일부 조각을 의미한다.

        스니핏은 테스트 케이스 하나 당 하나의 스니핏이 생성되며, 여러개의 스니핏을 모아서 하나의 API 문서를 생성할 수 있다.
        Asciidoc : Spring Rest Docs를 통해 생성되는 텍스트 기반 문서 포맷.

        주로 기술 문서 작성을 위해 설계된 가벼운 마크업 언어이다.
        Asciidoctor : AsciiDoc 포맷의 문서를 파싱해서 HTML 5, 매뉴얼 페이지, PDF 등의 문서를 생성하는 툴.

- 프레임워크와 라이브러리의 차이점
    - Framework(프레임워크)
        - Application 개발 시 필수적인 코드, 알고리즘, 데이터베이스 연동 등과 같은 기능들을 위해 어느정도 뼈대(구조)를 제공해주는 것
        - 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합

    - Library(라이브러리)
        - 프로그래머가 개발하는데 필요한 것들을 모아둔 것

    - Framework와 Library의 차이는 Flow(흐름)에 대한 제어 권한이 어디에 있느냐의 차이
    - 프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며, 프로그래머가 그 안에 필요한 코드를 작성하는
      반면에 라이브러리는 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것입니다.
      프레임워크에는 제어의 역전(Inversion Of Control)이 적용되어있다는 것

    - API란
        - 필요한 부분을 요청하여 응답을 받는 서비스간의 다리와 같은 역할
        - 구현과 독립적으로 사양만 정의 되어있음


- Filter vs Interceptor vs AOP
    - Filter
        - 필터에서는 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리
        - Filter는 다음 체인으로 넘기는 ServletRequest/ServletResponse 객체를 조작할 수 있다는 점에서 Interceptor보다 훨씬 강력한 기술
        - 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리되므로 DispatcherServlet으로 가기 전에 요청을 처리하는 것

        ex) 보안 관련 공통 작업
            모든 요청에 대한 로깅 또는 감사
            이미지/데이터 압축 및 문자열 인코딩

    - 인터셉터(Interceptor)
        - 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트 내부에서 Controller에 관한 요청과 응답에 대해 처리
        - 스프링의 모든 빈 객체에 접근할 수 있다.
        - 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다.
        - 필터와 다르게 HttpServletRequest나 HttpServletResponse 등과 같은 객체를 제공받으므로 객체 자체를 조작할 수는 없다.

        ex) 인증/인가 등과 같은 공통 작업
            API 호출에 대한 로깅 또는 감사
            Controller로 넘겨주는 정보(데이터)의 가공

        - Filter의 doFilter 메서드는 매개변수로 ServletRequest와 ServletResponse를 받고 Interceptor의 preHandle이나 postHandle은 HttpServletRequest를 받는다.
        - ServletRequest는 기본적인 클라이언트 요청에 관한 모든 정보를 가지고 있다. 그리고 이 인터페이스는 다시 HttpServletRequest로 확장하여
          HTTP 프로토콜 상에서 할 수 있는 일들이 포함되어져 있다.
          이 HttpServletReqeust는 서블릿의 service의 매개변수의 하나로 서블릿 프로그래머가 클라이언트의 요청에 관한 작업들을 핸들할 수 있도록하는 중요한 역할을 담당하고 있다.

    - AOP
        - Interceptor와 Filter와 달리 메소드 전 후의 지점에 자유롭게 설정이 가능하며 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.
        - 로깅, 트랜잭션, 에러 처리 등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용


- Spring과 SpringBoot의 차이점
    (1) 내장 톰캣
        - 내장 톰캣을 사용하기 때문에 따로 톰캣을 설치하거나 매번 버전을 관리해 주지 않아도 된다.
    (2) starter를 통한 dependency를 자동화
        - 기존의 Spring에서는 dependency들의 호환되는 버전을 직접 설정
        - 스프링 부트에서는 이 starter를 통해 종속된 모든 라이브러리를 알맞게 찾아서 함께 가져오기 때문에 의존성이나 호환버전에 대해 신경 쓸 필요가 없다.
    (3) XML
        - View Resolver, 데이터 액세스 등의 xml 설정을 하지 않아도 된다.
    (4) jar
        - jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.
    (5) AutoConfigurator
        - 공통적으로 필요한 설정을 어노테이션을 이용하여 대신할 수 있다.
    (6) Spring Initializr
        - pring Initilizr를 사용하면 실행 환경이나 의존성 관리 등의 인프라 부분을 신경 쓸 필요 없이 바로 코딩을 시작할 수 있게끔 환경을 제공


- Spring WebFlux
    - Non-Blocking IO
        - 우리가 보통 사용하던 Spring MVC + RDBMS 패턴은 Blocking IO 방식이다.
        - Blocking IO 방식이라는 것은 요청을 처리하기 전까지는 다른 작업을 수행할 수 없는 상태라는 것을 말한다.
        - 동시에 여러 요청을 처리하기 위해서는 Thread 수를 늘려서 하는 방법이 존재하기는 하지만 오버헤드가 발생한다.
        - 이를 개선하기 위해서 나온 기술이 Non-Blocking IO 방식인 Spring WebFlux이다.
        - Spring WebFlux는 동시에 처리되어야 할 많은 요청에 대해 효율적으로 처리해 줄 수 있다.

    - 비동기
        - 스레드 풀을 이용한 동기식 호출 방식은 코드가 간단하고 순차적으로 동작하기 때문에 개발자가 코드를 직관적이고 빠르게 작성할 수 있다.
        - 동기식 호출 방식에서는 상대편의 응답이 올 때까지 스레드는 기다려야(blocking)한다.
        - 응답이 빨리 오면 그 기다림은 길지 않겠지만 만약 응답이 늦게 오면 서버가 요청에 대한 응답을 기다리는 데 스레드를 모두 소진해서 추가 요청을 처리할 수 없는 상태가 될 수 있다.
        - 특히 MSA에서는 타임아웃이 발생할 정도의 지연이 발생하면 순식간에 다른 모듈로 전파되어 전체 시스템이 마비되는 등의 악영향을 끼칠 수 있다.
        - 쓰레드가 서버로 요청을 하고 나서 꼭 응답을 기다리면서 아무 것도 하지 않고 대기해야 할까?
        - 쓰레드가 응답을 기다리지 않고 다른 일을 처리하다가 응답이 왔을 때 해당 일을 처리한다면 응답만 기다리면서 불필요하게 리소스를 점유하는 일은 없을 것이다.
        - 이러한 요구 사항에서 나온 것이 이벤트 루프를 이용한 비동기 프로그래밍이다.
        - 이벤트 루프를 활용하면 요청을 보내고 응답이 올 때까지 무작정 기다리는 대신 자신에게 할당된 다른 여러 소켓의 요청을 순차적으로 빠르게 처리한다.
        - 이제 우리의 서버와 클라이언트의 스레드는 더이상 blocking되지 않는다.
        - Spring 생태계에서도 버전 5부터 도입된 WebFlux를 통해 비동기 프로그래밍을 본격적으로 도입하고 있다.
        - 순차적으로 처리되는 방식이 아니라 디버깅이 힘들고 개발이 어렵다.


- Servlet
    - Servlet 정의
        - 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램이 서블릿
        - 서블릿은 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해주는 기술

    - Servlet 특징
        - 서블릿 등장이전에는 CGI (Common Gateway Interface) 기술이 있었는데 이는 요청 당 프로세스를 생성함
            - 서블릿은 CGI에 비해서 작동이 빠르고, 플랫폼에 독립적이며, 보안이 좋고, 이식성이 강함
        - html을 사용하여 요청에 응답
        - 서블릿 객체는 싱글톤으로 관리
            - 고객의 요청이 올 때마다 생성하는 것은 비효율적이기 때문
            - 서블릿 컨테이너가 종료되면 서블릿도 종료

    - 서블릿 컨테이너(Servlet Container)
        - 정의
            - 서블릿을 관리해주며 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하며 post, get여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.
                - HttpServletRequest
                    - http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의
                      정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있다.
                - HttpServletResponse
                    - WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여
                      서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송한다.

        - 특징
            - java thread를 사용해서 서블릿을 호출
            - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함

        - 주요 기능
            - 서블릿의 생명주기를 관리
                - 서블릿 컨테이너가 기동 되는 순간 서블릿 클래스를 로딩해서 인스턴스화하고, 초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작한다.
                  그리고 서블릿의 생명이 다하는 순간 가비지 컬렉션을 통해 메모리에서 제거한다.

            - 통신 지원
                - 클라이언트의 Request를 받아주고 Response를 보낼 수 있게 웹 서버와 소켓을 만들어서 통신을 해준다.
                - 블릿 컨테이너는 이렇게 소켓을 만들고 listen, accept 등의 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해주고 개발자로서 비즈니스 로직에 더욱 집중할 수 있게 만들어준다.

            - 멀티스레딩 관리
                - 해당 서블릿의 요청이 들어오면 스레드를 생성해서 작업을 수행한다.

            - 선언적인 보안관리


- POJO
    스프링에서 생성되어 관리되는 POJO 기반의 객체를 Spring Bean이라고 합니다.
    여기서 POJO는 단순 getter, setter만으로 구성되어 있으며 단순히 new를 통해서 생성 가능한 형태를 말합니다.
    핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있고, 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스입니다.


- Spring Framework에 대해 설명해주세요.
    - 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크

    - 경량 컨테이너로서 자바 객체를 직접 관리
        각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
    - 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
        컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 다라 스프링에서 사용자의 코드를 호출한다.
    - 의존성 주입(DI, Dependency Injection)을 지원
        각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
    - 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
        트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.


- @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요.
    - @RequestBody
        - 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할
        - 값을 주입하지 않고 값을 변환 시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다.

    - @RequestParam
        - 1개의 HTTP 요청 파라미터를 받기 위해 사용.
        -  필수 여부 설정 가능

    - @ModelAttribute
        - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자,Getter,Setter를 통해 주입하기 위해 사용
        - 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter,Setter가 없으면 변수들이 저장되지 않는다.


- MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.
    1. 클라이언트는 URL을 통해 요청을 전송한다.
    2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
    3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
    4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
    5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
    6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
    7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
    8. 데이터가 추가된 뷰를 반환한다.


- 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.
    - 제어의 역전(IoC)란 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다.
    - 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고
      컨테이너에 등록한 객체들을 '빈'이라고 합니다.


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것
      이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있습니다.

    - 의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3 가지 방법이 있습니다.
      이 중 Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법입니다.
      그 이유는 1. 순환 참조를 방지 2. 불변성을 가짐 3. 테스트에 용이하기 때문입니다.


- 스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요.
    - 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료

    - 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리
        1. 인터페이스( InitializingBean, DisposableBean )
        2. 설정 정보에 초기화 메소드, 종료 메소드 지정
        3. @PostConstruct, @PreDestroy 어노테이션 지원


- Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.
    - Spring Filter
        - 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리
        - Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공
        ex) 보안 및 인증/인가 관련 작업
            모든 요청에 대한 로깅 또는 검사
            이미지/데이터 압축 및 문자열 인코딩
            Spring과 분리되어야 하는 기능

    - Interceptor
        - 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작
        - Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
        ex) 세부적인 보안 및 인증/인가 공통 작업
            API 호출에 대한 로깅 또는 검사
            Controller로 넘겨주는 정보(데이터)의 가공


- Lombok 라이브러리에 대해 알고 있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는 시점은 언제인가요?
    - Lombok은 메소드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어냅니다. 이것을 어노테이션 프로세싱
      (Lombok 라이브러리를 추가할 때 CompileOnly, AnnotationProcessor를 추가하는 이유도 된다.)


- 서블릿의 동작 방식에 대해 설명해주세요.
    1. 사용자(Client)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다.
    2. 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
    3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
    4. 해당 서블릿에서 service메소드를 호출한 후 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
    5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다.
    6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.


- 스케일 업(Scale-Up)과 스케일 아웃(Scale-Out)이란
    - 스케일 업(Scale-Up)
        - 기존 서버의 사양을 업그레이드해 시스템을 확장하는 것
        - CPU나 RAM 등을 추가하거나 고성능의 부품, 서버로 교환하는 방법
        - 수직 확장이며, 성능 확장에 한계가 있음
        - 성능 증가에 따른 비용 증가폭이 큼
        - 한 대의 서버에 부하가 집중되어 장애 영향도가 큼

    - 스케일 아웃(Scale-Out)
        - 서버를 여러 대 추가하여 시스템을 확장하는 것
        - 서버가 여러 대로 나뉘기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 '로드밸런싱'이 필수적으로 동반되어야 한다.
        - 수평 확장이며, 지속적 확장 가능
        - 비교적 저렴한 서버 사용으로 비용 부담이 적음
        - 읽기/쓰기가 여러 대의 서버에서 분산처리.
          장애 시 전면 장애의 가능성이 적음


- @Transactional의 동작 원리에 대해 설명해주세요.
    - @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며,
      Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행합니다.


- @Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다.
      즉, A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않은 일반 코드가 수행됩니다.


- A 라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때,
  @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.
      그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다.



******* 이벤트 기반 프로그래밍
    https://tech.kakaopay.com/post/event-driven-architecture/

***** 효율적으로 로그 모니터링하기 - 로그 레벨 구분하기
    https://jojoldu.tistory.com/712

***** 예외 먹는 @TransactionalEventListener
https://lenditkr.github.io/spring/transactional-event-listener/index.html


****** [Server] Restful API란?
    https://mangkyu.tistory.com/46

* 디자인 패턴-Factory Method
    https://youngkyonyou.github.io/interview/2021/12/14/Interview-interview-01.html

