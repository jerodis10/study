- 스프링이란?   https://mangkyu.tistory.com/281
    자바라는 객체지향 프로그래밍 개발을 빠르고 편하게 할 수 있도록 IoC, DI, AOP 를 통해 도와주는 프레임워크이다.
    스프링의 주요 기술인 Ioc/DI, AOP는 어플리케이션을 POJO로 개발할 수 있게 해주는 기술들이다.
    여기서 POJO에 제공한다는 말은 엔터프라이즈 서비스 기술과 POJO 애플리케이션 로직을 담은 코드를 분리했다는 뜻이다.
    개발자들은 스프링 프레임워크 틀 위에서 핵심 비즈니스 로직에만 집중 할 수 있어서 생산성이 향상된다.


- springBoot의 장점   https://mangkyu.tistory.com/208
    - starter를 통한 dependency를 자동화 ??
        - 기존의 Spring에서는 dependency들의 호환되는 버전을 직접 설정
        - 스프링 부트에서는 이 starter를 통해 종속된 모든 라이브러리를 알맞게 찾아서 함께 가져오기 때문에 의존성이나 호환버전에 대해 신경 쓸 필요가 없다.

    - AutoConfig로 복잡한 설정 자동화
        - 개발을 진행하다보면 json 메세지 변환, 프로프티 설정 등 다양한 공통적인 설정들이 필요하다.
          스프링 부트는 개발을 위해 필요한 공통적인 부분들을 자동으로 구성해준다.
        - 그 뿐만 아니라 스프링부트는 ElasticSearch, Redis, Gson 등과 같은 자주 사용되는 외부 라이브러리들 역시도 자동 설정을 제공하고 있다.
          해당 의존성을 추가하면 클래스 패스 기준으로 의존성이 존재하는지 파악하여 자동으로 설정을 해준다.

    - 내장 웹서버 제공
        - 과거의 스프링 프레임워크는 서버를 배포하기 위해 톰캣과 같은 별도의 외장 웹서버를 설치하고, war 파일을 생성하여 배포해주어야 했다.
          이러한 방식은 상당히 번거롭고 처리 속도도 느렸는데, 스프링 부트는 내장 웹서버(톰캣 or 리액터 네티)을 가지고 있어서
          별도의 작업 없이 빠르게 서버를 실행할 수 있도록 도와준다.

    - 실행 가능한 JAR로 개발 가능
        - 스프링 프로젝트를 배포하기 위해서는 war파일을 만들어 외장 웹서버에 배포해야 했다.
          하지만 스프링 부트는 순수 자바 애플리케이션 프로그램을 실행하는 것처럼 스프링부터 역시 jar로 실행 가능하도록 하였다.


- 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.
    - 객체에 대한 제어권이 개발자에게 있는 것이 아닌, 스프링 컨테이너에게 있는 것. 객체의 생성부터 소멸까지의 라이프싸이클 관리를 컨테이너가 대신 해준다.
    - IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고 컨테이너에 등록한 객체들을 '빈'이라고 합니다.
    - DI는 IoC를 구현하기 위한 디자인 패턴입니다.
    - 클래스간의 결합을 느슨하게 설계하여 테스트가 가능하고 유지보수가 용이하게 만드는데 도움이 됩니다.


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - DI는 IoC를 구현하기 위한 디자인 패턴으로 빈 사이의 의존관계를 빈 설정 정보를 바탕으로 DI 컨테이너가 자동으로 연결한다.
    - 제어의 역행(IOC)으로 특정 객체에 필요한 다른 객체를 외부에서 결정해서 연결시키는 것.
      런타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다.
    - 객체간의 결합을 느슨하게 만들어 유연하고 확장성이 뛰어난 코드를 작성하기 위한 패턴이다.

    - 의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3 가지 방법이 있습니다. 이 중 Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법입니다.
        1. 순환 참조를 방지
            - 필드/수정자 주입은 먼저 빈을 생성한 후, 주입하려는 빈을 찾아 주입하므로 어플리케이션 로딩 시점에 에러가 발생하지 않음. (빈의 생성과 조립 시점이 분리되어 있기 때문)
              생성자 주입은 객체의 생성과 조립(의존관계 주입)이 동시에 실행되다 보니 에러 발생.
              컨테이너가 빈을 생성하는 시점에서 객체 생성에 사이클관계가 생기기 때문
              참고로 스프링 부트 2.6부터는 순환 참조가 기본적으로 허용되지 않도록 변경되었다.

        2. final 선언 가능
            - 런타임에 객체 불변성 보장
            - 필드 주입과 setter 주입의 경우엔 객체 생성 후 주입이 발생하기 때문에 final 키워드를 사용할 수 없다.

        3. 테스트 코드 작성 용이
            - 테스트하고자 하는 클래스에 필드/수정자 주입으로 빈이 주입되어 있으면, Mockito를 이용해 목킹한 후 테스트 해아함.
            - 하지만 생성자 주입은 단순히 원하는 객체를 생성한 후, 생성자에 넣어주면 된다.

        4. NPE 방지
            - 의존관계가 설정되지 않으면 객체 생성 불가. 컴파일 타임에 인지 가능


- DI와 IoC의 차이는?
    DI는 의존관계를 어떻게 가질 것인가에 대한 문제고, IoC는 누가 소프트웨어의 제어권을 갖고 있느냐의 문제다.
    IoC 컨테이너가 빈을 생성할 때 빈들간의 의존관계를 DI를 통해 해결한다.
    DI는 IoC 사용을 필수로 요구하지 않는다는 점을 주의해야 한다.


- spring di는 -> di에 사용된 디자인 패턴은 -> 디자인패턴의 예시설명 ??
    DI는 위에서 설명한 '전략 패턴' 이라는 디자인 패턴 구조를 가지고 있습니다.
    DI를 함으로써 얻는 장점은 전략 패턴을 구현한 장점과 같습니다.
    의존하고 있는 클래스가 변경이 되더라도 구체클래스가 아닌 인터페이스를 통해서 의존하고 있기 때문에,
    구체클래스를 바꾸고 싶다면, 의존설정시에 다른 구체클래스만 명시하면 됩니다.
    여러 전략 (Strategy)가 있더라도 인터페이스에 의존하고 있기 때문에 다양한 전략(Strategy)으로 쉽게 변경이 가능해집니다.


- Autowiring 동작 과정은?
    스프링 서버가 올라갈 때 애플리케이션 컨텍스트가 @Bean이나 @Service, @Controller 등 어노테이션을 이용하여 등록한 스프링 빈을 생성하고,
    @Autowired 어노테이션이 붙은 위치 또는 생성자, 수정자를 통해 주입한다.


- Bean Factory(빈팩토리)/Application Context(애플리케이션 컨텍스트)란?
    - 빈 팩토리
        - 빈의 생성과 관계 설정 같은 제어를 담당하는 IoC 오브젝트.
        - 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당하지만
          보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다.

    - 애플리케이션 컨텍스트
        - IoC 방식을 따라 만들어진 일종의 빈 팩토리.
        - BeanFactory 기능을 모두 상속받아서 국제화, 환경변수, 이벤트 등 부가 기능을 제공
        - BeanDefinition 를 통해 빈 메타 정보를 생성하고 이걸 기반으로 스프링 빈 생성.
        - 스프링 컨테이너는 다양한 형식의 설정 정보를 BeanDefinition 으로 추상화해서 사용.


- 스프링 빈(Bean)이란?
    1. 정의
        - 스프링 빈은 스프링 컨테이너가 생성과 관계 설정, 사용 등을 제어해주는 IoC가 적용된 객체를 가리키는 말이다.

    2. 빈 생성
        - 스프링 컨테이너는 xml, java 등 다양한 형식의 설정 정보를 BeanDefinition 으로 추상화해서 사용.
          BeanDefinition 를 통해 빈 메타 정보를 생성하고 이걸 기반으로 스프링 빈 생성.

    3. 빈 등록
        - 자동 빈 등록 -> @ComponentScan
        - 수동 빈 등록 -> @Configuration

        - 조회 빈이 2개 이상일 경우
            - @Autowired
                - 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 매칭
            - @Qualifier
                - @Qualifier 끼리 매칭
            - @Primary
                - @Autowired 시에 여러 빈이 매칭되면 @Primary 가 우선권을 가진다.

    4. 빈 스코프
        - Scope의 종류
            - Singleton
                - 스프링 빈은 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때까지 1개의 객체로 유지
            - Prototype
                - 요청이 오면 항상 새로운 인스턴스를 생성하여 반환하고 이후에 관리하지 않음
                - 프로토타입을 받은 클라이언트가 객체를 관리해야 함
                    - 스프링 컨테이너는 프로토타입 스프링 빈의 생성과 의존관계 주입까지만 관여하고 이후의 과정은 관여하지 않는다.
                        (이후는 해당 빈을 호출한 사용자에 의해서 종료된다.)
                      스프링 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 처리.
                      @PreDestroy같은 종료 메서드가 호출 되지 않는다.
            - Web
                - Request: 각각의 요청이 들어오고 나갈 때까지 유지되는 scope (HTTP Request의 생명주기와 같음)
                - Session: 세션이 생성되고 종료될 때까지 유지되는 scope (HTTP Session의 생명주기와 같음)
                - Application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 scope

        - 왜 스프링 빈은 기본적으로 싱글톤일까?
            Spring Framework의 핵심은 스프링 컨테이너. 이 컨테이너는 객체를 갖고 있다가 필요할때 주입한다. 왜 그렇게 동작할까?
            서버는 많은 사람들이 사용하고 그 사용자들이 이용할 비즈니스 로직은 대부분 동일하다.
            동일한 비즈니스 로직(빈)이 이용하는 사람들마다 하나씩 생성된다면 서버는 부하에 걸리기 쉽고 애초에 동일한 로직이
            여러개 생성될 필요가 없기 때문에 스프링에서는 빈들을 싱글톤으로 관리한다.

        - 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
            - 싱글톤 스프링 빈 내부에 의존관계로 주입되는 스프링 빈이 프로토타입인 경우
                - 프로토타입 스코프의 스프링 빈이 새로 생성되기는 했지만 싱글톤 빈과 함께 사용되기 때문에 계속 유지된다.
                - 싱글톤 빈과 함께 사용하면서 프로토타입 빈이 자기의 스코프를 지키고 매번 새롭게 생성하기 위해서는 어떻게 해야 할까?

                - 의존관계를 외부에서 주입(DI) 받는 것이 아닌 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색)이라 한다.
                - ObjectProvider의 getObject()를 호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
                - 스프링의 의존성이 마음에 들지 않으면 JSR-330 자바 표전을 사용하는 방법이 있다.

        - 프로토타입 빈을 언제 사용해야 하는가?
            - 여러 인스턴스를 검색해야 하는 경우
            - 인스턴스를 지연 혹은 선택적으로 찾아야 하는 경우
            - 순환 종속성을 깨기 위해서
            - 스코프에 포함된 인스턴스로부터 더 작은 범위의 인스턴스를 찾아 추상화 하기 위해서 사용한다.

    5. 빈 라이프사이클
        - 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료
        - 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리
            1. 인터페이스( InitializingBean, DisposableBean )
            2. 설정 정보에 초기화 메소드, 종료 메소드 지정
            3. @PostConstruct, @PreDestroy 어노테이션 지원


- Servlet
    - Servlet 정의
        - 서블릿은 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해주는 기술
        - 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램이 서블릿

    - Servlet 특징
        - 서블릿 등장 이전에는 CGI (Common Gateway Interface) 기술이 있었는데 이는 요청 당 프로세스를 생성함
            - 서블릿은 CGI에 비해서 작동이 빠르고, 플랫폼에 독립적이며, 보안이 좋고, 이식성이 강함
        - html을 사용하여 요청에 응답
        - 서블릿 객체는 싱글톤으로 관리
            - 고객의 요청이 올 때마다 생성하는 것은 비효율적이기 때문
            - 서블릿 컨테이너가 종료되면 서블릿도 종료

    - 서블릿 컨테이너(Servlet Container)
        - 정의
            - 서블릿을 관리해주며 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하며 post, get 여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.
                - HttpServletRequest
                    - http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의
                      정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있다.
                - HttpServletResponse
                    - WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여
                      서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송한다.

        - 특징
            - java thread를 사용해서 서블릿을 호출
            - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함

        - 주요 기능
            - 서블릿의 생명주기를 관리
                - 서블릿 컨테이너가 기동 되는 순간 서블릿 클래스를 로딩해서 인스턴스화하고, 초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작한다.
                  그리고 서블릿의 생명이 다하는 순간 가비지 컬렉션을 통해 메모리에서 제거한다.

            - 통신 지원
                - 클라이언트의 Request를 받아주고 Response를 보낼 수 있게 웹 서버와 소켓을 만들어서 통신을 해준다.
                - 블릿 컨테이너는 이렇게 소켓을 만들고 listen, accept 등의 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해주고 개발자로서 비즈니스 로직에 더욱 집중할 수 있게 만들어준다.

            - 멀티스레딩 관리
                - 해당 서블릿의 요청이 들어오면 스레드를 생성해서 작업을 수행한다.

            - 선언적인 보안관리


- 서블릿의 동작 방식에 대해 설명해주세요.
    1. 사용자(Client)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다.
    2. 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
    3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
    4. 해당 서블릿에서 service 메소드를 호출한 후 GET, POST 여부에 따라 doGet() 또는 doPost()를 호출합니다.
    5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보냅니다.
    6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.


- MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.
    - MVC framework은 FrontController 패턴으로 이루어짐.
      모든 컨트롤러의 컨트롤러로써 서블릿 하나로 클라이언트의 요청을 받음
      spring web MCV 의 DispatcherServlet이 FrontController 패턴으로 구현되어 있음

    - HTTP 요청
    1.핸들러 조회: 핸들러 매핑을 통해 요청 URL 에 매핑된 핸들러(컨트롤러)를 조회한다.
    2.핸들러를 처리할 수 있는 어댑터 조회
    3.핸들러 어댑터 실행
    4.핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.
    5.ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView 로 변환해서 반환한다.
    6.viewResolver 호출: 뷰 리졸버를 찾고 실행한다.
    7.view 반환: 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
    8.뷰 렌더링: 뷰를 통해서 뷰를 렌더링 한다.
    - HTTP 응답

    1. 클라이언트는 URL을 통해 요청을 전송한다.
    2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
    3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
    4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
    5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
    6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
    7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
    8. 데이터가 추가된 뷰를 반환한다.


- @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요. ??
    - @RequestBody   https://blogshine.tistory.com/445   https://blogshine.tistory.com/446
        - 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할
        - 값을 주입하지 않고 값을 변환 시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다.
        - Jackson에서 기본생성자와 getter, setter가 없으면 자동적으로 @JsonCreater를 해당 인자를 받는 생성자에 붙여서 동작하도록 도와준다.
          @RequestBody를 바인딩 하기 위해 ObjectMapper를 사용하는데 기본 생성자로 DTO를 생성
          setter와 getter 모두 없는 경우에는 ObjectMapper가 바인딩하는데 오류가 생기므로 둘 중 하나는 필요

    - @RequestParam
        - 1개의 HTTP 요청 파라미터를 받기 위해 사용.
        - 필수 여부 설정 가능

    - @ModelAttribute
        - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자,Getter,Setter를 통해 주입하기 위해 사용
        - 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter,Setter가 없으면 변수들이 저장되지 않는다.


- AOP
    - AOP 가 무엇일까
        - Aspect Oriented Programming
        - 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 반복 작업을 줄이고 핵심 비즈니스 로직 개발에만 집중할 수 있음

        - 사용 목적에 따라
            - 프록시 패턴: 클라이언트가 타깃에 접근하는 방법 제어
            - 데코레이터 패턴: 타깃에 부가적인 기능 부여

    - AOP 의 용어들 ??
        - Target Object
            - 부가 기능을 부여할 대상
            - Aspect 가 적용되는 곳
            - 먼저 Target Object는 횡단기능(Advice)이 적용될 객체(Object)를 뜻한다.
            - 이 객체는 핵심 모듈(비즈니스 클래스)이라 할 수 있다. Spring AOP에선 Advice를 받는 객체라 하여 Adviced Object라는 용어로 쓰이기도 한다.
            - Spring AOP에선 실제 적용할 객체 대신 Runtime Proxy를 사용하여 구현되기 때문에, Target Object는 항상 Proxy Object다.

        - Aspect
            - 부가 기능을 정의한 Advice 와 어드바이스를 어디에 적용할 지 결정하는 Pointcut 을 함께 가짐.

        - Advice
            - 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.
            - Advice는 JoinPoint에 적용할 횡단 코드를(공통코드) 의미한다. 어떤 부가 기능 ? Before , AfterReturing , AfterThrowing , After , Around

        - JoinPoint
            - Advice 가 Target에 적용되는 시점
            - 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
            - JoinPoint는 Target Object안에서 횡단기능(Advice)이 적용될 수 있는 여러 위치를 뜻한다. 어디에 적용할 것인가? 메서드 , 필드 , 객체 , 생성자등

        - Pointcut
            Joint Point 의 상세 스펙을 정의한 것
            어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

        - 위빙 (Weaving)
            지정된 객체에 애스팩트를 적용해서 새로운 프록시 객체를 생성하는 과정

    - AOP 구현 방법
        - 컴파일 시점에 코드에 공통 기능 삽입

        - 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
            - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
              좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
            - 컴파일된 Target의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채 바이트코드를 조작하는 방법을 사용한다.
              그렇기 때문에 .java파일과 .class 파일을 비교해보면 내용이 달라진걸 확인할 수 있다.
            - 바이트코드 조작을 사용하는 이유는 두 가지 이유
                1. 스프링과 같은 DI컨테이너의 도움을 받지 않아도 AOP를 적용할 수 있기 때문이다.
                   그렇기에 스프링과같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP의 적용이 가능해진다.
                2. 프록시 방식보다 강력하고 유연한 AOP가 가능하다.
                   프록시를 AOP의 핵심 메커니즘으로 사용할 경우 부가기능(공통 모듈)을 부여할 대상은 클라이언트가 호출할 때 사용하는 메소드로 제한된다.
                   하지만, 바이트코드 조작 방식을 사용하면, 오브젝트의 생성, 필드 값 조회및 조작, 스태틱 초기화 등 다양한 작업에 부가기능을 부여할 수 있다.

        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입 (스프링 AOP가 사용하는 방법)
            프록시로 만들어서 DI 로 연결된 빈 사이에 적용해 Target의 메소드 호출 과정에 참여해 부가 기능(공통 모듈)을 제공해준다.
            런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.
            Advice 가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프록시의 InvocationHandler와 마찬가지로 프록시부터
            메소드 요청정보를 전달받아 타깃 오브젝트의 메소드를 호출하는데, 이렇게 메소드를 호출하는 전/후로 부가기능(공통 모듈)을 제공할 수 있다.

    - Spring 에서 AOP 를 구현한 방법
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
            - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
            - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
            - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용

    - target 에 여러 AOP 가 동시에 적용되어도, 스프링의 AOP 는 target 마다 하나의 프록시만 생성한다. ??

    - 동적 프록시
        - JDK 동적 프록시
            - 인터페이스를 기반으로 동적 프록시

        - CGLIB
            - 구체 클래스만 가지고 동적 프록시

        - 프록시 팩토리
            - 실제 객체의 인터페이스의 유무에 무관하게 프록시 객체를 생성 가능
            - 둘을 개념적으로 추상화 한 것

        - 빈 후처리기 ??
            - 프록시 객체를 빈으로 등록해야 하므로 수동 빈 등록만 가능하고 Config 에서 모든 빈마다 프록시 객체를 생성 해줘야하는 번거로움이 있다.
            - 객체를 빈으로 등록하기 직전에 프록시객체로 바꿔줄 수 있는 빈 후처리기
            - 자동 빈 등록도 프록시가 적용 가능하며, 일일이 프록시 객체를 생성할 필요 없다.

            - 자동 프록시 생성기는 2가지 일을 한다.
                1. @Aspect 를 보고 어드바이저( Advisor )로 변환해서 저장한다.
                2. 어드바이저를 기반으로 프록시를 생성한다.


- 다이나믹 프록시랑 cglib proxy 차이점은? cglib proxyj는 클래스기반만 가능한가?
    - JDK Dynamic Proxy
        proxy 생성을 위해 interface가 필요하다.
        Refelction을 이용해 proxy를 생성한다.

    - CGLIB Proxy
        바이트 코드를 조작해 프록시 생성

    Spring AOP에서는 기본적으로 JDK dynamic proxy를 사용한다. ??
    다만, JDK dynamic proxy는 인터페이스가 있어야만 사용할 수 있기 때문에 인터페이스가 없는 경우에는 CGLIB proxy를 사용
    Spring Boot에서는 설정을 통해 JDK dynamic proxy를 이용할지, CGLIB proxy를 이용할지 선택할 수 있다.
    Spring Boot 2.0부터는 디폴트 설정이 CGLIB proxy를 사용하도록 바뀌었다.

    - 왜 진작 CGLIB을 이용하지 않았을까?
        JDK dynamic proxy는 무조건 인터페이스가 있어야하고 Reflection을 사용하기 때문에 성능이 비교적 느리다고 알려져있다.
        그렇다면 진작에 CGLIB을 디폴트로 설정해두었으면 좋았을걸 왜 나중에 적용했을까?

        1. 오픈소스
            일단 CGLIB가 오픈 소스였던 것이 문제다. 신뢰하고 사용해도 될 정도로 검증할 시간이 필요했고 Spring에 내장되어있지 않아
            별도로 의존성을 추가해야한다는 문제도 있었다. Spring 3.2버전부터 spring-core로 리패키징된 상태라 의존성을 추가할 필요가 없어졌다.

        2. 디폴트 생성자 필요 & 생성자 중복 호출
            기존에는 CGLIB를 이용하면 디폴트 생성자가 필요했고 원본 객체의 생성자를 두 번 호출했다. 실제 빈을 생성할 때 한번, 프록시 생성을 위해 한번더.
            Spring 4.3부터는 Objenesis 라이브러리를 통해 생성되기 때문에 해당 현상이 개선되었다.


- AOP가 Proxy 방식이라 발생할 수 있는 단점(self invocation) ??
    - 같은 객체의 자신의 메소드 외의 다른 메소드를 호출 시 AOP 적용되지 않는 것
    - self-invocation 해결 방법
        - AopContext 이용
        - 자기 자신을 빈으로 등록 후, 메소드 호출
        - AspectJ Weaving 방식으로 변경


- Filter vs Interceptor vs AOP
    - 공통 관심 사항
        많은 로직에서 공통으로 관심이 있는 부분을 공통 관심사(cross-cutting concerns)라 한다.
        웹에 관련된 공통 관심사는 스프링 AOP 보다는 서블릿 필터, 스프링 인터셉터에서 처리하는게 좋다.
        웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL 정보가 필요한데 서블릿 필터나, 스프링 인터셉터는 HttpServletRequest를 제공하기 때문이다.

    - 서블릿 필터 vs 스프링 인터셉터
        둘 다 자유롭게 필터 및 인터셉터를 체인 형태로 추가할 수 있다.

        필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다.
        인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에
        스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.

        필터는 공통된 보안 및 인증/인가 관련 작업, Spring과 분리되어야 하는 기능
        인터셉터는 로그인 체크, 권한 체크

    - AOP
        주로 로깅, 트랜잭션, 에러 처리 등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용합니다.
        Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다.


- @Transactional의 동작 원리에 대해 설명해주세요.
    - @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며,
      Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행합니다.


- @Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다.
      즉, A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않은 일반 코드가 수행됩니다.


- @Transactional 이 동작하지 않을 때
    - @Transactional을 선언한 함수 내부에 try-catch구문
        에러를 밖으로 던져야 하는데 내부적으로 잡아버리니 함수는 성공 처리된다.
        성공으로 처리되기 때문에 트랜잭션이 롤백되지 않는다.

    - @Transactional을 선언한 함수를 같은 클래스에서 호출할 경우
        @Transactional은 스프링 AOP기반으로 동작하기 때문에 같은 클래스 내부의 함수를 호출한 경우 동작하지 않는다.

    - @Transactional이 걸린 함수가 private인 경우
        사실 private 로 선언되었다는 것은 같은 클래스 내부의 함수에서 호출된다는 말이므로 위의 2번과 같은 내용이다.

    - @Transactional이 걸린 함수 내부에서 CheckedException이 발생한 경우
        Checked Exception는 복구가 가능하다는 메커니즘을 가지고 있기 때문에 Rollback 이 아닌 일반적인 코드 흐름으로 제어해야 함


- A 라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때,
  @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.
      그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다.


- 트랜잭션 전파 방식
    - 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성

    - REQUIRED: 현재 진행중인 트랜잭션이 있으면 그것을 사용하고, 없으면 생성한다. [DEFAULT 값]
    - REQUIRES_NEW: 항상 새로운 트랜잭션을 시작.
    - MANDATORY: REQUIRED와 비슷. 현재 진행중인 트랜잭션이 있으면 그것을 사용하고, 없으면 Exception 발생. 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용
    - SUPPORTS: 이미 진행중인 트랜잭션이 있으면 그것을 사용. 없으면 그냥 트랜잭션 없이 진행.
    - NOT_SUPPORTED: 트랜잭션 사용하지 않게 한다. 이미 진행중인 트랜잭션이 있으면 보류
    - NEVER: 트랜젝션을 사용하지 않도록 강제한다. 이미 진행중인 트랜잭션도 존재하면 안됨. 있다면 예외 발생


- REQUIRES_NEW는 부모 트랜잭션에서 완전 독립적인 트랜잭션을 생성하는가 ?
    - 새롭게 생긴 자식 트랜잭션에서 Exception이 발생하면 부모 트랜잭션까지 전파된다.
      왜냐면 스프링에서 트랜잭션은 thread-local을 기반으로 동작한다.??
      TransactionSynchronizationManager는 관련 리소스들을 쓰레드 로컬에 보관하고있다. 트랜잭션 매니저는 이녀석을 이용해서 리소스를 사용한다.
      REQUIRES_NEW는 별도의 새로운 트랜잭션(커넥션도 실제 다르다)을 만들 뿐, 쓰레드는 동일하다.

    - 그럼 어떤 경우에 REQUIRES_NEW 전파 레벨을 사용하는 것이 좋을까?
        - 부모 트랜잭션에서 Exception이 발생해도 자식 트랜잭션은 커밋이 되어야 하는 경우
        - 부모 트랜잭션에서 자식 트랜잭션을 try - catch 하고 싶은 경우
            - 부모 트랜잭션 커밋, 자식 트랜잭션 롤백


- Read only Transaction을 사용하는 일반적인 이유 ??
    - 해당 설정을 사용한 트랜잭션은 데이터(테이블, 칼럼)에 대하여 Lock을 적용할 필요가 없고 접근할 수 있는 데이터가 (스냅샷, 튜플 등) 변경되지 않기 때문에, 일관적인 데이터를 읽어오고 제공할 수 있다.
    - 해당 속성의 경우 일반적으로 트랜잭션 ID를 부여하지 않아도 되기에 불필요한 ID 설정에 대한 오버헤드가 발생하지 않기 때문에 성능의 이점을 볼 수 있다.
    - 추가적으로 읽기-쓰기 트랜잭션을 위해 구성되는 별도 스냅샷의 총 수가 줄어든다.

    - Oracle
        - Read Only 트랜잭션을 이용할 경우 이 트랜잭션이 시작되기 이전에 커밋된 데이터만 접근할 수 있으며, 트랜잭션 실행되는 동안 커밋되는 데이터는 결과에 반영되지 않는다.
        - 해당 트랜잭션 시에 지원하는 DML은 SELECT(조회) 구문뿐이다.
        → 해당 트랜잭션 내에서 일관적인 데이터를 얻도록(데이터 일관성) 보장한다. 즉 성능 이점만을 위함이 아니다.


- 스프링에서 어떤 exception에서 롤백처리를 하냐?
    - 스프링의 Transcational 어노테이션은 기본 정책이 Unchecked Exception과 Errors 이다.
      즉, Checked Exception일 경우 Transactional 어노테이션이 작동하지 않는다.
      컴파일 시 체크할 수 있는 예외에 대한 처리를 호출자에게 강제할 수 있어야 한다.
    - 아무것도 설정하지 않으면, 스프링은 아래와 같이 인식한다.
      @Transactional(rollbackFor = {RuntimeException.class,Error.class})
    - Checked Exception에서 Rollback을 발생시키려면
      rollbackFor라는 옵션을 이용해 모든 예외에 대해서 rollback을 처리.
      Checked Exception을 try-catch문으로 더 구체적인 Unchecked Exception으로 처리.


- @autowired , @Resouce , @inject
    - @Inject 와 @Resource 는 JSR 에 실려있는 자바 기존의 어노테이션. 반면 @Autowired 는 스프링에서 등장한 어노테이션.
      따라서 프로젝트를 스프링이 아닌 다른 프레임워크로 바꿔야 한다면 @Inject 나 @Resource 를 써야 한다.
    - 연결 방식은 @Autowired 와 @Inject 는 타입에 맞춰서 하는 반면, @Resource 는 이름에 맞춰서 연결.

    @Autowired
        - 타입 -> 이름 -> @Qualifier -> 실패
        - 멤버변수, setter메소드, 생성자, 일반 메소드에 적용가능

    @Inject
        - 타입 -> @Qualifier-> 이름 -> 실패
        - 멤버변수, setter 메소드, 생성자, 일반 메소드에 적용 가능

    @Resource
        - 이름 -> 타입 -> @Qualifier -> 실패
        - 멤버변수 , setter 메소드


- 모델1 vs 모델2 ??
    - MVC1
        웹 브라우저의 요청을 JSP 페이지가 받아서 처리 하는 구조
        JSP 페이지에 비지니스 로직을 처리 하기 위한 코드와 웹 브라우저에 결과를 보여주기 위한 출력 관리 코드가 뒤섞여 있는 구조
        JSP 페이지 안에서 모든 정보를 표현(view)하고 저장(model)하고 처리(control)되므로 재사용이 힘들고, 읽기도 힘들어 가독성이 떨어진다.

        모든 클라이언트 요청과 응답을 JSP가 담당하는 구조
        단순한 페이지 작성으로 쉽개 구현 가능하다. 중소형 프로젝트에 적합
        웹 애플리케이션이 복잡해지면 유지보수 문제가 발생된다.

    - MVC2
        MVC1 구조와 달리 웹 브라우저의 요청을 하나의 서블릿이 받게 됨
        MVC 모델 2은 모델 1에서 유지보수가 힘들다는 단점을 보완하기 위해 나온 모델이다.
        기존에 뷰와 컨트롤러의 역할을 모두 수행하던 JSP는 뷰의 역할만 하게 하고, 대신 컨트롤러 역할을 Servlet이 수행한다.

        클라이언트의 요청처리와 응답처리, 비지니스 로직 처리하는 부분을 모듈화시킨 구조
        처리작업의 분리로 인해 유지보수와 확장이 용이하다. (Html과 Java 코드가 분리되어 확장에 용이하고 유지보수가 수월해진다.)
        구조 설계를 위한 시간이 많이 소요되므로 개발 기간이 증가한다.


- MVC패턴이란?
    - 데이터를 의미하는 Model, JSP와 같이 실질적으로 보여지는 페이지의 View, 그리고 클라이언트의 Request를 처리하고 View와 Model사이의
      중간 통신 역할을 하는 Controller의 3가지 형태로 구분하여 소프트웨어를 개발하는 방법론.
    - 모델2 방식은 MVC패턴을 따른 것이다.


- @compent로도 빈 설정을 할 수있는데 @service ,@repositorty를 나눠서 사용하는지
    - 레이어 역할을 분리하기 위해

    - 컴포넌트 클래스들에 @Component를 붙일 수 있지만, @Repository, @Service, @Controller를 붙인다면
    - 도구들이 클래스들을 처리하는데 더 적합하도록 할 수 있고 관점(aspects)에 더 연관성을 부여할 수 있다.
    - 스프링에서도 @Component보다는 @Repository, @Service, @Controller를 권장하고 있었던 것이었다.


- @bean , @Auwired등은 어떻게 동작하냐
    - https://kellis.tistory.com/70


- lcoal Thread란 ??
    - ThreadLocal은 thread-local 변수를 제공하는 클래스이다.
    - 여기서 thread-local 변수란 말그대로 thread 내부에서 사용되는 지역변수를 의미한다.
    - 가령 메소드에서 사용하는 변수나 데이터는 파라미터 혹은 메소드 scope 내에서 정의하고 사용하게 되는데,
    - Thread Local을 사용하게 되면, 굳이 변수를 파라미터 같은 곳에 넣지 않아도 공유 및 사용이 가능하게 된다.
    - 그래서 앞서 언급한 SecurityContextHolder은 ThreadLocal을 통해 파라미터로 Principal을 주입 받지 않더라도,
    - 현재 SecurityContextHolder에 ThreadLocal로 저장된 Principal을 꺼내와 사용할 수 있게 되는 것이다.
    - ThreadLocal 변수를 선언하면 각 스레드가 별도의 변수처럼 사용할 수 있다.
    - 스레드가 종료되기 전까지 변수를 사용할 수 있다.
    - 스레드풀을 통해 스레드를 재사용하는 경우 이전에 사용했던 값을 공유할 수 있다. (이해하고 목적에 맞게


- Spring Rest Docs VS Swagger
    - Spring Rest Docs
        - 프로덕션 코드에 영향이 없다.
        - 테스트 코드가 성공해야 문서 작성이 가능하다.
            => Controller에 정의되어 있는 Request Body나 Response Body 등의 API 스펙 정보와 일치하는 API 문서가 만들어진다는 것이다.
               따라서 API 스펙 정보와 API 문서 내의 정보의 불일치로 인해 발생하는 문제를 방지해준다.
        - 문서를 위한 테스트 코드를 관리해야 한다.
            - 개발 시에 테스트 케이스 작성은 필수이므로, 딱히 단점이 아니라고 생각할 수도 있다.
            - 하지만, 개발 도중에 API가 수시로 변경되는 상황에서는 변경사항에 대해 테스트 코드까지 일일이 수정하는 작업은 번거로울 수 있으므로,
              이러한 상황에선 Swagger를 사용하는 편이 더 적합하다고 볼 수 있다.
            - 테스트가 성공하는 올바른 프로덕션 코드에 대해서만 문서를 작성할 수 있다.
              API 스펙과 항상 일치하는 문서를 작성할 수 있다.

    - Swagger
        - 문서상에 api를 테스트할 수 있는 기능이 있다.
        - 테스트 코드가 없으므로 적용이 쉽다.

        - 프로덕션 코드에 어노테이션 추가해야한다. (라이브러리가 바뀌는 등의 경우 불편하다.)
        - 프로덕션 코드와 동기화가 안될 수 있다.
        - 프로젝트의 규모가 커질수록 프로덕션 코드의 유지보수성이 떨어지고, 변경점이 늘어난다.
        - API 문서의 목적은 개발하는 스펙을 정의하는것이라 생각합니다. Swagger는 API 동작을 테스트하는 용도에 더 특화

        - API 스펙이 변경되더라도 어노테이션을 변경하지 않으면 API 문서는 수정되지 않는다. 즉, 문서와 실제 API 스펙이 일치함을 보장할 수 없다.

    - AsciiDoc VS Markdown (문서화 도구)
        - Markdown은 문법이 굉장이 편하다.
          Slate를 사용하면 import 기능을 사용할 수 있지만 결과물이 우리가 생각한 doc파일과는 다르며 별도 설정을 해야하는 번거로움이 있습니다.
        - AsciiDoc은 문법은 조금 불편하지만 include가 가능하기 때문에 html을 작성하는 것처럼 재활용이 가능
          자동생성된 스니펫과 자신이 원하는 문서를 결합해서 사용할 수 있습니다.

    - MockMvc(@WebMvcTest) vs Rest Assured(@SpringBootTest)
        - 보통 문서를 작성할 때 서비스 계층은 Mocking을 하여 작성합니다. Rest Assured는 BDD 스타일로 직관적이지만 별도의 구성없이는 @SpringBootTest로 수행해야합니다.
          그러면 전체 컨테스트를 로드하여 빈을 주입하기에 속도가 많이 느립니다. 반면에 MockMvc는 @WebMvcTest로 수행이 가능합니다.
          그래서 Controller Layer만 테스트 하기에 속도가 빠릅니다. 만약 통합테스트를 한다면 Rest Assured가 좋은 선택일것 같지만
          Spring Rest Docs로 문서를 작성하는데에는 MockMvc가 더 나은 선택이라 생각됩니다.
        - @WebMvcTest는 @SpringBootTest와 다르게 프레젠테이션 레이어의 빈들만 로드한다. 나머지 계층은 Mocking을 한다.
          이렇게 독립적으로 하나의 계층만을 테스트 하는 기법을 슬라이스 테스트라고 한다.

    - Rest Docs 적용해보기
        1. Spring TEST에 의해 성공한 케이스들에 대한 snippet이 자동으로 생성된다.
        2. 문서를 직접 작성하고 코드들에 대한 정보는 아까 생성된 snippet을 include하여 추가하여 완성한다.

    - Spring Rest Docs의 API 문서 생성 흐름
        - 테스트 코드 작성 -> test 태스크(task) 실행 -> API 문서 스니펫(.doc 파일) 생성 -> API 문서 생성 -> API 문서를 HTML로 변환

    - 관련 용어
        스니핏(snippet) : 문서/코드의 일부 조각을 의미한다.

        스니핏은 테스트 케이스 하나 당 하나의 스니핏이 생성되며, 여러개의 스니핏을 모아서 하나의 API 문서를 생성할 수 있다.
        Asciidoc : Spring Rest Docs를 통해 생성되는 텍스트 기반 문서 포맷.

        주로 기술 문서 작성을 위해 설계된 가벼운 마크업 언어이다.
        Asciidoctor : AsciiDoc 포맷의 문서를 파싱해서 HTML 5, 매뉴얼 페이지, PDF 등의 문서를 생성하는 툴.


- Spring WebFlux ??
    - Non-Blocking IO
        - 우리가 보통 사용하던 Spring MVC + RDBMS 패턴은 Blocking IO 방식이다.
        - Blocking IO 방식이라는 것은 요청을 처리하기 전까지는 다른 작업을 수행할 수 없는 상태라는 것을 말한다.
        - 동시에 여러 요청을 처리하기 위해서는 Thread 수를 늘려서 하는 방법이 존재하기는 하지만 오버헤드가 발생한다.
        - 이를 개선하기 위해서 나온 기술이 Non-Blocking IO 방식인 Spring WebFlux이다.
        - Spring WebFlux는 동시에 처리되어야 할 많은 요청에 대해 효율적으로 처리해 줄 수 있다.

    - 비동기
        - 스레드 풀을 이용한 동기식 호출 방식은 코드가 간단하고 순차적으로 동작하기 때문에 개발자가 코드를 직관적이고 빠르게 작성할 수 있다.
        - 동기식 호출 방식에서는 상대편의 응답이 올 때까지 스레드는 기다려야(blocking)한다.
        - 응답이 빨리 오면 그 기다림은 길지 않겠지만 만약 응답이 늦게 오면 서버가 요청에 대한 응답을 기다리는 데 스레드를 모두 소진해서 추가 요청을 처리할 수 없는 상태가 될 수 있다.
        - 특히 MSA에서는 타임아웃이 발생할 정도의 지연이 발생하면 순식간에 다른 모듈로 전파되어 전체 시스템이 마비되는 등의 악영향을 끼칠 수 있다.
        - 쓰레드가 서버로 요청을 하고 나서 꼭 응답을 기다리면서 아무 것도 하지 않고 대기해야 할까?
        - 쓰레드가 응답을 기다리지 않고 다른 일을 처리하다가 응답이 왔을 때 해당 일을 처리한다면 응답만 기다리면서 불필요하게 리소스를 점유하는 일은 없을 것이다.
        - 이러한 요구 사항에서 나온 것이 이벤트 루프를 이용한 비동기 프로그래밍이다.
        - 이벤트 루프를 활용하면 요청을 보내고 응답이 올 때까지 무작정 기다리는 대신 자신에게 할당된 다른 여러 소켓의 요청을 순차적으로 빠르게 처리한다.
        - 이제 우리의 서버와 클라이언트의 스레드는 더이상 blocking되지 않는다.
        - Spring 생태계에서도 버전 5부터 도입된 WebFlux를 통해 비동기 프로그래밍을 본격적으로 도입하고 있다.
        - 순차적으로 처리되는 방식이 아니라 디버깅이 힘들고 개발이 어렵다.


- spring boot xml로 설정했는지 java cofig로 했는데 config로 하는거랑, xml로 설정하는 것중 머가 더 편한지 편하면 왜 편하지 머가 다른지 ??
    Spring 프레임워크는 3.1부터 기존의 XML 설정에 더해 Java 기반의 설정까지 지원하기 시작하였다.
    초기에는 XML로 설정들을 관리할 것을 권하였지만, 이제는 다음과 같은 이유로 Java 기반의 설정을 권장하고 있다.

    1. 더 많은 정보를 얻을 수 있다.
        @Component
        public class UserFactory {
        }

        위의 코드는 @Component이라는 간단한 어노테이션만 추가되었을 뿐이다. 하지만 우리는 이를 통해 해당 어노테이션이 클래스에 적용가능하며,
        어노테이션이 붙은 클래스의 메타 정보들(패키지, 클래스 이름, 접근 제한자, 상속/구현 등) 까지 얻을 수 있다. 또한 해당 클래스는 정상적으로 빈 등록이 되어 있음을 파악할 수 있다.
        반면에 XML은 모든 설정을 명시적으로 나타내야 하며, 간단한 클래스를 지정하는 것도 상당히 번거롭다. 그리고 얻을 수 있는 정보의 양도 제한적이다.
        왜냐하면 XML은 단순 텍스트이기 때문에 해당 클래스가 다른 클래스와 어떤 관계를 갖는지 등을 알 수 없기 때문이다.

        < bean id="userFactory" class="org.mangkyu.user.UserFactory" />

        또한 우리는 해당 클래스만을 보고 빈(Bean)이 정상적으로 설정되었는지 파악하기가 어려울 것이다.
        빈의 등록정보를 파악하기 위해서는 또 다시 XML 파일을 찾아봐야 할 것이다.

    2. 설정의 변경이 용이하다.
        IDE를 통해 클래스의 위치나 이름을 바꾸는 것은 상당히 간단하다. 반면에 XML로 되어있는 설정은 단순 테스트로 되어있기 때문에 변경이 번거로우며 안전하지 못하다.
        물론 최근에 IDE가 이를 많이 지원하고 있지만, 그래도 문제를 유발할 수 있는 텍스트를 다루는 것 보다는 Java 파일을 다루는 것이 좋을 것이다.

    3. 컴파일 에러를 얻을 수 있다.
        빈 등록과 같은 설정을 진행하다 보면 빈의 클래스 이름이나 메소드 등을 작성할 때 오타가 나거나 타입이 맞지 않는 것 등을 컴파일러가 미리 잡아줄 수 있다.
        하지만 XML로 작성했을 때는 컴파일러가 이를 잡아주지 못할 뿐더러, 문제가 생겼을 경우에 원인을 찾는게 상당히 까다로워 질 수 있다.


- AOP에 대한 사실과 오해 그런데 트랜잭션을 사알짝 곁들인..
    - public 이외의 메서드는 AOP가 걸리지 않는다.
        - 실제 인텔리제이에서 private 메서드에 @Transactional 을 선언하면 위와 같이 컴파일 에러를 띄워줍니다.
        - 왜 private 메서드에는 @Transactional이 붙을 수 없을까요?
            스프링 aop에서 프록시는 크게 JDK Dynamic proxy또는 CGLIB으로 작동합니다. 그리고 spring boot 1.4 버전 이후부터는 default로 CGLIB을 사용합니다.
            CGLIB은 동적으로 상속을 통해 프록시를 생성합니다. 따라서 private 메서드는 상속이 불가능하기 때문에 프록시로 만들어지지 않는것
        - protected일 때 또한 정상 동작하지 않습니다.
            분명히 인텔리제이로 확인을 해보면 컴파일 에러는 나오지 않는다.
            JDK Dynamic proxy는 인터페이스를 기반으로 동작합니다. 따라서 protected 메서드에서는 프록시가 동작할 수 없는 것이죠.
            그래서 스프링에서는 일관된 AOP적용을 위해서 protected로 선언된 메서드 또한 트랜잭션이 걸리지 않도록 한 것입니다.
            즉, 프록시 설정에 따라 트랜잭션이 적용되었다 안되었다 하는 변칙적인 결과를 막기 위함

    - 같은 클래스내에서 트랜잭션이 걸린 메소드를 호출하면 트랜잭션이 작동하지 않는다.
        Spring AOP에서 프록시의 동작 과정을 보면 프록시를 통해 들어오는 외부 메서드 호출을 인터셉트 하여 작동합니다.
        프록시 내부에서 호출하게 됩니다. 따라서 proxy가 인터셉트하지 못해서 트랜잭션이 동작하지 않는것입니다.

        - 그렇다면 내부 메서드에서 호출은 AOP적용이 불가능하다?
            - AspectJ
                타겟 내에서 타겟의 다른 메서드를 호출할 때, 런타임에 실제 트랜잭션이 작동하지 않는다고 합니다. 즉, 런타임 시점에 작동은 안 하지만 이것을 컴파일 시점에 적용하면 된다는 것이죠.
                AspectJ는 스프링AOP와 다르게 컴파일 시점에 위빙이 이루어집니다. 따라서 AspectJ를 사용하면 self-invocation문제를 해결할수 있는 것

            - AopContext
                AopContext의 currentProxy() 메서드는 현재 AOP proxy를 반환
                @EnableAspectJAutoProxy(exposeProxy = true) 옵션을 적용해서 작동

            - 자기 자신을 호출하는 방법
                내부에서 프록시를 호출하면 인터셉터가 작동하지 않으므로 외부에서 호출하는 방식으로 해결하는 것
                    @Resource
                    @Autowired
                    @Inject

                외부에서 내부 빈으로 호출을 하므로 아래와 같이 aop가 정상 동작

                *주의: 해당 방식은 2.6 보다 낮은 버전에서 가능합니다. 스프링 부트 2.6 버전부터는 기본적으로 순환 참조를 금지하도록 변경되었습니다.
                만약 2.6 버전 이상에서 실습해보고 싶으시다면 아래의 설정을 추가하시면 됩니다.
                    spring:
                      main:
                        allow-circular-references: true


- ControllerAdvice는 AOP로 구현되어 있을까? ControllerAdvice의 동작 과정 살펴보기
    - ControllerAdvice의 동작 과정
        1. 디스패처 서블릿이 에러를 catch함
            스프링에서 모든 요청을 가장 먼저 받는 곳은 디스패처 서블릿이다. 그러다보니 에러가 발생하면 에러 처리가 시작되는 곳 역시 디스패처 서블릿인데,
            디스패처 서블릿의 핵심 메소드인 doDispatch에는 다음과 같이 모든 Exception과 Throwable을 catch하고 있다.

        2. 해당 에러를 처리할 수 있는 처리기(HandlerExceptionResolver)가 에러를 처리함
            HandlerExceptionResolver의 구현체 중에서 ControllerAdvice는 ExceptionHandlerExceptionResolver에 의해 처리된다.

        3. 컨트롤러의 ExceptionHandler로 처리가능한지 검사함
            ExceptionHandler는 Controller에 구현할 수도 있고, ControllerAdvice에도 구현할 수 있다.
            ControllerAdvice에 구현하는 것은 전역적인 반면에 Controller에 구현하는 것은 지역적이다.
            그러므로 Controller에 있는 ExceptionHandler가 우선 순위를 갖도록 먼저 컨트롤러의 ExceptionHandler를 검사한다.

        4. ControllerAdvice의 ExceptionHandler로 처리가능한지 검사함
            컨트롤러에서 갖는 ExceptionHandler로 처리가 불가능하다면 등록된 모든 ControllerAdvice 빈을 검사한다.

        5. ControllerAdvice의 ExceptionHandler 메소드를 invoke하여 예외를 반환함
            스프링은 리플렉션 API를 이용해 ExceptionHandler의 구현 메소드를 호출해 처리한 에러를 반환한다.

    - ControllerAdvice는 AOP로 구현되어 있을까?
        AOP가 적용된 것은 아니다. AOP를 적용하였으면 JDK 동적 프록시나 CGLib등을 이용해 프록시를 적용했어야 한다. 또한 AOP가 갖는 개념들이 있어야 하지만 그러한 부분 존재하지 않는다.
        ControllerAdvice는 단지 중앙 집중형으로 요청을 처리하는 디스패처 서블릿 단에서 에러 처리를 도와주는 스프링의 빈일 뿐이며 AOP로 구현된 것은 아니다.


- 스프링 첫 요청이 처리되는데 오래 걸리는 이유
    1. 스프링의 서블릿 초기화 작업들
        - 디스패처 서블릿과 서블릿의 생명 주기
            스프링에는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임하는 디스패처 서블릿이 있다.

            초기화: 요청이 들어오면 서블릿이 웹 컨테이너에 등록되어 있는지 확인하고, 없으면 초기화를 진행함
            요청 처리: 요청이 들어오면 각각의 HTTP 메소드에 맞게 요청을 처리함
            소멸: 웹 컨테이너가 서블릿에 종료 요청을 하여 종료 시에 처리해야하는 작업들을 처리함

            여기서 우리가 주목해서 봐야하는 부분은 초기화 단계이다.
            클라이언트로부터 요청이 오면 웹 컨테이너는 먼저 서블릿이 초기화 되었는지를 확인한다. 만약 서블릿이 이미 할당되어 있다면 바로 요청을 처리하지만
            그렇지 않다면 init() 메소드를 호출해 초기화를 진행하고 할당한다. SpringBoot에서는 스프링 컨테이너가 웹 컨텍스트까지 제어 가능하므로
            이미 디스패처 서블릿이 할당은 되어 있고, 초기화는 되어있지 않은 상태이다.
            init() 메소드는 첫 요청이 왔을 때 한번만 실행되기 때문에 서블릿의 쓰레드에서 공통적으로 필요로 하는 작업들이 진행되며,
            이러한 이유로 스프링은 첫 요청을 처리하는데 많은 시간을 필요로 하는 것이다.

        - 서블릿 초기화에서 진행되는 작업들
            스프링은 Lazy-Init 전략을 사용해 애플리케이션을 빠르게 구동하도록 하고 있어서, 디스패처 서블릿에 해당 도구들이 설정되지 않은 상태로 띄워지게 된다.
            그리고 서블릿 초기화 시에 애플리케이션 컨택스트로부터 해당 타입의 빈을 찾아서 디스패처 서블릿에 설정(Set)해준다. 그래야 요청을 정상적으로 처리할 수 있기 때문이다.
            이러한 작업들이 서블릿 초기화 시점에 처리되는데, 사실 이러한 부분은 성능에 많은 영향을 주지는 않는다. 오히려 JVM의 JIT 컴파일러에 의한 영향이 훨씬 크다.

    2. JIT 컴파일러의 웜업(Warm-Up)
        - 자바 언어의 동작 방식
            컴파일 언어는 컴파일 과정에서 바로 기계어를 만들어낸다. 그리고 컴파일 시에 코드 최적화까지 진행하여 처리 성능이 상당히 뛰어나다.
            대신 생성된 기계어가 빌드 환경(CPU 아키텍처)에 종속적이라서, 플랫폼이 바뀐다면 다시 빌드해야 하는 문제가 있다.

            하지만 자바는 이러한 플랫폼 종속적인 문제를 해결하고자 JVM을 도입하였고, 그래서 동작 과정이 조금 다르다.
            자바는 먼저 작성된 소스 코드를 바이트 코드로 컴파일하는데, 바이트 코드는 주로 JAR 또는 WAR로 아카이브하여 활용하게 된다.
            JVM은 아카이빙된 파일을 구동하는데, 실시간으로 바이트 코드를 기계어로 번역하면 CPU가 해당 기계어를 처리한다.
            이러한 구조 덕분에 Java는 플랫폼에 종속되지 않게 되었지만, 코드를 실행할 때 바이트 코드를 기계어로 번역하는 작업 때문에 성능이 느려졌다.
            그래서 이러한 문제를 해결하고자 JIT 컴파일러를 도입하여 사용하고 있다.

        - JIT 컴파일러(Just In Time Compiler)의 웜업(Warm-Up) 문제
            자바는 성능 문제를 해결하고자 적시에 기계어를 만들어낸다는 의미의 JIT(Just In Time) 컴파일러를 도입하여 사용하고 있다.
            JIT 컴파일러는 핫스팟이라고도 불리는데, JDK 1.3부터 반영되어 있다.
            JIT 컴파일러는 바이트 코드를 기계어로 번역하는 과정에서 캐시를 활용한다. 그래서 이미 번역된 기계어를 재사용할 수 있도록 하며,
            그에 더해 런타임 환경에 맞춰 코드도 최적화함으로써 성능을 향상시킨다.
            하지만 문제는 애플리케이션이 시작될 때에는 캐싱된 기계어가 없다는 것이고, 그래서 스프링에서 첫 요청이 오래걸리는 것이다.
            만약 요청이 많은 서비스에서 캐싱된 기계어가 없는 상태라면 배포 직후에는 응답 지연이 발생하여 문제가 발생할 수 있다.
            그래서 애플리케이션 시작 후에 강제로 로직을 호출하여 기계어를 캐싱해두는 작업이 필요한데, 이를 warm-up 이라고 한다. 트래픽이 많은 서비스라면 warm-up 작업은 반드시 고려되어야 한다.
            참고로 위에서 설명한 서블릿 초기화 보다는 JIT 컴파일러 부분이 훨씬 성능에 크게 영향을 미친다.

    3. 첫 요청이 느린 문제의 해결 방법
        스프링 애플리케이션이 실행된 후에 핵심 로직들을 강제로 호출시켜 warm-up 하면 된다. warm-up 후에 해당 서버를 투입시키는 것


- 의존성(Dependency)이란? 컴파일타임 의존성과 런타임 의존성의 차이 및 비교
    - 의존성(Dependency)이란?
        - 의존성(Dependency)이란?
            객체의 세계에서 협력은 필수적이며, 객체가 협력한다는 것은 객체 간의 의존성이 존재한다는 것
            여기서 의존성이란 파라미터나 리턴값 또는 지역변수 등으로 다른 객체를 참조하는 것을 의미

        - 의존성 전이, 의존성(Dependency)이 위험한 이유
            의존성은 객체 간의 협력을 위해 필수적이다. 하지만 의존성은 위험하므로 의존성은 최소화되어야 한다.
            왜냐하면 한 객체가 다른 객체에 의존한다는 것은 다른 객체가 변할 때 변경이 전파될 수 있다는 것을 의미. 이를 의존성 전이
            이러한 것들은 불필요한 변경이므로 개방 폐쇠 원칙을 준수하도록 의존성 전이를 최소화해야 한다.
            의존성 전이를 최소화하기 위해서는 컴파일 타임 의존성이 아닌 런타임 의존성을 가져야 한다.

    - 컴파일타임 의존성과 런타임 의존성
        - 컴파일타임 의존성
            코드를 컴파일하는 시점에 결정되는 의존성이며, 클래스 사이의 의존성에 해당
            일반적으로 추상화된 클래스나 인터페이스가 아닌 구체 클래스에 의존하면 컴파일타임 의존성을 갖게된다.
            컴파일타임 의존성은 결합도가 높다.
            소프트웨어 세계에서 결합도는 낮을수록 좋은데, 결합도를 낮추고 바람직한 의존성을 갖기 위해서는 결국 런타임 의존성을 가져야 한다.

        - 런타임 의존성
            코드(애플리케이션)를 실행하는 시점에 결정되는 의존성이며, 객체 사이의 의존성에 해당
            일반적으로 추상화된 클래스나 인터페이스에 의존할 때 런타임 의존성을 갖게 된다.
            런타임 의존성은 추상클래스 또는 인터페이스에 의존하므로 컴파일 시점에 어느 객체에 의존하는지 알지 못한다.
            컴파일 시점에는 딱 비밀번호를 암호화해야 한다는 것만 알고 있을 뿐, 실행될 때 어떠한 객체를 주입받아서 어떤 PasswordEncoder와 결합되는지 알 수 있다.
            이러한 이유로 런타임 의존성은 결합도가 낮으며 다른 객체들과 협력할 가능성을 열어두므로 변경에 유연한 설계를 갖는다.

    - 컴파일타임 의존성과 런타임 의존성 차이 및 비교 정리
        - 컴파일타임 의존성
            - 코드를 컴파일하는 시점에 결정되는 의존성
            - 클래스 사이의 의존성
            - 결합도가 높으며 변경에 유연하지 못함

        - 런타임 의존성
            - 코드(애플리케이션)를 실행하는 시점에 결정되는 의존성
            - 객체 사이의 의존성
            - 결합도가 낮으며 변경에 유연함


- spring에서 사용한 최신버전은??
    1. Spring 2.x
        XML 네임스페이스와 AspectJ를 지원한다

    2. Spring 3.x
        Java 5+ 기반과 Java 기반 @Configuration모델과 같은 기능을 도입
        Bean을 XML 형태로 관리할 수 있다
        RestTemplate을 지원
        h2 같은 내장 자바 데이터베이스 엔진을 편리하게 지원

    3. Spring 4.x
        Java 8 기능을 완전히 지원하는 최초의 버전
        Groovy DSL을 이용하여 외부 빈 설정을 정의
        @Autowire 생성자에 적용 가능
        @RestController 사용 가능
        WebSocket, SockJS 및 STOMP에 대한 지원이 추가

    4. Spring 5.x
        non-blocking과 함수형 프로그래밍, reactive stream의 구현을 할 수 있는 Spring WebFlux를 지원
        Kotlin을 지원과 JUnit 5를 지원
        Spring Boot 2.x 라인은 Spring Framework 5를 기반
        Spring Framework 5에는 Java 8 이상이 필요


- 주입이랑 spring aop차이를 아냐

- spring의 핵심기능에 대해 말해주세요.

- spring aop 동작 원리

- 다이나믹 프록시랑 cglib proxy 차이점은? cglib proxyj는 클래스기반만 가능한가?

- 의존 역전 법칙은 스프링에 어떤 연관이 있냐?

- 스프링 IOC, DI

- IOC가 왜 스프링 장점인지

- 트랜잭션 처리 어떻게 하는지

- 트랜잭션 프로파게이션?(전파레벨)



- starter를 통한 dependency를 자동화 ??

- spring di는 -> di에 사용된 디자인 패턴은 -> 디자인패턴의 예시설명 ??

- @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요. ??

- AOP 의 용어들 ??

- target 에 여러 AOP 가 동시에 적용되어도, 스프링의 AOP 는 target 마다 하나의 프록시만 생성한다. ??

- 빈 후처리기 ??

Spring AOP에서는 기본적으로 JDK dynamic proxy를 사용한다. ??

- AOP가 Proxy 방식이라 발생할 수 있는 단점(self invocation) ??

왜냐면 스프링에서 트랜잭션은 thread-local을 기반으로 동작한다.??

- Read only Transaction을 사용하는 일반적인 이유 ??

- 모델1 vs 모델2 ??

- lcoal Thread란 ??

- Spring WebFlux ??

- spring boot xml로 설정했는지 java cofig로 했는데 config로 하는거랑, xml로 설정하는 것중 머가 더 편한지 편하면 왜 편하지 머가 다른지 ??

- spring 버전별 특징