- 싱글턴 패턴

- Bean Scope
    - 스프링 빈(Spring Bean)이란?
        - 스프링 IoC 컨테이너에 의해서 관리되고 애플리케이션의 핵심을 이루는 객체들을 스프링 빈

    - Scope의 종류
        - Singleton
            - 스프링 빈은 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때까지  1개의 객체로 유지
        - Prototype
            - 요청이 오면 항상 새로운 인스턴스를 생성하여 반환하고 이후에 관리하지 않음
            - 프로토타입을 받은 클라이언트가 객체를 관리해야 함
                - 스프링 컨테이너는 프로토타입 스프링 빈의 생성과 의존관계 주입까지만 관여하고 이후의 과정은 관여하지 않는다.
                    (이후는 해당 빈을 호출한 사용자에 의해서 종료된다.)
                  스프링 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 처리.
                  @PreDestroy같은 종료 메서드가 호출 되지 않는다.
        - Web
            - Request: 각각의 요청이 들어오고 나갈 때까지 유지되는 scope
            - Session: 세션이 생성되고 종료될 때까지 유지되는 scope
            - Application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 scope

    - 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
        - 싱글톤 스프링 빈 내부에 의존관계로 주입되는 스프링 빈이 프로토타입인 경우
            - 프로토타입 스코프의 스프링 빈이 새로 생성되기는 했지만 싱글톤 빈과 함께 사용되기 때문에 계속 유지된다.
            - 싱글톤 빈과 함께 사용하면서 프로토타입 빈이 자기의 스코프를 지키고 매번 새롭게 생성하기 위해서는 어떻게 해야 할까?

            - 의존관계를 외부에서 주입(DI) 받는 것이 아닌 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색)이라 한다.
            - ObjectProvider의 getObject()를 호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
            - 스프링의 의존성이 마음에 들지 않으면 JSR-330 자바 표전을 사용하는 방법이 있다.

    - 프로토타입 빈을 언제 사용해야 하는가?
        - 여러 인스턴스를 검색해야 하는 경우
        - 인스턴스를 지연 혹은 선택적으로 찾아야 하는 경우
        - 순환 종속성을 깨기 위해서
        - 스코프에 포함된 인스턴스로부터 더 작은 범위의 인스턴스를 찾아 추상화 하기 위해서 사용한다.


- Spring Rest Docs VS Swagger
    - Spring Rest Docs
        - 프로덕션 코드에 영향이 없다.
        - 테스트 코드가 성공해야 문서 작성이 가능하다.
            => Controller에 정의되어 있는 Request Body나 Response Body 등의 API 스펙 정보와 일치하는 API 문서가 만들어진다는 것이다.
               따라서 API 스펙 정보와 API 문서 내의 정보의 불일치로 인해 발생하는 문제를 방지해준다.
        - 문서를 위한 테스트 코드를 관리해야 한다.
            - 개발 시에 테스트 케이스 작성은 필수이므로, 딱히 단점이 아니라고 생각할 수도 있다.
            - 하지만, 개발 도중에 API가 수시로 변경되는 상황에서는 변경사항에 대해 테스트 코드까지 일일이 수정하는 작업은 번거로울 수 있으므로,
              이러한 상황에선 Swagger를 사용하는 편이 더 적합하다고 볼 수 있다.

    - Swagger
        - 문서상에 api를 테스트할 수 있는 기능이 있다.
        - 테스트 코드가 없으므로 적용이 쉽다.

        - 프로덕션 코드에 어노테이션 추가해야한다. (라이브러리가 바뀌는 등의 경우 불편하다.)
        - 프로덕션 코드와 동기화가 안될 수 있다.
        - API 문서의 목적은 개발하는 스펙을 정의하는것이라 생각합니다. Swagger는 API 동작을 테스트하는 용도에 더 특화

    - AsciiDoc VS Markdown (문서화 도구)
        - Markdown은 문법이 굉장이 편하다.
          Slate를 사용하면 가능하다고 하지만 결과물이 우리가 생각한 doc파일과는 다르며 별도 설정을 해야하는 번거로움이 있습니다.
        - AsciiDoc은 문법은 조금 불편하지만 include가 가능하기 때문에 html을 작성하는 것처럼 재활용이 가능
          자동생성된 스니펫과 자신이 원하는 문서를 결합해서 사용할 수 있습니다.

    - MockMvc(@WebMvcTest) vs Rest Assured(@SpringBootTest)
        - 보통 문서를 작성할 때 서비스 계층은 Mocking을 하여 작성합니다. Rest Assured는 BDD 스타일로 직관적이지만 별도의 구성없이는 @SpringBootTest로 수행해야합니다.
          그러면 전체 컨테스트를 로드하여 빈을 주입하기에 속도가 많이 느립니다. 반면에 MockMvc는 @WebMvcTest로 수행이 가능합니다.
          그래서 Controller Layer만 테스트 하기에 속도가 빠릅니다. 만약 통합테스트를 한다면 Rest Assured가 좋은 선택일것 같지만
          Spring Rest Docs로 문서를 작성하는데에는 MockMvc가 더 나은 선택이라 생각됩니다.

    - Rest Docs 적용해보기
        1. Spring TEST에 의해 성공한 케이스들에 대한 snippet이 자동으로 생성된다.
        2. 문서를 직접 작성하고 코드들에 대한 정보는 아까 생성된 snippet을 include하여 추가하여 완성한다.

    - Spring Rest Docs의 API 문서 생성 흐름
        - 테스트 코드 작성 -> test 태스크(task) 실행 -> API 문서 스니핏(.doc 파일) 생성 -> API 문서 생성 -> API 문서를 HTML로 변환

    - 관련 용어
        스니핏(snippet) : 문서/코드의 일부 조각을 의미한다.

        스니핏은 테스트 케이스 하나 당 하나의 스니핏이 생성되며, 여러개의 스니핏을 모아서 하나의 API 문서를 생성할 수 있다.
        Asciidoc : Spring Rest Docs를 통해 생성되는 텍스트 기반 문서 포맷.

        주로 기술 문서 작성을 위해 설계된 가벼운 마크업 언어이다.
        Asciidoctor : AsciiDoc 포맷의 문서를 파싱해서 HTML 5, 매뉴얼 페이지, PDF 등의 문서를 생성하는 툴.


- Filter vs Interceptor vs AOP
    - Filter
        - 필터에서는 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리
        - Filter는 다음 체인으로 넘기는 ServletRequest/ServletResponse 객체를 조작할 수 있다는 점에서 Interceptor보다 훨씬 강력한 기술
        - 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리되므로 DispatcherServlet으로 가기 전에 요청을 처리하는 것

        ex) 보안 관련 공통 작업
            모든 요청에 대한 로깅 또는 감사
            이미지/데이터 압축 및 문자열 인코딩

    - 인터셉터(Interceptor)
        - 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트 내부에서 Controller에 관한 요청과 응답에 대해 처리
        - 스프링의 모든 빈 객체에 접근할 수 있다.
        - 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다.
        - 필터와 다르게 HttpServletRequest나 HttpServletResponse 등과 같은 객체를 제공받으므로 객체 자체를 조작할 수는 없다.

        ex) 인증/인가 등과 같은 공통 작업
            API 호출에 대한 로깅 또는 감사
            Controller로 넘겨주는 정보(데이터)의 가공

        - Filter의 doFilter 메서드는 매개변수로 ServletRequest와 ServletResponse를 받고 Interceptor의 preHandle이나 postHandle은 HttpServletRequest를 받는다.
        - ServletRequest는 기본적인 클라이언트 요청에 관한 모든 정보를 가지고 있다. 그리고 이 인터페이스는 다시 HttpServletRequest로 확장하여
          HTTP 프로토콜 상에서 할 수 있는 일들이 포함되어져 있다.
          이 HttpServletReqeust는 서블릿의 service의 매개변수의 하나로 서블릿 프로그래머가 클라이언트의 요청에 관한 작업들을 핸들할 수 있도록하는 중요한 역할을 담당하고 있다.

    - AOP
        - Interceptor와 Filter와 달리 메소드 전 후의 지점에 자유롭게 설정이 가능하며 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.
        - 로깅, 트랜잭션, 에러 처리 등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용


- Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.
    - Spring Filter
        - 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리
        - Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공
        ex) 보안 및 인증/인가 관련 작업
            모든 요청에 대한 로깅 또는 검사
            이미지/데이터 압축 및 문자열 인코딩
            Spring과 분리되어야 하는 기능

    - Interceptor
        - 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작
        - Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
        ex) 세부적인 보안 및 인증/인가 공통 작업
            API 호출에 대한 로깅 또는 검사
            Controller로 넘겨주는 정보(데이터)의 가공


- Spring Framework에 대해 설명해주세요.
    - 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크

    - 경량 컨테이너로서 자바 객체를 직접 관리
        각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
    - 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
        컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 다라 스프링에서 사용자의 코드를 호출한다.
    - 의존성 주입(DI, Dependency Injection)을 지원
        각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
    - 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
        트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.


- Spring과 SpringBoot의 차이점
    (1) 내장 톰캣
        - 내장 톰캣을 사용하기 때문에 따로 톰캣을 설치하거나 매번 버전을 관리해 주지 않아도 된다.
    (2) starter를 통한 dependency를 자동화
        - 기존의 Spring에서는 dependency들의 호환되는 버전을 직접 설정
        - 스프링 부트에서는 이 starter를 통해 종속된 모든 라이브러리를 알맞게 찾아서 함께 가져오기 때문에 의존성이나 호환버전에 대해 신경 쓸 필요가 없다.
    (3) XML
        - View Resolver, 데이터 액세스 등의 xml 설정을 하지 않아도 된다.
    (4) jar
        - jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.
    (5) AutoConfigurator
        - 공통적으로 필요한 설정을 어노테이션을 이용하여 대신할 수 있다.
    (6) Spring Initializr
        - pring Initilizr를 사용하면 실행 환경이나 의존성 관리 등의 인프라 부분을 신경 쓸 필요 없이 바로 코딩을 시작할 수 있게끔 환경을 제공


- Spring WebFlux
    - Non-Blocking IO
        - 우리가 보통 사용하던 Spring MVC + RDBMS 패턴은 Blocking IO 방식이다.
        - Blocking IO 방식이라는 것은 요청을 처리하기 전까지는 다른 작업을 수행할 수 없는 상태라는 것을 말한다.
        - 동시에 여러 요청을 처리하기 위해서는 Thread 수를 늘려서 하는 방법이 존재하기는 하지만 오버헤드가 발생한다.
        - 이를 개선하기 위해서 나온 기술이 Non-Blocking IO 방식인 Spring WebFlux이다.
        - Spring WebFlux는 동시에 처리되어야 할 많은 요청에 대해 효율적으로 처리해 줄 수 있다.

    - 비동기
        - 스레드 풀을 이용한 동기식 호출 방식은 코드가 간단하고 순차적으로 동작하기 때문에 개발자가 코드를 직관적이고 빠르게 작성할 수 있다.
        - 동기식 호출 방식에서는 상대편의 응답이 올 때까지 스레드는 기다려야(blocking)한다.
        - 응답이 빨리 오면 그 기다림은 길지 않겠지만 만약 응답이 늦게 오면 서버가 요청에 대한 응답을 기다리는 데 스레드를 모두 소진해서 추가 요청을 처리할 수 없는 상태가 될 수 있다.
        - 특히 MSA에서는 타임아웃이 발생할 정도의 지연이 발생하면 순식간에 다른 모듈로 전파되어 전체 시스템이 마비되는 등의 악영향을 끼칠 수 있다.
        - 쓰레드가 서버로 요청을 하고 나서 꼭 응답을 기다리면서 아무 것도 하지 않고 대기해야 할까?
        - 쓰레드가 응답을 기다리지 않고 다른 일을 처리하다가 응답이 왔을 때 해당 일을 처리한다면 응답만 기다리면서 불필요하게 리소스를 점유하는 일은 없을 것이다.
        - 이러한 요구 사항에서 나온 것이 이벤트 루프를 이용한 비동기 프로그래밍이다.
        - 이벤트 루프를 활용하면 요청을 보내고 응답이 올 때까지 무작정 기다리는 대신 자신에게 할당된 다른 여러 소켓의 요청을 순차적으로 빠르게 처리한다.
        - 이제 우리의 서버와 클라이언트의 스레드는 더이상 blocking되지 않는다.
        - Spring 생태계에서도 버전 5부터 도입된 WebFlux를 통해 비동기 프로그래밍을 본격적으로 도입하고 있다.
        - 순차적으로 처리되는 방식이 아니라 디버깅이 힘들고 개발이 어렵다.


- Servlet
    - Servlet 정의
        - 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램이 서블릿
        - 서블릿은 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해주는 기술

    - Servlet 특징
        - 서블릿 등장이전에는 CGI (Common Gateway Interface) 기술이 있었는데 이는 요청 당 프로세스를 생성함
            - 서블릿은 CGI에 비해서 작동이 빠르고, 플랫폼에 독립적이며, 보안이 좋고, 이식성이 강함
        - html을 사용하여 요청에 응답
        - 서블릿 객체는 싱글톤으로 관리
            - 고객의 요청이 올 때마다 생성하는 것은 비효율적이기 때문
            - 서블릿 컨테이너가 종료되면 서블릿도 종료

    - 서블릿 컨테이너(Servlet Container)
        - 정의
            - 서블릿을 관리해주며 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하며 post, get여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.
                - HttpServletRequest
                    - http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의
                      정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있다.
                - HttpServletResponse
                    - WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여
                      서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송한다.

        - 특징
            - java thread를 사용해서 서블릿을 호출
            - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함

        - 주요 기능
            - 서블릿의 생명주기를 관리
                - 서블릿 컨테이너가 기동 되는 순간 서블릿 클래스를 로딩해서 인스턴스화하고, 초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작한다.
                  그리고 서블릿의 생명이 다하는 순간 가비지 컬렉션을 통해 메모리에서 제거한다.

            - 통신 지원
                - 클라이언트의 Request를 받아주고 Response를 보낼 수 있게 웹 서버와 소켓을 만들어서 통신을 해준다.
                - 블릿 컨테이너는 이렇게 소켓을 만들고 listen, accept 등의 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해주고 개발자로서 비즈니스 로직에 더욱 집중할 수 있게 만들어준다.

            - 멀티스레딩 관리
                - 해당 서블릿의 요청이 들어오면 스레드를 생성해서 작업을 수행한다.

            - 선언적인 보안관리


- 서블릿의 동작 방식에 대해 설명해주세요.
    1. 사용자(Client)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다.
    2. 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
    3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
    4. 해당 서블릿에서 service메소드를 호출한 후 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
    5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다.
    6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.


- MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.
    1. 클라이언트는 URL을 통해 요청을 전송한다.
    2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
    3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
    4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
    5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
    6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
    7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
    8. 데이터가 추가된 뷰를 반환한다.


- POJO
    스프링에서 생성되어 관리되는 POJO 기반의 객체를 Spring Bean이라고 합니다.
    여기서 POJO는 단순 getter, setter만으로 구성되어 있으며 단순히 new를 통해서 생성 가능한 형태를 말합니다.
    핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있고, 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스입니다.


- @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요.
    - @RequestBody
        - 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할
        - 값을 주입하지 않고 값을 변환 시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다.

    - @RequestParam
        - 1개의 HTTP 요청 파라미터를 받기 위해 사용.
        -  필수 여부 설정 가능

    - @ModelAttribute
        - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자,Getter,Setter를 통해 주입하기 위해 사용
        - 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter,Setter가 없으면 변수들이 저장되지 않는다.


- 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.
    - 제어의 역전(IoC)란 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다.
    - 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고
      컨테이너에 등록한 객체들을 '빈'이라고 합니다.


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것
      이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있습니다.

    - 의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3 가지 방법이 있습니다.
      이 중 Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법입니다.
        1. 순환 참조를 방지
            - 생성자 주입 방식은 필드나 수정자 주입과는 빈을 주입하는 순서가 다르기 때문
            - 필드/수정자 주입은 먼저 빈을 생성한 후, 주입하려는 빈을 찾아 주입.
            - 하지만 생성자 주입은 먼저 생성자 인자에 사용되는 빈을 찾거나 빈 팩토리에서 만든다.
              그 후에 찾은 인자 빈으로 주입하려는 빈의 생성자를 호출
            - 객체 생성 시점에 빈을 주입하기 때문에 서로 참조하는 객체가 생성되지 않은 상태에서 그 빈을 참조하기 때문에 오류가 발생
        2. final 선언 가능
            - 런타임에 객체 불변성 보장
        3. 테스트 코드 작성 용이
            - 스프링 컨테이너 도움 없이 테스트 코드를 더 편리하게 작성 가능
            - 테스트하고자 하는 클래스에 필드/수정자 주입으로 빈이 주입되어 있으면, Mockito를 이용해 목킹한 후 테스트 해아함.
            - 하지만 생성자 주입은 단순히 원하는 객체를 생성한 후, 생성자에 넣어주면 된다.


- 스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요.
    - 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료

    - 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리
        1. 인터페이스( InitializingBean, DisposableBean )
        2. 설정 정보에 초기화 메소드, 종료 메소드 지정
        3. @PostConstruct, @PreDestroy 어노테이션 지원


- @Transactional의 동작 원리에 대해 설명해주세요.
    - @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며,
      Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행합니다.


- @Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다.
      즉, A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않은 일반 코드가 수행됩니다.


- A 라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때,
  @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요.
    - 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.
      그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다.

- AOP
    - AOP 가 무엇일까
        - Aspect Oriented Programming
        - 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 반복 작업을 줄이고 핵심 비즈니스 로직 개발에만 집중할 수 있음

        - 사용 목적에 따라
            - 프록시 패턴: 클라이언트가 타깃에 접근하는 방법 제어
            - 데코레이터 패턴: 타깃에 부가적인 기능 부여

    - AOP 의 용어들
        - Target Object: 부가 기능을 부여할 대상
        - Aspect: 부가 기능을 정의한 Advice 와 어드바이스를 어디에 적용할 지 결정하는 Pointcut 을 함께 가짐.
        - Advice: 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.
        - JoinPoint: 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
        - Pointcut: 어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

    - AOP 구현 방법
        - 컴파일 시점에 코드에 공통 기능 삽입
        - 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
            - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
              좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            (런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.)

    - Spring 에서 AOP 를 구현한 방법
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
            - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
            - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
            - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용

    - target 에 여러 AOP 가 동시에 적용되어도, 스프링의 AOP 는 target 마다 하나의 프록시만 생성한다.

    - 동적 프록시
        - JDK 동적 프록시
            - 인터페이스를 기반으로 동적 프록시

        - CGLIB
            - 구체 클래스만 가지고 동적 프록시

        - 프록시 팩토리
            - 실제객체의 인터페이스의 유무에 무관하게 프록시객체를 생성 가능
            - 둘을 개념적으로 추상화 한 것

        - 빈후처리기
            - 프록시객체를 빈으로 등록해야 하므로 수동 빈 등록만 가능하고 Config 에서 모든 빈마다 프록시객체를 생성해줘야하는 번거로움이 있다.
            - 객체를 빈으로 등록하기 직전에 프록시객체로 바꿔줄 수 있는 빈 후처리기
            - 자동빈 등록도 프록시가 적용 가능하며, 일일이 프록시객체를 생성할 필요 없다.

            - 자동 프록시 생성기는 2가지 일을 한다.
                1. @Aspect 를 보고 어드바이저( Advisor )로 변환해서 저장한다.
                2. 어드바이저를 기반으로 프록시를 생성한다.


- 상태 패턴
    - 아키텍쳐 패턴 vs 디자인 패턴
      아키텍쳐 패턴은 디자인 패턴보다 상위 수준의 설계에 사용된다.
      아키텍쳐 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들끼리의 관계를 설계하기 위한 참조 모델이다.

    - 디자인 패턴
      반복적으로 나타난 문제에 대해 그것을 해결한 경험 및 노하우를 축적하여 재이용하기 좋은 형태로 이름을 붙여 해법을 제시하는 패턴 양식.
      객체지향 프로그래밍을 설계할 때 자주 발생하는 문제를 피하기 위해 사용되는 패턴. 객체 지향의 재사용과 유지보수성 등의 장점을
      이 디자인 패턴을 사용해 극대화할 수 있다.

    - GOF 디자인 패턴  https://4z7l.github.io/2020/12/25/design_pattern_GoF.html
        - 23 가지의 디자인 패턴을 목적에 따라 3가지 유형으로 분류
            - 생성 패턴: 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 하는 패턴
                       객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여 프로그램에 유연성을 더해준다.
                - 추상 팩토리 패턴, 빌더 패턴, 팩토리 메서드 패턴, 프로토타입 패턴, 싱글톤 패턴
            - 구조 패턴: 자료 구조나 인터페이스 등 프로그램의 구조를 설계하는데 활용하는 패턴. 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
                - 어댑터 패턴, 브리지 패턴, 컴포지트 패턴, 데코레이터 패턴, 파사드 패턴, 플라이웨이트 패턴, 프록시 패턴
            - 행위 패턴: 반복적으로 사용되는 객체들의 상호 작용을 패턴화. 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
                       행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 어떤 태스크, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지를 정의하는 패턴
                - 책임 체인 패턴, 커맨드 패턴, 인터프리터 패턴, 중재자 패턴, 메멘토 패턴, 옵저버 패턴, 상태 패턴
                  전략 패턴, 템플릿 메서드 패턴, 방문자 패턴

        -> 디자인 원칙을 떠올려보자. 변하는 것은 잘 변하지 않는 것과 분리해라. 즉, 변하는 녀석들을 캡슐화해라!

    - 상태 패턴
        - 객체 자신의 내부 상태에 따라 행위를 변경하도록 하는 패턴
        - 객체의 특정 상태를 클래스로 선언하고 해당 상태에서 할 수 있는 행위들을 메서드로 정의
          이러한 상태 클래스를 인터페이스로 캡슐화하여 클라이언트에서 인터페이스로 호출하는 방식으로 사용

    - 상태 패턴은 언제 사용할까
        1. 객체의 행동이 상태에 따라 달라질 수 있고, 객체의 상태에 따라 런타임 행동이 바뀌어야 한다.
        2. 객체에 상태에 따라 달라지는 다중 분기조건, 처리가 너무 많이 들어있을 때, 객체의 상태를 표현하기 위해 ENUM 으로 정의해야 한다.

    - 효과
        1. 상태에 따른 행동을 국소화하며 서로 다른 상태에 대한 행동을 별도의 객체로 관리한다.
           새로운 상태가 추가되더라도 context 코드가 받는 영향이 적다.
        2. 상태 전이를 명확하게 만든다. (상태 전이 - 입력에 따라 다음 상태로 바뀌는 것)
        3. 상태에 따른 동작을 구현한 코드를 수정하기 쉽다.

    - 상태 패턴과 전략 패턴의 차이
        - 목적에 따라 구분
            - 상태 패턴: 코드 내 조건문을 대체
            - 전략 패턴: 상속을 대체
        - 다음 상태를 자기 자신이 정하는가
            - 상태 패턴: 상태 객체 내부에서 다음 상태를 결정
            - 전략 패턴: 클라이언트(외부)에서 다음에 실행할 객체를 지정할 수 있다.
            -> 상태 패턴도 외부에서 설정될 수 있기 때문에 상태 기반인가, 방법 기반인가로 나뉘어야 한다.

        -> 전략 패턴 - 사용자가 쉽게 알고리즘 전략을 바꿀 수 있도록 유연성을 제공. 상속의 한계를 해결하기 위하여 나온 패턴
           상태 패턴 - 한 객체가 동일한 동작을 상태에 따라 다르게 수행해야 할 경우 사용하는 패턴

- 전략 패턴
    - 전략, 전략 패턴의 개념
        - 전략: 특정한 목표를 수행하기 위한 행동 계획
        - 전략 패턴: 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고 사용하며, 동적으로 전략 수정이 가능한 패턴
        - 동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만든다.

    - 전략 패턴 in JDK
        ex) Comparator - 개발 상황에 맞게 비교 전략을 구현할 수 이게 하여 기존 코드의 수정 없이 확장할 수 있음

    - 전략 패턴이란?
        - 소프트웨어 디자인 패턴중 하나
        - 동일 계열의 알고리즘을 정의하고, 각 알고리즘을 캡슐화하며, 이 알고리즘들을 상호 교체가 가능하게 만든다.

    - 전략 패턴의 장단점
        - 장점
            - 상속을 사용하지 않을 수 있음
            - if 문을 제거할 수 잇음
            - 구현의 선택이 가능
        - 단점
            - 객체 수 증가
            - 서로 다른 전략을 이해해야 함

    - 상태 패턴과의 비교
        - 공통점
            - 인터페이스를 사용해서 클래스르 캡슐화 한다. (구조가 같다)
            - 컨텍스트 클래스는 영향을 받지 않고 변경에 유연한 대처가 가능 (둘 다 OCP 를 따른다)
        - 차이점
            - 전략 패턴
                - 클라이언트 혹은 사용자에 의해 전략을 주입받는다.
                - 어떻게 객체가 이을 할지, 즉 알고리즘을 캡슐화한다.
                - 하나의 특정 작업만 처리
                - 원하는 알고리즘으로 언제든지 변경하고 싶을 때
            - 상태 패턴
                - 컨텍스트 스스로 상태를 변환할 수 있다.
                - 상태에 따른 행동을 캡슐화한다.
                - 컨텍스트 객체가 수행하는 대부분의 메서드에 대한 인터페이스가 제공
                - 상태 변화가 잦을 경우


- 선언적 트랜잭션 속성
        - propagation
            - 트랜잭션 전파란 트랜잭션 경계에서 이미 진행중인 트랜잭션이 있을  어떻게 동작할지 결정하는 것

            - REQUIRED (디폴트)
                - 이미 시작된 트랜잭션이 있으면 그 트랜잭션에 참여
                - 모든 트랜잭션 매니저가 지원합니다.
                - 해당 메서드를 호출한 곳에서 별도의 트랜잭션이 설정되어 있지 않다면 트랜잭션을 새로 시작
                - 부모 트랜잭션이 존재하면 포함되어 동작
            - SUPPORTS
                - 진행 중인 트랜잭션이 있으면 REQUIRED 처럼 참여하고 트랜잭션이 없으면 트랜잭션 없이 메서드를 실행
                - 해당 경계 안에서 Connection 객체나 하이버네이트의 Session 등은 공유 가능
            - MANDATORY
                - 진행 중인 트랜잭션이 있으면 참여하고 없으면 예외가 발생. 혼자서는 트랜잭션을 시작할 수 없고 메서드를 실행할 수도 없다.
                - 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용
            - REQUIRES_NEW
                - 항상 새로운 트랜잭션을 시작한다. 진행중인 트랜잭션이 있으면 잠시 보류시키고 새로운 트랜잭션으로 실행
                - 새로운 트랜잭션 안에서 예외가 발생해도 호출한 곳으로 롤백이 전파되지 않는다
                - 부모 트랜잭션이 존재하면 2개의 트랜잭션이 완전 독립적으로 동작
            - NOT_SUPPORTED
                - 이미 시작된 트랜잭션이 있으면 보류하고 자신의 메서드를 실행하는, 트랜잭션을 사용하지 않는 설정
                  진행중 인 트랜잭션이 있으면 보류하고 자신의 메서드 실행
                - 트랜잭션을 사용하지 않는다.
                - 부모 트랜잭션이 존재하면 보류시키고 트랜잭션 사용을 정지시킨다
            - NEVER
                - 트랜잭션을 사용하지 않도록 강제. 진행중인 트랜잭션이 없다면 자신의 메서드를 실행하지만 트랜잭션이 있다면 예외 발생
            - NESTED
                - 이미 진행 중인 트랜잭션 있으면 그 안에 새로운 트랜잭션을 만드는 설정.
                - 트랜잭션1 내부에 메서드 2를 트랜잭션 2로 삽입
                - 이렇게 중첩된 트랜잭션 2는 부모인 트랜잭션1의 커밋/롤백에는 영향을 받지만,
                  트랜잭션2의 커밋/롤백에는 트랜잭션1이 영향을 받지 않는다.
                - 부모 트랜잭션의 커밋과 롤백에 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않는다
                    예시) 메인작업을 진행하며 이와 관련된 로그를 DB에 저장
                         메인 작업이 실패 -> 로그 작업 롤백
                         로그를 저장하는 작업이 실패 -> 메인 작업의 트랜잭션은 롤백 X
                - 모든 트랜잭션 매니저에 적용 가능하진 않다.


- @autowired , @Resouce , @inject
    - @Inject 와 @Resource 는 JSR 에 실려있는 자바 기존의 어노테이션. 반면 @Autowired 는 스프링에서 등장한 어노테이션.
      따라서 프로젝트를 스프링이 아닌 다른 프레임워크로 바꿔야 한다면 @Inject 나 @Resource 를 써야 한다.
    - 연결 방식은 @Autowired 와 @Inject 는 타입에 맞춰서 하는 반면, @Resource 는 이름에 맞춰서 연결.

    @Autowired
        - 타입 -> 이름 -> @Qualifier -> 실패
        - 멤버변수, setter메소드, 생성자, 일반 메소드에 적용가능

    @Inject
        - 타입 -> @Qualifier-> 이름 -> 실패
        - 멤버변수, setter 메소드, 생성자, 일반 메소드에 적용 가능

    @Resource
        - 이름 -> 타입 -> @Qualifier -> 실패
        - 멤버변수 , setter 메소드


- 스프링에서 어떤 exception에서 롤백처리를 하냐?
    - 스프링의 Transcational 어노테이션은 기본 정책이 Unchecked Exception과 Errors 이다.
      즉, Checked Exception일 경우 Transactional 어노테이션이 작동하지 않는다.
      컴파일 시 체크할 수 있는 예외에 대한 처리를 호출자에게 강제할 수 있어야 한다.
    - 아무것도 설정하지 않으면, 스프링은 아래와 같이 인식한다.
      @Transactional(rollbackFor = {RuntimeException.class,Error.class})
    - Checked Exception에서 Rollback을 발생시키려면
      rollbackFor라는 옵션을 이용해 모든 예외에 대해서 rollback을 처리.
      Checked Exception을 try-catch문으로 더 구체적인 Unchecked Exception으로 처리.


- @bean , @Auwired등은 어떻게 동작하냐

- 주입이랑 spring aop차이를 아냐

- spring boot xml로 설정했는지 java cofig로 했는데 config로 하는거랑, xml로 설정하는 것중 머가 더 편한지 편하면 왜 편하지 머가 다른지?

- spring의 핵심기능에 대해 말해주세요.

- spring에서 사용한 최신버전은?

- spring di는 -> di에 사용된 디자인 패턴은 -> 디자인패턴의 예시설명

- string이 불변한 이유는?

- spring aop 동작 원리

- 다이나믹 프록시랑 cglib proxy 차이점은 cglib proxyj는 클래스기반만 가능한가?

- solid에 의존 역전 법칙에 대해 아느냐?

- 의존 역전 법칙은 스프링에 어떤 연관이 있냐?

- 스프링 IOC, DI

- IOC가 왜 스프링 장점인지

- 트랜잭션 처리 어떻게 하는지

- 트랜잭션 프로파게이션?(전파레벨)

- state 패턴과 싱글톤 패턴의 설명요구

- spring boot 부트동작원리 설명?

- dispatcherServlet 리다이렉트,포어딩?

- 싱글톤 패턴은 어떤 패턴인가, 어떤 상황에 사용하는가

- 전략 패턴 템플릿 메소드 패턴