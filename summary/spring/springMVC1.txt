1. webApplication
    1.1 웹 서버, 웹 애플리케이션 서버
        - 웹 시스템 구성 - WEB, WAS, DB
            - 정적 리소스는 웹 서버가 처리
            - 웹 서버는 애플리케이션 로직 같은 동적인 처리가 필요하면 WAS 에 요청을 위임
            - WAS 는 중요한 애플리케이션 로직 처리 전담
            - 효율적인 리소스 관리
                - 정적 리소스가 많이 사용되면 Web 서버 증설
                - 애플리케이션 리소스가 많이 사용되면 WAS 증설
            - 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음
            - 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음

    1.2 서블릿
        - 톰캣처럼 서블릿을 지원하는 WAS 를 서블릿 컨테이너라고 함
        - 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리
        - 서블릿 객체는 싱글톤으로 관리
            - 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용
            - 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
            - 서블릿 컨테이너 종료시 함께 종료

        - 웹 애플리케이션 서버 직접 구현
            - 서버 TCP/IP 연결 대기, 소켓 연결
            - HTTP 요청 메시지를 파싱해서 읽기
            - POST 방식, /save URL 인지
            - Content-Type 확인
            - HTTP 메시지 바디 내용 파싱
            - 저장 프로세스 실행
            - 비즈니스 로직 실행   ==> 의미있는 비즈니스 로직
                - 데이터베이스에 저장 요청
            - HTTP 응답 메시지 생성 시작
                - HTTP 시작 라인 생성
                - Header 생성
                - 메시지 바디에 HTML 생성에서 입력
            - TCP/IP 응답 전달, 소켓 종료

    1.3 동시 요청 - 멀티 쓰레드
        - 쓰레드
            - 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드
            - 자바 메인 메서드를 처음 실행하면 main 이라는 이름의 쓰레드가 실행
            - 쓰레드가 없다면 자바 애플리케이션 실행이 불가능
            - 쓰레드는 한번에 하나의 코드 라인만 수행
            - 동시 처리가 필요하면 쓰레드를 추가로 생성

            - 요청마다 쓰레드 생성
                - 장점
                    - 동시 요청을 처리할 수 있다.
                    - 리소스(CPU, 메모리)가 허용할 때까지 처리 가능
                    - 하나의 쓰레드가 지연 되어도, 나머지 쓰레드는 정상 동작
                - 단점
                    - 쓰레드 생성 비용은 매우 비싸다
                        - 고객의 요청이 올 때마다 쓰레드를 생성하면, 응답 속도가 늦어진다.
                    - 쓰레드는 컨텍스트 스위칭 비용이 발생한다.
                    - 쓰레드 생성에 제한이 없다.
                        - 고객 요청이 너무 많이 오면 CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.
        - 쓰레드 풀
            - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.
            - 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정
            - 최대 쓰레드가 모두 사용중이면 기다리는 요청은 거절하거나 특정 숫자만큼 대기하도록 설정 가능
            - 장점
                - 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답시간이 빠르다.
                - 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.
            - 팁
                - WAS 의 주요 튜닝 포인트는 최대 쓰레드이다.
                - 이 값을 너무 낮게 설정하면?
                    - 동시 요청이 많으면, 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연
                - 이 갑을 너무 높게 설정하면?
                    - 동시 요청이 너무 많으면 CPU, 메모리 리소스 임계점 초과로 서버 다운
                - 장애 발생시?
                    - 클라우드면 일단 서버부터 늘리고, 이후에 튜닝
                    - 클라우드가 아니면 열심히 튜닝
                - 적정 숫자 찾는법
                    - 어플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다름
                    - 성능 테스트
                        - 최대한 실제 서비스와 유사하게 성능 테스트 시도
                        - 툴: 어파치 ab, 제이미터, nGrinder
        - WAS 의 멀티 쓰레드 지원
            - 멀티 쓰레드에 대한 부분은 WAS 가 처리. 개발자가 멀티 쓰레드 관련 코드를 신경 쓰지 않아도 됨.
            - 멀티 쓰레드 환경이므로 싱글통 객체(서블릿, 스프링 빈)는 주의해서 사용

    1.4 SSR, CSR
        - SSR: 서버 사이드 렌더링
            - HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달
            - 주로 정적인 화면에서 사용 (SSR 을 사용하더라도 자바스크립트를 사용해서 화면 일부를 동적으로 변경 가능)
            - 관련 기술: JSP, 타임리프 -> 백엔드 개발자

        - CSR: 클라이언트 사이드 렌더링
            - HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용
            - 주로 동적인 화면에서 사용, 웹 환경을 마치 앱처럼 필요한 부분부분 변경할 수 있음
            - ex) 구글 지도, Gmail, 구글 캘린더
            - 관련 기술: React, Vue,js -> 프론트엔드 개발자

    * 스프링 부트
        - 스프링 부트는 서버를 내장
        - 과거에는 서버에 WAS 를 직접 설치하고, 소스는 War 파일을 만들어서 설치한 WAS 에 배포
        - 스프링 부트는 빌드 결과(Jar)에 WAS 서버 포함 -> 빌드 배포 단순화

    * 스프링 웹 기술의 분화
        - Web Servlet - Spring MVC
        - Web Reactive - Spring WebFlux
            - 특징
                - 비동기 넌 블러킹 처리
                - 최소 쓰레드로 최대 성능 -> 쓰레드 컨텍스트 스위칭 비용 효율화
                - 함수형 스타일로 개발 -> 동시처리 코드 효율화
                - 서블릿 기술 사용X
            - 단점
                - 러닝커브가 높다.
                - 아직은 RDB 지원 부족
                - 일반 MVC 의 쓰레드 모델도 충분히 빠르다.

    * 자바 뷰 템플릿
        - JSP: 속도 느림, 기능 부족
        - 타임리프
            - 내추럴 템플릿: HTML 의 모양을 유지하면서 뷰 템플릿 적용 가능
            - 스프링 MVC 와 강력한 기능 통합
        - 프리마커, 벨로시티: 성능은 타임리프보다 빠름

2. servlet
    2.1 서블릿
        - 서블릿은 톰캣 같은 웹 애플리케이션 서버를 직접 설치하고, 그 위에 서블릿 코드를 클래스 파일로 빌드해서 올린 다음,
          톰캣 서버를 실행하면 된다. 하지만 이 과정은 매우 번거롭다. 스프링 부트는 톰캣 서버를 내장하고 있으므로, 톰캣 서버 설치 없이
          편리하게 서블릿 코드를 실행.

        - 서블릿 컨테이너 동작 방식

    2.2 HttpServletRequest, HttpServletResponse
        - HttpServletRequest 객체
            - HTTP 요청메시지를 편리하게 사용하도록 도와주는 객체
            - 임시 저장소 기능: 해당 HTTP 요청이 시작부터 끝날 때까지 유지되는 임시 저장소 기능
            - 세션 관리 기능

    2.3 HTTP 요청 데이터
        - HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법
            - GET - 쿼리 파라미터
                - 메시지 바디 없이, URL 의 쿼리 파라미터에 데이터를 포함해서 전달
            - POST - HTML Form
                - 메시지 바디에 쿼리 파리미터 형식으로 전달
            - HTTP message body 에 데이터를 직접 담아서 요청
                - HTTP API 에서 주로 사용, JSON, XML, TEXT

        * content-type 은 HTTP 메시지 바디의 데이터 형식을 지정한다.
            - GET URL 쿼리 파라미터 형식으로 클라이언트에서 서버로 데이터를 전달할 때는 HTTP 메시지 바디를
              사용하지 않기 때문에 content-type 이 없다.
            - POST HTML Form 형식으로 데이터를 전달하면 HTTP 메시지 바디에 해당 데이터를 포함해서 보내기
              때문에 바디에 포함된 데이터가 어떤 형식인지 content-type 을 꼭 지정해야 한다. 이렇게 폼으로 데이터를
              전송하는 형식을 application/x-www-form-urlencoded 라 한다.

3.서블릿, JSP, MVC 패턴

4. MVC framework
    4.1 프론트 컨트롤러 패턴 소개
        - FrontController 패턴 특징
            - 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
            - 프론트 컨트롤러 요청에 맞는 컨트롤러를 찾아서 호출
            - spring web MCV 의 DispatcherServlet 이 FrontController 패턴으로 구현되어 있음

5. MVC framework construction
    5.1 스프링 MVC 전체 구조
        - HTTP 요청
        1.핸들러 조회: 핸들러 매핑을 통해 요청 URL 에 매핑된 핸들러(컨트롤러)를 조회한다.
        2.핸들러를 처리할 수 있는 어댑터 조회
        3.핸들러 어댑터 실행
        4.핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.
        5.ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView 로 변환해서 반환한다.
        6.viewResolver 호출: 뷰 리졸버를 찾고 실행한다.
        7.view 반환: 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
        8.뷰 렌더링: 뷰를 통해서 뷰를 렌더링 한다.
        - HTTP 응답

        - DispatcherServlet 서블릿 등록
            - DispatcherServlet 도 부모 클래스에서 HttpServlet 을 상속 받아서 사용하고, 서블릿으로 동작한다.
            - 스프링 부트는 DispatcherServlet 을 서블릿으로 자동으로 등록하면서 모든 경로( urlPatterns="/" )에 대해서 매핑한다.

6. MVC framework function
    6.1 로깅 간단히 알아보기
        - 스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리( spring-boot-starter-logging )가 함께 포함된다.
            - SLF4J는 인터페이스이고, 그 구현체로 Logback 같은 로그 라이브러리
            - 실무에서는 스프링 부트가 기본으로 제공하는 Logback 을 대부분 사용
        - 로그 사용시 장점
            - 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
            - 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.
            - 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.
              특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
            - 성능도 일반 System.out 보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를
              사용해야 한다.

    6.2 HTTP 요청
        - 요청 파라미터를 조회하는 기능: @RequestParam , @ModelAttribute
        - HTTP 메시지 바디를 직접 조회하는 기능: @RequestBody
            - 참고로 헤더 정보가 필요하다면 HttpEntity 를 사용하거나 @RequestHeader 를 사용하면 된다.

        - 스프링 MVC 내부에서 HTTP 메시지 바디를 읽어서 문자나 객체로 변환해서 전달해주는데, 이때 HTTP
          메시지 컨버터( HttpMessageConverter )라는 기능을 사용한다.
        - HttpEntity , @RequestBody 를 사용하면 HTTP 메시지 컨버터가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환.
        - HTTP 메시지 컨버터는 문자 뿐만 아니라 JSON 도 객체로 변환해준다.

    6.3 HTTP 응답
        - 스프링(서버)에서 응답 데이터를 만드는 방법은 크게 3가지이다.
            - 정적 리소스
            - 뷰 템플릿 사용
            - HTTP 메시지 사용
                - @ResponseBody

    6.4 HTTP 메시지 컨버터
        - @ResponseBody 를 사용
            - HTTP 의 BODY 에 문자 내용을 직접 반환
            - viewResolver 대신에 HttpMessageConverter 가 동작
                - 기본 문자처리: StringHttpMessageConverter
                - 기본 객체처리: MappingJackson2HttpMessageConverter
                - byte 처리 등등 기타 여러 HttpMessageConverter 가 기본으로 등록되어 있음
            - 응답의 경우 클라이언트의 HTTP Accept 해더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서
              HttpMessageConverter 가 선택된다. 만약 만족하지 않으면 다음 메시지 컨버터로 우선순위가 넘어간다.

        - 스프링 MVC 는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.
            - HTTP 요청: @RequestBody , HttpEntity(RequestEntity)
            - HTTP 응답: @ResponseBody , HttpEntity(ResponseEntity)

        - HTTP 요청 데이터 읽기
            1. HTTP 요청이 오고, 컨트롤러에서 @RequestBody , HttpEntity 파라미터를 사용한다.
            2. 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 canRead() 를 호출한다.
                - 대상 클래스 타입을 지원하는가.
                    - 예) @RequestBody 의 대상 클래스 ( byte[] , String , HelloData )
                - HTTP 요청의 Content-Type 미디어 타입을 지원하는가.
                    - 예) text/plain , application/json , */*
            3. canRead() 조건을 만족하면 read() 를 호출해서 객체 생성하고, 반환한다.

        - HTTP 응답 데이터 생성
            1. 컨트롤러에서 @ResponseBody , HttpEntity 로 값이 반환된다.
            2. 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite() 를 호출한다.
                - 대상 클래스 타입을 지원하는가.
                    - 예) return 의 대상 클래스 ( byte[] , String , HelloData )
                - HTTP 요청의 Accept 미디어 타입을 지원하는가.(더 정확히는 @RequestMapping 의 produces )
                    - 예) text/plain , application/json , */*
            3. canWrite() 조건을 만족하면 write() 를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.

    6.5 요청 매핑 핸들러 어댑터 구조
        - RequestMappingHandlerAdapter -> Argument Resolver -> handler(controller) -> ReturnValue Handler

        - Argument Resolver
            - 애노테이션 기반의 컨트롤러가 파라미터를 유연하게 처리할 수 있는 이유가 바로 ArgumentResolver 덕분이다.
            - 애노테이션 기반 컨트롤러를 처리하는 RequestMappingHandlerAdaptor 는 바로 이
              ArgumentResolver 를 호출해서 컨트롤러(핸들러)가 필요로 하는 다양한 파라미터의 값(객체)을 생성한다.
              그리고 이렇게 파리미터의 값이 모두 준비되면 컨트롤러를 호출하면서 값을 넘겨준다.

        - ReturnValueHandler
            - 응답 값을 변환하고 처리한다.
            - 컨트롤러에서 String 으로 뷰 이름을 반환해도, 동작하는 이유가 바로 ReturnValueHandler 덕분이다.
              어떤 종류들이 있는지 살짝 코드로 확인만 해보자.
