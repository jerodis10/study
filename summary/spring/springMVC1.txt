1. webApplication
    1.1 웹 서버, 웹 애플리케이션 서버
        - 웹 시스템 구성 - WEB, WAS, DB
            - 정적 리소스는 웹 서버가 처리
            - 웹 서버는 애플리케이션 로직 같은 동적인 처리가 필요하면 WAS 에 요청을 위임
            - WAS 는 중요한 애플리케이션 로직 처리 전담
            - 효율적인 리소스 관리
                - 정적 리소스가 많이 사용되면 Web 서버 증설
                - 애플리케이션 리소스가 많이 사용되면 WAS 증설
            - 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음
            - 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음

    1.2 서블릿
        - 톰캣처럼 서블릿을 지원하는 WAS 를 서블릿 컨테이너라고 함
        - 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리
        - 서블릿 객체는 싱글톤으로 관리
            - 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용
            - 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
            - 서블릿 컨테이너 종료시 함께 종료

        - 웹 애플리케이션 서버 직접 구현
            - 서버 TCP/IP 연결 대기, 소켓 연결
            - HTTP 요청 메시지를 파싱해서 읽기
            - POST 방식, /save URL 인지
            - Content-Type 확인
            - HTTP 메시지 바디 내용 파싱
            - 저장 프로세스 실행
            - 비즈니스 로직 실행   ==> 의미있는 비즈니스 로직
                - 데이터베이스에 저장 요청
            - HTTP 응답 메시지 생성 시작
                - HTTP 시작 라인 생성
                - Header 생성
                - 메시지 바디에 HTML 생성에서 입력
            - TCP/IP 응답 전달, 소켓 종료

    1.3 동시 요청 - 멀티 쓰레드
        - 쓰레드
            - 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드
            - 자바 메인 메서드를 처음 실행하면 main 이라는 이름의 쓰레드가 실행
            - 쓰레드가 없다면 자바 애플리케이션 실행이 불가능
            - 쓰레드는 한번에 하나의 코드 라인만 수행
            - 동시 처리가 필요하면 쓰레드를 추가로 생성

            - 요청마다 쓰레드 생성
                - 장점
                    - 동시 요청을 처리할 수 있다.
                    - 리소스(CPU, 메모리)가 허용할 때까지 처리 가능
                    - 하나의 쓰레드가 지연 되어도, 나머지 쓰레드는 정상 동작
                - 단점
                    - 쓰레드 생성 비용은 매우 비싸다
                        - 고객의 요청이 올 때마다 쓰레드를 생성하면, 응답 속도가 늦어진다.
                    - 쓰레드는 컨텍스트 스위칭 비용이 발생한다.
                    - 쓰레드 생성에 제한이 없다.
                        - 고객 요청이 너무 많이 오면 CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.
        - 쓰레드 풀
            - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.
            - 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정
            - 최대 쓰레드가 모두 사용중이면 기다리는 요청은 거절하거나 특정 숫자만큼 대기하도록 설정 가능
            - 장점
                - 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답시간이 빠르다.
                - 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.
            - 팁
                - WAS 의 주요 튜닝 포인트는 최대 쓰레드이다.
                - 이 값을 너무 낮게 설정하면?
                    - 동시 요청이 많으면, 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연
                - 이 갑을 너무 높게 설정하면?
                    - 동시 요청이 너무 많으면 CPU, 메모리 리소스 임계점 초과로 서버 다운
                - 장애 발생시?
                    - 클라우드면 일단 서버부터 늘리고, 이후에 튜닝
                    - 클라우드가 아니면 열심히 튜닝
                - 적정 숫자 찾는법
                    - 어플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다름
                    - 성능 테스트
                        - 최대한 실제 서비스와 유사하게 성능 테스트 시도
                        - 툴: 어파치 ab, 제이미터, nGrinder
        - WAS 의 멀티 쓰레드 지원
            - 멀티 쓰레드에 대한 부분은 WAS 가 처리. 개발자가 멀티 쓰레드 관련 코드를 신경 쓰지 않아도 됨.
            - 멀티 쓰레드 환경이므로 싱글통 객체(서블릿, 스프링 빈)는 주의해서 사용

    1.4 SSR, CSR
        - SSR: 서버 사이드 렌더링
            - HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달
            - 주로 정적인 화면에서 사용 (SSR 을 사용하더라도 자바스크립트를 사용해서 화면 일부를 동적으로 변경 가능)
            - 관련 기술: JSP, 타임리프 -> 백엔드 개발자

        - CSR: 클라이언트 사이드 렌더링
            - HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용
            - 주로 동적인 화면에서 사용, 웹 환경을 마치 앱처럼 필요한 부분부분 변경할 수 있음
            - ex) 구글 지도, Gmail, 구글 캘린더
            - 관련 기술: React, Vue,js -> 프론트엔드 개발자

    * 스프링 부트
        - 스프링 부트는 서버를 내장
        - 과거에는 서버에 WAS 를 직접 설치하고, 소스는 War 파일을 만들어서 설치한 WAS 에 배포
        - 스프링 부트는 빌드 결과(Jar)에 WAS 서버 포함 -> 빌드 배포 단순화

    * 스프링 웹 기술의 분화
        - Web Servlet - Spring MVC
        - Web Reactive - Spring WebFlux
            - 특징
                - 비동기 넌 블러킹 처리
                - 최소 쓰레드로 최대 성능 -> 쓰레드 컨텍스트 스위칭 비용 효율화
                - 함수형 스타일로 개발 -> 동시처리 코드 효율화
                - 서블릿 기술 사용X
            - 단점
                - 러닝커브가 높다.
                - 아직은 RDB 지원 부족
                - 일반 MVC 의 쓰레드 모델도 충분히 빠르다.

    * 자바 뷰 템플릿
        - JSP: 속도 느림, 기능 부족
        - 타임리프
            - 내추럴 템플릿: HTML 의 모양을 유지하면서 뷰 템플릿 적용 가능
            - 스프링 MVC 와 강력한 기능 통합
        - 프리마커, 벨로시티: 성능은 타임리프보다 빠름

2. servlet
    2.1 서블릿
        - 서블릿은 웹 서버의 성능을 향상하기 위해서 사용되는 자바 클래스의 일종.
          기존에 서버는 정적인 자료(HTML, 사진, 글 등)만을 주고 받았다. 하지만 웹에 다양한 기능이 요구되면서 정적인 자료뿐만 아니라
          사용자 요구에 맞춘 동적인 페이지들을 만들 필요가 생겼다. 이를 위해 만들어진 것이 서블릿.
          서블릿은 WAS 의 서블릿 컨테이너 안에서 동작. 요청(Request)을 받으면 요청에 맞는 로직을 실행하고 클라이언트에게 HTTP 형식으로 응답(Response)하게 된다.
        - 서블릿은 톰캣 같은 웹 애플리케이션 서버를 직접 설치하고, 그 위에 서블릿 코드를 클래스 파일로 빌드해서 올린 다음,
          톰캣 서버를 실행하면 된다. 하지만 이 과정은 매우 번거롭다. 스프링 부트는 톰캣 서버를 내장하고 있으므로, 톰캣 서버 설치 없이
          편리하게 서블릿 코드를 실행.

        - 서블릿 컨테이너 동작 방식
            - 서블릿 컨테이너는 서블릿을 담고 관리해주는 컨테이너이다. 서블릿 컨테이너는 구현되어 있는 서블릿 클래스의 규칙에 맞게
              서블릿을 관리하며 클라이언트의 요청을 받으면 HttpServletRequest 와 HttpServletResponse 객체를 생성하여
              post, get 여부에 따라 동적인 페이지를 생성하여 응답한다.

            1. 서블릿 생명주기 관리
                서블릿 컨테이너는 서블릿의 탄생과 죽음을 관리한다. 서블릿 클래스를 로딩하여 인스턴스화하고, 초기화 메서드를 호출하고,
                요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작한다. 또한 서블릿의 생명이 다하면 가비지 컬렉션(Garbage Collection)을 통해 메모리에서 제거한다.
            2. 통신 지원
                서블릿 컨테이너는 웹 서버와 소켓을 만들어서 클라이언트의 요청을 받고 응답할 수 있는 통신을 지원해준다.
                통신을 하기 위한 listen, accept 등의 과정을 API 로 제공하여 복잡한 과정을 생략해주기 때문에 개발자가 비즈니스 로직 개발에 집중할 수 있게 도와준다.
            3. 멀티쓰레드 지원 및 관리
                서블릿 컨테이너는 클라이언트의 요청을 받을 때마다 새로운 자바 스레드를 생성한다. 따라서 동시에 여러 요청이 들어와도
                멀티쓰레딩 환경에서 동시다발적인 작업을 관리할 수 있다.
            4. 선언적인 보안 관리
                서블릿 컨테이너는 보안 관련 기능을 제공하기 때문에 개발자는 서블릿에 보안 관련 메서드를 구현하지 않아도 된다.

    2.2 HttpServletRequest, HttpServletResponse
        - HttpServletRequest 객체
            - HTTP 요청메시지를 편리하게 사용하도록 도와주는 객체
            - 임시 저장소 기능: 해당 HTTP 요청이 시작부터 끝날 때까지 유지되는 임시 저장소 기능
            - 세션 관리 기능

    2.3 HTTP 요청 데이터
        - HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법
            - GET - 쿼리 파라미터
                - 메시지 바디 없이, URL 의 쿼리 파라미터에 데이터를 포함해서 전달
            - POST - HTML Form
                - 메시지 바디에 쿼리 파리미터 형식으로 전달
            - HTTP message body 에 데이터를 직접 담아서 요청
                - HTTP API 에서 주로 사용, JSON, XML, TEXT

        * content-type 은 HTTP 메시지 바디의 데이터 형식을 지정한다.
            - GET URL 쿼리 파라미터 형식으로 클라이언트에서 서버로 데이터를 전달할 때는 HTTP 메시지 바디를
              사용하지 않기 때문에 content-type 이 없다.
            - POST HTML Form 형식으로 데이터를 전달하면 HTTP 메시지 바디에 해당 데이터를 포함해서 보내기
              때문에 바디에 포함된 데이터가 어떤 형식인지 content-type 을 꼭 지정해야 한다. 이렇게 폼으로 데이터를
              전송하는 형식을 application/x-www-form-urlencoded 라 한다.

3.서블릿, JSP, MVC 패턴

4. MVC framework
    4.1 프론트 컨트롤러 패턴 소개
        - FrontController 패턴 특징
            - 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
            - 프론트 컨트롤러 요청에 맞는 컨트롤러를 찾아서 호출
            - spring web MCV 의 DispatcherServlet 이 FrontController 패턴으로 구현되어 있음

5. MVC framework construction
    5.1 스프링 MVC 전체 구조
        - HTTP 요청
        1.핸들러 조회: 핸들러 매핑을 통해 요청 URL 에 매핑된 핸들러(컨트롤러)를 조회한다.
        2.핸들러를 처리할 수 있는 어댑터 조회
        3.핸들러 어댑터 실행
        4.핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.
        5.ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView 로 변환해서 반환한다.
        6.viewResolver 호출: 뷰 리졸버를 찾고 실행한다.
        7.view 반환: 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
        8.뷰 렌더링: 뷰를 통해서 뷰를 렌더링 한다.
        - HTTP 응답

        - DispatcherServlet 서블릿 등록
            - DispatcherServlet 도 부모 클래스에서 HttpServlet 을 상속 받아서 사용하고, 서블릿으로 동작한다.
            - 스프링 부트는 DispatcherServlet 을 서블릿으로 자동으로 등록하면서 모든 경로( urlPatterns="/" )에 대해서 매핑한다.

6. MVC framework function
    6.1 로깅 간단히 알아보기
        - 스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리( spring-boot-starter-logging )가 함께 포함된다.
            - SLF4J는 인터페이스이고, 그 구현체로 Logback 같은 로그 라이브러리
            - 실무에서는 스프링 부트가 기본으로 제공하는 Logback 을 대부분 사용
        - 로그 사용시 장점
            - 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
            - 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.
            - 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.
              특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
            - 성능도 일반 System.out 보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를
              사용해야 한다.

    6.2 HTTP 요청
        - 요청 파라미터를 조회하는 기능: @RequestParam , @ModelAttribute
        - HTTP 메시지 바디를 직접 조회하는 기능: @RequestBody
            - 참고로 헤더 정보가 필요하다면 HttpEntity 를 사용하거나 @RequestHeader 를 사용하면 된다.

        - 스프링 MVC 내부에서 HTTP 메시지 바디를 읽어서 문자나 객체로 변환해서 전달해주는데, 이때 HTTP
          메시지 컨버터( HttpMessageConverter )라는 기능을 사용한다.
        - HttpEntity , @RequestBody 를 사용하면 HTTP 메시지 컨버터가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환.
        - HTTP 메시지 컨버터는 문자 뿐만 아니라 JSON 도 객체로 변환해준다.

    6.3 HTTP 응답
        - 스프링(서버)에서 응답 데이터를 만드는 방법은 크게 3가지이다.
            - 정적 리소스
            - 뷰 템플릿 사용
            - HTTP 메시지 사용
                - @ResponseBody

    6.4 HTTP 메시지 컨버터
        - @ResponseBody 를 사용
            - HTTP 의 BODY 에 문자 내용을 직접 반환
            - viewResolver 대신에 HttpMessageConverter 가 동작
                - 기본 문자처리: StringHttpMessageConverter
                - 기본 객체처리: MappingJackson2HttpMessageConverter
                - byte 처리 등등 기타 여러 HttpMessageConverter 가 기본으로 등록되어 있음
            - 응답의 경우 클라이언트의 HTTP Accept 해더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서
              HttpMessageConverter 가 선택된다. 만약 만족하지 않으면 다음 메시지 컨버터로 우선순위가 넘어간다.

        - 스프링 MVC 는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.
            - HTTP 요청: @RequestBody , HttpEntity(RequestEntity)
            - HTTP 응답: @ResponseBody , HttpEntity(ResponseEntity)

        - HTTP 요청 데이터 읽기
            1. HTTP 요청이 오고, 컨트롤러에서 @RequestBody , HttpEntity 파라미터를 사용한다.
            2. 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 canRead() 를 호출한다.
                - 대상 클래스 타입을 지원하는가.
                    - 예) @RequestBody 의 대상 클래스 ( byte[] , String , HelloData )
                - HTTP 요청의 Content-Type 미디어 타입을 지원하는가.
                    - 예) text/plain , application/json , */*
            3. canRead() 조건을 만족하면 read() 를 호출해서 객체 생성하고, 반환한다.

        - HTTP 응답 데이터 생성
            1. 컨트롤러에서 @ResponseBody , HttpEntity 로 값이 반환된다.
            2. 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite() 를 호출한다.
                - 대상 클래스 타입을 지원하는가.
                    - 예) return 의 대상 클래스 ( byte[] , String , HelloData )
                - HTTP 요청의 Accept 미디어 타입을 지원하는가.(더 정확히는 @RequestMapping 의 produces )
                    - 예) text/plain , application/json , */*
            3. canWrite() 조건을 만족하면 write() 를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.

    6.5 요청 매핑 핸들러 어댑터 구조
        - RequestMappingHandlerAdapter -> Argument Resolver -> handler(controller) -> ReturnValue Handler

        - Argument Resolver
            - 애노테이션 기반의 컨트롤러가 파라미터를 유연하게 처리할 수 있는 이유가 바로 ArgumentResolver 덕분이다.
            - 애노테이션 기반 컨트롤러를 처리하는 RequestMappingHandlerAdaptor 는 바로 이
              ArgumentResolver 를 호출해서 컨트롤러(핸들러)가 필요로 하는 다양한 파라미터의 값(객체)을 생성한다.
              그리고 이렇게 파리미터의 값이 모두 준비되면 컨트롤러를 호출하면서 값을 넘겨준다.

        - ReturnValueHandler
            - 응답 값을 변환하고 처리한다.
            - 컨트롤러에서 String 으로 뷰 이름을 반환해도, 동작하는 이유가 바로 ReturnValueHandler 덕분이다.
              어떤 종류들이 있는지 살짝 코드로 확인만 해보자.