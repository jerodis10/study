- RESTful
    - REST 의 제약을 준수했다는 의미를 가진다.
    - REST: 웹에서 사용하는 아키텍처 중 하나
    - URI 를 통해 자원을 지정하고, HTTP 메서드를 통해 자원에 대한 행위를 표현
    - REST API 란 REST 아키텍쳐 스타일에 부합하는 API

    - 초기의 웹은 정적인 페이지의 나열로 구성되어 있었기 때문에 사용자들은 서버에서 제공하는 데이터를
      받아서 읽는 것이 사용자가 할 수 있는 행동의 전부.
    - 그런데 이제 웹이 점점 더 진화하고 복잡해지면서 사용자는 읽는 행동 뿐만 아니라 쓰고, 고치고, 지우는 행동까지 할 수 있게 됨.
      이렇게 읽고, 쓰고, 고치고, 지우는 행동 하나하나는 전부 서버와 클라이언트 사이의 통신으로 이루어진다.
      서버-클라이언트 구조는 클라이언트가 서버에게 데이터를 요청하고 서버는 요청받은 데이터를 서버에서 찾는다. 그리고 클라이언트에게
      넘겨주면 서버와 클라이언트 구조가 끝난다.
    - 이렇게 서버와 클라이언트의 통신이 늘어나게 되면서 일관된 통신 방식이 필요성 제기됨.
      그 중에 하나로 등장한 것이 SOAP. SOAP 라는 하나의 방식으로 통신할 수 있음.
      어렵고, 복잡하고, 느리기 때문에 현재는 사용되고 있지 않음. 현재는 REST 가 사용됨.

    - REST (Representational State Transfer)
        - 서버와 클라이언트 간 통신 방식 중 하나
        - 자원을 이름으로 구분하여 자원의 상태를 주고 받는다.

    - 자원의 표현
        - URI
            - REST 에서는 자원을 표현할 때 URI 라는 방식으로 표현한다.
              URI 는 REST 에서 자원을 구분하고 처리하기 위해 사용되며 URI 를 잘 네이밍 할수록 API 가 직관적이고 사용하기 쉽다.

        - Singleton and Collection Resources
            - URI 는 Singleton 이나 Collection 으로 표현한다.

        - Collection and Sub-collection Resources
            - URI 는 서브 컬렉션을 포함할 수 있다.

        - URI 네이밍 규칙을 지키면 개발자들의 공용어처럼 사용 가능
            - 명사를 사용해서 자원을 표현
            - 예외적으로 동사 허용하는 경우 (controller)
                 ex) /game/play 에 접근 시 게임이 시작되는 경우
            - 자원 간 계층 관계를 표현하기 위해 /(슬래시)를 사용
                ex) /crews/frontend
                    /product/5
            - URI 경로 마지막에는 /(슬래시)를 붙이지 않는다.
            - 하이픈(-) 기호를 사용하여 URI 의 가독성을 향상할 수 있다.
                ex) /profilemanagement (X)
                    /profileManagement (X)
                    /profile-management (O)
            - URI 에는 가급적 밑줄을 사용하지 않는다.
                - 일부 브라우저나 화면에서 글꼴에 따라 (_) 문자가 가려지거나 숨겨질 수 있다.
            - URI 에는 소문자만 사용
            - URI 에 파일 확장자를 표시하지 않는다.
            - URI 에 CRUD 함수의 이름을 사용하지 않는다. -> HTTP 메서드를 통해 표현
            - 자원의 필터링을 위해 새로운 API 를 만들지 않는다.
                - Query string 을 이용
                - Query string: 주소?속성=값&속성=값&...
                - Query string 은 특정 주소로 접근할 때 페이지에 대한 옵션으로 활용
            - 프론트엔드 크루 이름, 오름차순으로 보고 싶다면?
                ex) /crews?type=frontend&sort=name,asc

    - 자원의 상태를 주고 받는다.
        - 자원의 상태를 주고 받는 방식은 클라이언트와 서버 간의 통신으로 이루어진다.
        - 클라이언트가 HTTP 메서드를 보내면 서버는 HTTP 상태 코드를 통해서 정상적으로 처리되었는지 실패했는지 여부를 알려주는 방식으로 소통

        - HTTP 메서드
            - 자원의 상태를 주고받기 위해 사용하는 메서드
            - GET, POST, PUT, PATCH, DELETE
            - 같은 URI 사용 + 다른 동작
            - CRUD 메서드의 이름을 URI 에 표현하지 않을 수 있음

            - GET: 자원을 검색할 때 사용
            - POST: 자원을 생성할 때 사용
            - PUT: 자원을 업데이트할 때 사용 (보내지 않은 정보는 null 값으로 업데이트)
            - PATCH: 자원을 업데이트할 때 사용 (보내지 않은 데이터는 기존 데이터를 유지)
            - DELETE: 자원을 삭제할 때 사용

        - HTTP 상태코드
            - 1xx: 조건부 응답
            - 2xx: 성공
            - 3xx: 리다이렉션
            - 4xx: 클라이언트 오류
            - 5xx: 서버 오류

            HATEOAS ? self-descriptive ?

    => RESTful 이 이론적인 내용을 100% 충족하지 못한다고 하더라도 개발자들 사이의 의사소통 수단으로 잘 활용된다면
       이것을 RESTful 이라고 불러도 되지 않을까?

- IoC/DI
    - spring -> IoC/DI, AOP, PSA

    - IoC/DI
        - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
        - 유연하고 확장성이 뛰어난 코드를 만들 수 있게 해주는 프로그래밍 모델
            - 유연하고 확장성이 뛰어나다. -> 관심사의 분리가 잘 이루어졌다. (전략 패턴)

        - 제어의 두 가지 관점
            1. 어떤 연관관계를 맺으며 생성될 것인가?
                - 팩토리 -> 빈 컨테이너
            2. 어떻게 사용될 것인가?
                - 클라이언트 -> 스프링 내부 코드
            -> 우리는 컨트롤러, 서비스 그리고 각종 빈들에 대한 구현체들을 구현하고 있지만, 이것들이 어떻게 생성되고
               어떻게 연관관계를 맺는지에 관한 것은 전부 Configuration 파일, 빈 컨테이너가 담당
            -> AOP, PSA 도 다 이걸로 이루어지는 것

        => 관심사의 분리를 통해 유연하고 확장성이 쉬운 코드를 만들다 보니 자연스럽게 만들어진 프로그래밍 모델

        - IoC 란 제어의 역전
            - 제어 -> 객체 생명주기나 메서드의 호출을 직접 제어
            - 역전 -> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것

            - 객체지향 원칙을 잘 지키기 위해 쓰는 것
            - 역할과 관심을 분리해 응집도를 높이고 결합도르 낮추며, 이에 따라 변경에 유연한 코드를 작성할 수 있는 구조가 될 수 있기 때문

            - DIP: 의존 역전 원칙
              상위 레벨의 모듈은 절대 하위 레벨의 모듈에 의존하지 않는다. 둘 다 추상화에 의존해야 한다.

            - IoC 와 DIP 의 목적은 클래스 간 결합을 느슨히 하기 위함
              한 클래스의 변경에 따른 다른 클래스들의 영향을 최소화
              -> 어플리케이션을 지속가능하고 확장성 있게 만든다.
            - Ioc 는 제어의 역전, DIP 는 의존 방향의 역전

            - IoC 방법: Service Locator, Factory, Abstract, Template Method, Strategy, Dependency Injection

        - DI
            - 의존 -> 한 클래스가 바뀔 때 다른 클래스가 영향을 받는 것

            - 의존성 주입
                - DI 패턴
                    - 필드 주입
                        - 테스트 등의 이유로 자동이 아닌 수동으로 의존성 주입을 하고 싶어도 생성자도 setter 도 없으므로
                          직접 의존성을 넣어 줄 수가 없다. -> 의존성이 프레임워크에 강하게 종속됨
                    - 생성자 주입
                        - 필요한 의존성을 모두 포함하는 생성자를 만들고 그 생성자를 통해서 의존성을 주입
                        - 필드를 final 로 만들어 줄 수 있고 의존성 주입이 생성자 호출 시 최초 1회만 이루어지기 문에
                          의존관계를 불변으로 만들어 줄 수 있다.
                        - 필드 주입이나 setter 주입의 경우 스프링의 빈 관리 기능을 빌리지 않고 new 키워드로 객체를 생성해 줄 경우
                          NullPointerException 이 발생할 수 있다. 하지만 생성자 주입은 x
                        - @Autowired 가 여러 개 있을 경우 가장 많은 의존성을 주입할 수 있는 생성자를 사용
                          @Autowired 가 붙은 모든 생성자가 사용 불가능한 경우 또는 어떤 생성자에도 @Autowired 가 없을 경우
                          기본 생성자 호출. 기본 생성자 조차 없는 경우 컴파일 에러
                    - Setter 주입
                        - 의존성을 입력받는 setter 메서드를 만들고 메서드들을 호출해서 의존성을 주입
                        - 주로 런타임에 의존성을 수정해줘야 하거나 의존성을 선택적으로 주입할 때 사용
                    - Interface 주입
                        - 의존성을 주입하는 메서드를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써
                          실행 시에 이를 통하여 의존성 주입. setter 주입처럼 메서드를 외부에서 호출해줘야 하는 것은 비슷하지만
                          의존성 주입 메서드를 빠뜨릴 수 있는 setter 와 다르게 오버라이드를 통해 메서드 구현을 강제할 수 있다는 차이가 있다.
                        - 객체의 최초 생성 시점에 스프링이 의존성 주입

                    - 의존성 주입 순서: 생성자 -> 필드 -> setter
                    - 의존선 주입 기준: 타입 -> @Qualifier -> @Primary -> 이름
            - 의존성 분리
                - DIP 를 이용해 의존 관계를 분리
                - 상위계층이 하위계층에 의존하는 상황을 Interface 를 이용해 반전시켜 하위계층의 구현으로부터 독립시킨다.

        - DIP 도 원칙
        - Ioc 는 원칙 중 하나고 DI 는 IoC 를 달성하는 디자인 패턴 중 하나
        - 이 DI 를 자동으로 해줌으로써 프로그램의 제어권을 가져가는 역할을 해주는 것이 스프링

- AOP
    - AOP 가 무엇일까
        - Aspect Oriented Programming
        - 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 반복 작업을 줄이고 핵심 비즈니스 로직 개발에만 집중할 수 있음

        - 사용 목적에 따라
            - 프록시 패턴: 클라이언트가 타깃에 접근하는 방법 제어
            - 데코레이터 패턴: 타깃에 부가적인 기능 부여

    - AOP 의 용어들
        - Target Object: 부가 기능을 부여할 대상
        - Aspect: 부가 기능을 정의한 Advice 와 어드바이스를 어디에 적용할 지 결정하는 Pointcut 을 함께 가짐.
        - Advice: 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.
        - JoinPoint: 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
        - Pointcut: 어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

    - AOP 구현 방법
        - 컴파일 시점에 코드에 공통 기능 삽입
        - 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
            - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
              좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            (런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.)

    - Spring 에서 AOP 를 구현한 방법
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
            - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
            - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
            - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용

- git branch 전략
    - branch 전략이란?
        - 여러 명의 개발자가 1개의 저장소를 사용하는 환경에서 효과적으로 사용하기 위해 나온 개념
        - 대표적인 전략
            - GitHub flow
            - git flow
            - gitLab flow

    - GitHub flow 란?
        - GitHub 에서 만든 단순한 구조의 브랜치 전략
        - Master 브랜치를 중심으로 운영되며 기능 개발, 버그 수정 등의 작업용 브랜치를 구분하지 않는 단순한 구조
        - 수시로 배포가 일어나는 프로젝트에 유용

        1. 브랜치 생성
            - Master 로부터 기능 추가, 버그 수정 작업을 위한 새로운 브랜치를 생성
        2. 기능 개발, 버그 수정
            - 작업을 하며, 기능별로 commit 을 한다.
            - commit 메시지와 브랜치 이름은 정확하고 간결하게 작성
            - commit 은 서버의 동일한 브랜치에 push 해줘야 한다. (Git flow 와 차이점)
        3. Pull Request 생성
        4. 리뷰와 논의
        5. 공개 및 테스트
            - GitHub 에서는 master 에 합치기 전에 브랜치에서 코드를 공개 및 테스트 할 수 있다.
            - 오류가 발생할 경우 원래의 master 브랜치를 다시 배포하여 rollback 한다.
        6. Merge
            - 브랜치의 검증이 완료되면 master 브랜치에 합친다.
            - 이로써 GitHub flow 의 브랜치의 생명주기가 끝난다.

    - Git flow 란
        - 많은 기업에서 표준으로 사용하고 있는 대표적인 Git branch 전략
        - GitHub flow 와는 다르게 크게 5개의 브랜치를 운영하며 관리한다.
            - 메인 브랜치: master, develop
            - 보조 브랜치: feature, release, hotfix
        - 배포 주기가 길고 팀의 여력이 있는 경우 적합

        - 메인 브랜치의 특징
            - master, develop 두 개의 브랜치는 항상 남아있는다.
            - master 브랜치는 제품으로 배포할 수 있는 브랜치
            - develop 브랜치는 개발자들이 개발을 하는 브랜치

        - 보조 브랜치의 특징
            - 사용을 마치면 브랜치를 삭제한다.
            - feature: 기능 구현
              release: QA 진행
              hotfix: 버그의 빠른 수정

            - Feature 브랜치
                - 다음 버전을 위한 특정 기능 개발을 할 때는 develop 브랜치에서 직접 개발을 하는 것이 아닌
                  develop 으로부터 feature 브랜치를 생성하여 개발을 진행.
                  feature 브랜치에서 개발을 완료한 후에는 develop 으로 merge 한 후 브랜치를 삭제

                - 만약 feature 브랜치에서 개발한 후 merge 를 진행할 때 develop 과 conflict 되는 내용이 있으면
                  develop 으로부터 변경 내용을 불러와 수정을 한 후 merge 를 진행

                - 브랜치들 간의 merge 를 할 때는 --no-ff 옵션을 사용하여 다른 브랜치에서 merge 를 했다는 이력을 남겨주는 것을 권장
                  fast-forward 관계에 있어도 merge commit 을 생성하여 해당 브랜치가 존재하였다는 정보를 남길 수 있다.
                  코드 내에 오류가 발생했을 때, 개발한 기능을 제거하려고 할 때 commit 을 되돌리기 편해진다.
                  --no-ff 을 사용하지 않으면 브랜치의 존재 여부를 몰라 어떤 commit 부터 해당 기능을 구현했는지 확인하기 어렵다.
                  또한, 브랜치가 fast-forward 관계에 있을 때 develop 입장에서는 feature 의 commit 기록들을 동일하게 가져와도 문제가
                  없다고 판단하여 브랜치의 참조 값만 변경하여 merge commit 을 생성하지 않는다.
                  만약 이런 방식으로 commit 기록들이 나오면 어떤 특정 feature 와 관련된 commit 이 어디서부터 해당하는지 확인이 힘들다.

            - Release 브랜치
                - 프로덕션에 다음 버전 출시를 준비하기 위한 브랜치
                - develop 브랜치에서 개발이 완료된 코드를 master 로 merge 하기 이전에 QA 테스트 진행
                - QA 를 진행하기 위해 develop 으로부터 release 브랜치를 생성하여 해당 브랜치에서 QA 진행
                - 만약 오류가 발견된면 해당 브랜치 내에서 수정을 하고 QA 가 끝나고 배포할 준비가 완료되었다고 판단되면
                  release 브랜치를 master 브랜치와 develop 브랜치에 merge 하고 release 브랜치를 삭제
                - 이 때 develop 브랜치에 merge 할 때 그 사이에 develop 내에 추가적인 개발 상황이 있어 충돌이 발생할 수도 있다.
                - 이러한 경우 해당 내용을 수정하고 다시 merge 하는 방식으로 진행
                - merge 할 때 --no-ff 를 사용하여 기록을 그룹화
                - master 로 merge 후에는 tag 명령을 통해 버전을 명시

            - Hotfix 브랜치
                - production 에 버그가 발생하면 빠른 수정을 위해 생성하는 브랜치
                - master 에 올라가 실제 필드에 나가 있는 코드에서 오류가 발생한다면 긴급하게 hotfix 브랜치를 생성하여 오류를 수정한 후
                  변경사항을 master 에 merge 하여 오류를 수정
                - 이 때 발생한 오류들은 develop 과 release 로부터 거르지 못한 오류이기 때문에 현재 브랜치의 코드에도 반영을 해줘야 한다.
                - production 코드를 수정하는 중에도 develop 에서는 계속 개발을 할 수 있다는 장점
                - master 로 merge 후에는 tag 명령을 통해 이전 버전보다 높은 버전 명시

        - 무슨 전략을 사용해야 할까?
            - 팀의 브랜칭 전략은 조직의 규모, 서비스의 특징 등을 고려하여 협의를 통해 전략을 결정해야 한다.
            - production 의 공식 배포 주기가 길고 QA, 테스트, hotfix 등의 여력이 있으면 Git flow 가 적합
            - 지속적으로 테스트 및 배포를 하는 팀의 경우 간단한 GitHub flow 를 사용하는 것이 적합

- 캐시
    - 캐시란?
        - 프로세서의 성능이 매년 60%씩 증가하는 반면 메모리 지연 시간 향상은 9%밖에 일어나지 않고 있다.
          각 성능 간의 격차가 매년 50%씩 증가하고 있는 셈. 이렇게 되면 아무리 프로세서 성능이 좋아져도 메모리 처리 속도가 느리기 때문에
          전체적인 프로그램 속도가 느리게 된다. -> 따라서 캐시가 등장

        - 데이터를 재사용하거나 원본 데이터를 접근하는데 오래걸린다면 데이터 값을 미리 복사해 더 빠른 속도로 접근 가능

    - 캐싱의 종류
        - CPU 캐시 메모리
            ex) 쿼드 코어 칩의 경우 각 코어마다 L2 캐시가 있고 각 코어들이 공유하는 Shared L3 캐시가 있다.
        - 웹 캐시
            - 브라우저 캐시
                - 요청과 응답을 하는 과정 이후에 클라이언트 내부 디스크의 정적 파일들을 저장해 놓는 것. 이를 통해 다음부터는 서버까지
                  요청할 필요 없이 내부 캐시로부터 불러올 수 있다.
            - 프록시 캐시
            - 게이트웨이 캐시

    - Java 코드로 캐싱
        - 캐싱: 캐시라는 작업을 하는 행위. 자주 사용하는 데이터를 저장해서 재활용하는 기술
          ex) Integer 클래스는 내부적으로 IntegerCache 라는 클래스를 가지고 있다. cache 라는 배열에 미리 low 부터 high 까지의
              Integer 인스턴스를 생성해둔 뒤 저장. 이후에 Integer 객체를 만들 때는 캐시로부터 가져오거나 범주 내에 없다면
              새로운 인스턴스를 생성

    - Spring 에서의 캐싱
        - 스프링에서 빈의 메서드에 캐시를 적용할 수 있는 기능을 제공
        - AOP 를 이용해 메서드 내부 구현에 영향을 미치지 않고 적용
        - 특정 캐시 기술에 종속 x
        - 캐싱이 필요한 비즈니스 로직에 EhCache, Redis 등 캐싱 종류에 의존할 필요 x

        - 캐시 매니저 (Cache Manager)
            - 캐시 추상화에서는 캐시 기술을 지원하는 캐시 매니저를 빈으로 등록해야 한다.
            - 캐시 매니저 구현체
                - ConcurrentMapCacheManager
                    - 캐시 정보 Map 타입
                    - 빠르고 별다른 설정이 필요없음
                - SimpleCacheManager
                    - 기본적으로 제공하는 캐시 x
                    - 사용할 캐시를 직접 등록하여 사용하기 위한 캐시 매니저
                - EhCacheCacheManager
                    - EhCache 를 지원하는 캐시 매니저

        - start-cache 의존성 추가 필요
            - @EnableCaching, @Cacheable ...

    - 주의할 점
        - 모든 상황에서 캐싱을 하는 것은 좋지 않다.
        - 캐시는 값을 저장하고 불러오기 때문에 반복적으로 동일한 결과를 반환하는 경우에 용이
        - 매번 다른 결과를 돌려줘야 하는 상황이라면 오히려 성능 저하를 야기
        - 캐시 저장 및 확인 작업에서 부하가 생김
        - 작업의 시간이 오래 걸리거나 서버에 부담을 주는 경우에 사용을 고려

- Spring vs Spring Boot  https://ict-nroo.tistory.com/93  https://tecoble.techcourse.co.kr/post/2021-10-14-springboot-autoconfiguration/  https://knoc-story.tistory.com/47
    - spring 생태계
        - spring 은 프로덕트 별로 하위 프로젝트(모듈)을 가지고 있다.
            - spring boot, spring framework, spring batch ...
              ex) spring framework > spring aop, spring core, spring web mvc ...
        - 스프링 프로젝트들은 스프링 프레임워크 기반에서 돌아간다.

    - spring framework 란?
        - 객체 지향의 특징을 잘 활용할 수 있게 해주며, 개발자들은 핵심 비즈니스 로직 구현에만 집중할 수 있게 해주는 프레임워크
        - 스프링의 기본 전략은 비즈니스 로직을 담은 코드와 엔터프라이즈 기술을 처리하는 코드를 분리하는 것
          이렇게 분리함으로써 개발자들은 객체지향 설계에 초점을 맞출 수 있게 되고 이를 돕기 위해 스프링은 DI 같은 기능을 제공
        - 초기 spring 기본 설정만 잘 해놓는다면, 스프링 관련 코드를 신경 쓸 일이 거의 없다.

    - spring boot 란?
        - 독립적이며, 운영할 수 있는 수준의 spring 기반 어플리케이션을 쉽게 만들 수 있게 해준다.
          최소한의 설정으로 spring 플랫폼과 서드파티 라이브러리 사용 가능. 대부분 spring boot 어플리케이션은 최소한의 spring 설정 필요

    - spring boot 를 사용하면 달라지는 점
        1. 의존성 관리 - spring-boot-starter, spring-boot-starter-parent
            - spring
                - 기존 spring 은 개발에 필요한 모듈의 의존성을 각각 다운받아 줘야했으며, 각 모듈의 버전을 개발자가 하나하나 명시해줘야함
                  모듈 간의 의존성이 존재하는 경우 버전 충돌이 일어날 수 있다.
            - spring boot
                - spring boot 는 spring-boot-starter 모듈을 통해 자주 사용하게 되는 모듈간의 의존성과 버전 조합을 제공해준다.
                - spring boot 는 spring-boot-starter-parent 를 통해 버전 관리(각 모듈의 현재 spring boot 버전에 가장 적합한 버전 제공)

        2. 자동 설정 - @EnableAutoConfiguration ??
            - spring
                - 기존 spring 은 많은 환경 설정이 필요하다.
            - spring boot
                - spring boot 는 라이브러리만 추가해주면 추가된 jar 파일을 인지해서 관련된 스프링 설정을 자동으로 처리해준다.
                - @SpringBootApplication
                    - @ComponentScan: @Component 가 붙은 클래스를 Bean 으로 등록시켜준다.
                    - @SpringBootConfiguration: spring boot 전용 애노테이션으로 spring boot 의 설정을 나타냄
                                                spring 의 @Configuration 이라고 볼 수 있다.
                                                스프링 제공 테스트(@SpringBootTest, @WebMvcTest 등) 시
                                                @SpringBootConfiguration 이 붙은 클래스가 없다면 실패한다.
                    - @EnableAutoConfiguration: 자동 설정 담당
                        1. Classpath 에 라이브러리 jar 파일이 등록되면 spring.factories 에 있는 관련 설정이 실행된다.
                        2. 자동 설정 후보 클래스의 @Conditional~ 조건에 따라 빈으로 등록된다.
                        3. spring-configuration-metadata 는 자동 설정에 사용할 프로퍼티 정의 파일로, application.yml 에 작성한
                           값으로 프로퍼티를 세팅한 후, 구현되어 있는 자동 설정에 값을 주입시켜준다.

        3. 내장 WAS - Embedded WAS (tomcat, jetty, undertow)
            - spring
                1. 어플리케이션 WAR 패키징
                2. WAS 설치
                3. WAS 에 빌드한 WAR 파일 올리기
            - spring boot
                - 배포할 때 spring boot 는 독립적으로 실행 가능한 어플리케이션을 빠르게 개발하는 것을 목표로 하기 때문에
                  웹 어플리케이션을 war 파일이 아닌 jar 파일로 패키징하여 바로 사용 가능. 외장 WAS 를 쓰고자하면 war 파일로
                  패키징 할 수도 있다. spring boot 를 사용하면 war 나 jar 둘 다 가능
                - 내장 서버가 작동하는 원리도 자동 설정으로 인해 작동
                  (tomcat 이 기본이지만 의존선을 통해서 jetty 나 undertow 로 변경 가능)

                - 부트는 서버가 아니다.
                  톰캣 객체 생성
                  포트 설정
                  톰캣에 컨텍스트 추가
                  서블릿 만들기
                  톰캣에 서블릿 추가
                  컨텍스트에 서블릿 맵핑
                  톰캣 실행 및 대기

                  이 모든 과정을 보다 상세히 또 유연하게 설정하고 실행해주는게 바로 스프링 부트의 자동 설정

        4. 모니터링 - Actuator
            - spring boot 의 모듈 중 하나인 Actuator 는 어플리케이션의 관리 및 모니터링을 지원해준다.
            - Actuator 는 상용 서비스 수준에서 필요로 할 모니터링 기능을 엔드포인트로 미리 만들어서 제공
            - Actuator 를 사용하면 실행 중인 부트 어플리케이션 내에서 어떤 일이 일어나는 지 볼 수 있는데
              어떤 빈이 등록되어 있는지, 자동 설정이 어떻게 되어 있는지 환경 변수나 시스템 속성 같은 것을 알 수 있다.

            - 주의할 점
                - actuator 는 민감한 정보도 많이 제공해주기 때문에 운영 시에는 spring security 등을 이용하여 보안에 신경써야 한다.
                - actuator 의 데이터를 영구 저장소에 저장해주지 않으면 없어질 수 있다.
                  actuator 의 데이터는 메모리에 저장하기 때문에 tomcat 을 재시작하거나 하면 데이터가 모두 날아간다.

    - 정리
        - spring 은 spring framework 를 기반으로 서브 프로젝트들의 모음으로 이루어져있으며, 서브 프로젝트들은 여러 모듈을 가지고 있다.
          개발할 어플리케이션에 맞게 모듈들을 조합해서 사용한다.
        - spring boot 도 spring 프로젝트 중 하나로, spring framework 와 별개로 사용x, spring 을 편하게 사용하게 해주는 역할
        - spring boot 는 1) 의존성 관리, 2) 자동 설정, 3) 내장 WAS, 4) 모니터링 등의 장점이 있다.

- 웹소켓/spring
    - 웹소켓? 언제쓰지?
        - 웹소켓은 전이중 통신 채널을 제공해서 실시간성을 보장
          ex) 게임, 채팅, 실시간 주식 거래 사이트 등등

    - 웹소켓 vs HTTP
        - HTTP 에서도 실시간성을 보장하는 기법이 존재
          ex) Polling, Long Polling, Streaming
              서버쪽으로 클라이언트가 지속적으로 요청을 보내든지
              한 번 요청을 보내놓고 커넥션을 끊지 않은 상태에서 서버에서 메시지를 계속 받는 방식

        - HTTP
            - 비 연결성 (클라이언트가 요청을 보낼 때마다 연결을 맺고 응답을 받은 후에 연결을 끊는다.)
            - 매번 연결 맺고 끊는 과정의 비용
            - (요청 - 응답) 구조
            - 매 요청-응답 마다 HTTP 메시지를 주고 받음
        - 웹소켓
            - 연결 지향 (한번 연결을 맺고 나면 어는 한쪽에서 연결을 끊으라는 요청을 보내기 전까지 연결을 유지)
            - 한번 연결 맺은 뒤 유지
            - 양방향 통신
            - 처음 핸드쉐이크를 할 때는 HTTP 프로토콜을 사용하기 때문에 유사한 양의 정보를 주고 받지만,
              한 번 연결이 수립되고 나서는 간단한 메시지들만 주고 받음. -> 통신에 오가는 비용을 많이 줄일 수 있다.
            - 텍스트와 바이너리 타입의 메시지를 양방향으로 주고 받을 수 있는 프로토콜
        -> 수립된 커넷션을 어떻게 하느냐

        - 웹소켓을 지원하지 않는 환경에서는?
          ex) internet explorer, firefox, safari...
          -> 이 때 사용할 수 있는 것이 SockJS, socket.io
             브라우저별로 웹소켓 기술을 제공하고 있다면 웹소켓을 사용하고 없으면 streaming, 그것도 없으면 polling 방식을 사용해서 제공
          -> 웹소켓을 지원하지 않는 브라우저 환경에서도 비슷한 경험을 제공하기 위해서 사용하는 것이 SockJS 라이브러리

    - 웹소켓 in spring
        - @EnableWebSocket, WebSocketConfigurer 인터페이스

    - STOMP and spring-messaging
        - STOMP
            - Simple Text Oriented Messaging Protocol
            - 메시지 브로커를 활용하여 쉽게 메시지를 주고 받을 수 있는 프로토콜
                - pub - sub (발생-구독): 발신자가 메시지를 발행하면 수신자가 그것을 수신하는 메시징 패러다임
                - 메시지 브로커: 발신자의 메시지를 받아와서 수신자들에게 메시지를 전달하는 어떤 것
            - 웹소켓 위에 얹어 함께 사용할 수 있는 하위(서브) 프로토콜
              STOMP 는 웹소켓만을 위해서 만들어진 것은 아니다. 몇몇 양방향 통신 프로토콜에서 함께 사용할 수 있다.

            - STOMP 가 왜 필요한지, 어떤 이점이 있는지
                - 클라이언트와 서버가 어떤 형식으로 머시지를 주고 받을지, 메시지의 타입은 어떻게 명시할지, 메시지의 본문과 설정 정보와
                  같은 데이터들은 어떻게 구분할 것인지 등등 따로 정의해야 하고 그것을 파싱하는 로직도 필요
                - 하지만 STOMP 를 사용하면 형식을 따로 고민할 필요도, 그것을 파싱하기 위한 코드를 따로 구현할 필요가 없다.
                - STOMP 는 프레임(커맨드, 헤더, 바디) 이라는 형식을 정의해둠

        - STOMP 통신 흐름
            ex) 서버 내에서의 어떤 처리 혹은 가공이 필요하다면 /app 으로 메시지 송신
                가공된 메시지를 /topic 이라는 경로를 담아 다시 전송하면 메시지 브로커에게 전달
                메시지 브로커는 전달 받은 메시지들을 /topic 을 구독하고 있는 구독자들에게 최종적으로 전달
                서버의 어떤 처리나 메시지를 가공할 필요가 없다면 발신자가 바로 메시지 브로커를 통해 구독자들에게 보내는 것도 가능

        - STOMP 를 사용하는 장점
            - 하위 프로토콜 혹은 컨벤션을 따로 정의할 필요가 없다.
            - 연결 주소마다 새로 핸들러를 구현하고 설정해줄 필요가 없다.
            - 외부 Messaging Queue 를 사용할 수 있다. (RabbitMQ, 카프가 ...)
            - Spring Security 를 사용할 수 있다.

- 상태 패턴
    - 아키텍쳐 패턴 vs 디자인 패턴
      아키텍쳐 패턴은 디자인 패턴보다 상위 수준의 설계에 사용된다.
      아키텍쳐 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들끼리의 관계를 설계하기 위한 참조 모델이다.

    - 디자인 패턴
      반복적으로 나타난 문제에 대해 그것을 해결한 경험 및 노하우를 축적하여 재이용하기 좋은 형태로 이름을 붙여 해법을 제시하는 패턴 양식.
      객체지향 프로그래밍을 설계할 때 자주 발생하는 문제를 피하기 위해 사용되는 패턴. 객체 지향의 재사용과 유지보수성 등의 장점을
      이 디자인 패턴을 사용해 극대화할 수 있다.

    - GOF 디자인 패턴  https://4z7l.github.io/2020/12/25/design_pattern_GoF.html
        - 23 가지의 디자인 패턴을 목적에 따라 3가지 유형으로 분류
            - 생성 패턴: 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 하는 패턴
                       객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여 프로그램에 유연성을 더해준다.
                - 추상 팩토리 패턴, 빌더 패턴, 팩토리 메서드 패턴, 프로토타입 패턴, 싱글톤 패턴
            - 구조 패턴: 자료 구조나 인터페이스 등 프로그램의 구조를 설계하는데 활용하는 패턴. 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
                - 어댑터 패턴, 브리지 패턴, 컴포지트 패턴, 데코레이터 패턴, 파사드 패턴, 플라이웨이트 패턴, 프록시 패턴
            - 행위 패턴: 반복적으로 사용되는 객체들의 상호 작용을 패턴화. 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
                       행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 어떤 태스크, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지를 정의하는 패턴
                - 책임 체인 패턴, 커맨드 패턴, 인터프리터 패턴, 중재자 패턴, 메멘토 패턴, 옵저버 패턴, 상태 패턴
                  전략 패턴, 템플릿 메서드 패턴, 방문자 패턴

        -> 디자인 원칙을 떠올려보자. 변하는 것은 잘 변하지 않는 것과 분리해라. 즉, 변하는 녀석들을 캡슐화해라!

    - 상태 패턴
        - 객체 자신의 내부 상태에 따라 행위를 변경하도록 하는 패턴
        - 객체의 특정 상태를 클래스로 선언하고 해당 상태에서 할 수 있는 행위들을 메서드로 정의
          이러한 상태 클래스를 인터페이스로 캡슐화하여 클라이언트에서 인터페이스로 호출하는 방식으로 사용

    - 상태 패턴은 언제 사용할까
        1. 객체의 행동이 상태에 따라 달라질 수 있고, 객체의 상태에 따라 런타임 행동이 바뀌어야 한다.
        2. 객체에 상태에 따라 달라지는 다중 분기조건, 처리가 너무 많이 들어있을 때, 객체의 상태를 표현하기 위해 ENUM 으로 정의해야 한다.

    - 효과
        1. 상태에 따른 행동을 국소화하며 서로 다른 상태에 대한 행동을 별도의 객체로 관리한다.
           새로운 상태가 추가되더라도 context 코드가 받는 영향이 적다.
        2. 상태 전이를 명확하게 만든다. (상태 전이 - 입력에 따라 다음 상태로 바뀌는 것)
        3. 상태에 따른 동작을 구현한 코드를 수정하기 쉽다.

    - 상태 패턴과 전략 패턴의 차이
        - 목적에 따라 구분
            - 상태 패턴: 코드 내 조건문을 대체
            - 전략 패턴: 상속을 대체
        - 다음 상태를 자기 자신이 정하는가
            - 상태 패턴: 상태 객체 내부에서 다음 상태를 결정
            - 전략 패턴: 클라이언트(외부)에서 다음에 실행할 객체를 지정할 수 있다.
            -> 상태 패턴도 외부에서 설정될 수 있기 때문에 상태 기반인가, 방법 기반인가로 나뉘어야 한다.

        -> 전략 패턴 - 사용자가 쉽게 알고리즘 전략을 바꿀 수 있도록 유연성을 제공. 상속의 한계를 해결하기 위하여 나온 패턴
           상태 패턴 - 한 객체가 동일한 동작을 상태에 따라 다르게 수행해야 할 경우 사용하는 패턴

- 전략 패턴
    - 전략, 전략 패턴의 개념
        - 전략: 특정한 목표를 수행하기 위한 행동 계획
        - 전략 패턴: 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고 사용하며, 동적으로 전략 수정이 가능한 패턴
        - 동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만든다.

    - 전략 패턴 in JDK
        ex) Comparator - 개발 상황에 맞게 비교 전략을 구현할 수 이게 하여 기존 코드의 수정 없이 확장할 수 있음

    - 전략 패턴이란?
        - 소프트웨어 디자인 패턴중 하나
        - 동일 계열의 알고리즘을 정의하고, 각 알고리즘을 캡슐화하며, 이 알고리즘들을 상호 교체가 가능하게 만든다.

    - 전략 패턴의 장단점
        - 장점
            - 상속을 사용하지 않을 수 있음
            - if 문을 제거할 수 잇음
            - 구현의 선택이 가능
        - 단점
            - 객체 수 증가
            - 서로 다른 전략을 이해해야 함

    - 상태 패턴과의 비교
        - 공통점
            - 인터페이스를 사용해서 클래스르 캡슐화 한다. (구조가 같다)
            - 컨텍스트 클래스는 영향을 받지 않고 변경에 유연한 대처가 가능 (둘 다 OCP 를 따른다)
        - 차이점
            - 전략 패턴
                - 클라이언트 혹은 사용자에 의해 전략을 주입받는다.
                - 어떻게 객체가 이을 할지, 즉 알고리즘을 캡슐화한다.
                - 하나의 특정 작업만 처리
                - 원하는 알고리즘으로 언제든지 변경하고 싶을 때
            - 상태 패턴
                - 컨텍스트 스스로 상태를 변환할 수 있다.
                - 상태에 따른 행동을 캡슐화한다.
                - 컨텍스트 객체가 수행하는 대부분의 메서드에 대한 인터페이스가 제공
                - 상태 변화가 잦을 경우

- 도메인 주도 설계 (Domain-Driven-Design)
    - DDD 란?
        - domain: 사용자가 사용하는것, 소프트웨어로 해결하고자 하는 문제 영역, 비즈니스 영역
        - 도메인 주도 설계: 도메인을 중심으로 하는 개발 방식. 도메인에 관련된 문제를 해결하는 것
          복잡한 도메인을 해결하는 것을 높은 우선순위로 생각해 서비스를 만들어 나가는 방법
          -> 도메인의 복잡성을 조금 더 쉽게 다룰 수 있게 도와주는 도구
        - 도메인  ->  모델  ->  소프트웨어
              (추상화)   (실체화)
            (전략적 설계) (전술적 설계)
        - 소프트웨어 개발과 모델링의 불일치 발생할 수 있음
            - 유비쿼터스 랭귀지(보편 언어)
                - 도메인에 대한 어휘를 이해관계자(도메인 전문가, 개발자, 분석가...)들이 공통적으로 의미를 이해할 수 있도록 정의하는 것
            - 모델 주도 설계
                - 분석과 설계를 나누지 않으면 분석/설계/구현의 모든 단계를 관통하는 하나의 모델을 유지
                - 모델링 통해 가져올 수 있는 통찰을 코드에도 적용
                - 모델 == 코드

        - 도메인 모델
            - 도메인에 대한 구체적인 설계, 도메인을 개념적으로 표현한 것
            - 개념들의 관계를 표현한 모델
            - 문제 영역을 시각화

        - 도메인 주도 설계
            - 복잡한 소프트웨어는 기술 자체의 복잡성 보다는 도메인 자체의 복잡성에 기인
            - 도메인을 가장 잘 아는 사람(도메인 전문가)과 어떻게 협업할 것인지가 가장 중요
            - 유비쿼터스 랭귀지, 모델 주도 디자인

    - 왜 도메인 주도 설계인가?
        - 등장 배경
            - 데이터에 종속적인 어플리케이션
                - 기존 개발은 DB 테이블 중심 -> 빈약한 도메인 도델
            - 모델링과 개발과의 불일치
                - getter 와 setter 만으로 구성된 모델
                - 데이터만 가지는 데이터홀더 개념
                - Big Service Layer

    - DDD 의 전략적, 전술적 패턴
        - 전략적 설계
            - 복잡한 메인 맥락(Context) 경계를 명확히 정의하는 과정
            - Bounded Context 안의 도메인 모델에서 보편 언어를 개발하는 방법
            - 도메인에서 서브 도메인으로 복잡성을 분리 (핵심, 지원 도메인 파악)
            - 컨텍스트 맵핑 기술을 활용해 여러 개의 Bounded Context 를 통합
            - 이벤트 스토밍 기법을 활용해 Bounded Context 식별

        - 전술적 설계
            - 전략적 설계에서 더 상세한 부분(바운디드 컨텍스트 내부) 모델링
            - Model Driven Design
            - 빌딩 블록(패턴)을 사용해 모델링 - Aggregate 패턴
                - Entity: 속성이 아닌 식별성을 기준으로 정의되는 도메인 객체
                - Value Object: 식별성이 아닌 속성을 이용해 정의되는 불변 객체
                - Service: Domain Object 에서 위치시키기 어려운 operation 을 가지는 객체
                - Aggregate: 연관된 entity 와 value object 의 묶음. 일관성과 트랜셕선, 분산의 단위. 캡슐화를 통한 복잡성 관리
                - Factory: 복잡한 entity 의 생성 절차에 캡슐화할 수 있는 개념. 생성하기 복잡한 Aggregate 내의 여러 객체 동시 생성
                           생성시 Aggregate 의 일관성 유지
                - Repository: 도메인 영역과 데이터 인프라스트럭처 계층을 분리하여 데이터 계층에 대한 결합도를 낯추기 위한 방안
                              생성된 Aggregate 에 대한 영속성 관리, 조회, 등록, 수정 삭제 시 Aggregate 의 일관성 유지
            - 계층형 아키텍처를 통한 모데인 모델 분리
            - 도메인 이벤트를 통해 도메인을 보다 명확히 모델링

- DTO vs VO
    - DTO 와 VO 의 혼용 사례와 원인
    - 결론
        - DTO: 데이터 전달용
        - VO: 값 표현용

    - DTO
        - Data Transfer Object
        - 데이터를 전달하기 위해 사용하는 객체
        - "계층 간" 데이터를 전달하기 위한 객체
        - 오직 getter/setter 메서드 만을 갖는다. 다른 로직을 갖지 않는다.
        - DTO 를 불변객체로 -> 생성자를 통해 속성 값들을 초기화해 불변객체로 생성
        - DTO 클래스와 Entity 클래스
            - 절대로 요청이나 응답 값을 전달하는 클래스로 엔티티를 사용하면 안된다.
              데이터베이스와 매핑되어 있는 핵심 클래스이기 때문. 엔티티 클래스를 기준으로 테이블이 생성되고 스키마가 변경된다.
              뷰는 비즈니스 요구사항에서 자주 변경되는 부분이다. 요청이나 응답 값을 전달하는 클래스로 엔티티를 쓴다면
              뷰가 변경될 때마다 엔티티 클래스를 그에 맞춰 매번 같이 변경해야 한다.
              수많은 서비스 클래스나 비즈니스 로직들이 엔티티 클래스를 기준으로 동작한다. 엔티티 클래스를 변경하면 관련되어 있는
              많은 클래스들에게 영향을 주게 된다. 따라서 요청이나 응답 값을 전달할 때는 뷰의 변경에 따라 다른 클래스들에게
              영향을 주지 않고 자유롭게 변경할 수 있는 DTO 사용해야 함. 또한 응답 값으로 여러 테이블들을 조인한 결과값을 줘야할 경우가
              빈번하기 때문에 엔티티 클래스만으로는 응답값을 표현하기 어려운 경우가 많다.

    - VO
        - Value Object
        - 값 그 자체를 표현하는 객체
        - VO 는 값 자체를 표현하기 때문에 불변객체여야 한다.

    - DTO vs VO
        - DTO
            - 레이어 간 데이터 전달
            - 속성값이 모두 같다고 해서 같은 객체가 아니다
            - setter 존재 시 가변, setter 비 존재시 불변
            - getter/setter 외의 로직을 갖지 않는다
        - VO
            - 값 자체 표현
            - 속성값이 모두 같으면 같은 객체다
            - 불변
            - getter/setter 외의 로직을 가질 수 있다

- spring Webflux
    - spring framework 주요 기능
        - Dependency Injection / Inversion of Control
        - Portable Service Abstraction
        - Aspect Oriented Programming
        - 경량 컨테이너, POJO 지원, @Transaction 등등
    - spring framework 5.xx 특징
        - Java 호환 버전 변경: JDK8 부터 지원
        - Kotlin 지원
        - 호환 라이브러리 변경 (JUnit5, JDBC 4.0, Hibernate 5...)
        - Reactive Programming 지원 -> spring Webflux

    - Spring Webflux 가 생겨난 배경
        - 적은 수의 스레드로 동시성 처리 / Non-blocking / Functional Programming
        - 쓰레드 풀의 딜레마
            - CPU, 메모리가 충분하지만 스레드가 모자라서 처리율 저하 (큐에 쌓임)
            - 그래서 스레드를 과도하게 늘리면 이번엔 메모리, CPU 의 부하로 성능 저하
            - 컨텍스트 스위칭이라 하여 CPU 간 전환 과정은 엄청난 부하가 필요
            - 즉, 스레드를 무조건 늘린다고 문제를 해결할 수 있는 것은 아님

        - spring MVC: 스레드를 늘려서 동시성 처리
          어플리케이션에서 I/O 요청을 한 후 완료되기 전까지는 어플리케이션이 Block 이 되어 다른 작업을 수행할 수 없다. 이는 해당 자원이
          효율적으로 사용되지 못하고 있음을 의미한다. 그러나 현재 어플리케이션들은 Blocking 방식임에도 불구하고 마치 Block 이 안된듯이
          동작하는 것처럼 보인다. 이것은 싱글 스레드 기반이 아닌 멀티 스레드 기반으로 동작하기 때문이다. Block 이 되는 순간 다른 스레드가
          동작함으로써 BLock 의 문제를 해소하였다. 그러나 스레드 간의 전환(컨텍스트 스위칭)에 드는 비용이 존재하므로 여러 개의 I/O 를
          처리하기 위해 여러 개의 스레드를 사용하는 것은 비효율적이다.

        - Webflux: 적은 수의 스레드로 동시성 처리 (Asynchronous Non-Blocking I/O)
          I/O 요청을 한 후 Non-Blocking I/O 와 마찬가지로 즉시 리턴된다. 허나, 데이터 준비가 완료되면 이벤트가 발생하여 알려주거나,
          미리 등록해놓은 callback 을 통해서 이후 작업이 진행된다. Blocking 이 없기 때문에 자원을 보다 효율적으로 사용 가능

        - Non-blocking: 자신이 호출되었을 때 바로 자신을 호출한 쪽으로 넘기며 자신을 호출한 쪽에서 다른 일을 할 수 있도록 하는 것

        -> 적은 스레드와 메모리를 효율적으로 사용할 수 있는 것뿐.
           "속도가 빠르다" 보다는 "적은 리소스로 많은 트래픽을 감당한다"고 할 수 있다.

        - Functional Programming: 함수가 일급 객체로 쓰일 수 있어(반환값, 인자) 메소드 체이닝과 람다를 섞어쓰는 것(Java 8 ~)

        - Reactive Programming
            - Non-blocking IO 에 Reactive Stream 과 BackPressure 를 곁들였다. Publisher 가 Subscriber 를 압도하지 못하게
              하는 목적이 핵심인 BackPressure 를 가지고 작은 수의 스레드로 확장성 있는 Non-blocking / Event Driven 개발 지향

            - Reactive Stream
                - Asynchronous, Non-blocking 으로 작동하는 stream. stream 의 기능이 더 많은 것
                - Publisher (웹 클라이언트, 데이터베이스) 에서 변경이 생기면 Subscriber 에 변경된 데이터들을 Stream 으로 전달
                - 이 Stream 으로 프로그래밍하는 패러다임이 Reactive Programming (모든 것은 Steam 이다.)

            - BackPressure
                - Subscriber 로 들어오는 Stream 양을 조정, 적은 컴퓨팅 자원으로 일을 처리하기 가능한 정도씩만 받기
                - 물론 이건 실시간 통신을 사용하지 않는 이상 크게 어렵다.

- @Transactional
    - 데이터베이스에서는 트랜잭션을 조작함으로써 사용자가 데이터베이스에 대한 완전성을 신뢰할 수 있도록 하고 있다.
      트랜잭션이란 더이상 나눌 수 없는 가장 작은 하나의 단위.
    - 데이터베이스에서는 명령을 끝마칠 때까지 수행내역을 로그에 저장. 이 로그들을 이용해 트랜잭션을 지원
        - redo log: 데이터베이스에 반영된 내용을 재반영하기 위함
        - undo log: 수행을 실패해 이전의 상태로 되돌리기 위함

    - 트랜잭션의 성질
        - 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성징 (ACID)

        - 원자성: 트랜잭션은 DB 에 모두 반영되거나, 전혀 반영되지 않아야 한다.
        - 일관성: 데이터베이스의 상태, 데이터베이스 내의 계층 관계, 칼럼의 속성 등이 항상 일관되게 유지되어야 한다.
            ex) 어떤 칼럼의 속성이 수정되었다면 trigger 를 통해 일괄적으로 모든 데이터베이스에 적용해야 한다.
        - 지속성: 트랜잭션이 성공적으로 수행되어 커밋되었다면 어떠한 문제가 발생하더라도 데이터베이스에 그 내용이 영원히 지속되어야 한다.
                 이를 위해 모든 트랜잭션은 로그로 남겨져 어떠한 장애에도 대비할 수 있도록 한다.
        - 독립성: 다른 트랜잭션이 작업에 끼어들 수 없고 각 트랜잭션을 독립적으로 수행해야 한다.
                 트랜잭션은 격리 수준 설정을 통한 독립성을 보장.
                 하지만 데이터베이스에 작업이 들어왔을 때 모든 작업의 독립성을 보장해 하나씩 순차적으로 진행하게 된다면 CPU 는 DBMS 보다
                 인풋 아웃풋 작업을 빈번히 수행하기 때문에 CPU 는 점점 응답을 기다리는 시간이 길어져 프로그램이 비효율적으로 동작하는
                 문제가 발생할 수 있다.
                 이처럼 데이터베이스에 저장된 데이터의 무결성과 동시성의 성능을 지키기 위해 트랜잭션의 설정이 중요

    - 데이터베이스에서는 각각의 명령을 하나의 트랜잭션으로 보고 보장해주기 때문에 여러 명령을 하나의 트랜잭션으로 묶고 싶은 경우
      개발자가 직접 트랜잭션의 경계설정을 통해 트랜잭션을 명시해야 함

    - 선언적 트랜잭션 사용 방법
        - 메서드, 클래스, 인터페이스 등에 적용 가능
        - 클래스 상단에 적용된 어노테이션에 대해서는 해당 클래스에 존재하는 모든 메서드에 어노테이션이 적용
        - 중첩되어 존재하는 경우에는 클래스 메서드, 클래스, 인터페이스 메서드, 인터페이스 순으로 우선순위를 갖고 적용된다.
        - 데이터베에스에 여러 번 접근하면서 하나의 작업을 수행하는 서비스 계층 메서드에 붙이는 것이 통상적
        - @Transaction(value="txManager")
          @Transaction(transactionManager="txManager")
          -> 빈으로 등록되어 있는 특수한 트랜잭션 매니저를 지정하고 싶은 경우에 지정해서 사용 가능

    - 선언적 트랜잭션 속성
        - propagation
            - 트랜잭션 전파란 트랜잭션 경계에서 이미 진행중인 트랜잭션이 있을  어떻게 동작할지 결정하는 것

            - REQUIRED (디폴트)
                - 이미 시작된 트랜잭션이 있으면 그 트랜잭션에 참여
                - 모든 트랜잭션 매니저가 지원합니다.
                - 해당 메서드를 호출한 곳에서 별도의 트랜잭션이 설정되어 있지 않다면 트랜잭션을 새로 시작
                - 부모 트랜잭션이 존재하면 포함되어 동작
            - SUPPORTS
                - 진행 중인 트랜잭션이 있으면 REQUIRED 처럼 참여하고 트랜잭션이 없으면 트랜잭션 없이 메서드를 실행
                - 해당 경계 안에서 Connection 객체나 하이버네이트의 Session 등은 공유 가능
            - MANDATORY
                - 진행 중인 트랜잭션이 있으면 참여하고 없으면 예외가 발생. 혼자서는 트랜잭션을 시작할 수 없고 메서드를 실행할 수도 없다.
                - 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용
            - REQUIRES_NEW
                - 항상 새로운 트랜잭션을 시작한다. 진행중인 트랜잭션이 있으면 잠시 보류시키고 새로운 트랜잭션으로 실행
                - 새로운 트랜잭션 안에서 예외가 발생해도 호출한 곳으로 롤백이 전파되지 않는다
                - 부모 트랜잭션이 존재하면 2개의 트랜잭션이 완전 독립적으로 동작
            - NOT_SUPPORTED
                - 이미 시작된 트랜잭션이 있으면 보류하고 자신의 메서드를 실행하는, 트랜잭션을 사용하지 않는 설정
                  진행중 인 트랜잭션이 있으면 보류하고 자신의 메서드 실행
                - 트랜잭션을 사용하지 않는다.
                - 부모 트랜잭션이 존재하면 보류시키고 트랜잭션 사용을 정지시킨다
            - NEVER
                - 트랜잭션을 사용하지 않도록 강제. 진행중인 트랜잭션이 없다면 자신의 메서드를 실행하지만 트랜잭션이 있다면 예외 발생
            - NESTED
                - 이미 진행 중인 트랜잭션 있으면 그 안에 새로운 트랜잭션을 만드는 설정.
                - 트랜잭션1 내부에 메서드 2를 트랜잭션 2로 삽입
                - 이렇게 중첩된 트랜잭션 2는 부모인 트랜잭션1의 커밋/롤백에는 영향을 받지만,
                  트랜잭션2의 커밋/롤백에는 트랜잭션1이 영향을 받지 않는다.
                - 부모 트랜잭션의 커밋과 롤백에 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않는다
                    예시) 메인작업을 진행하며 이와 관련된 로그를 DB에 저장
                         메인 작업이 실패 -> 로그 작업 롤백
                         로그를 저장하는 작업이 실패 -> 메인 작업의 트랜잭션은 롤백 X
                - 모든 트랜잭션 매니저에 적용 가능하진 않다.

        - isolation 으로 전달받는 트랜잭션 격리 수준      ** https://steady-coding.tistory.com/562 **
            - 동시에 여러 트랜잭션이 실행될 때 다른 트랜잭션이 변경하거나 조회하는 데이터를 허용할지 말지를 결정하는 것
              동시에 수행되는 트랜잭션끼리 어느 정도 영향을 줄지 그 수준을 정하는 것
              가능한 많은 트랜잭션을 동시에 진행하면서도 문제가 생기지 않도록 하려는 설정
              기본적으로 데이터베이스에 설정되어 있지만 이 속성을 통해 재설정할 수 있다.
              격리수준을 낮추면 동시성 높아지고, 데이터 무결성 보장이 어려움
              격리수준을 높이면 동시성이 낮아지고, 데이터 무결성 보장
            - 트랜잭션 격리수준(isolation level)이란 동시에 여러 트랜잭션을 처리할 때, 트랜잭션이 얼마나 서로 고립되어 있는지를 의미한다.
              즉, 해당 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 볼 수 있는 기준을 결정하는 것이다.

            - DEFAULT
                - 데이터베이스의 기본 설정을 따른다는 것
                  대부분의 DB는 READ_UNCOMMITTED 를 기본 격리 수준으로 갖고 있지만, 올바른 트랜잭션 설정을 위해서는 확인 필수
            - READ_UNCOMMITTED
                - 가장 낮은 격리 수준으로 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있는 설정
                - Dirty Read, Non-REPEATABLE READ, Phantom Read 문제
                - Dirty Read
                    - 하나의 트랜랙션에서 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
            - READ_COMMITTED
                - 가장 많이 사용되는 두번째로 낮은 격리 수준으로 커밋되지 않은 정보는 읽을 수 없다.
                - Non-REPEATABLE READ, Phantom Read 문제
                    - Non-REPEATABLE READ: 같은 트랜잭션 내에서 select 문을 두 번 조회했는데
                      서로 다른 값이 나오는 데이터 불일치 문제
            - REPEATABLE_READ
                - 세번째로 낮은 격리 수준으로 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 없다.
                  한번 조회한 데이터는 반복적으로 조회해도 같은 값을 반환한다.
                - 특정 행을 조회시 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준이다. 하지만, SERIALIZABLE 과 다르게 행이 추가되는 것을 막지는 않는다. 이로 인해 팬텀 리드 현상이 발생할 수 있다.
                - Phantom Read 문제
                    - Non-REPEATABLE READ 의 한 종류로 조건이 걸렸든 안 걸렸든 select 문을 쓸 때 나타날 수 있는 현상
                      해당 쿼리로 읽히는 데이터에 들어가는 행이 새로 생기거나 없어져 있는 현상

                - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
                - Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
                    - Undo에 백업된 데이터는 주기적으로 삭제한다.
                - Phantom Read가 발생할 수 있다.
                    - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
                    - Undo를 사용해서 시점을 보장하지만, 새로 삽입된 레코드는 Undo가 없기 때문
                    - InnoDB에서는 넥스트 키 락(레코드 락 + 갭 락)을 이용해서 Phantom Read 문제를 해결한다!
            - SERIALIZABLE
                - 가장 강력한 격리 수준으로 동시에 같은 테이블의 정보에 접근할 수 없다.
                  트랜잭션의 ACID 성질이 엄격하게 지켜지나 성능은 가장 떨어짐
                  단순 select 만으로도 트랜잭션이 커밋될 때까지 모든 데이터에 잠금이 설정되어 다른 트랜잭션에서 해당 데이터 변경 x
                  하지만 트랜잭션을 순차적으로 수행하는 것과 다를 바 없어서 성능이 매우 떨어지니 극단적인 상황에만 사용해야 함.

            -> 데이터베이스에서는 이러한 격리 수준에 따라 트랜잭션이 실행되는 동안 각기 다른 lock 을 걸고 데이터를 보호하고자 한다.
               격리 수준이 높아질수록 더욱 강하게 lock 을 걸고 트랜잭션을 마치면 lock 을 해재한다.

            - 격리 수준에 따른 문제점  https://wildeveloperetrain.tistory.com/123,   https://zangzangs.tistory.com/167
                - dirty read - 커밋하지 않은 데이터를 읽을 수 있다.
                - non-repeatable read - 반복해서 같은 데이터를 읽을 수 없다.
                - phantom read - 반복 조회 시 결과 집합이 달라진다.

        - timeout 으로 지정되는 트랜잭션 시간 제한
            - 초 단위로 제한시간 설정 가능
              ex) @Transaction(timeout=10) -> 10초가 지나면 예외가 발생해 롤백된다.
            - 따로 설정하지 않으면 timeout 은 지정되어 있지 않다.

        - readOnly 로 지정하는 읽기 전용 트랜잭션
            - true 로 설정하면 트랜잭션 작업 안에서 update, insert, delete 작업이 일어나는 것을 방지
            - flush 모드가 manual 로 설정되어 jpa 의 더티체킹 기능을 무시할 수 있다. (성능 향상에 도움이 되기도 한다.)
            - 기본 값은 false 로 모든 작업을 허용

        - rollbackFor 로 전달받는 트랜잭션 롤백 예외
            - 기본적으로 트랜잭션은 런타임 예외와 Error 가 발생했을  때만 롤백. 하지만 체크 예외나 예외가 발생하지 않으면 커밋.
              체크 예외를 롤백 대상으로 삼고 싶으면 특정 exception 을 클래스로 전달해 사용할 수 있다.

        - noRollbackFor 로 지정하는 트랜잭션 커밋 예외
            - 특정 exception 이 발생했을 때 롤백하지 않고 커밋


- Web Server vs WAS
    - Web Server
        - Web Server 란
            - 웹 브라우저(클라이언트)로부터 HTTP 요청을 받아 HTML 문서와 같은 정적 컨텐츠를 제공하는 프로그램
            - 정적 컨텐츠
                - 요청 인자 값에 상관없이 달라지지 않는 컨텐츠(html, css, image...)
                - 어느 사용자 요청이든 항상 동일한 컨텐츠

        - Web Server 의 기능
            - 클라이언트로부터 HTTP 요청을 받을 수 있다.
            - 정적 컨텐츠 요청 시 정적 컨텐츠를 제공할 수 있다.
            - 동적 컨텐츠 요청 시 WAS 로 전달하여 WAS 가 처리한 결과를 클라이언트에 전달

    - Web Application Server (WAS)
        - Web Application Server (WAS) 란?
            - DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 프로그램
            - 동적 컨텐츠
                - 요청 인자에 따라 바뀔 수 있는 컨텐츠
        - WAS 의 기능
            - 클라이언트로부터 HTTP 요청을 받을 수 있다. (대부분의 WAS 는 Web Server 내장)
            - 요청에 맞는 정적 컨텐츠를 제공할 수 있다.
            - DB 조회나 다양한 로직 처리를 통해 동적 컨텐츠를 제공할 수 있다.

    - Web Server 는 왜 필요할까?
        - Web Server 를 같이 사용했을 때의 장점
            - 책임 분할을 통한 서버 부하 방지
                - 정적인 컨텐츠는 Web server, 동적인 컨텐츠는 WAS 가 담당
            - 여러 대의 WAS 로드밸런싱
                - WAS 가 처리해야 하는 요청을 여러 WAS 가 나누어서 처리할 수 있도록 설정
                - 여러 대의 WAS Health check
                    - Health check 란?
                        - 서버에 주기적으로 HTTP 요청을 보내 서버의 상태를 확인 (ex 특정 url 요청에 200 응답이 오는지?)
                            - 로드밸런싱을 해주다보면 특정 WAS 에서 동작이 제대로 안될 경우 Web server 에서 WAS 가 정상적으로
                              동작하고 있는지 확인하는 것
                        - interval: health check 를 통해 서버 상태를 확인하는 요청을 날리는 주기 (default: 5초)
                        - Fails: 아래의 경우 3회 연속 실패하면 서버가 비정상이라고 인지 (default: 1회)
                        - passes: 서버가 다시 복구되어 요청이 2번 연속 성공하면 서버가 정상으로 인지 (default: 1회)
            - 보안
                - 리버스 프록시를 통해 실제 서버를 외부에 노출하지 않을 수 있다.

    - 정리
        - 결론적으로 WAS 만으로도 서비스는 가능하다.
        - 서비스 확장성, 안정성을 고려한다면 앞 단에 Web server 를 두는 것이 유리

- 쿠키/세션/토큰/캐시
    - 쿠키: 사용자에 의해 조작되어도 크게 문제되지 않을 정보를 브라우저에 저장
    - 세션: 인증에 대한 정보를 서버가 저장
    - 토큰: 인증에 대한 정보를 사용자가 저장
    - 캐시: 한 번 전송받은 데이터를 저장해 놨다가 필요할 때 꺼내 쓰기 가능

- 스프링 빈
    - 빈과 의존성 주입
        - 직접 의존성을 주입한다면 의존 관계를 모두 파악해야 하고 많은 객체가 중복 생성된다.
        - 의존성 주입이 필요한 객체를 빈으로 등록하여 스프링 IoC 컨테이너가 객체의 생성과 의존성 주입을 관리하도록 해야함
          이렇게 구현하면 주입된 의존성을 사용하는 부분에만 집중할 수 있게 된다.

    - 빈과 싱글턴
        - 객체를 싱글톤으로 만들어 사용한다면?
            - 다형성을 이용하지 못함
                - 싱글톤 패턴을 사용하면 생성자의 접근 지정자를 private 으로 설정해야 한다. 이렇게 되면 상속이 불가능
            - 안정성이 중요한 어플리케이션에서 필수적인 단위 테스트가 어렵다.
                - 객체를 싱글톤 패턴으로 구현할 경우 해당 객체는 공유 객체가 되므로 단위 테스트를 실행할 때 테스트의 순서에 따라
                  결과가 달라진다.

    - 스프링 IoC 컨테이너는 빈을 어떻게 관리할까?
        - 객체 생성 + property 설정 -> 의존 설정 -> 초기화 -> 사용 -> 소멸
        - spring IoC 컨테이너가 생성되면 빈 스코프가 싱글톤인 객체를 생성. 이 때 빈으로 등록하기 위해서 어노테이션 기반 혹은 java 기반
          설정 클래스 기반 혹은 xml 기반의 다양한 Configuration 메타데이터를 이용하여 통일된 Bean Definition 을 생성한다. 그리고
          빈으로 등록할 POJO 와 Bean Definition 정보를 이용하여 빈을 생성한다. 이 과정에서 싱글톤 패턴을 사용하는 것이 아닌
          평범한 자바 클래스를 이용하여 객체 생성.
        - IoC 컨테이너는 싱글톤 레지스트리라는 기능도 가지고 있다. 레지스트리는 spring 뿐만 아니라 CS 에서 전반적으로 쓰이는 개념으로
          Key 와 Value 형태로 데이터를 저장하는 방법. IoC 컨테이너는 빈 스코프가 싱글톤인 객체에 빈의 이름을 key 로 객체를 value 로
          저장한다. 그래서 의종성 주입이 되어야하는 객체가 빈으로 등록되어 있을 때, 스프링은 빈의 이름을 이용하여 항상 동일한
          Single Object 를 반환하게 된다.
        - 이렇게 빈 객체가 생성되면 IoC 컨테이너는 의존성 자동 주입함.
        - 그리고 객체를 초기화 하는 과정을 진행하는데, 모든 객체가 다 필요한 것은 아니지만 커넥션 풀처럼 사용 전에 초기화 과정이 필요한
          객체들은 초기화 과정을 진행한다.
        - 초기화가 끝나면 빈을 사용할 수 있게 된다.
        - 스프링 컨테이너가 종류될 때 빈 스코프가 싱글톤인 객체들도 함께 소멸된다.

    - 빈 설정시 주의점
        - 빈 스코프를 싱글톤으로 설정할 경우 상태를 가지면 안된다.
          하지만 상태를 가질 수 있는 빈도 있다. @Scope 를 통해 빈 스코프 설정 가능. 디폴트는 싱글톤 타입이지만 프로토 타입이라는
          스코프도 있다. IoC 컨테이너와 함께 생성되고 소멸되는 것이 아닌 요청이 올 때마다 객체가 생성된다. 모든 스레드에서 공유하는 것이
          아니므로 해당 객체는 상태를 가질 수 있다.
        - 의존성을 자동 주입해야 할 인터페이스에 구현체가 두 개 이상이라면 스프링은 어떤 구현체를 자동 주입할지 정하지 못해서 충돌이 일어남
            - @Primary, @Qualifier

    - 정리
        - 스프링 빈이 왜 필요할까? -> 스프링 IoC 컨테이너가 특정 객체의 라이프사이클을 관리한다는 것을 명시
        - 스프링 IoC 컨테이너는 왜 빈을 관리할까? -> 의존성을 사용하는 로직에만 집중 가능, 의존성이 주입될 객체가 싱글 오브젝트임을 보장

- Servlet & Spring Web MVC
    - 서블릿 이전의 웹 어플리케이션
        - 초기의 웹 어플리케이션은 클라이언트에서 요청하면 단순히 html 파일과 같은 정적인 데이터만 제공할 수 있었다. 즉, 사용자마다
          다른 화면이 아닌 동일한 화면만 제공 받음. 하지만 정적 컨텐츠만 제공하는 웹 서버는 사용자들에게 다양한 화면을 전달하기 힘들었고
          이 때문에 동적 컨텐츠 제공의 필요성을 느낌. 이러한 문제 해결을 위해서 CGI 나옴.
        - CGI (Common Gate Interface) 는 동적인 데이터를 제공하기 위한 규약. 클라이언트로부터 요청이 오면 서버는 CGI 를 구현한
          구현체에게 동적인 데이터를 제공해달라고 요청한다. CGI 구현체는 이를 수행해 결과를 전달함으로써 클라이언트는 동적인 데이터를
          제공받을 수 있음.
        - 하지만 CGI 는 모든 사용자 요청마다 process 를 사용해서 요청을 처리함. process 는 각자의 공간을 지니기 때문에 무겁고 생성되는
          시간이 오려 걸려 서버가 더 많은 리소스를 부담해야 한다. 또, 같은 요청이라도 동일한 CGI 구현체를 생성한다. 매번 객체를 생성하고
          종료하는 작업은 필요없는 서버 리소스를 불필요하게 낭비.
          이러한 문제를 해결하기 위해 Servlet 이 등장하게 됨.

    - 서블릿
        - 자바 진영에서 동적 데이터를 제공하기 위해서 CGI 를 기반으로 제작된 프로그램. 앞서 CGI 가 가진 문제를 해결함.
          각 요청마다 Thread 를 사용, 싱글톤 패턴 사용해서 하나의 구현체를 재사용
        - 웹 어플리케이션 요청을 보내기 위해서 HTTP 규약에 따른 요청을 해야하고 이를 기반으로 한 HTTP 메시지로 통신. 서버에서
          HTTP 메시지를 응답받으면 각 의미에 맞게 파싱하여 응답을 처리한 후 응답 HTTP 메시지를 만들어서 클라이언트에게 전달.
          매번 개발자가 일일히 요청 값을 파싱해서 분석하고 응답 메시지를 만들어주는 작업은 번거롭고 반복됨. 서블릿은 API 를 통해서 이러한
          작업 처리할 수 있는 기능 제공. 또한, HTTP 메서드에 대한 분기처리도 각 요청별로 대신 처리.

    - 서블릿 컨테이너와 서블릿의 동작 과정
        - 서블릿 컨테이너
            - 서블릿은 성성 시 init(), 제거 시 destroy() 메서드를 통해서 생성 및 제거됨. 서블릿 컨테이너는 이러한 서블릿의 생성, 호출, 제거의
              모든 작업들을 관리하면서 서블릿의 생명주기 담당.
        - 서블릿의 동작 과정
            - 클라이언트의 요청이 오게 되면, 서블릿 컨테이너는 해당 요청과 매핑된 서블릿을 찾는다. 만약 서블릿이 생성되어 있지 않다면
              서블릿 컨테이너는 서블릿을 생성하고 이를 동작시킴. 작업이 종료된 서블릿은 소멸되지 않고 다시 서블릿 컨테이너에서 관리됨.
              클라이언트 요청과 매핑되어 있는 서블릿이 이미 존재한다면 서블릿 컨테이너는 해당 서블릿을 다시 호출해서 재사용.
        - 서블릿의 문제점
            - 서블릿은 각 요청마다 하나의 서블릿이 1:1로 매핑되는 구조를 가지고 있어 서블릿마다 공통으로 실행되는 로직이 매번 반복됨.
                - 각 서블릿의 service() 메서드에서 중복되는 부분이 많다.
                - 서블릿에 종속적인 구조를 가진다.
                - 이후, 각 컨트롤러에서 공통으로 처리해야하는 로직이 생기면 중복 발생.

    - 프론트 컨트롤러 패턴
        - 클라이언트 요청을 받는 서버의 최앞단에 모든 요청을 받을 수 있도록 컨트롤러를 하나 만들고 여기서 각 요청별 처리하는 로직을 찾아
          이를 전달해 요청을 수행.
          매 요청마다 각각의 서블릿을 사용하는 것이 아닌 하나의 서블릿을 통해 요청을 수행할 수 있게 되었고 이로 인해 요청의 진입점이
          같게 되어 관리가 수월. 또, 각 서블릿마다 중복되는 요청들을 프론트 컨트롤러 한 곳에서만 사용

    - Spring Web MVC
        - DispatcherServlet
            - Servlet WebApplicationContext
                - 웹 요청을 담당하는 객체들이 들어가서 관리됨
                - Controller, ViewResolver, HandlerMapping
            - Root WebApplicationContext
                - 서비스 계층이나 레파지토리 등 웹 환경에 독립적인 빈들이 들어가서 관리됨
                - Service, Repository

            -> 웹 요청시 필요한 부분들을 DispatcherServlet 이 알아서 주입하는 구조로 웹 요청이 동작
               설정만 잘하면 그 설정으로 생성된 객체가 스프링 컨테이너 내부에서 관리되고 필요한 부분을 주입받아서 DispatcherServlet 이
               스스로 사용될 수 있게 되는 것

- scale up vs scale out, SPOF
    - scale up
        - 서버 자체를 증강시켜 처리 능력을 향상
        - 수직 스케일
        - 장점
            - 구축, 설계가 쉬움
            - 컨트롤러나 네트워크 인프라 비용은 별도로 발생 x
        - 단점
            - 스토리지 컨트롤러 확장성 한계
            - 용량, 성능 확장 제한
            - 비쌈
            - 트래픽 부하로 인한 장애 영향도 up
        - 주요 기술
            - 고성능 CPU
            - Memory 확장
            - SSD
        - 사용
            - 정합성 유지가 어려운 경우
            - OLTP(온라인 트랜잭션 관리)
            - 데이터베이스 서버
    - scale out
        - 서버의 대수를 증가시켜 처리 능력 향상
        - 수평 스케일
        - 장점
            - 지속적인 확장 가능
            - 분산처리 -> 장애 가능성 down
            - scale up 보단 저렴
        - 단점
            - 설계, 구현의 복잡성 -> 관리 비용의 증가
            - 기본적인 직렬화 존재
            - 기술적인 문제 (병렬성, 대역폭 등)
            - 코어 개수와 성능이 비례 x
        - 사용
            - 높은 병렬성을 실현하기 쉬운 경우
            - 정합성 유지가 쉬운 경우
            - 메일 게시판 서버, 데이터 읽기 전용 어플리케이션, 웹 서버 등

    - SPOF
        - Single Point Of Failure
        - 단일 장애점 (고장점, 실패점)
        - 전체 시스템이 중단
        - 예방
            - 복잡한 시스템인지 판별
            - 단일 장애점 파악 및 제거
            - 높은 신뢰성은 단일 컴포넌트의 의존 x
        - 방법
            - 복잡도 낮추기
            - 복제
            - 다양성
            - 문서화

        - Web Browser -> Web Server
            - Load Balance
            - N 대의 Web Server or L4, L7
        - Web 서버 -> WAS
            - 개발자의 코드로 인한 문제점 발생
            - N 대의 WAS 구축
        - DataBase
            - 용량 부족으로 인한 장애 발생
            - RAID, NAS 등

