- RESTful
    - REST 의 제약을 준수했다는 의미를 가진다.
    - REST: 웹에서 사용하는 아키텍처 중 하나
    - URI 를 통해 자원을 지정하고, HTTP 메서드를 통해 자원에 대한 행위를 표현
    - REST API 란 REST 아키텍쳐 스타일에 부합하는 API

    - 초기의 웹은 정적인 페이지의 나열로 구성되어 있었기 때문에 사용자들은 서버에서 제공하는 데이터를
      받아서 읽는 것이 사용자가 할 수 있는 행동의 전부.
    - 그런데 이제 웹이 점점 더 진화하고 복잡해지면서 사용자는 읽는 행동 뿐만 아니라 쓰고, 고치고, 지우는 행동까지 할 수 있게 됨.
      이렇게 읽고, 쓰고, 고치고, 지우는 행동 하나하나는 전부 서버와 클라이언트 사이의 통신으로 이루어진다.
      서버-클라이언트 구조는 클라이언트가 서버에게 데이터를 요청하고 서버는 요청받은 데이터를 서버에서 찾는다. 그리고 클라이언트에게
      넘겨주면 서버와 클라이언트 구조가 끝난다.
    - 이렇게 서버와 클라이언트의 통신이 늘어나게 되면서 일관된 통신 방식이 필요성 제기됨.
      그 중에 하나로 등장한 것이 SOAP. SOAP 라는 하나의 방식으로 통신할 수 있음.
      어렵고, 복잡하고, 느리기 때문에 현재는 사용되고 있지 않음. 현재는 REST 가 사용됨.

    - REST (Representational State Transfer)
        - 서버와 클라이언트 간 통신 방식 중 하나
        - 자원을 이름으로 구분하여 자원의 상태를 주고 받는다.

    - 자원의 표현
        - URI
            - REST 에서는 자원을 표현할 때 URI 라는 방식으로 표현한다.
              URI 는 REST 에서 자원을 구분하고 처리하기 위해 사용되며 URI 를 잘 네이밍 할수록 API 가 직관적이고 사용하기 쉽다.

        - Singleton and Collection Resources
            - URI 는 Singleton 이나 Collection 으로 표현한다.

        - Collection and Sub-collection Resources
            - URI 는서브 컬렉션을 포함할 수 있다.

        - URI 네이밍 규칙을 지키면 개발자들의 공용어처럼 사용 가능
            - 명사를 사용해서 자원을 표현
            - 예외적으로 동사 허용하는 경우 (controller)
                 ex) /game/play 에 접근 시 게임이 시작되는 경우
            - 자원 간 계층 관게를 표현하기 위해 /(슬래시)를 사용
                ex) /crews/frontend
                    /product/5
            - URI 경로 마지막에는 /(슬래시)를 붙이지 않는다.
            - 하이픈(-) 기호를 사용하여 URI 의 가독성을 향상할 수 있다.
                ex) /profilemanagement (X)
                    /profileManagement (X)
                    /profile-management (O)
            - URI 에는 가급적 밑줄을 사용하지 않는다.
                - 일부 브라우저나 화면에서 글꼴에 따라 (_) 문자가 가려지거나 숨겨질 수 있다.
            - URI 에는 소문자만 사용
            - URI 에 파일 확장자를 표시하지 않는다.
            - URI 에 CRUD 함수의 이름을 사용하지 않는다. -> HTTP 메서드를 통해 표현
            - 자원의 필터링을 위해 새로운 API 를 만들지 않는다.
                - Query string 을 이용
                - Query string: 주소?속성=값&속성=값&...
                - Query string 은 특정 주소로 접근할 때 페이지에 대한 옵션으로 활용
            - 프론트엔드 크루 이름, 오름차순으로 보고 싶다면?
                ex) /crews?type=frontend&sort=name,asc

    - 자원의 상태를 주고 받는다.
        - 자원의 상태를 주고 받는 방식은 클라이언트와 서버 간의 통신으로 이루어진다.
        - 클라이언트가 HTTP 메서드를 보내면 서버는 HTTP 상태 코드를 통해서 정상적으로 처리되었는지 실패했는지 여부를 알려주는 방식으로 소통

        - HTTP 메서드
            - 자원의 상태를 주고받기 위해 사용하는 메서드
            - GET, POST, PUT, PATCH, DELETE
            - 같은 URI 사용 + 다른 동작
            - CRUD 메서드의 이름을 URI 에 표현하지 않을 수 있음

            - GET: 자원을 검색할 때 사용
            - POST: 자원을 생성할 때 사용
            - PUT: 자원을 업데이트할 때 사용 (보내지 않은 정보는 null 값으로 업데이트)
            - PATCH: 자원을 업데이트할 때 사용 (보내지 않은 데이터는 기존 데이터를 유지)
            - DELETE: 자원을 삭제할 때 사용

        - HTTP 상태코드
            - 1xx: 조건부 응답
            - 2xx: 성공
            - 3xx: 리다이렉션
            - 4xx: 클라이언트 오류
            - 5xx: 서버 오류

            HATEOAS ? self-descriptive ?

    => RESTful 이 이론적인 내용을 100% 충족하지 못한다고 하더라도 개발자들 사이의 의사소통 수단으로 잘 활용된다면
       이것을 RESTful 이라고 불러도 되지 않을까?

- IoC/DI
    - spring -> IoC/DI, AOP, PSA

    - IoC/DI
        - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
        - 유연하고 확장성이 뛰어난 코드를 만들 수 있게 해주는 프로그래밍 모델
            - 유연하고 확장성이 뛰어나다. -> 관심사의 분리가 잘 이루어졌다. (전략 패턴)

        - 제어의 두 가지 관점
            1. 어떤 연관관계를 맺으며 생성될 것인가?
                - 팩토리 -> 빈 컨테이너
            2. 어떻게 사용될 것인가?
                - 클라이언트 -> 스프링 내부 코드
            -> 우리는 컨트롤러, 서비스 그리고 각종 빈들에 대한 구현체들을 구현하고 있지만, 이것들이 어떻게 생성되고
               어떻게 연관관계를 맺는지에 관한 것은 전부 Configuration 파일, 빈 컨테이너가 담당
            -> AOP, PSA 도 다 이걸로 이루어지는 것

        => 관심사의 분리를 통해 유연하고 확장성이 쉬운 코드를 만들다 보니 자연스럽게 만들어진 프로그래밍 모델

        - IoC 란 제어의 역전
            - 제어 -> 객체 생명주기나 메서드의 호출을 직접 제어
            - 역전 -> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것

            - 객체지향 원칙을 잘 지키기 위해 쓰는 것
            - 역할과 관심을 분리해 응집도를 높이고 결합도르 낮추며, 이에 따라 변경에 유연한 코드를 작성할 수 있는 구조가 될 수 있기 때문

            - DIP: 의존 역전 원칙
              상위 레벨의 모듈은 절대 하위 레벨의 모듈에 의존하지 않는다. 둘 다 추상화에 의존해야 한다.

            - IoC 와 DIP 의 목적은 클래스 간 결합을 느슨히 하기 위함
              한 클래스의 변경에 따른 다른 클래스들의 영향을 최소화
              -> 어플리케이션을 지속가능하고 확장성 있게 만든다.
            - Ioc 는 제어의 역전, DIP 는 의존 방향의 역전

            - IoC 방법: Service Locator, Factory, Abstract, Template Method, Strategy, Dependency Injection

        - DI
            - 의존 -> 한 클래스가 바뀔 때 다른 클래스가 영향을 받는 것

            - 의존성 주입
                - DI 패턴
                    - 필드 주입
                        - 테스트 등의 이유로 자동이 아닌 수동으로 의존성 주입을 하고 싶어도 생성자도 setter 도 없으므로
                          직접 의존성을 넣어 줄 수가 없다. -> 의존성이 프레임워크에 강하게 종속됨
                    - 생성자 주입
                        - 필요한 의존성을 모두 포함하는 생성자를 만들고 그 생성자를 통해서 의존성을 주입
                        - 필드를 final 로 만들어 줄 수 있고 의존성 주입이 생성자 호출 시 최초 1회만 이루어지기 떄문에
                          의존관계를 불변으로 만들어 줄 수 있다.
                        - 필드 주입이나 setter 주입의 경우 스프링의 빈 관리 기능을 빌리지 않고 new 키워드로 객체를 생성해 줄 경우
                          NullPointerException 이 발생할 수 있다. 하지만 생성자 주입은 x
                        - @Autowired 가 여러 개 있을 경우 가장 많은 의존성을 주입할 수 있는 생성자를 사용
                          @Autowired 가 붙은 모든 생성자가 사용 불가능한 경우 또는 어떤 생성자에도 @Autowired 가 없을 경우
                          기본 생성자 호출. 기본 생성자 조차 없는 경우 컴파일 에러
                    - Setter 주입
                        - 의존성을 입력받는 setter 메서드를 만들고 메서드들을 호출해서 의존성을 주입
                        - 주로 런타임에 의존성을 수정해줘야 하거나 의존성을 선택적으로 주입할 때 사용
                    - Interface 주입
                        - 의존성을 주입하는 메서드를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써
                          실행 시에 이를 통하여 의존성 주입. setter 주입처럼 메서드를 외부에서 호출해줘야 하는 것은 비슷하지만
                          의존성 주입 메서드를 빠뜨릴 수 있는 setter 와 다르게 오버라이드를 통해 메서드 구현을 강제할 수 있다는 차이가 있다.
                        - 객체의 최초 생성 시점에 스프링이 의존성 주입

                    - 의존성 주입 순서: 생성자 -> 필드 -> setter
                    - 의존선 주입 기준: 타입 -> @Qualifier -> @Primary -> 이름
            - 의존성 분리
                - DIP 를 이용해 의존 관계를 분리
                - 상위계층이 하위계층에 의존하는 상황을 Interface 를 이용해 반전시켜 하위계층의 구현으로부터 독립시킨다.

        - DIP 도 원칙
        - Ioc 는 원칙 중 하나고 DI 는 IoC 를 달성하는 디자인 패턴 중 하나
        - 이 DI 를 자동으로 해줌으로써 프로그램의 제어권을 가져가는 역할을 해주는 것이 스프링

- git branch 전략
    - branch 전략이란?
        - 여러 명의 개발자가 1개의 저장소를 사용하는 환경에서 효과적으로 사용하기 위해 나온 개념
        - 대표적인 전략
            - GitHub flow
            - git flow
            - gitLab flow

    - GitHub flow 란?
        - GitHub 에서 만든 단순한 구조의 브랜치 전략
        - Master 브랜치를 중심으로 운영되며 기능 개발, 버그 수정 등의 작업용 브랜치를 구분하지 않는 단순한 구조
        - 수시로 배포가 일어나는 프로젝트에 유용

        1. 브랜치 생성
            - Master 로부터 기능 추가, 버그 수정 작업을 위한 새로운 브랜치를 생성
        2. 기능 개발, 버그 수정
            - 작업을 하며, 기능별로 commit 을 한다.
            - commit 메시지와 브랜치 이름은 정확하고 간결하게 작성
            - commit 은 서버의 동일한 브랜치에 push 해줘야 한다. (Git flow 와 차이점)
        3. Pull Request 생성
        4. 리뷰와 논의
        5. 공개 및 테스트
            - GitHub 에서는 master 에 합치기 전에 브랜치에서 코드를 공개 및 테스트 할 수 있다.
            - 오류가 발생할 경우 원래의 master 브랜치를 다시 배포하여 rollback 한다.
        6. Merge
            - 브랜치의 검증이 완료되면 master 브랜치에 합친다.
            - 이로써 GitHub flow 의 브랜치의 생명주기가 끝난다.

    - Git flow 란
        - 많은 기업에서 표준으로 사용하고 있는 대표적인 Git branch 전략
        - GitHub flow 와는 다르게 크게 5개의 브랜치를 운영하며 관리한다.
            - 메인 브랜치: master, develop
            - 보조 브랜치: feature, release, hotfix
        - 배포 주기가 길고 팀의 여력이 있는 경우 적합

        - 메인 브랜치의 특징
            - master, develop 두 개의 브랜치는 항상 남아있는다.
            - master 브랜치는 제품으로 배포할 수 있는 브랜치
            - develop 브랜치는 개발자들이 개발을 하는 브랜치

        - 보조 브랜치의 특징
            - 사용을 마치면 브랜치를 삭제한다.
            - feature: 기능 구현
              release: QA 진행
              hotfix: 버그의 빠른 수정

            - Feature 브랜치
                - 다음 버전을 위한 특정 기능 개발을 할 때는 develop 브랜치에서 직접 개발을 하는 것이 아닌
                  develop 으로부터 feature 브랜치를 생성하여 개발을 진행.
                  feature 브랜치에서 개발을 완료한 후에는 develop 으로 merge 한 후 브랜치를 삭제

                - 만약 feature 브랜치에서 개발한 후 merge 를 진행할 때 develop 과 conflict 되는 내용이 있으면
                  develop 으로부터 변경 내용을 불러와 수정을 한 후 merge 를 진행

                - 브랜치들 간의 merge 를 할 때는 --no-ff 옵션을 사용하여 다른 브랜치에서 merge 를 했다는 이력을 남겨주는 것을 권장
                  fast-forward 관계에 있어도 merge commit 을 생성하여 해당 브랜치가 존재하였다는 정보를 남길 수 있다.
                  코드 내에 오류가 발생했을 때, 개발한 기능을 제거하려고 할 때 commit 을 되돌리기 편해진다.
                  --no-ff 을 사용하지 않으면 브랜치의 존재 여부를 몰라 어떤 commit 부터 해당 기능을 구현했는지 확인하기 어렵다.
                  또한, 브랜치가 fast-forward 관계에 있을 때 develop 입장에서는 feature 의 commit 기록들을 동일하게 가져와도 문제가
                  없다고 판단하여 브랜치의 참조 값만 변경하여 merge commit 을 생성하지 않는다.
                  만약 이런 방식으로 commit 기록들이 나오면 어떤 특정 feature 와 관련된 commit 이 어디서부터 해당하는지 확인이 힘들다.

            - Release 브랜치
                - 프로덕션에 다음 버전 출시를 준비하기 위한 브랜치
                - develop 브랜치에서 개발이 완료된 코드를 master 로 merge 하기 이전에 QA 테스트 진행
                - QA 를 진행하기 위해 develop 으로부터 release 브랜치를 생성하여 해당 브랜치에서 QA 진행
                - 만약 오류가 발견된면 해당 브랜치 내에서 수정을 하고 QA 가 끝나고 배포할 준비가 완료되었다고 판단되면
                  release 브랜치를 master 브랜치와 develop 브랜치에 merge 하고 release 브랜치를 삭제
                - 이 때 develop 브랜치에 merge 할 때 그 사이에 develop 내에 추가적인 개발 상황이 있어 충돌이 발생할 수도 있다.
                - 이러한 경우 해당 내용을 수정하고 다시 merge 하는 방식으로 진행
                - merge 할 때 --no-ff 를 사용하여 기록을 그룹화
                - master 로 merge 후에는 tag 명령을 통해 버전을 명시

            - Hotfix 브랜치
                - production 에 버그가 발생하면 빠른 수정을 위해 생성하는 브랜치
                - master 에 올라가 실제 필드에 나가 있는 코드에서 오류가 발생한다면 긴급하게 hotfix 브랜치를 생성하여 오류를 수정한 후
                  변경사항을 master 에 merge 하여 오류를 수정
                - 이 때 발생한 오류들은 develop 과 release 로부터 거르지 못한 오류이기 때문에 현재 브랜치의 코드에도 반영을 해줘야 한다.
                - production 코드를 수정하는 중에도 develop 에서는 계속 개발을 할 수 있다는 장점
                - master 로 merge 후에는 tag 명령을 통해 이전 버전보다 높은 버전 명시

        - 무슨 전략을 사용해야 할까?
            - 팀의 브랜칭 전략은 조직의 규모, 서비스의 특징 등을 고려하여 협의를 통해 전략을 결정해야 한다.
            - production 의 공식 배포 주기가 길고 QA, 테스트, hotfix 등의 여력이 있으면 Git flow 가 적합
            - 지속적으로 테스트 및 배포를 하는 팀의 경우 간단한 GitHub flow 를 사용하는 것이 적합

- 캐시
    - 캐시란?
        - 프로세서의 성능이 매년 60%씩 증가하는 반면 메모리 지연 시간 향상은 9%밖에 일어나지 않고 있다.
          각 성능 간의 격차가 매년 50%씩 증가하고 있는 셈. 이렇게 되면 아무리 프로세서 성능이 좋아져도 메모리 처리 속도가 느리기 때문에
          전체적인 프로그램 속도가 느리게 된다. -> 따라서 캐시가 등장

        - 데이터를 재사용하거나 원본 데이터를 접근하는데 오래걸린다면 데이터 값을 미리 복사해 더 빠른 속도로 접근 가능

    - 캐싱의 종류
        - CPU 캐시 메모리
            ex) 쿼드 코어 칩의 경우 각 코어마다 L2 캐시가 있고 각 코어들이 공유하는 Shared L3 캐시가 있다.
        - 웹 캐시
            - 브라우저 캐시
                - 요청과 응답을 하는 과정 이후에 클라이언트 내부 디스크의 정적 파일들을 저장해 놓는 것. 이를 통해 다음부터는 서버까지
                  요청할 필요 없이 내부 캐시로부터 불러올 수 있다.
            - 프록시 캐시
            - 게이트웨이 캐시

    - Java 코드로 캐싱
        - 캐싱: 캐시라는 작업을 하는 행위. 자주 사용하는 데이터를 저장해서 재활용하는 기술
          ex) Integer 클래스는 내부적으로 IntegerCache 라는 클래스를 가지고 있다. cache 라는 배열에 미리 low 부터 high 까지의
              Integer 인스턴스를 생성해둔 뒤 저장. 이후에 Integer 객체를 만들 때는 캐시로부터 가져오거나 범주 내에 없다면
              새로운 인스턴스를 생성

    - Spring 에서의 캐싱
        - 스프링에서 빈의 메서드에 캐시를 적용할 수 있는 기능을 제공
        - AOP 를 이용해 메서드 내부 구현에 영향을 미치지 않고 적용
        - 특정 캐시 기술에 종속 x
        - 캐싱이 필요한 비즈니스 로직에 EhCache, Redis 등 캐싱 종류에 의존할 필요 x

        - 캐시 매니저 (Cache Manager)
            - 캐시 추상화에서는 캐시 기술을 지원하는 캐시 매니저를 빈으로 등록해야 한다.
            - 캐시 매니저 구현체
                - ConcurrentMapCacheManager
                    - 캐시 정보 Map 타입
                    - 빠르고 별다른 설정이 필요없음
                - SimpleCacheManager
                    - 기본적으로 제공하는 캐시 x
                    - 사용할 캐시를 직접 등록하여 사용하기 위한 캐시 매니저
                - EhCacheCacheManager
                    - EhCache 를 지원하는 캐시 매니저

        - start-cache 의존성 추가 필요
            - @EnableCaching, @Cacheable ...

    - 주의할 점
        - 모든 상황에서 캐싱을 하는 것은 좋지 않다.
        - 캐시는 값을 저장하고 불러오기 때문에 반복적으로 동일한 결과를 반환하는 경우에 용이
        - 매번 다른 결과를 돌려줘야 하는 상황이라면 오히려 성능 저하를 야기
        -  캐시 저장 및 확인 작업에서 부하가 생김
        - 작업의 시간이 오래 걸리거나 서버에 부담을 주는 경우에 사용을 고려