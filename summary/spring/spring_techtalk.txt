- RESTful
    - REST 의 제약을 준수했다는 의미를 가진다.
    - REST: 웹에서 사용하는 아키텍처 중 하나
    - URI 를 통해 자원을 지정하고, HTTP 메서드를 통해 자원에 대한 행위를 표현
    - REST API 란 REST 아키텍쳐 스타일에 부합하는 API

    - 초기의 웹은 정적인 페이지의 나열로 구성되어 있었기 때문에 사용자들은 서버에서 제공하는 데이터를
      받아서 읽는 것이 사용자가 할 수 있는 행동의 전부.
    - 그런데 이제 웹이 점점 더 진화하고 복잡해지면서 사용자는 읽는 행동 뿐만 아니라 쓰고, 고치고, 지우는 행동까지 할 수 있게 됨.
      이렇게 읽고, 쓰고, 고치고, 지우는 행동 하나하나는 전부 서버와 클라이언트 사이의 통신으로 이루어진다.
      서버-클라이언트 구조는 클라이언트가 서버에게 데이터를 요청하고 서버는 요청받은 데이터를 서버에서 찾는다. 그리고 클라이언트에게
      넘겨주면 서버와 클라이언트 구조가 끝난다.
    - 이렇게 서버와 클라이언트의 통신이 늘어나게 되면서 일관된 통신 방식이 필요성 제기됨.
      그 중에 하나로 등장한 것이 SOAP. SOAP 라는 하나의 방식으로 통신할 수 있음.
      어렵고, 복잡하고, 느리기 때문에 현재는 사용되고 있지 않음. 현재는 REST 가 사용됨.

    - REST (Representational State Transfer)
        - 서버와 클라이언트 간 통신 방식 중 하나
        - 자원을 이름으로 구분하여 자원의 상태를 주고 받는다.

    - 자원의 표현
        - URI
            - REST 에서는 자원을 표현할 때 URI 라는 방식으로 표현한다.
              URI 는 REST 에서 자원을 구분하고 처리하기 위해 사용되며 URI 를 잘 네이밍 할수록 API 가 직관적이고 사용하기 쉽다.

        - Singleton and Collection Resources
            - URI 는 Singleton 이나 Collection 으로 표현한다.

        - Collection and Sub-collection Resources
            - URI 는서브 컬렉션을 포함할 수 있다.

        - URI 네이밍 규칙을 지키면 개발자들의 공용어처럼 사용 가능
            - 명사를 사용해서 자원을 표현
            - 예외적으로 동사 허용하는 경우 (controller)
                 ex) /game/play 에 접근 시 게임이 시작되는 경우
            - 자원 간 계층 관게를 표현하기 위해 /(슬래시)를 사용
                ex) /crews/frontend
                    /product/5
            - URI 경로 마지막에는 /(슬래시)를 붙이지 않는다.
            - 하이픈(-) 기호를 사용하여 URI 의 가독성을 향상할 수 있다.
                ex) /profilemanagement (X)
                    /profileManagement (X)
                    /profile-management (O)
            - URI 에는 가급적 밑줄을 사용하지 않는다.
                - 일부 브라우저나 화면에서 글꼴에 따라 (_) 문자가 가려지거나 숨겨질 수 있다.
            - URI 에는 소문자만 사용
            - URI 에 파일 확장자를 표시하지 않는다.
            - URI 에 CRUD 함수의 이름을 사용하지 않는다. -> HTTP 메서드를 통해 표현
            - 자원의 필터링을 위해 새로운 API 를 만들지 않는다.
                - Query string 을 이용
                - Query string: 주소?속성=값&속성=값&...
                - Query string 은 특정 주소로 접근할 때 페이지에 대한 옵션으로 활용
            - 프론트엔드 크루 이름, 오름차순으로 보고 싶다면?
                ex) /crews?type=frontend&sort=name,asc

    - 자원의 상태를 주고 받는다.
        - 자원의 상태를 주고 받는 방식은 클라이언트와 서버 간의 통신으로 이루어진다.
        - 클라이언트가 HTTP 메서드를 보내면 서버는 HTTP 상태 코드를 통해서 정상적으로 처리되었는지 실패했는지 여부를 알려주는 방식으로 소통

        - HTTP 메서드
            - 자원의 상태를 주고받기 위해 사용하는 메서드
            - GET, POST, PUT, PATCH, DELETE
            - 같은 URI 사용 + 다른 동작
            - CRUD 메서드의 이름을 URI 에 표현하지 않을 수 있음

            - GET: 자원을 검색할 때 사용
            - POST: 자원을 생성할 때 사용
            - PUT: 자원을 업데이트할 때 사용 (보내지 않은 정보는 null 값으로 업데이트)
            - PATCH: 자원을 업데이트할 때 사용 (보내지 않은 데이터는 기존 데이터를 유지)
            - DELETE: 자원을 삭제할 때 사용

        - HTTP 상태코드
            - 1xx: 조건부 응답
            - 2xx: 성공
            - 3xx: 리다이렉션
            - 4xx: 클라이언트 오류
            - 5xx: 서버 오류

            HATEOAS ? self-descriptive ?

    => RESTful 이 이론적인 내용을 100% 충족하지 못한다고 하더라도 개발자들 사이의 의사소통 수단으로 잘 활용된다면
       이것을 RESTful 이라고 불러도 되지 않을까?

- IoC/DI
    - spring -> IoC/DI, AOP, PSA

    - IoC/DI
        - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
        - 유연하고 확장성이 뛰어난 코드를 만들 수 있게 해주는 프로그래밍 모델
            - 유연하고 확장성이 뛰어나다. -> 관심사의 분리가 잘 이루어졌다. (전략 패턴)

        - 제어의 두 가지 관점
            1. 어떤 연관관계를 맺으며 생성될 것인가?
                - 팩토리 -> 빈 컨테이너
            2. 어떻게 사용될 것인가?
                - 클라이언트 -> 스프링 내부 코드
            -> 우리는 컨트롤러, 서비스 그리고 각종 빈들에 대한 구현체들을 구현하고 있지만, 이것들이 어떻게 생성되고
               어떻게 연관관계를 맺는지에 관한 것은 전부 Configuration 파일, 빈 컨테이너가 담당
            -> AOP, PSA 도 다 이걸로 이루어지는 것

        => 관심사의 분리를 통해 유연하고 확장성이 쉬운 코드를 만들다 보니 자연스럽게 만들어진 프로그래밍 모델

        - IoC 란 제어의 역전
            - 제어 -> 객체 생명주기나 메서드의 호출을 직접 제어
            - 역전 -> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것

            - 객체지향 원칙을 잘 지키기 위해 쓰는 것
            - 역할과 관심을 분리해 응집도를 높이고 결합도르 낮추며, 이에 따라 변경에 유연한 코드를 작성할 수 있는 구조가 될 수 있기 때문

            - DIP: 의존 역전 원칙
              상위 레벨의 모듈은 절대 하위 레벨의 모듈에 의존하지 않는다. 둘 다 추상화에 의존해야 한다.

            - IoC 와 DIP 의 목적은 클래스 간 결합을 느슨히 하기 위함
              한 클래스의 변경에 따른 다른 클래스들의 영향을 최소화
              -> 어플리케이션을 지속가능하고 확장성 있게 만든다.
            - Ioc 는 제어의 역전, DIP 는 의존 방향의 역전

            - IoC 방법: Service Locator, Factory, Abstract, Template Method, Strategy, Dependency Injection

        - DI
            - 의존 -> 한 클래스가 바뀔 때 다른 클래스가 영향을 받는 것

            - 의존성 주입
                - DI 패턴
                    - 필드 주입
                        - 테스트 등의 이유로 자동이 아닌 수동으로 의존성 주입을 하고 싶어도 생성자도 setter 도 없으므로
                          직접 의존성을 넣어 줄 수가 없다. -> 의존성이 프레임워크에 강하게 종속됨
                    - 생성자 주입
                        - 필요한 의존성을 모두 포함하는 생성자를 만들고 그 생성자를 통해서 의존성을 주입
                        - 필드를 final 로 만들어 줄 수 있고 의존성 주입이 생성자 호출 시 최초 1회만 이루어지기 떄문에
                          의존관계를 불변으로 만들어 줄 수 있다.
                        - 필드 주입이나 setter 주입의 경우 스프링의 빈 관리 기능을 빌리지 않고 new 키워드로 객체를 생성해 줄 경우
                          NullPointerException 이 발생할 수 있다. 하지만 생성자 주입은 x
                        - @Autowired 가 여러 개 있을 경우 가장 많은 의존성을 주입할 수 있는 생성자를 사용
                          @Autowired 가 붙은 모든 생성자가 사용 불가능한 경우 또는 어떤 생성자에도 @Autowired 가 없을 경우
                          기본 생성자 호출. 기본 생성자 조차 없는 경우 컴파일 에러
                    - Setter 주입
                        - 의존성을 입력받는 setter 메서드를 만들고 메서드들을 호출해서 의존성을 주입
                        - 주로 런타임에 의존성을 수정해줘야 하거나 의존성을 선택적으로 주입할 때 사용
                    - Interface 주입
                        - 의존성을 주입하는 메서드를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써
                          실행 시에 이를 통하여 의존성 주입. setter 주입처럼 메서드를 외부에서 호출해줘야 하는 것은 비슷하지만
                          의존성 주입 메서드를 빠뜨릴 수 있는 setter 와 다르게 오버라이드를 통해 메서드 구현을 강제할 수 있다는 차이가 있다.
                        - 객체의 최초 생성 시점에 스프링이 의존성 주입

                    - 의존성 주입 순서: 생성자 -> 필드 -> setter
                    - 의존선 주입 기준: 타입 -> @Qualifier -> @Primary -> 이름
            - 의존성 분리
                - DIP 를 이용해 의존 관계를 분리
                - 상위계층이 하위계층에 의존하는 상황을 Interface 를 이용해 반전시켜 하위계층의 구현으로부터 독립시킨다.

        - DIP 도 원칙
        - Ioc 는 원칙 중 하나고 DI 는 IoC 를 달성하는 디자인 패턴 중 하나
        - 이 DI 를 자동으로 해줌으로써 프로그램의 제어권을 가져가는 역할을 해주는 것이 스프링

- AOP
    - AOP 가 무엇일까
        - Aspect Oriented Programming
        - 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 반복 작업을 줄이고 핵심 비즈니스 로직 개발에만 집중할 수 있음

        - 사용 목적에 따라
            - 프록시 패턴: 클라이언트가 타깃에 접근하는 방법 제어
            - 데코레이터 패턴: 타깃에 부가적인 기능 부여

    - AOP 의 용어들
        - Target Object: 부가 기능을 부여할 대상
        - Aspect: 부가 기능을 정의한 Advice 와 어드바이스를 어디에 적용할 지 결정하는 Pointcut 을 함께 가짐.
        - Advice: 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.
        - JoinPoint: 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
        - Pointcut: 어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

    - AOP 구현 방법
        - 컴파일 시점에 코드에 공통 기능 삽입
        - 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
            - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
              좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            (런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.)

    - Spring 에서 AOP 를 구현한 방법
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
            - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
            - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
            - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용

- git branch 전략
    - branch 전략이란?
        - 여러 명의 개발자가 1개의 저장소를 사용하는 환경에서 효과적으로 사용하기 위해 나온 개념
        - 대표적인 전략
            - GitHub flow
            - git flow
            - gitLab flow

    - GitHub flow 란?
        - GitHub 에서 만든 단순한 구조의 브랜치 전략
        - Master 브랜치를 중심으로 운영되며 기능 개발, 버그 수정 등의 작업용 브랜치를 구분하지 않는 단순한 구조
        - 수시로 배포가 일어나는 프로젝트에 유용

        1. 브랜치 생성
            - Master 로부터 기능 추가, 버그 수정 작업을 위한 새로운 브랜치를 생성
        2. 기능 개발, 버그 수정
            - 작업을 하며, 기능별로 commit 을 한다.
            - commit 메시지와 브랜치 이름은 정확하고 간결하게 작성
            - commit 은 서버의 동일한 브랜치에 push 해줘야 한다. (Git flow 와 차이점)
        3. Pull Request 생성
        4. 리뷰와 논의
        5. 공개 및 테스트
            - GitHub 에서는 master 에 합치기 전에 브랜치에서 코드를 공개 및 테스트 할 수 있다.
            - 오류가 발생할 경우 원래의 master 브랜치를 다시 배포하여 rollback 한다.
        6. Merge
            - 브랜치의 검증이 완료되면 master 브랜치에 합친다.
            - 이로써 GitHub flow 의 브랜치의 생명주기가 끝난다.

    - Git flow 란
        - 많은 기업에서 표준으로 사용하고 있는 대표적인 Git branch 전략
        - GitHub flow 와는 다르게 크게 5개의 브랜치를 운영하며 관리한다.
            - 메인 브랜치: master, develop
            - 보조 브랜치: feature, release, hotfix
        - 배포 주기가 길고 팀의 여력이 있는 경우 적합

        - 메인 브랜치의 특징
            - master, develop 두 개의 브랜치는 항상 남아있는다.
            - master 브랜치는 제품으로 배포할 수 있는 브랜치
            - develop 브랜치는 개발자들이 개발을 하는 브랜치

        - 보조 브랜치의 특징
            - 사용을 마치면 브랜치를 삭제한다.
            - feature: 기능 구현
              release: QA 진행
              hotfix: 버그의 빠른 수정

            - Feature 브랜치
                - 다음 버전을 위한 특정 기능 개발을 할 때는 develop 브랜치에서 직접 개발을 하는 것이 아닌
                  develop 으로부터 feature 브랜치를 생성하여 개발을 진행.
                  feature 브랜치에서 개발을 완료한 후에는 develop 으로 merge 한 후 브랜치를 삭제

                - 만약 feature 브랜치에서 개발한 후 merge 를 진행할 때 develop 과 conflict 되는 내용이 있으면
                  develop 으로부터 변경 내용을 불러와 수정을 한 후 merge 를 진행

                - 브랜치들 간의 merge 를 할 때는 --no-ff 옵션을 사용하여 다른 브랜치에서 merge 를 했다는 이력을 남겨주는 것을 권장
                  fast-forward 관계에 있어도 merge commit 을 생성하여 해당 브랜치가 존재하였다는 정보를 남길 수 있다.
                  코드 내에 오류가 발생했을 때, 개발한 기능을 제거하려고 할 때 commit 을 되돌리기 편해진다.
                  --no-ff 을 사용하지 않으면 브랜치의 존재 여부를 몰라 어떤 commit 부터 해당 기능을 구현했는지 확인하기 어렵다.
                  또한, 브랜치가 fast-forward 관계에 있을 때 develop 입장에서는 feature 의 commit 기록들을 동일하게 가져와도 문제가
                  없다고 판단하여 브랜치의 참조 값만 변경하여 merge commit 을 생성하지 않는다.
                  만약 이런 방식으로 commit 기록들이 나오면 어떤 특정 feature 와 관련된 commit 이 어디서부터 해당하는지 확인이 힘들다.

            - Release 브랜치
                - 프로덕션에 다음 버전 출시를 준비하기 위한 브랜치
                - develop 브랜치에서 개발이 완료된 코드를 master 로 merge 하기 이전에 QA 테스트 진행
                - QA 를 진행하기 위해 develop 으로부터 release 브랜치를 생성하여 해당 브랜치에서 QA 진행
                - 만약 오류가 발견된면 해당 브랜치 내에서 수정을 하고 QA 가 끝나고 배포할 준비가 완료되었다고 판단되면
                  release 브랜치를 master 브랜치와 develop 브랜치에 merge 하고 release 브랜치를 삭제
                - 이 때 develop 브랜치에 merge 할 때 그 사이에 develop 내에 추가적인 개발 상황이 있어 충돌이 발생할 수도 있다.
                - 이러한 경우 해당 내용을 수정하고 다시 merge 하는 방식으로 진행
                - merge 할 때 --no-ff 를 사용하여 기록을 그룹화
                - master 로 merge 후에는 tag 명령을 통해 버전을 명시

            - Hotfix 브랜치
                - production 에 버그가 발생하면 빠른 수정을 위해 생성하는 브랜치
                - master 에 올라가 실제 필드에 나가 있는 코드에서 오류가 발생한다면 긴급하게 hotfix 브랜치를 생성하여 오류를 수정한 후
                  변경사항을 master 에 merge 하여 오류를 수정
                - 이 때 발생한 오류들은 develop 과 release 로부터 거르지 못한 오류이기 때문에 현재 브랜치의 코드에도 반영을 해줘야 한다.
                - production 코드를 수정하는 중에도 develop 에서는 계속 개발을 할 수 있다는 장점
                - master 로 merge 후에는 tag 명령을 통해 이전 버전보다 높은 버전 명시

        - 무슨 전략을 사용해야 할까?
            - 팀의 브랜칭 전략은 조직의 규모, 서비스의 특징 등을 고려하여 협의를 통해 전략을 결정해야 한다.
            - production 의 공식 배포 주기가 길고 QA, 테스트, hotfix 등의 여력이 있으면 Git flow 가 적합
            - 지속적으로 테스트 및 배포를 하는 팀의 경우 간단한 GitHub flow 를 사용하는 것이 적합

- 캐시
    - 캐시란?
        - 프로세서의 성능이 매년 60%씩 증가하는 반면 메모리 지연 시간 향상은 9%밖에 일어나지 않고 있다.
          각 성능 간의 격차가 매년 50%씩 증가하고 있는 셈. 이렇게 되면 아무리 프로세서 성능이 좋아져도 메모리 처리 속도가 느리기 때문에
          전체적인 프로그램 속도가 느리게 된다. -> 따라서 캐시가 등장

        - 데이터를 재사용하거나 원본 데이터를 접근하는데 오래걸린다면 데이터 값을 미리 복사해 더 빠른 속도로 접근 가능

    - 캐싱의 종류
        - CPU 캐시 메모리
            ex) 쿼드 코어 칩의 경우 각 코어마다 L2 캐시가 있고 각 코어들이 공유하는 Shared L3 캐시가 있다.
        - 웹 캐시
            - 브라우저 캐시
                - 요청과 응답을 하는 과정 이후에 클라이언트 내부 디스크의 정적 파일들을 저장해 놓는 것. 이를 통해 다음부터는 서버까지
                  요청할 필요 없이 내부 캐시로부터 불러올 수 있다.
            - 프록시 캐시
            - 게이트웨이 캐시

    - Java 코드로 캐싱
        - 캐싱: 캐시라는 작업을 하는 행위. 자주 사용하는 데이터를 저장해서 재활용하는 기술
          ex) Integer 클래스는 내부적으로 IntegerCache 라는 클래스를 가지고 있다. cache 라는 배열에 미리 low 부터 high 까지의
              Integer 인스턴스를 생성해둔 뒤 저장. 이후에 Integer 객체를 만들 때는 캐시로부터 가져오거나 범주 내에 없다면
              새로운 인스턴스를 생성

    - Spring 에서의 캐싱
        - 스프링에서 빈의 메서드에 캐시를 적용할 수 있는 기능을 제공
        - AOP 를 이용해 메서드 내부 구현에 영향을 미치지 않고 적용
        - 특정 캐시 기술에 종속 x
        - 캐싱이 필요한 비즈니스 로직에 EhCache, Redis 등 캐싱 종류에 의존할 필요 x

        - 캐시 매니저 (Cache Manager)
            - 캐시 추상화에서는 캐시 기술을 지원하는 캐시 매니저를 빈으로 등록해야 한다.
            - 캐시 매니저 구현체
                - ConcurrentMapCacheManager
                    - 캐시 정보 Map 타입
                    - 빠르고 별다른 설정이 필요없음
                - SimpleCacheManager
                    - 기본적으로 제공하는 캐시 x
                    - 사용할 캐시를 직접 등록하여 사용하기 위한 캐시 매니저
                - EhCacheCacheManager
                    - EhCache 를 지원하는 캐시 매니저

        - start-cache 의존성 추가 필요
            - @EnableCaching, @Cacheable ...

    - 주의할 점
        - 모든 상황에서 캐싱을 하는 것은 좋지 않다.
        - 캐시는 값을 저장하고 불러오기 때문에 반복적으로 동일한 결과를 반환하는 경우에 용이
        - 매번 다른 결과를 돌려줘야 하는 상황이라면 오히려 성능 저하를 야기
        -  캐시 저장 및 확인 작업에서 부하가 생김
        - 작업의 시간이 오래 걸리거나 서버에 부담을 주는 경우에 사용을 고려

- Spring vs Spring Boot
    - spring 생태계
        - spring 은 프로텍트 별로 하위 프로젝트(모듈)을 가지고 있다.
            - spring boot, spring framework, spring batch ...
              ex) spring framework > spring aop, spring core, spring web mvc ...
        - 스프링 프로젝트들은 스프링 프레임워크 기반에서 돌아간다.

    - spring framework 란?
        - 객체 지향의 특징을 잘 활용할 수 있게 해주며, 개발자들은 핵심 비즈니스 로직 구현에만 집중할 수 있게 해주는 프레임워크
        - 스프링의 기본 전략은 비즈니스 로직을 담은 코드와 엔터프라이즈 기술을 처리하는 코드를 분리하는 것
          이렇게 분리함으로써 개발자들은 객체지향 설계에 초점을 맞출 수 있게 되고 이를 돕기 위해 스프링은 DI 같은 기능을 제공
        - 초기 spring 기본 설정만 잘 해놓는다면, 스프링 관련 코드를 신경 쓸 일이 거의 없다.

    - spring boot 란?
        - 독립적이며, 운영할 수 있는 수준의 spring 기반 어플리케이션을 쉽게 만들 수 있게 해준다.
          최소한의 설정으로 spring 플랫폼과 서드파티 라이브러리 사용 가능. 대부분 spring boot 어플리케이션은 최소한의 spring 설정 필요

    - spring boot 를 사용하면 달라지는 점
        1. 의존성 관리 - spring-boot-starter, spring-boot-starter-parent
            - spring
                - 기존 spring 은 개발에 필요한 모듈의 의존성을 각각 다운받아 줘야했으며, 각 모듈의 버전을 개발자가 하나하나 명시해줘야함
                  모듈 간의 의존성이 존재하는 경우 버전 충돌이 일어날 수 있다.
            - spring boot
                - spring boot 는 spring-boot-starter 모듈을 통해 자주 사용하게 되는 모듈간의 의존성과 버전 조합을 제공해준다.
                - spring boot 는 spring-boot-starter-parent 를 통해 버전 관리(각 모듈의 현재 spring boot 버전에 가장 적합한 버전 제공)

        2. 자동 설정 - @EnableAutoConfiguration
            - spring
                - 기존 spring 은 많은 환경 설정이 필요하다.
            - spring boot
                - spring boot 는 라이브러리만 추가해주면 추가된 jar 파일을 인지해서 관련된 스프링 설정을 자동으로 처리해준다.
                - @SpringBootApplication
                    - @ComponentScan: @Component 가 붙은 클래스를 Bean 으로 등록시켜준다.
                    - @SpringBootConfiguration: spring boot 전용 애노테이션으로 spring boot 의 설정을 나타냄
                                                spring 의 @Configuration 이라고 볼 수 있다.
                                                스프링 제공 테스트(@SpringBootTest, @WebMvcTest 등) 시
                                                @SpringBootConfiguration 이 붙은 클래스가 없다면 실패한다.
                    - @EnableAutoConfiguration: 자동 설정 담당
                        1. Classpath 에 라이브러리 jar 파이이 등록되면 spring.factories 에 있는 관련 설정이 실행된다.
                        2. 자동 설정 후보 클래스의 @Conditional~ 조건에 따라 빈으로 등록된다.
                        3. spring-configuration-metadata 는 자동 설정에 사용할 프로퍼티 정의 파일로, application.yml 에 작성한
                           값으로 프로퍼티를 세팅한 후, 구현되어 있는 자동 설정에 값을 주입시켜준다.

        3. 내장 WAS - Embedded WAS (tomcat, jetty, undertow)
            - spring
                1. 어플리케이션 WAR 패키징
                2. WAS 설치
                3. WAS 에 빌드한 WAR 파일 올리기
            - spring boot
                - 배포할 때 spring boot 는 독립적으로 실행 가능한 어플리케이션을 빠르게 개발하는 것을 목표로 하기 때문에
                  웹 어플리케이션을 war 파일이 아닌 jar 파일로 패키징하여 바로 사용 가능. 외장 WAS 를 쓰고자하면 war 파일로
                  패키징 할 수도 있다. spring boot 를 사용하면 war 나 jar 둘 다 가능
                - 내장 서버가 작동하는 원리도 자동 설정으로 인해 작동
                  (tomcat 이 기본이지만 의존선을 통해서 jetty 나 undertow 로 변경 가능)

        4. 모니터링 - Actuator
            - spring boot 의 모듈 중 하나인 Actuator 는 어플리케이션의 관리 및 모니터링을 지원해준다.
            - Actuator 는 상용 서비스 수준에서 필요로 할 모니터링 기능을 엔드포인트로 미리 만들어서 제공
            - Actuator 를 사용하면 실행 중인 부트 어플리케이션 내에서 어떤 일이 일어나는 지 볼 수 있는데
              어떤 빈이 등록되어 있는지, 자동 설정이 어떻게 되어 있는지 환경 변수나 시스템 속성 같은 것을 알 수 있다.

            - 주의할 점
                - actuator 는 민감한 정보도 많이 제공해주기 때문에 운영 시에는 spring security 등을 이용하여 보안에 신경써야 한다.
                - actuator 의 데이터를 영구 저장소에 저장해주지 않으면 없어질 수 있다.
                  actuator 의 데이터는 메모리에 저장하기 때문에 tomcat 을 재시작하거나 하면 데이터가 모두 날아간다.

    - 정리
        - spring 은 spring framework 를 기반으로 서브 프로젝트들의 모음으로 이루어져있으며, 서브 프로젝트들은 여러 모듈을 가지고 있다.
          개발할 어플리케이션에 맞게 모듈들을 조합해서 사용한다.
        - spring boot 도 spring 프로젝트 중 하나로, spring framework 와 별개로 사용x, spring 을 편하게 사용하게 해주는 역할
        - spring boot 는 1) 의존성 관리, 2) 자동 설정, 3) 내장 WAS, 4) 모니터링 등의 장점이 있다.

- 웹소켓/spring
    - 웹소켓? 언제쓰지?
        - 웹소켓은 전이중 통신 채널을 제공해서 실시간성을 보장
          ex) 게임, 채팅, 실시간 주식 거래 사이트 등등

    - 웹소켓 vs HTTP
        - HTTP 에서도 실시간성을 보장하는 기법이 존재
          ex) Polling, Long Polling, Streaming
              서버쪽으로 클라이언트가 지속적으로 요청을 보내든지
              한 번 요청을 보내놓고 커넥션을 끊지 않은 상태에서 서버에서 메시지를 계속 받는 방식

        - HTTP
            - 비 연결성 (클라이언트가 요청을 보낼 때마다 연결을 맺고 응답을 받은 후에 연결을 끊는다.)
            - 매번 연결 맺고 끊는 과정의 비용
            - (요청 - 응답) 구조
            - 매 요청-응답 마다 HTTP 메시지를 주고 받음
        - 웹소켓
            - 연결 지향 (한번 연결을 맺고 나면 어는 한쪽에서 연결을 끊으라는 요청을 보내기 전까지 연결을 유지)
            - 한번 연결 맺은 뒤 유지
            - 양방향 통신
            - 처음 핸드쉐이크를 할 때는 HTTP 프로토콜을 사용하기 때문에 유사한 양의 정보를 주고 받지만,
              한 번 연결이 수립되고 나서는 간단한 메시지들만 주고 받음. -> 통신에 오가는 비용을 많이 줄일 수 있다.
            - 텍스트와 바이너리 타입의 메시지를 양방향으로 주고 받을 수 있는 프로토콜
        -> 수립된 커넷션을 어떻게 하느냐

        - 웹소켓을 지원하지 않는 환경에서는?
          ex) internet explorer, firefox, safari...
          -> 이 때 사용할 수 있는 것이 SockJS, socket.io
             브라우저별로 웹소켓 기술을 제공하고 있다면 웹소켓을 사용하고 없으면 streaming, 그것도 없으면 polling 방식을 사용해서 제공
          -> 웹소켓을 지원하지 않는 브라우저 환경에서도 비슷한 경험을 제공하기 위해서 사용하는 것이 SockJS 라이브러리

    - 웹소켓 in spring
        - @EnableWebSocket, WebSocketConfigurer 인터페이스

    - STOMP and spring-messaging
        - STOMP
            - Simple Text Oriented Messaging Protocol
            - 메시지 브로커를 활용하여 쉽게 메시지를 주고 받을 수 있는 프로토콜
                - pub - sub (발생-구독): 발신자가 메시지를 발행하면 수신자가 그것을 수신하는 메시징 패러다임
                - 메시지 브로커: 발신자의 메시지를 받아와서 수신자들에게 메시지를 전달하는 어떤 것
            - 웹소켓 위에 얹어 함께 사용할 수 있는 하위(서브) 프로토콜
              STOMP 는 웹소켓만을 위해서 만들어진 것은 아니다. 몇몇 양방향 통신 프로토콜에서 함께 사용할 수 있다.

            - STOMP 가 왜 필요한지, 어떤 이점이 있는지
                - 클라이언트와 서버가 어떤 형식으로 머시지를 주고 받을지, 메시지의 타입은 어떻게 명시할지, 메시지의 본문과 설정 정보와
                  같은 데이터들은 어떻게 구분할 것인지 등등 따로 정의해야 하고 그것을 파싱하는 로직도 필요
                - 하지만 STOMP 를 사용하면 형식을 따로 고민할 필요도, 그것을 파싱하기 위한 코드를 따로 구현할 필요가 없다.
                - STOMP 는 프레임(커맨드, 헤더, 바디) 이라는 형식을 정의해둠

        - STOMP 통신 흐름
            ex) 서버 내에서의 어떤 처리 혹은 가공이 필요하다면 /app 으로 메시지 송신
                가공된 메시지를 /topic 이라는 경로를 담아 다시 전송하면 메시지 브로커에게 전달
                메시지 브로커는 전달 받은 메시지들을 /topic 을 구독하고 있는 구독자들에게 최종적으로 전달
                서버의 어떤 처리나 메시지를 가공할 필요가 없다면 발신자가 바로 메시지 브로커를 통해 구독자들에게 보내는 것도 가능

        - STOMP 를 사용하는 장접
            - 하위 프로토콜 혹은 컨벤션을 따로 정의할 필요가 없다.
            - 연결 주소마다 새로 핸들러를 구현하고 설정해줄 필요가 없다.
            - 외부 Messaging Queue 를 사용할 수 있다. (RabbitMQ, 카프가 ...)
            - Spring Security 를 사용할 수 있다.

- 상태 패턴
    - 디자인 패턴
      반복적으로 나타난 문제에 대해 그것을 해결한 경험 및 노하우를 축적하여 재이용하기 좋은 형태로 이름을 붙여 해법을 제시하는 패턴 양식.
      객체지향 프로그래밍을 설계할 때 자주 발생하는 문제를 피하기 위해 사용되는 패턴. 객체 지향의 재사용과 유지보수성 등의 장점을
      이 디자인 패턴을 사용해 극대화할 수 있다.

    - GOF 디자인 패턴
        - 23 가지의 디자인 패턴을 목적에 따라 3가지 유형으로 분류
            - 생성 패턴: 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 하는 패턴
                - 추상 팩토리 패턴, 빌더 패턴, 팩토리 메서드 패턴, 프로토타입 패턴, 싱글톤 패턴
            - 구조 패턴: 자료 구조나 인터페이스 등 프로그램의 구조를 설계하는데 활용하는 패턴. 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
                - 어댑터 패턴, 브리지 패턴, 컴포지트 패턴, 데코레이터 패턴, 파사드 패턴, 플라이웨이트 패턴, 프록시 패턴
            - 행위 패턴: 반복적으로 사용되는 객체들의 상호 작용을 패턴화. 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
                - 책임 체인 패턴, 커맨드 패턴, 인터프리터 패턴, 중재자 패턴, 메멘토 패턴, 옵저버 패턴, 상태 패턴
                  전략 패턴, 템플릿 메서드 패턴, 방문자 패턴

    - 상태 패턴
        - 객체 자신의 내부 상태에 따라 행위를 변경하도록 하는 패턴
        - 객체의 특정 상태를 클래스로 선언하고 해당 상태에서 할 수 있는 행위들을 메서드로 정의.
          이러한 상태 클래스를 인터페이스로 캡슐화하여 클라이언트에서 인터페이스로 호출하는 방식으로 사용

    - 상태 패턴은 언제 사용할까
        1. 객체의 행동이 상태에 따라 달라질 수 있고, 객체의 상태에 따라 런타임 행동이 바뀌어야 한다.
        2. 객체에 상태에 따라 달라지는 다중 분기조건, 처리가 너무 많이 들어있을 때, 객체의 상태를 표현하기 위해 ENUM 으로 정의해야 한다.

    - 효과
        1. 상태에 따른 행동을 국소화하며 서로 다른 상태에 대한 행동을 별도의 객체로 관리한다.
           새로운 상태가 추가되더라도 context 코드가 받는 영향이 적다.
        2. 상태 전이를 명확하게 만든다. (상태 전이 - 입력에 따라 다음 상태로 바뀌는 것)
        3. 상태에 따른 동작을 구현한 코드를 수정하기 쉽다.

    - 상태 패턴과 전략 패턴의 차이
        - 목적에 따라 구분
            - 상태 패턴: 코드 내 조건문을 대체
            - 전략 패턴: 상속을 대체
        - 다음 상태를 자기 자신이 정하는가
            - 상태 패턴: 상태 객체 내부에서 다음 상태를 결정
            - 전략 패턴: 클라이언트(외부)에서 다음에 실행할 객체를 지정할 수 있다.
            -> 상태 패턴도 외부에서 설정될 수 있기 때문에 상태 기반인가, 방법 기반인가로 나뉘어야 한다.

- 전략 패턴
    - 전략, 전략 패턴의 개념
        - 전략: 특정한 목표를 수행하기 위한 행동 계획
        - 전략 패턴: 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고 사용하며, 동적으로 전략 수정이 가능한 패턴
        - 동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만든다.

    - 전략 패턴 in JDK
        ex) Comparator - 개발 상황에 맞게 비교 전략을 구현할 수 이게 하여 기존 코드의 수정 없이 확장할 수 있음


- 도메인 주도 설계 (Domain-Driven-Design)
    - DDD 란?
        - domain: 사용자가 사용하는것, 소프트웨어로 해결하고자 하는 문제 영역, 비즈니스 영역
        - 도메인 주도 설계: 도메인을 중심으로 하는 개발 방식. 도메인에 관련된 문제를 해결하는 것
          복잡한 도메인을 해결하는 것을 높은 우선순위로 생각해 서비스를 만들어 나가는 방법
          -> 도메인의 복잡성을 조금 더 쉽게 다룰 수 있게 도와주는 도구
        - 도메인  ->  모델  ->  소프트웨어
              (추상화)   (실체화)
            (전략적 설계) (전술적 설계)
        - 소프트웨어 개발과 모델링의 불일치 발생할 수 있음
            - 유비쿼터스 랭귀지(보편 언어)
                - 도메인에 대한 어휘를 이해관계자(도메인 전문가, 개발자, 분석가...)들이 공통적으로 의미를 이해할 수 있도록 정의하는 것
            - 모델 주도 설계
                - 분석과 설계를 나누지 않으면 분석/설계/구현의 모든 단계를 관통하는 하나의 모델을 유지
                - 모델링 통해 가져올 수 있는 통찰을 코드에도 적용
                - 모델 == 코드

        - 도메인 모델
            - 도메인에 대한 구체적인 설계, 도메인을 개념적으로 표현한 것
            - 개념들의 관계를 표현한 모델
            - 문제 영역을 시각화

        - 도메인 주도 설계
            - 복잡한 소프트웨어는 기술 자체의 복잡성 보다는 도메인 자체의 복잡성에 기인
            - 도메인을 가장 잘 아는 사람(도메인 전문가)과 어떻게 협업할 것인지가 가장 중요
            - 유비쿼터스 랭귀지, 모델 주도 디자인

    - 왜 도메인 주도 설계인가?
        - 등장 배경
            - 데이터에 종속적인 어플리케이션
                - 기존 개발은 DB 테이블 중심 -> 빈약한 도메인 도델
            - 모델링과 개발과의 불일치
                - getter 와 setter 만으로 구성된 모델
                - 데이터만 가지는 데이터홀더 개념
                - Big Service Layer

    - DDD 의 전략적, 전술적 패턴
        - 전략적 설계
            - 복잡한 메인 맥락(Context) 경계를 명확히 정의하는 과정
            - Bounded Context 안의 도메인 모델에서 보편 언어를 개발하는 방법
            - 도메인에서 서브 도메인으로 복잡성을 분리 (핵심, 지원 도메인 파악)
            - 컨텍스트 맵핑 기술을 활용해 여러 개의 Bounded Context 를 통합
            - 이벤트 스토밍 기법을 활용해 Bounded Context 식별

        - 전술적 설계
            - 전략적 설계에서 더 상세한 부분(바운디드 컨텍스트 내부) 모델링
            - Model Driven Design
            - 빌딩 블록(패턴)을 사용해 모델링 - Aggregate 패턴
                - Entity: 속성이 아닌 식별성을 기준으로 정의되는 도메인 객체
                - Value Object: 식별성이 아닌 속성을 이용해 정의되는 불변 객체
                - Service: Domain Object 에서 위치시키기 어려운 operation 을 가지는 객체
                - Aggregate: 연관된 entity 와 value object 의 묶음. 일관성과 트랜셕선, 분산의 단위. 캡슐화를 통한 복잡성 관리
                - Factory: 복잡한 entity 의 생성 절차에 캡슐화할 수 있는 개념. 생성하기 복잡한 Aggregate 내의 여러 객체 동시 생성
                           생성시 Aggregate 의 일관성 유지
                - Repository: 도메인 영역과 데이터 인프라스트럭처 계층을 분리하여 데이터 계층에 대한 결합도를 낯추기 위한 방안
                              생성된 Aggregate 에 대한 영속성 관리, 조회, 등록, 수정 삭제 시 Aggregate 의 일관성 유지
            - 계층형 아키텍처를 통한 모데인 모델 분리
            - 도메인 이벤트를 통해 도메인을 보다 명확히 모델링

- DTO vs VO
    - DTO 와 VO 의 혼용 사례와 원인
    - 결론
        - DTO: 데이터 전달용
        - VO: 값 표현용

    - DTO
        - Data Transfer Object
        - 데이터를 전달하기 위해 사용하는 객체
        - "계층 간" 데이터를 전달하기 위한 객체
        - 오직 getter/setter 메서드 만을 갖는다. 다른 로직을 갖지 않는다.
        - DTO 를 불변객체로 -> 생성자를 통해 속성 값들을 초기화해 불변객체로 생성
        - DTO 클래스와 Entity 클래스
            - 절대로 요청이나 응답 값을 전달하는 클래스로 엔티티를 사용하면 안된다.
              데이터베이스와 매핑되어 있는 핵심 클래스이기 때문. 엔티티 클래스를 기준으로 테이블이 생성되고 스키마가 변경된다.
              뷰는 비즈니스 요구사항에서 자주 변경되는 부분이다. 요청이나 응답 값을 전달하는 클래스로 엔티티를 쓴다면
              뷰가 변경될 때마다 엔티티 클래스를 그에 맞춰 매번 같이 변경해야 한다.
              수많은 서비스 클래스나 비즈니스 로직들이 엔티티 클래스를 기준으로 동작한다. 엔티티 클래스를 변경하면 관련되어 있는
              많은 클래스들에게 영향을 주게 된다. 따라서 요청이나 응답 값을 전달할 때는 뷰의 변경에 따라 다른 클래스들에게
              영향을 주지 않고 자유롭게 변경할 수 있는 DTO 사용해야 함. 또한 응답 값으로 여러 테이블들을 조인한 결과값을 줘야할 경우가
              빈번하기 때문에 엔티티 클래스만으로는 응답값을 표현하기 어려운 경우가 많다.

    - VO
        - Value Object
        - 값 그 자체를 표현하는 객체
        - VO 는 값 자체를 표현하기 때문에 불변객체여야 한다.

    - DTO vs VO
        - DTO
            - 레이어 간 데이터 전달
            - 속성값이 모두 같다고 해서 같은 객체가 아니다
            - setter 존재 시 가변, setter 비 존재시 불변
            - getter/setter 외의 로직을 갖지 않는다
        - VO
            - 값 자체 표현
            - 속성값이 모두 같으면 같은 객체다
            - 불변
            - getter/setter 외의 로직을 가질 수 있다

- spring Webflux
    - spring framework 주요 기능
        - Dependency Injection / Inversion of Control
        - Portable Service Abstraction
        - Aspect Oriented Programming
        - 경량 컨테이너, POJO 지원, @Transaction 등등
    - spring framework 5.xx 특징
        - Java 호환 버전 변경: JDK8 부터 지원
        - Kotlin 지원
        - 호환 라이브러리 변경 (JUnit5, JDBC 4.0, Hibernate 5...)
        - Reactive Programming 지원 -> spring Webflux

    - Spring Webflux 가 생겨난 배경
        - 적은 수의 스레드로 동시성 처리 / Non-blocking / Functional Programming
        - 쓰레드 풀의 딜레마
            - CPU, 메모리가 충분하지만 스레드가 모자라서 처리율 저하 (큐에 쌓임)
            - 그래서 스레드를 과도하게 늘리면 이번엔 메모리, CPU 의 부하로 성능 저하
            - 컨텍스트 스위칭이라 하여 CPU 간 전환 과정은 엄청난 부하가 필요
            - 즉, 스레드를 무조건 늘린다고 문제를 해결할 수 있는 것은 아님

        - spring MVC: 스레드를 늘려서 동시성 처리
          어플리케이션에서 I/O 요청을 한 후 완료되기 전까지는 어플리케이션이 Block 이 되어 다른 작업을 수행할 수 없다. 이는 해당 자원이
          효율적으로 사용되지 못하고 있음을 의미한다. 그러나 현재 어플리케이션들은 Blocking 방식임에도 불구하고 마치 Block 이 안된듯이
          동작하는 것처럼 보인다. 이것은 싱글 스레드 기반이 아닌 멀티 스레드 기반으로 동작하기 때문이다. Block 이 되는 순간 다른 스레드가
          동작함으로써 BLock 의 문제를 해소하였다. 그러나 스레드 간의 전환(컨텍스트 스위칭)에 드는 비용이 존재하므로 여러 개의 I/O 를
          처리하기 위해 여러 개의 스레드를 사용하는 것은 비효율적이다.

        - Webflux: 적은 수의 스레드로 동시성 처리 (Asynchronous Non-Blocking I/O)
          I/O 요청을 한 후 Non-Blocking I/O 와 마찬가지로 즉시 리턴된다. 허나, 데이터 준비가 완료되면 이벤트가 발생하여 알려주거나,
          미리 등록해놓은 callback 을 통해서 이후 작업이 진행된다. Blocking 이 없기 때문에 자원을 보다 효율적으로 사용 가능

        - Non-blocking: 자신이 호출되었을 때 바로 자신을 호출한 쪽으로 넘기며 자신을 호출한 쪽에서 다른 일을 할 수 있도록 하는 것

        -> 적은 스레드와 메모리를 효율적으로 사용할 수 있는 것뿐.
           "속도가 빠르다" 보다는 "적은 리소스로 많은 트래픽을 감당한다"고 할 수 있다.

        - Functional Programming: 함수가 일급 객체로 쓰일 수 있어(반환값, 인자) 메소드 체이닝과 람다를 섞어쓰는 것(Java 8 ~)

        - Reactive Programming
            - Non-blocking IO 에 Reactive Stream 과 BackPressure 를 곁들였다. Publisher 가 Subscriber 를 압도하지 못하게
              하는 목적이 핵심인 BackPressure 를 가지고 작은 수의 스레드로 확장성 있는 Non-blocking / Event Driven 개발 지향

            - Reactive Stream
                - Asynchronous, Non-blocking 으로 작동하는 stream. stream 의 기능이 더 많은 것
                - Publisher (웹 클라이언트, 데이터베이스) 에서 변경이 생기면 Subscriber 에 변경된 데이터들을 Stream 으로 전달
                - 이 Stream 으로 프로그래밍하는 패러다임이 Reactive Programming (모든 것은 Steam 이다.)

            - BackPressure
                - Subscriber 로 들어오는 Stream 양을 조정, 적은 컴퓨팅 자원으로 일을 처리하기 가능한 정도씩만 받기
                - 물론 이건 실시간 통신을 사용하지 않는 이상 크게 어렵다.

- redis
    - redis 개요
        - Remote dictionary server
           외부    hashMap    서버
        - Database, Cache, Message broker
        - in-memory Data Structure Store
        - Supports rich data structure

    - Cache 개념
        - 나중의 요청에 대한 결과를 미리 저장했다가 빠르게 사용하는 것
        - Memory Hierarchy
            - CPU Register
            - CPU Cache
                ex) 12MB Cache memory(SRAM) - 빠르고 비싸고 용량이 작다
            - Main Memory (DRAM)
                ex) 16GB DRAM - 적당히 빠르고 적당히 비싸고 적당이 용량이 크다, 휘발성
            - Storage (SSD, HDD)
                ex) 512GB SSD - 비교적 느리고 저렴하고 용량이 엄청 크다, 비휘발성
        -> in-memory Database (Cache) - Database 보다 더 빠른 Memory 에 더 자주 접근하고 덜 자주 바뀌는 데이터를 저장하자

    - redis 자료구조
        - 서버가 여러대인 경우 Consistency 의 문제 발생
        - 멀티 스레드 환경에서 Race condition
            - Race condition 이란 여러 개의 스레드가 경합하는 것. 컨텍스트 스위칭에 따라 원하지 않는 결과가 발생할 수 있다.
            - 레디스는 기본적으로 싱글 스레드
            - 레디스 자료구조는 Atomic. Critical Section 에 대한 동기화를 제공
                (Critical Section -> 동시에 여러 프로세스가 접근하면 안되는 영역)
            - 서로 다른 Transaction Read/Write 를 동기화

        - 어디에 쓰이나
            - 여러 서버에서 같은 데이터를 공유할 때
            - Single Server 라면? Atomic 자료구조 & Cache

    - redis 주의사항
        - Single Thread 서버이므로 시간 복잡도를 고려해야한다.
            - 레디스는 네트워크로부터 요청을 받아서 명령어를 처리하는 데 이런 커맨드를 형성하고 처리하는 과정이 싱글 스레디 이기 때문에
              커맨드가 오랜 시간이 걸리는 경우 나머지 요청들이 더이상 받아지지 않고 서버가 다운되는 문제가 발생할 수 있다.
              그래서 싱글 스레드이기 때문에 처리가 빨라야 한다. 전체 데이터를 다루는 시간 복잡도를 가진
              O(N) 의 명령어는 주의해서 사용. (KEYS, Flush, GetAll 연산 등)
        - in-memory 특성상 메모리 파편화, 가상 메모리 등의 이해가 필요하다.
        - 레디스가 왜 Single Thread 로 동작하느냐?
            - Event Driven (비동기)
            - IO-bound Process
            - Context Switching 의 효율이 적다
            - Single Threaded
        - 메모리 관리
            - 메모리 파편화
            - 가상메모리 Swap
            - Replication - Fork

    - 그외..
        - 레디스를 저장소처럼 -> Redis Persistent, RDB, AOF
        - 레디스의 메모리는 제한되어 있기 때문에 주기적으로 Scale out, Back up 해야함 -> Redis Cluster
        - 부하 분산 -> Constant Hashing
        - Data Grid -> Spring Gemfire, Hazlecast
          (데이터베이스를 사용하지 않고 인메모리 db 만 사용하는 방식)

