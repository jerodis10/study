- 서킷 브레이커 패턴(Circuit Breaker Pattern)   https://mangkyu.tistory.com/261  https://godekdls.github.io/Resilience4j/circuitbreaker/
    - 정의
        - 외부 서비스에 의한 문제를 방지하기 위해 등장한 것이 서킷 브레이커 패턴이다. 문제가 발생한 지점을 감지하고 실패하는 요청을 계속하지 않도록 방지.
          이를 통해 시스템의 장애 확산을 막고, 장애 복구를 도와주며 사용자는 불필요하게 대기하지 않게 된다.
          즉, 서킷 브레이커 패턴은 클라이언트 측면에서 장애를 방지하기 위한 도구로써, 실패할 수 있는 작업을 계속 시도하지 않도록 방지한다.

        - MSA(Micro Service Architecture)에선 서로의 모듈이 의존함에 따라 한 모듈이 장애가 나면
          다른 모듈에도 장애로 이어지는 것을 막기 위해 MSA 회복성 패턴 중 하나인 CircuitBreaker를 사용

    - 동작 원리
        - 서킷 브레이커의 3가지 상태
            - Closed
                - 상황: 모든 것이 정상인 상황
                - 요청: Open 상태가 되고 일정 시간이 지난 상황
                - 상태 전이: 외부(Callee)로의 요청을 차단하고 바로 에러를 받음
            - Open
                - 상황: 외부(Callee)에 장애가 발생한 상황
                - 요청: 외부(Callee)로의 요청을 차단하고 바로 에러를 받음
                - 상태 전이: 특정 시간이 지나면 Half Open 상태가 됨
            - Half Open
                - 상황: Open 상태가 되고 일정 시간이 지난 상황
                - 요청: 외부(Callee)로의 요청을 차단하고 바로 에러를 받음
                - 상태 전이: 일부 허용된 요청들이 성공한 경우 Closed 상태로, 실패인 경우 Open 상태로 변경

            - 여기서 외부에 장애가 발생했는지 판단하는 기준은 크게 2가지가 있는데, 각각의 정해진 임계치가 넘어갈 경우 요청이 차단된다.
                - slow call: 기준 시간보다 오래 걸린 요청
                - failure call: 실패하거나 오류를 응답받은 요청
            - 그러므로 이러한 기준을 적용하여 다음과 같은 규칙을 만들 수 있다.
                - 특정 요청이 3번 연속 실패할 경우 요청을 차단한다.
                - 특정 요청이 5번 연속 n초 이상 시간초과 할 경우 요청을 차단한다.
                - 차단했던 요청이 3번 연속 성공 할 경우 요청을 전송한다.

        - 서킷 브레이커의 동작 방식 예시
            1. 일반적으로 외부 서버는 정상 실행중이므로, 서킷이 닫혀있고 요청이 정상적으로 전달됨
            2. 외부 서버에 장애 발생
            3. 요청이 계속해서 실패하고, 회로가 Open 상태가 됨
            4. 이후의 요청들은 더 이상 전달되지 않고 차단되며, 빠르게 에러 또는 실패 응답을 반환함
            5. 이후에 외부 서버가 정상적으로 복구됨
            6. 회로가 Open 상태가 된지 특정 시간이 지나고, Half Open 상태로 변경됨
            7. 일부 요청들이 외부 서버로 전달되고, 응답에 성공하여 Closed 상태됨
            8. 모든 요청들이 정상적으로 전달됨

            - Open 상태가 되면 특정 시간이 지나야 Half Open 상태가 된다. 만약 Half Open 상태가 되었는데도 외부 서버가 복구되되지 않았다면,
              요청들은 실패해서 다시 Open 상태로 변경될 수도 있다. 여기서 중요한 것은 이러한 상태 변경이 자동으로 수행된다는 것이며,
              상태 전이를 위한 시간들은 시스템 내부에서 관리되므로 대부분 타임아웃과 관련된 모니터링 시스템을 제공해준다.

        - 서킷브레이커의 OPEN 상태전이는 임계치로 지정한 실패율(실패+느린호출 실패) 혹은 느린호출 비율 중 하나만 달성해도 발생한다.

    - 장점 및 필요성
        - 장애 감지 및 격리
            - 만약 장애가 발생한 서비스를 호출한다면 요청이 타임아웃만큼 대기하게 되고, 쓰레드와 메모리 및 CPU 등의 자원을 점유하게 된다.
              이것은 결국 시스템 리소스를 부족하게 만들어 장애를 유발할 수 있다. 장애가 발생한 것은 다른 서비스인데, 장애가 전파되는 것이다.
              서킷 브레이커 패턴은 장애가 발생한 서비스를 감지하고, 더 이상 요청을 보내지 않도록 차단함으로써 장애를 격리시켜 준다.
              그래서 장애가 발생한 기능 외의 다른 기능들은 동작하게 하여 시스템의 안정성을 높일 수 있다.

        - 자동 시스템 복구
            - 서킷 브레이커는 요청이 차단되면 해당 서비스가 정상인지 주기적으로 검사한다. 그리고 해당 서비스가 복구되었다면 차단이 해제되고,
              정상적으로 요청을 보내게 된다. 이러한 부분들은 시스템이 자동으로 해주므로 개발자들이 신경쓰지 않아도 된다.
              대부분 타임아웃 등을 위한 모니터링 기능까지 제공하며, 서킷 브레이커가 모든 연동에 적용되면 대시보드를 통해 전체 시스템들의 연동 현황까지 모니터링 가능하다.

        - 빠른 실패 및 고객 응답
            - 만약 다른 서비스가 문제있음을 알 수 있다면, 타임아웃 동안 기다리며 자원을 낭비할 필요가 없다.
              그래서 빠르게 장애를 탐지하는 것이 중요한데, 서킷브레이커 패턴을 적용하면 가능한 빠르게 실패를 반환하고, 고객에게 응답을 전달할 수 있다.

        - 장애 서비스로의 부하 감소
            - 외부 서비스가 완전히 죽지는 않았는데, slow query 등의 이유로 사용 가능한 쓰레드가 더 남아있지 않을 수도 있다.
              이때 계속 요청을 보내는 것은 외부 서비스의 상황을 악화시켜 장애를 유발시킬 수 있다. 그러므로 해당 서비스가 안정을 찾도록 요청을 멈추는 것이 좋은데,
              서킷 브레이커를 사용하면 해당 서비스는 더 이상의 요청이 유입되지 않아 장애를 복구할 수 있는 기회를 얻을 수 있다.

        - 장애 대안 커스터마이징
            - 외부 서비스에서 장애가 발생했다면 원하는 데이터를 얻지 못할 수 있다. 이때 아무런 대응책이 없다면 해당 서비스 역시 장애가 발생하게 된다.
              서킷 브레이커를 적용하면, 장애 대안을 커스터마이징 할 수 있는데, 예를 들어 다른 소스로부터 값을 얻어오거나,
              서킷 브레이커가 자체적으로 캐싱해 둔 값으로 응답하는 등 다양한 방법을 적용할 수 있다. 그러면 외부에 장애가 발생해도 문제없이 서비스를 운영할 수도 있다.

        - 국내 대부분의 서비스들은 스프링 MVC 기반으로 되어있다. 스프링 MVC는 멀티 쓰레드 기반으로 동작하므로 장애가 있는 서비스를 호출하면
          쓰레드 점유에 의한 응답 지연이 발생하기 쉽다. 그래서 장애가 전파되기 쉬운데, 서킷 브레이커를 사용하면 빠르게 장애가 발생한 서버로의
          요청을 차단하고 이를 해결할 수 있다. 심지어 대안책을 적절히 마련한다면 정상적인 서비스 운영까지 가능하다. 물론 서킷 브레이커를 도입한다면
          서킷 브레이커의 상태 및 히스토리 관리 등을 위한 추가 비용이 발생한다. 하지만 오늘날 서킷 브레이커는 안정적인 서비스 운영을 위한 필수 패턴이므로 반드시 적용해야 한다.


- Resilience4J
    - 정의
        - Resilience4J는 함수형 프로그래밍으로 설계된 경량(lightweight) 장애 허용(fault tolerance) 라이브러리로, 서킷브레이커 패턴을 위해 사용된다.

    - 구성 요소
        - CircuitBreaker
            - CircuitBreaker는 일반적인 서킷 브레이커의 상태(CLOSED, OPEN, HALF_OPEN)에 맞게 유한 상태 기계(Finite state machine, FSM)를 구현한 모듈로,
              아래의 기본 상태에 더해 DISABLED와 FORCED_OPEN 이라는 특수한 상태 2개를 추가하였다.

            - CircuitBreaker는 호출 결과를 저장하고 집계하기 위해 슬라이딩 윈도우를 사용한다.
                - count-based sliding window(횟수 기반 슬라이딩 윈도우): 마지막 N번의 호출 결과를 기반
                - time-based sliding window(시간 기반 슬라이딩 윈도우): 마지막 N초의 결과를 기반

            - 느린 호출율과 호출 실패율이 서킷브레이커에 설정된 임계값보다 크거나 같다면 CLOSED에서 OPEN으로 상태가 변경된다.
            - 모든 예외 발생은 실패로 간주되므로, 특정 예외만 실패로 간주하고 싶다면 예외 목록을 정의해주면 된다. 그러면 나머지 예외들은 성공으로 간주되며,
              혹시나 예외 발생 부분은 결과에서 ignore 하고 싶다면 해당 설정 역시 가능하다.
            - 이때 최소 호출 수가 있어서, 일정 호출 수가 기록된 후에 느린 호출율과 호출 실패율이 계산된다.

            - CircuitBreaker는 서킷이 OPEN 상태라면 CallNotPermittedException을 발생시킨다.
            - 그리고 특정 시간이 지나 HALF_OPEN 상태로 바뀌고 설정된 수의 요청만을 허용하고 나머지는 동일하게 예외를 발생시킨다.
              그리고 동일하게 느린 호출율과 호출 실패율에 따라 서킷의 상태를 OPEN 또는 CLOSED로 변경한다.

            - DISABLED: 서킷브레이커를 비활성화하여 항상 요청을 허용하는 상태
            - FORCED_OPEN: 강제로 서킷을 열어두어 항상 요청을 거부하는 상태. 해당 상태에서는 상태 전환을 트리거하거나 서킷브레이커를 리셋하는 것이다.

            - 서킷브레이커는 다음과 같이 Thread-safe 하다.
                - 서빗브레이커의 상태는 AtomicReference에 저장됨
                - 서킷브레이커는 atomic 기능을 사용하여 부작용없는 함수로 상태를 업데이트함
                - 슬라이딩 윈도우에서 요청을 기록하고 스냅샷을 읽는 작업은 동기적으로 처리됨

                - 즉, 서킷브레이커는 원자성이 보장되며 특정 시점에 하나의 쓰레드만이 서킷브레이커의 상태나 슬라이딩 윈도우를 업데이트할 수 있는 것이다.
                  그러나 서킷브레이커는 함수 호출을 동기화하지 않는다. 만약 그렇게 하면 이는 엄청난 성능적인 약점과 병목이 될 것이다.
                  예를 들어 슬라이딩 윈도우의 크기가 15라고 할지라도, 20개의 쓰레드가 CLOSED 상태에서 호출 여부를 묻는다면 모든 쓰레드는 요청을 보낼 것이다.
                  슬라이딩 윈도우는 동시에 요청가능한 수가 아니며, 해당 설정은 Bulkhead에서 지원하는 것이다.

        - Bulkhead
            - Resilience4J는 동시 실행의 수를 제어하기 위한 Bulkhead 패턴을 위해 2가지 구현을 제공한다.
                - SemaphoreBulkhead: 세마포어를 사용함
                - FixedThreadPoolBulkhead: 제한된 큐와 고정된 쓰레드 풀을 사용함

        - RateLimiter
            - API의 확장을 준비하고 서비스의 고가용성과 안정성을 확립하고 위한 필수 기술
            - 이 기술에는 감지된 한도 초과를 처리하는 방법이나 제한하려는 요청에 대한 다양한 옵션을 제공

        - Retry
            - Resilience4j는 Retry를 위한 인메모리 RetryRegistry를 제공

        - TimeLimiter
            - CircuitBreaker 모듈처럼 시간 제한을 위한 인메모리 TimeLimiter 역시 제공
            - TimeLimiter 역시 global 설정과 instance별 설정이 가능하며, 2가지 옵션을 제공
                - timeoutDuration
                - cancelRunningFuture

            - Resilience4j는 함수형 기반의 라이브러리인만큼 내부적으로 Java의 Future로 요청을 실행한다.
              위의 timeoutDuration은 Future의 timemout으로 설정되며, 주어진 시간이 지났을 때 해당 Future를 취소시킬지 여부를 설정한다.


    - RestTemplate에 Resilience4J 적용하기
        - 설정 파일 추가
            - yaml 파일을 이용하면 설정값을 바탕으로 자동 설정(AutoConfig)이 되는데, 공통으로 사용할 값들은 configs에 정의하고 개별 인스턴스 설정은 instances에 작성해주면 된다.
            - Resilience4J는 Thread-safe와 원자성 보장을 제공하는 ConcurrentHashMap 기반의 인메모리 CircuitBreakerRegistry를 제공해준다.
              해당 객체에서 설정 내용이 관리되며, CircuitBreaker 객체를 얻어올 수 있다.

        - recordFailurePredicate 작성
            - recordFailurePredicate는 어떤 예외를 Fail로 기록할 것인지를 결정하기 위한 Predicate 설정이다.
            - 해당 클래스에서 true를 반환하면 요청 실패로 기록되며, 실패가 쌓이면 서킷이 OPEN 상태로 변경되게 된다.
            - 해당 Predicate 클래스를 적용하려면 yaml 설정 파일에 recordFailurePredicate 내용을 추가해주면 된다.

        - 서킷브레이커 적용
            - 서킷브레이커를 적용하는 방법에는 크게 2가지가 있다.
                - 코드 방식
                    - 작업이 번거로우며 중복이 상당히 많아진다. 반면에 어노테이션 방식을 적용하면 작업이 상당히 간결해지지만 매번 어노테이션을 붙여주어야 하며,
                      서킷브레이커 인스턴스(name값) 관리가 필요해진다. 새롭게 연동해야 하는 서버가 생긴다면 번거로우며, 해당 값을 잘못 지정했을 경우에 문제가 생길 수도 있다.

                    - 그래서 이러한 문제를 완전히 해결하고자 코드 방식에 AOP를 적용하여 해결
                    - 이렇게 하면 중복 코드도 제거되고, 자동으로 서킷 브레이커도 적용되며, 서킷 브레이커 인스턴스도 host 기반으로 자동 식별할 수 있다.

                    - AOP 방식으로 사용하려면 application.yaml에 지정한 서킷브레이커를 비롯해 데코레이팅 할 기능의 애너테이션에 모두 동일하게 이름을 적어줘야 하는데 실수할 여지가 있다.
                      데코레이팅 할 기능의 순서를 지정하기 쉽다.
                      특정 exception을 블랙리스트, 화이트리스트로 등록하는 기능을 사용하기 위해 AOP 방식을 사용하면 해당 exception의 풀 패키지 경로를
                      application.yaml에 적어야 하는데 코드로 구현하면 exception을 풀 패키지 경로를 적다가 실수 할 일이 없다.
                      서킷브레이커에 기능에 대한 테스트에 스프링 컨텍스트가 필요없다.
                      https://bottom-to-top.tistory.com/57

                - 어노테이션 방식

        - CircuitBreakerNameResolver 작성

        - CallNotPermittedException 예외 처리
            - 서킷이 OPEN 상태로 바뀌면 더 이상 요청이 전달되지 않는다. 대신 요청을 차단하고 바로 CallNotPermittedException 예외를 발생시킨다.
            - 그러므로 각각의 예외 처리 방법에 맞게 CallNotPermittedException 예외를 처리해주어야 한다.
              일반적으로 ControllerAdvice를 사용하고 있을 것인데, 그렇다면 해당 클래스에 아래의 내용을 추가 및 구현하면 된다.

        - 의존성 추가

***** 슬라이딩 윈도우
    https://godekdls.github.io/Resilience4j/circuitbreaker/

***** MSA 환경에서 장애 전파를 막기 위한 서킷 브레이커 패턴
    https://hudi.blog/circuit-breaker-pattern/

***** CircuitBreaker를 이용한 외부 API 장애 관리
    https://velog.io/@hgs-study/CircuitBreaker

***** CircuitBreaker와 Retry 설정
    https://gngsn.tistory.com/232
    https://bkjeon1614.tistory.com/711

* 서킷브레이커 모니터링
    https://bkjeon1614.tistory.com/712
    https://cheese10yun.github.io/resilience4j-basic/
    https://happycloud-lee.tistory.com/219