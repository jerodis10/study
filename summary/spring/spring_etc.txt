- Spring Framework에 대해 설명해주세요.
    - 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크

    - 경량 컨테이너로서 자바 객체를 직접 관리
        각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
    - 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
        컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 다라 스프링에서 사용자의 코드를 호출한다.
    - 의존성 주입(DI, Dependency Injection)을 지원
        각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
    - 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
        트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.


- 스프링이란?
    - Java 기반의 엔터프라이즈 Application 개발을 빠르고 편하게 할 수 있도록 도와주는 경량 프레임워크.

    - 왜 '경량' 프레임워크인가?
        초기 서버사이드 처리는 직접 쓰레드, 소켓연결 등을 개발자들이 직접 처리했고, 개발자 마다 구현하는 방법이 다 달라 협업에 불편함이 많았다.
        정형화, 표준화 된 방법을 찾기 시작하면서 등장한 것이 Framework이다.
        EJB가 나왔지만 분산환경 처리에 특화된 EJB는 너무 무거운데다 불편한 점이 많았고, 이런 EJB에 반기를 들고 탄생한 '경량화'된 Java 엔터프라이즈용 Framework이 Spring인 것이다.

    - 왜 스프링을 사용하는가?
        스프링은 Framework이고, Framework은 개발자들이 좀 더 쉽고 편리하게 애플리케이션을 개발할 수 있도록 미리 갖춰진 구조를 말한다.
        Framework이 없었다면 개발자들은 처음부터 끝까지 직접 모든 구조를 만들어내야 할 것이다.
        스프링은 Application 개발에 필요한 하부 구조를 포괄적으로 제공함에 따라 개발자들의 실력의 간극을 메꿔줄 수 있는 데다가
        올바른 형태의 코드만 넣어준다면 일정 수준의 성능과 안정성을 보장해 줄 수 있다. 그 틀과 구조 위에서 개발자들은
        핵심 비즈니스 로직에만 집중할 수 있어서 생산성 또한 향상된다.


- Spring과 SpringBoot의 차이점
    (1) 내장 톰캣
        - 내장 톰캣을 사용하기 때문에 따로 톰캣을 설치하거나 매번 버전을 관리해 주지 않아도 된다.
    (2) starter를 통한 dependency를 자동화
        - 기존의 Spring에서는 dependency들의 호환되는 버전을 직접 설정
        - 스프링 부트에서는 이 starter를 통해 종속된 모든 라이브러리를 알맞게 찾아서 함께 가져오기 때문에 의존성이나 호환버전에 대해 신경 쓸 필요가 없다.
    (3) XML
        - View Resolver, 데이터 액세스 등의 xml 설정을 하지 않아도 된다.
    (4) jar
        - jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.
    (5) AutoConfigurator
        - 공통적으로 필요한 설정을 어노테이션을 이용하여 대신할 수 있다.
    (6) Spring Initializr
        - pring Initilizr를 사용하면 실행 환경이나 의존성 관리 등의 인프라 부분을 신경 쓸 필요 없이 바로 코딩을 시작할 수 있게끔 환경을 제공


- 스프링 부트
    - 의존성 관리
        스프링 부트는 starter- 를 통해서 의존성관리를 한다.

    - 자동 설정
        - @ComponentScan을 통해서 @Component, @Serveice, @Repository .. 와 같은 컴포넌트 기반을 스캐닝해서 우리가 정의한 빈들을 등록한다.
        - @EnableAutoConfiguration을 통해서, META-INF 하위에 있는 spring.factories 파일에 정의된 클래스들에 의해서 빈으로 등록된다.
          (@ConditionalOnMissingBean 같은 경우, 빈으로 등록되어있지 않은 경우, 저기에서 정의한 대로 빈으로 등록한다.)

    - 내장 웹서버
        메인 애플리케이션으로 띄울 수 있고, jar로 패키징된 파일 하나로 만들고, 해당 jar를 실행해서도 애플리케이션을 띄울 수 있다.
        여러 가지 설정을 할 수 있다.
            server.port = 0 (random)
            spring.main.web-application-type=none -> 내장 웹서버로 실행하지 않음
            https 설정, http2.0 설정


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - 설정만 해준다면(applicationContext.xml) 스프링은 그 설정 정보를 참고해서 객체를 생성,관리하고 그 관계를 맺어준다.
    - 핵심은 개발자가 new 연산자 등을 통해 객체를 생성할 필요가 없다는 것이다(제어의 역행-IoC).
    - 스프링 컨테이너에게 그 참조변수만 일러준다면(@Autowired나 setter주입 등) 스프링이 알아서 객체를 생성해주고, 관계를 맺어준다.

    2. 순환 참조를 방지
        - 생성자 주입 방식은 필드나 수정자 주입과는 빈을 주입하는 순서가 다르기 때문
        - 생성자를 통한 의존성 주입의 장점은 객체 생성 시점에서 순환 참조가 일어나기 때문에 스프링 애플리케이션이 실행되지 않습니다.
          (앱 구동 단계에서 오류를 찾을 수 있다.)
          컨테이너가 빈을 생성하는 시점에서 객체생성에 사이클 관계가 생기기 때문입니다.

    3. 테스트 코드 작성 용이
        - 스프링 컨테이너 도움 없이 테스트 코드를 더 편리하게 작성 가능
        - 생성자 주입이 아닌 다른 주입으로 작성된 코드는 순수한 자바 코드로 단위 테스트를 작성하는 것이 어렵다.
          필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는
          필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양
          Mock 객체를 만들어야 하는데 DI 컨테이너에 의존하는 바람에 독립적으로 인스턴스화가 불가능한 문제가 발생한다.
          DI 컨테이너에서 관리되는 클래스는 특정 컨테이너에 의존하지 않고 POJO여야 한다.
          스프링 컨테이너가 생성해서 주입해주는 방식이기 때문에
          반면 생성자 주입을 사용하면 객체를 생성할 때 원하는 구현체를 넘겨주면 되고, 구현체를 넘겨주지 않으면 객체 생성 자체가 불가능


- DI   https://mangkyu.tistory.com/150
    - 정의
        DI란 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고
        런타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다.

    - 필요성
        - 두 클래스가 강하게 결합되어 있음
        - 객체들 간의 관계가 아니라 클래스 간의 관계가 맺어짐


- 스프링 컨테이너(Spring Container)란?
    - 빈의 생성,관계설정,생명주기 등을 관장하는 컨테이너.

    - 객체(빈)관리의 관점에서 Application Context를 스프링 컨테이너라고 부른다.
    - Application Context는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데,
      그러한 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용되고, 이를 통틀어서 스프링 컨테이너라고 볼 수 있다.


- POJO
    어느 곳에 종속되지 않은 순수한 자바 객체.

    과거에 자바로 웹 애플리케이션을 만들기 위해 Servlet클래스를 상속받아 구현했어야 했다. 서블릿 컨테이너 안에서 서블릿으로 존재하기 위해서는 그 구현이 강제되었던 것이다.
    그렇게 강제된 구현으로 만들어진 서블릿 객체는 서블릿 컨테이너 환경에서 사용되어질 수 있다. 이는 그 환경에 종속 되어 있기에 POJO라고 할 수 없다.
    어느 곳에 종속되지 않는다는 의미는, 해당 클래스를 사용하기 위해 외부 환경(like 프레임워크)이 필요하고, 해당 환경이 특정 인터페이스를 구현할 것을 강요하는 등의 제약에서 자유롭다는 것을 의미한다.
    (따라서 단순히 외부 구동환경과 무관한 다른 클래스의 상속 또는 구현은 상관 없다.)
    즉, 다시말해 POJO는 외부환경(like Spring MVC)을 걷어내도 정상적으로 작동이 되어야 한다는 것이다.
    Spring은 개발자가 직접 위와같이 Servlet클래스를 작성하지 않고 POJO만으로 웹 애플리케이션을 구축할 수 있다는 것이 특징이다.(개발자가 비즈니스로직만 신경 쓸 수 있다)

    스프링에서 생성되어 관리되는 POJO 기반의 객체를 Spring Bean이라고 합니다.
    여기서 POJO는 단순 getter, setter만으로 구성되어 있으며 단순히 new를 통해서 생성 가능한 형태를 말합니다.
    핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있고, 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스입니다.


- spring bean 생명주기
    1. 빈 객체 생성
    2. BeanNameAware.setBeanName()
        의 id/name 속성에 지정된 값 전달
            - 스프링에서 관리되는 bean 내부에서 id나 name이 무엇으로 지정되어 있는지 확인하는 경우 BeanNameAware Interface를 구현한다.
            - 이때 그림의 노란색 부분처럼 bean생성과 property 의존성 주입을 완료한 이후, init method를 수행하기 전 시점에 호출된다.
    3. BeanFactoryAware.setBeanFactory()
        - bean객체에 bean을 관리하는 BeanFactory 객체 전달
    4. BeanPostProcessor의 초기화 전처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 되기전 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
    5. 커스텀 init - method
        - @PostConstruct
    6. InitializingBean.afterPropertiesSet()
    7. BeanPostProcessor의 초기화 후처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 된 후 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
        - postProcessAfterInitialization
    8. 빈 객체 사용
    9. DisposableBean.destroy()
    10. 커스텀 destroy - method 2_8_ii


- 빈(Bean)이란?
    - 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트.
    - 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니고, 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
    - POJO와 설정(Configuration. xml이나 어노테이션)을 Spring의 컨테이너에 주입시키면 Bean으로 등록되고 사용할 수 있다.


- 스프링 빈(Spring Bean)이란?
    - 스프링 IoC 컨테이너에 의해서 관리되고 애플리케이션의 핵심을 이루는 객체들을 스프링 빈
    - 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서,
      강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있는데 대표적으로 프로토타입 스코프가 있다.
      프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할때마다 매번 새로운 오브젝트를 만들어 준다. 스코프는 xml과 어노테이션 설정으로 가능하다.