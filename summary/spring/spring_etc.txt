- Spring Framework에 대해 설명해주세요.
    - 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크

    - 경량 컨테이너로서 자바 객체를 직접 관리
        각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
    - 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
        컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 다라 스프링에서 사용자의 코드를 호출한다.
    - 의존성 주입(DI, Dependency Injection)을 지원
        각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
    - 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
        트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.


- 스프링이란?
    - Java 기반의 엔터프라이즈 Application 개발을 빠르고 편하게 할 수 있도록 도와주는 경량 프레임워크.

    - 왜 '경량' 프레임워크인가?
        초기 서버사이드 처리는 직접 쓰레드, 소켓연결 등을 개발자들이 직접 처리했고, 개발자 마다 구현하는 방법이 다 달라 협업에 불편함이 많았다.
        정형화, 표준화 된 방법을 찾기 시작하면서 등장한 것이 Framework이다.
        EJB가 나왔지만 분산환경 처리에 특화된 EJB는 너무 무거운데다 불편한 점이 많았고, 이런 EJB에 반기를 들고 탄생한 '경량화'된 Java 엔터프라이즈용 Framework이 Spring인 것이다.

    - 왜 스프링을 사용하는가?
        스프링은 Framework이고, Framework은 개발자들이 좀 더 쉽고 편리하게 애플리케이션을 개발할 수 있도록 미리 갖춰진 구조를 말한다.
        Framework이 없었다면 개발자들은 처음부터 끝까지 직접 모든 구조를 만들어내야 할 것이다.
        스프링은 Application 개발에 필요한 하부 구조를 포괄적으로 제공함에 따라 개발자들의 실력의 간극을 메꿔줄 수 있는 데다가
        올바른 형태의 코드만 넣어준다면 일정 수준의 성능과 안정성을 보장해 줄 수 있다. 그 틀과 구조 위에서 개발자들은
        핵심 비즈니스 로직에만 집중할 수 있어서 생산성 또한 향상된다.


- Spring과 SpringBoot의 차이점
    (1) 내장 톰캣
        - 내장 톰캣을 사용하기 때문에 따로 톰캣을 설치하거나 매번 버전을 관리해 주지 않아도 된다.
    (2) starter를 통한 dependency를 자동화
        - 기존의 Spring에서는 dependency들의 호환되는 버전을 직접 설정
        - 스프링 부트에서는 이 starter를 통해 종속된 모든 라이브러리를 알맞게 찾아서 함께 가져오기 때문에 의존성이나 호환버전에 대해 신경 쓸 필요가 없다.
    (3) XML
        - View Resolver, 데이터 액세스 등의 xml 설정을 하지 않아도 된다.
    (4) jar
        - jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.
    (5) AutoConfigurator
        - 공통적으로 필요한 설정을 어노테이션을 이용하여 대신할 수 있다.
    (6) Spring Initializr
        - pring Initilizr를 사용하면 실행 환경이나 의존성 관리 등의 인프라 부분을 신경 쓸 필요 없이 바로 코딩을 시작할 수 있게끔 환경을 제공


- 실행 가능한 JAR로 개발 가능
    - 스프링 프로젝트를 배포하기 위해서는 war파일을 만들어 외장 웹서버에 배포해야 했다.
      하지만 스프링 부트는 순수 자바 애플리케이션 프로그램을 실행하는 것처럼 스프링부터 역시 jar로 실행 가능하도록 하였다.


- 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.
    - 일반적으로 프로그램의 흐름은 main()메서드처럼 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고, 생성하고, 오브젝트의 메서드를 호출하고,
      그 메서드 안에서 다음에 사용할 것을 결정하는 식의 작업이 반복되는데, 스프링 프레임워크에서는 애플리케이션 코드가 프레임워크에 의해 사용되어지는 구조.
      애플리케이션 컨텍스트가 빈의 생성과 관계설정 같은 제어를 담당한다.


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것.
    - 제어의 역행(IOC)으로 특정 객체에 필요한 다른 객체를 외부에서 결정해서 연결시키는 것.
    - 객체간의 결합을 느슨하게 만들어 유연하고 확장성이 뛰어난 코드를 작성하기 위한 패턴이다.

    1. 순환 참조를 방지
        하지만 생성자 주입은 먼저 생성자 인자에 사용되는 빈을 찾거나 빈 팩토리에서 만든다. 그 후에 찾은 인자 빈으로 주입하려는 빈의 생성자를 호출
        객체 생성 시점에 빈을 주입하기 때문에 서로 참조하는 객체가 생성되지 않은 상태에서 그 빈을 참조하기 때문에 오류가 발생


- Spring IoC/DI의 동작 과정은?
    IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종 호출은
    개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어진다.
    DI(의존관계 주입)은 스프링 프레임워크에서 지원하는 IoC의 형태로 객체(빈) 사이의 의존관계를 빈 설정 정보를 바탕으로 DI 컨테이너가 자동으로 연결한다.


- 스프링 부트
    - 의존성 관리
        스프링 부트는 starter- 를 통해서 의존성관리를 한다.

    - 자동 설정
        - @ComponentScan을 통해서 @Component, @Serveice, @Repository .. 와 같은 컴포넌트 기반을 스캐닝해서 우리가 정의한 빈들을 등록한다.
        - @EnableAutoConfiguration을 통해서, META-INF 하위에 있는 spring.factories 파일에 정의된 클래스들에 의해서 빈으로 등록된다.
          (@ConditionalOnMissingBean 같은 경우, 빈으로 등록되어있지 않은 경우, 저기에서 정의한 대로 빈으로 등록한다.)

    - 내장 웹서버
        메인 애플리케이션으로 띄울 수 있고, jar로 패키징된 파일 하나로 만들고, 해당 jar를 실행해서도 애플리케이션을 띄울 수 있다.
        여러 가지 설정을 할 수 있다.
            server.port = 0 (random)
            spring.main.web-application-type=none -> 내장 웹서버로 실행하지 않음
            https 설정, http2.0 설정


- 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
    - 설정만 해준다면(applicationContext.xml) 스프링은 그 설정 정보를 참고해서 객체를 생성,관리하고 그 관계를 맺어준다.
    - 핵심은 개발자가 new 연산자 등을 통해 객체를 생성할 필요가 없다는 것이다(제어의 역행-IoC).
    - 스프링 컨테이너에게 그 참조변수만 일러준다면(@Autowired나 setter주입 등) 스프링이 알아서 객체를 생성해주고, 관계를 맺어준다.

    2. 순환 참조를 방지
        - 생성자 주입 방식은 필드나 수정자 주입과는 빈을 주입하는 순서가 다르기 때문
        - 생성자를 통한 의존성 주입의 장점은 객체 생성 시점에서 순환 참조가 일어나기 때문에 스프링 애플리케이션이 실행되지 않습니다.
          (앱 구동 단계에서 오류를 찾을 수 있다.)
          컨테이너가 빈을 생성하는 시점에서 객체생성에 사이클 관계가 생기기 때문입니다.

    3. 테스트 코드 작성 용이
        - 스프링 컨테이너 도움 없이 테스트 코드를 더 편리하게 작성 가능
        - 생성자 주입이 아닌 다른 주입으로 작성된 코드는 순수한 자바 코드로 단위 테스트를 작성하는 것이 어렵다.
          필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는
          필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양
          Mock 객체를 만들어야 하는데 DI 컨테이너에 의존하는 바람에 독립적으로 인스턴스화가 불가능한 문제가 발생한다.
          DI 컨테이너에서 관리되는 클래스는 특정 컨테이너에 의존하지 않고 POJO여야 한다.
          스프링 컨테이너가 생성해서 주입해주는 방식이기 때문에
          반면 생성자 주입을 사용하면 객체를 생성할 때 원하는 구현체를 넘겨주면 되고, 구현체를 넘겨주지 않으면 객체 생성 자체가 불가능


- DI   https://mangkyu.tistory.com/150
    - 정의
        DI란 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고
        런타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다.

    - 필요성
        - 두 클래스가 강하게 결합되어 있음
        - 객체들 간의 관계가 아니라 클래스 간의 관계가 맺어짐


- 스프링 컨테이너(Spring Container)란?
    - 빈의 생성,관계설정,생명주기 등을 관장하는 컨테이너.

    - 객체(빈)관리의 관점에서 Application Context를 스프링 컨테이너라고 부른다.
    - Application Context는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데,
      그러한 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용되고, 이를 통틀어서 스프링 컨테이너라고 볼 수 있다.


- POJO
    어느 곳에 종속되지 않은 순수한 자바 객체.

    과거에 자바로 웹 애플리케이션을 만들기 위해 Servlet클래스를 상속받아 구현했어야 했다. 서블릿 컨테이너 안에서 서블릿으로 존재하기 위해서는 그 구현이 강제되었던 것이다.
    그렇게 강제된 구현으로 만들어진 서블릿 객체는 서블릿 컨테이너 환경에서 사용되어질 수 있다. 이는 그 환경에 종속 되어 있기에 POJO라고 할 수 없다.
    어느 곳에 종속되지 않는다는 의미는, 해당 클래스를 사용하기 위해 외부 환경(like 프레임워크)이 필요하고, 해당 환경이 특정 인터페이스를 구현할 것을 강요하는 등의 제약에서 자유롭다는 것을 의미한다.
    (따라서 단순히 외부 구동환경과 무관한 다른 클래스의 상속 또는 구현은 상관 없다.)
    즉, 다시말해 POJO는 외부환경(like Spring MVC)을 걷어내도 정상적으로 작동이 되어야 한다는 것이다.
    Spring은 개발자가 직접 위와같이 Servlet클래스를 작성하지 않고 POJO만으로 웹 애플리케이션을 구축할 수 있다는 것이 특징이다.(개발자가 비즈니스로직만 신경 쓸 수 있다)

    스프링에서 생성되어 관리되는 POJO 기반의 객체를 Spring Bean이라고 합니다.
    여기서 POJO는 단순 getter, setter만으로 구성되어 있으며 단순히 new를 통해서 생성 가능한 형태를 말합니다.
    핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있고, 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스입니다.


- spring bean 생명주기
    1. 빈 객체 생성
    2. BeanNameAware.setBeanName()
        의 id/name 속성에 지정된 값 전달
            - 스프링에서 관리되는 bean 내부에서 id나 name이 무엇으로 지정되어 있는지 확인하는 경우 BeanNameAware Interface를 구현한다.
            - 이때 그림의 노란색 부분처럼 bean생성과 property 의존성 주입을 완료한 이후, init method를 수행하기 전 시점에 호출된다.
    3. BeanFactoryAware.setBeanFactory()
        - bean객체에 bean을 관리하는 BeanFactory 객체 전달
    4. BeanPostProcessor의 초기화 전처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 되기전 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
    5. 커스텀 init - method
        - @PostConstruct
    6. InitializingBean.afterPropertiesSet()
    7. BeanPostProcessor의 초기화 후처리
        - 아래의 두 메서드를 적용하여 빈이 초기화 된 후 빈의 상태 조사 , 수정 , 확인등의 작업을 할 수 있습니다.
        - postProcessAfterInitialization
    8. 빈 객체 사용
    9. DisposableBean.destroy()
    10. 커스텀 destroy - method 2_8_ii


- 빈(Bean)이란?
    - 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트.
    - 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니고, 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
    - POJO와 설정(Configuration. xml이나 어노테이션)을 Spring의 컨테이너에 주입시키면 Bean으로 등록되고 사용할 수 있다.


- 스프링 빈(Spring Bean)이란?
    - 스프링 IoC 컨테이너에 의해서 관리되고 애플리케이션의 핵심을 이루는 객체들을 스프링 빈
    - 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서,
      강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있는데 대표적으로 프로토타입 스코프가 있다.
      프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할때마다 매번 새로운 오브젝트를 만들어 준다. 스코프는 xml과 어노테이션 설정으로 가능하다.


- Filter vs Interceptor vs AOP
    - Filter
        - 필터에서는 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리
        - Filter는 다음 체인으로 넘기는 ServletRequest/ServletResponse 객체를 조작할 수 있다는 점에서 Interceptor보다 훨씬 강력한 기술
        - 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리되므로 DispatcherServlet으로 가기 전에 요청을 처리하는 것

        ex) 보안 관련 공통 작업
            모든 요청에 대한 로깅 또는 감사
            이미지/데이터 압축 및 문자열 인코딩

    - 인터셉터(Interceptor)
        - 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트 내부에서 Controller에 관한 요청과 응답에 대해 처리
        - 스프링의 모든 빈 객체에 접근할 수 있다.
        - 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다.
        - 필터와 다르게 HttpServletRequest나 HttpServletResponse 등과 같은 객체를 제공받으므로 객체 자체를 조작할 수는 없다.

        ex) 인증/인가 등과 같은 공통 작업
            API 호출에 대한 로깅 또는 감사
            Controller로 넘겨주는 정보(데이터)의 가공

        - Filter의 doFilter 메서드는 매개변수로 ServletRequest와 ServletResponse를 받고 Interceptor의 preHandle이나 postHandle은 HttpServletRequest를 받는다.
        - ServletRequest는 기본적인 클라이언트 요청에 관한 모든 정보를 가지고 있다. 그리고 이 인터페이스는 다시 HttpServletRequest로 확장하여
          HTTP 프로토콜 상에서 할 수 있는 일들이 포함되어져 있다.
          이 HttpServletReqeust는 서블릿의 service의 매개변수의 하나로 서블릿 프로그래머가 클라이언트의 요청에 관한 작업들을 핸들할 수 있도록하는 중요한 역할을 담당하고 있다.

    - 용도
        필터
            필터에서는 기본적으로 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리.
            대표적으로 보안 공통 작업이 있다.
            필터는 인터셉터보다 앞단에서 동작하므로 전역적으로 해야하는 보안 검사(XSS 방어 등)를 하여 올바른 요청이 아닐 경우 차단을 할 수 있다.
            그러면 스프링 컨테이너까지 요청이 전달되지 못하고 차단되므로 안정성을 더욱 높일 수 있다.
            필터는 이미지나 데이터의 압축이나 문자열 인코딩과 같이 웹 애플리케이션에 전반적으로 사용되는 기능을 구현하기에 적당하다.

        인터셉터
            인터셉터에서는 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있다.
            대표적으로 세부적으로 적용해야 하는 인증이나 인가와 같이 클라이언트 요청과 관련된 작업 등이 있다.
            예를 들어 특정 그룹의 사용자는 어떤 기능을 사용하지 못하는 경우가 있는데, 이러한 작업들은
            컨트롤러로 넘어가기 전에 검사해야 하므로 인터셉터가 처리하기에 적합하다.
            API 호출에 대한 로깅, Controller로 넘겨주는 정보(데이터)의 가공하기에 용이

    - Filter는 다음 체인으로 넘기는 ServletRequest/ServletResponse 객체를 조작할 수 있다.

    - AOP
        - Interceptor와 Filter와 달리 메소드 전 후의 지점에 자유롭게 설정이 가능하며 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.
        - 로깅, 트랜잭션, 에러 처리 등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용


- Filter vs Interceptor vs AOP
    - Interceptor와 Filter는 Servlet 단위에서 실행된다. <> 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.

    - Filter(필터)
        요청과 응답을 거른뒤 정제하는 역할
        서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러가지 체크를 수행할 수 있다.
        또한 자원의 처리가 끝난 후 응답내용에 대해서도 변경하는 처리를 할 수가 있다.
        보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS방어 등의 요청에 대한 처리로 사용된다.

    - Interceptor(인터셉터)
        요청에 대한 작업 전/후로 가로챈다.
        필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다.
        하지만 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에
        스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.
        스프링의 모든 빈 객체에 접근할 수 있다.
        로그인 체크, 권한체크, 프로그램 실행시간 계산작업 로그확인 등의 업무처리

    - AOP
        OOP를 보완하기 위해 나온 개념
        객체 지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.
        주로 '로깅', '트랜잭션', '에러 처리'등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용합니다.
        Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다.
        Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다.

        AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이다.
        Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다.
        반면 HandlerInterceptor는 Filter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다.


- 서블릿 필터 vs 스프링 인터셉터
    많은 로직에서 공통으로 관심이 있는 부분을 공통 관심사(cross-cutting concerns)라 한다.

    둘 다 자유롭게 필터 및 인터셉터를 체인 형태로 추가할 수 있다.

    필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다.
    인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에
    스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.

    필터는 공통된 보안 및 인증/인가 관련 작업, Spring과 분리되어야 하는 기능
    인터셉터는 로그인 체크, 권한 체크

- Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.
    - Spring Filter
        - 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리
        - Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공
        ex) 보안 및 인증/인가 관련 작업
            모든 요청에 대한 로깅 또는 검사
            이미지/데이터 압축 및 문자열 인코딩
            Spring과 분리되어야 하는 기능

    - Interceptor
        - 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작
        - Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
        ex) 세부적인 보안 및 인증/인가 공통 작업
            API 호출에 대한 로깅 또는 검사
            Controller로 넘겨주는 정보(데이터)의 가공

    필터는 서블릿에서 제공하고 인터셉터는 스프링 MVC가 제공하는 기술인데, 적용되는 순서와 범위, 그리고 사용방법이 다르다.
    필터를 적용하면 필터가 호출된 이후 서블릿이 호출된다.
    인터셉터를 적용하면 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출된다.
    인터셉터는 서블릿 호출 이후 호출되기에 인터셉터는 서블릿에서 예외가 발생한다면 호출되지 않는다.


- 선언적 트랜잭션 속성
    - propagation
        - 트랜잭션 전파란 트랜잭션 경계에서 이미 진행중인 트랜잭션이 있을 경우 어떻게 동작할지 결정하는 것

        - REQUIRED (디폴트)
            - 이미 시작된 트랜잭션이 있으면 그 트랜잭션에 참여
            - 모든 트랜잭션 매니저가 지원합니다.
            - 해당 메서드를 호출한 곳에서 별도의 트랜잭션이 설정되어 있지 않다면 트랜잭션을 새로 시작
            - 부모 트랜잭션이 존재하면 포함되어 동작

        - SUPPORTS
            - 진행 중인 트랜잭션이 있으면 REQUIRED 처럼 참여하고 트랜잭션이 없으면 트랜잭션 없이 메서드를 실행
            - 해당 경계 안에서 Connection 객체나 하이버네이트의 Session 등은 공유 가능

        - MANDATORY
            - 진행 중인 트랜잭션이 있으면 참여하고 없으면 예외가 발생. 혼자서는 트랜잭션을 시작할 수 없고 메서드를 실행할 수도 없다.
            - 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용

        - REQUIRES_NEW
            - 항상 새로운 트랜잭션을 시작한다. 진행중인 트랜잭션이 있으면 잠시 보류시키고 새로운 트랜잭션으로 실행
            - 새로운 트랜잭션 안에서 예외가 발생해도 호출한 곳으로 롤백이 전파되지 않는다
            - 부모 트랜잭션이 존재하면 2개의 트랜잭션이 완전 독립적으로 동작

        - NOT_SUPPORTED
            - 이미 시작된 트랜잭션이 있으면 보류하고 자신의 메서드를 실행하는, 트랜잭션을 사용하지 않는 설정
              진행중인 트랜잭션이 있으면 보류하고 자신의 메서드 실행
            - 트랜잭션을 사용하지 않는다.
            - 부모 트랜잭션이 존재하면 보류시키고 트랜잭션 사용을 정지시킨다

        - NEVER
            - 트랜잭션을 사용하지 않도록 강제. 진행중인 트랜잭션이 없다면 자신의 메서드를 실행하지만 트랜잭션이 있다면 예외 발생

        - NESTED
            - 이미 진행 중인 트랜잭션 있으면 그 안에 새로운 트랜잭션을 만드는 설정.
            - 트랜잭션1 내부에 메서드 2를 트랜잭션 2로 삽입
            - 이렇게 중첩된 트랜잭션 2는 부모인 트랜잭션1의 커밋/롤백에는 영향을 받지만,
              트랜잭션2의 커밋/롤백에는 트랜잭션1이 영향을 받지 않는다.
            - 부모 트랜잭션의 커밋과 롤백에 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않는다
                예시) 메인작업을 진행하며 이와 관련된 로그를 DB에 저장
                     메인 작업이 실패 -> 로그 작업 롤백
                     로그를 저장하는 작업이 실패 -> 메인 작업의 트랜잭션은 롤백 X
            - 모든 트랜잭션 매니저에 적용 가능하진 않다.


- 모델1 방식이란?
    - JSP에 비즈니스 로직과 화면영역을 함께 구현하는 방식. (비즈니스 로직과 화면을 분리하지 않은 방식)
    - 비즈니스 로직이 복잡하지 않거나 소규모 프로젝트일 경우 빠르고 쉽게 개발할 수 있다는 장점이 있지만,
      출력을 위한 뷰 코드와 로직처리를 위한 자바 코드가 함께 섞여있기 때문에 JSP코드 자체가 복잡하고, 분업에 용이하지 않으며 유지보수가 어렵다.


-  모델2 방식이란?
    - 화면과 비즈니스 로직이 분리되어있는 방식.
    - 화면출력을 위한 뷰 코드는 JSP에서, 로직 처리를 위한 자바코드는 Servlet에서 처리하도록 분리하기 때문에 분업이 용이하고 유지보수가 쉽다.


- spring aop vs aspectj
    - spring aop
        - 런타임 위빙 만 사용할 수 있다
        - 덜 강력 함 – 메서드 수준 위빙 만 지원
        - Spring 컨테이너가 관리하는 Bean에서만 구현 가능
        - AspectJ보다 훨씬 느림
            Runtime weaving: Aspect 가 대상 객체의 Proxy(JDK 동적 Proxy 나 CGLIB 의 Proxy)를 실행시 Weaving 된다

    - aspectj
        - 런타임때 아무것도 안한다. Aspect를 코드에 Weaving하기 위해, AspectJ compiler(ajc)라는 컴파일러를 도입한다.
        - 컨파일 시점 위빙
        - 더욱 강력 함 – 필드, 메서드, 생성자, 정적 이니셜 라이저, 최종 클래스 / 메서드 등을 엮을 수 있다
        - 모든 도메인 개체에서 구현 가능
        - 모든 포인트 컷 지원
        - 애플리케이션이 실행되기 전에 (런타임 전에) Aspect가 코드로 직접 짜여짐


- jdk dynamic proxy vs CGLIB(code Generator Library)
    - Spring AOP는 프록시 기반으로 JDK Dynamic Proxy와 CGLIB을 활용하여 AOP 제공하고 있습니다.
    - JDK Dynamic Proxy는 인터페이스를 구현하여 Proxy를 생성
    - CGLib은 클래스를 상속받아 Proxy를 생성
    - 성능의 차이
        - 성능의 차이의 근본적인 이유는 CGLib은 타깃에 대한 정보를 제공 받기 때문입니다.
        - 따라서 CGLib은 제공받은 타깃 클래스에 대한 바이트 코드를 조작하여 Proxy를 생성


- 스프링 시큐리티
    - 스프링 시큐리티는 스프링 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크입니다.
      즉 인증(Authenticate, 누구인지?) 과 인가(Authorize, 어떤것을 할 수 있는지?)를 담당하는 프레임워크를 말합니다.
    - 스프링 시큐리티에서는 주로 서블릿 필터(filter)와 이들로 구성된 필터체인으로의 구성된 위임모델을 사용합니다. 그리고 보안과 관련해서
      체계적으로 많은 옵션을 제공해주기 때문에 개발자 입장에서는 일일이 보안관련 로직을 작성하지 않아도 된다는 장점이 있습니다.

    기본용어
    접근 주체(Principal) : 보호된 리소스에 접근하는 대상
    인증(Authentication) : 보호된 리소스에 접근한 대상에 대해  누구인지, 애플리케이션의 작업을 수행해도 되는 주체인지 확인하는 과정
                            (ex. Form 기반 로그인) => 즉, 누구인지?
    인가(Authorize) : 해당 리소스에 대해 접근 가능한 권한을 가지고 있는지 확인하는 과정(After Authentication, 인증 이후)
                        => 즉, 어떤 것을 할 수 있는지?
    권한 : 어떠한 리소스에 대한 접근 제한, 모든 리소스는 접근 제어 권한이 걸려있음.
          인가 과정에서 해당 리소스에 대한 제한된 최소한의 권한을 가졌는지 확인

    - 보안과 관련하여 체계적으로 많은 옵션을 제공하여 편리하게 사용할 수 있음
    - Filter 기반으로 동작하여 MVC 와 분리하여 관리 및 동작
    - 어노테이션을 통한 간단한 설정
    - Spring Security 는 기본적으로 세션 & 쿠키방식으로 인증
    - 인증관리자(Authentication Manager)와 접근 결정 관리자(Access Decision Manager)를 통해 사용자의 리소스 접근을 관리
    - 인증 관리자는 UsernamePasswordAuthenticationFilter, 접근 결정 관리자는 FilterSecurityInterceptor 가 수행

    - Spring Security 를 사용하지 않으면
        자체적으로 세션을 체크해야 한다.
      redirect 를 일일이 설정해주어야 한다.
        로그인 완료 시 다음 화면으로 넘어가기 등


    - 스프링 시큐리티 가이드에서는 8가지 이유에 대해 스프링 시큐리티의 특징을 적어놓았다.
         모든 URL 에 대해서 인증을 요구한다.
         로그인 폼을 생성한다.
         기초적인 폼에 대해서 사용자 이름과 비밀번호를 요구한다.
         사용자에 대한 로그아웃 기능도 있다.
         CSRF(Cross Site Request Forgery) 공격을 방어한다.
         CSRF 공격이란 ? 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격을 말한다.
         출처: https://swk3169.tistory.com/24 [swk의 지식저장소]
         Session Fixsation을 방어한다.
         공격자가 자신의 세션 id를 다른 사용자에게 줌으로써 공격하는 방법.
         요청 헤드 보안
         HSTS 강화
         강제적으로 HTTPS로 접속하도록 만드는 기
         https://m.blog.naver.com/PostView.nhn?blogId=aepkoreanet&logNo=221575708943&proxyReferer=https:%2F%2Fwww.google.com%2F
         X-Content-TypeOptions
         캐시 컨트롤(정적 리소스 캐싱)
         X-XSS-Protection XSS 보안
         스크립트 공격 보안
         클릭재킹을 보안하기 위한 X-Frame-Options 통
         웹 사용자가 자신이 클릭하고 있다고 인지하는 것과 다른 어떤 것을 클릭하게 속이는 악의적인 기법으로써 잠재적으로 공격자는 비밀 정보를 유출시키거나 그들의 컴퓨터에 대한 제어를 획득할 수 있게 된다
         Servlet API 제공

    - 동작 순서
        1. Http Request 수신
            (요청이 들어오면, 인증과 권한을 위한 필터들을 통하게 된다.)
        2. username 과 password 를 요청에서 추출하여 인증토큰(AuthenticationToken) 만들기
        3. Filter 를 통해 AuthenticationToken 을 AuthenticationManager 에 위임하여 인증 메소드 호출
        4. ProviderManager 에 의해 제공된 AuthenticationProvider 의 목록으로 인증을 시도한다.
        5. UserDetails 를 이용해서 User 객체에 대한 정보를 검색한다.
        6. DB 에서 User 객체에 매핑된 정보를 가져와 UserDetailsService(LoginService)에 전달한다.
        7. 전달된 User 객체의 정보와 사용자가 요청한 인증 정보(username, password)를 확인
        8. 유저의 인증이 성공하면, 전체 인증정보를 리턴한다.
           인증에 실패하면 AuthenticationException 을 던진다.
        9. AuthenticationManager 는 완전한 인증(Fully Populated Authentication)객체를 Authentication Filter 에 반환한다.
        10. AuthenticationFilter 는 인증 객체를 SecurityContext 에 저장한다.


        1. 사용자가 Form으로 로그인 정보를 입력하고 Http프로토콜로 인증요청을 Server로 보냄
        2. AuthenticationFilter (UsernamePasswordAuthenticationFilter)가 HttpServletRequest에서 사용자가 보낸 아이디와 패스워드를 인터셉트 함
        아이디와 패스워드 유효성 검사 이후 HttpServletRequest에서 사용자아이디, 패스워드 인증을 담당할 AuthenticationManager 인터페이스(Providermanager)에게 인증용 객체(UsernamePasswordAuthenticationToken)를 위함
        3. AuthenticationFilter 에 인증용 객체(UsernamePasswordAuthenticationToken) 전달
        4. 인증할 AuthenticationProvider에게 Authentication 객체 (UsernamePasswordAuthenticationToken) 다시전달 받음
        5. DB에서 사용자 인증정보를 가져올 UserDetailService에 유니크한 식별자(email, hp, name, id)를 전달 후
        사용자 정보(사용자아이디, 암호화된 패스워드, 권한)를 UserDetails(인증용 객체와 도메인 객체를 분리하지 않기 위해서 실제 사용되는 도메인 객체 UserDetails 상속하기도 함) 객체로 전달 받음
        6. AuthenticationProvider는 UserDetails 객체를 전달 받은 이후 실제 사용자의 입력정보와 UserDetails 객체를 가지고 인증 시도
        7,8,9 요청한 내용들을 기반으로 Response전달함.
        10. 인증이 완료되면 사용자 정보를 가진 Authentication 객체를 SecurityContextHolder에 담은 이후 AuthenticationSuccessHandle를 실행
        (실패시 AuthenticationFailureHandler 실행)

- 스프링 배치
    - 일괄 처리를 위한 오픈 소스 프레임워크
    - Spring Batch 는 엔터프라이즈 시스템의 운영에 있어 대용량 일괄처리의 편의를 위해 설계된 가볍고 포괄적인 배치 프레임워크다.
      Spring 의 특성을 그대로 가져왔기 때문에 DI, AOP, 서비스 추상화 등 Spring 프레임워크의 3대 요소를 모두 사용할 수 있다.
    - Spring batch 는 Spring MVC 처럼 개발자들이 온전히 비즈니스 로직의 개발에만 집중할 수 있도록 합니다. 이와 연결되는 사항 중 하나로
      바로 확장성과 안정성을 볼 수 있습니다. 과거 메인 프레임 방식이나 배치를 커스텀으로 개발해서 처리 했던 방식은 배치 내 Job 들의
      병렬 처리 시 고려할 사항이 많았습니다. 결국 이로 인해 배치 프로그램의 확장성과 안정성이 떨어지는 결과를 초래했고 Spring batch 는
      개발자들이 더 이상 이러한 부분에서 고민하지 않도록 만들어 준 것입니다.

    - 스프링 배치 사용 이유
        - 대용량의 비즈니스 데이터를 복잡한 작업으로 처리해야하는 경우
        - 특정한 시점에 스케쥴러를 통해 자동화된 작업이 필요한 경우 (ex. 푸시알림, 월 별 리포트)
        - 대용량 데이터의 포맷을 변경, 유효성 검사 등의 작업을 트랜잭션 안에서 처리 후 기록해야하는 경우
          Spring Batch 는 로깅/추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작, 건너뛰기, 리소스 관리 등 대용량 레코드 처리에
          필수적인 재사용 가능한 기능을 제공한다. 또한 최적화 및 파티셔닝 기술을 통해 대용량 및 고성능 일괄 작업을
          가능하게 하는 고급 기술 서비스 및 기능을 제공한다.

        - 일정 주기로 실행해야 할 떄
          실시간 처리가 어려운 대량의 데이터를 처리해야 할 때
          -> 이런 작업을 하나의 어플리케이션에서 수행하면 성능 저하를 유발할 수 있으니 배치 어플리케이션을구현

        - 트랜잭션 타임 아웃 발생 시 실패한 작업부터 재시도
        - 사용자의 접속이 거의 없는 시간대에 주기적인 시도

    - 스프링 배치 아키텍처
        Application : Spring Batch 를 사용하여 개발자가 작성한 모든 배치 작업과 사용자 정의 코드
        Batch Core : 배치 작업을 시작하고 제어하는 데 필요한 핵심 런타임 클래스를 포함
        Batch Infrastructure : 개발자와 애플리케이션에서 사용하는 일반적인 Reader 와 Writer
                               그리고 RetryTemplate 과 같은 서비스를 포함

        스프링 배치는 계층 구조가 위와 같이 설계되어 있기 때문에 개발자는 Application 계층의 비즈니스 로직에 집중할 수 있고,
        배치의 동작과 관련된 것은 Batch Core 에 있는 클래스들을 이용하여 제어할 수 있다.


- AOP 용어
    - Target
        - Aspect를 적용하는 곳

        - 부가 기능을 부여할 대상
        - Aspect 가 적용되는 곳
        - 먼저 Target Object는 횡단기능(Advice)이 적용될 객체(Object)를 뜻한다.
        - 이 객체는 핵심 모듈(비즈니스 클래스)이라 할 수 있다. Spring AOP에선 Advice를 받는 객체라 하여 Adviced Object라는 용어로 쓰이기도 한다.
        - Spring AOP에선 실제 적용할 객체 대신 Runtime Proxy를 사용하여 구현되기 때문에, Target Object는 항상 Proxy Object다.

    - Advice
        - 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.

        - Advice는 JoinPoint에 적용할 횡단 코드를(공통코드) 의미한다. 어떤 부가 기능 ? Before , AfterReturing , AfterThrowing , After , Around

    - JoinPoint
        - Advice 가 Target에 적용되는 위치

        - 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
        - JoinPoint는 Target Object안에서 횡단기능(Advice)이 적용될 수 있는 여러 위치를 뜻한다. 어디에 적용할 것인가? 메서드 , 필드 , 객체 , 생성자등

    - Pointcut
        - Joint Point 의 상세 스펙을 정의한 것
        - 구체적으로 Advice가 실행될 시점을 정함.

        어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

- Spring 에서 AOP 를 구현한 방법
    - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
        - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
        - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
        - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
        - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용


- 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
    - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
      좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
    - 컴파일된 Target의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채 바이트코드를 조작하는 방법을 사용한다.
      그렇기 때문에 .java파일과 .class 파일을 비교해보면 내용이 달라진걸 확인할 수 있다.
    - 바이트코드 조작을 사용하는 이유는 두 가지 이유
        1. 스프링과 같은 DI컨테이너의 도움을 받지 않아도 AOP를 적용할 수 있기 때문이다.
           그렇기에 스프링과같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP의 적용이 가능해진다.
        2. 프록시 방식보다 강력하고 유연한 AOP가 가능하다.
           프록시를 AOP의 핵심 메커니즘으로 사용할 경우 부가기능(공통 모듈)을 부여할 대상은 클라이언트가 호출할 때 사용하는 메소드로 제한된다.
           하지만, 바이트코드 조작 방식을 사용하면, 오브젝트의 생성, 필드 값 조회및 조작, 스태틱 초기화 등 다양한 작업에 부가기능을 부여할 수 있다.

- 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입 (스프링 AOP가 사용하는 방법)
    프록시로 만들어서 DI 로 연결된 빈 사이에 적용해 Target의 메소드 호출 과정에 참여해 부가 기능(공통 모듈)을 제공해준다.
    런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.
    Advice 가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프록시의 InvocationHandler와 마찬가지로 프록시부터
    메소드 요청정보를 전달받아 타깃 오브젝트의 메소드를 호출하는데, 이렇게 메소드를 호출하는 전/후로 부가기능(공통 모듈)을 제공할 수 있다.