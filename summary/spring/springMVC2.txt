3.메시지, 국제화
    3.1 메시지, 국제화 소개
        - 메시지
            - 다양한 메시지를 한 곳에서 관리하도록 하는 기능을 메시지 기능이라 한다. (messages.properties)
        - 국제화
            - messages.properties 를 각 나라별로 별도로 관리 (messages_en.properties, messages_ko.properties)

    3.2 스프링 메시지 소스 설정
        - 직접 등록
            - 메시지 관리 기능을 사용하려면 스프링이 제공하는 MessageSource 를 스프링 빈으로 등록하면 되는데,
              MessageSource 는 인터페이스이다. 따라서 구현체인 ResourceBundleMessageSource 를 스프링 빈으로
              등록하면 된다.

        - 스프링 부트
            - 스프링 부트를 사용하면 스프링 부트가 MessageSource 를 자동으로 스프링 빈으로 등록한다.

    3.3 스프링 메시지 소스 사용
        - 국제화 파일 선택
            - locale 정보를 기반으로 국제화 파일을 선택한다.
              Locale 이 en_US 의 경우 messages_en_US messages_en messages 순서로 찾는다.
              Locale 에 맞추어 구체적인 것이 있으면 구체적인 것을 찾고, 없으면 디폴트를 찾는다.

    3.4 웹 어플리케이션 국제화 적용하기
        - 웹 브라우저의 언어 설정 값을 변경하면 요청시 Accept-Language 의 값이 변경된다.
        - 스프링도 Locale 정보를 알아야 언어를 선택할 수 있는데, 스프링은 언어 선택시 기본으로 Accept-Language 헤더의 값을 사용한다.
        - LocaleResolver
          스프링은 Locale 선택 방식을 변경할 수 있도록 LocaleResolver 라는 인터페이스를 제공하는데,
          스프링 부트는 기본으로 Accept-Language 를 활용하는 AcceptHeaderLocaleResolver 를 사용한다.

4.Validation
    4.1 BindingResult
        - 필드에 오류가 있으면 FieldError 객체를 생성해서 bindingResult 에 담아두면 된다.
        - 특정 필드를 넘어서는 오류가 있으면 ObjectError 객체를 생성해서 bindingResult 에 담아두면 된다.
        - 스프링이 제공하는 검증 오류를 보관하는 객체이다. 검증 오류가 발생하면 여기에 보관하면 된다.
          BindingResult 가 있으면 @ModelAttribute 에 데이터 바인딩 시 오류가 발생해도 컨트롤러가 호출된다!
        - BindingResult 는 검증할 대상 바로 다음에 와야한다. 순서가 중요하다.

    4.2 FieldError, ObjectError
        - 타입 오류로 바인딩에 실패하면 스프링은 FieldError 를 생성하면서 사용자가 입력한 값을 넣어둔다.
          그리고 해당 오류를 BindingResult 에 담아서 컨트롤러를 호출한다.

    4.3 오류 코드와 메시지 처리1
        - FieldError , ObjectError 의 생성자는 errorCode , arguments 를 제공한다. 이것은 오류 발생시 오류
          코드로 메시지를 찾기 위해 사용된다.

        - errors 메시지 파일 생성
          messages.properties 를 사용해도 되지만, 오류 메시지를 구분하기 쉽게 errors.properties 라는
          별도의 파일로 관리해보자.

    4.4 오류 코드와 메시지 처리2
        - BindingResult 가 제공하는 rejectValue() , reject() 를 사용하면 FieldError , ObjectError 를
          직접 생성하지 않고, 깔끔하게 검증 오류를 다룰 수 있다.

    4.5 오류 코드와 메시지 처리3
        - 가장 좋은 방법은 범용성으로 사용하다가, 세밀하게
          작성해야 하는 경우에는 세밀한 내용이 적용되도록 메시지에 단계를 두는 방법이다.
        - 스프링은 MessageCodesResolver 라는 것으로 이러한 기능을 지원한다.

    4.8 오류 코드와 메시지 처리4
        - 정리
            1. rejectValue() 호출
            2. MessageCodesResolver 를 사용해서 검증 오류 코드로 메시지 코드들을 생성
            3. new FieldError() 를 생성하면서 메시지 코드들을 보관
            4. th:errors 에서 메시지 코드들로 메시지를 순서대로 메시지에서 찾고, 노출

        - 검증 오류 코드는 다음과 같이 2가지로 나눌 수 있다.
          개발자가 직접 설정한 오류 코드 rejectValue() 를 직접 호출
          스프링이 직접 검증 오류에 추가한 경우(주로 타입 정보가 맞지 않음)

    4.9 Validator 분리
        - validator 를 직접 호출하는 부분이 사라지고, 대신에 검증 대상 앞에 @Validated 가 붙었다.
        - 동작 방식
          @Validated 는 검증기를 실행하라는 애노테이션이다.
          이 애노테이션이 붙으면 앞서 WebDataBinder 에 등록한 검증기를 찾아서 실행한다. 그런데 여러 검증기를
          등록한다면 그 중에 어떤 검증기가 실행되어야 할지 구분이 필요하다. 이때 supports() 가 사용된다.
          여기서는 supports(Item.class) 호출되고, 결과가 true 이므로 ItemValidator 의 validate() 가 호출된다.

        - @Validated 는 스프링 전용 검증 애노테이션이고, @Valid 는 자바 표준 검증 애노테이션이다.

5.Bean Validation
    - 이런 검증 로직을 모든 프로젝트에 적용할 수 있게 공통화하고, 표준화 한 것이 바로 Bean Validation 이다.
      Bean Validation 을 잘 활용하면, 애노테이션 하나로 검증 로직을 매우 편리하게 적용할 수 있다.
    - Bean Validation 을 구현한 기술중에 일반적으로 사용하는 구현체는 하이버네이트 Validator 이다.

    - 스프링 부트가 spring-boot-starter-validation 라이브러리를 넣으면 자동으로 Bean Validator 를
      인지하고 스프링에 통합한다.
    - 스프링 부트는 자동으로 글로벌 Validator 로 등록한다.
    - 이렇게 글로벌 Validator 가 적용되어 있기 때문에, @Valid , @Validated 만 적용하면 된다.
      검증 오류가 발생하면, FieldError , ObjectError 를 생성해서 BindingResult 에 담아준다.
    - 다음과 같이 직접 글로벌 Validator 를 직접 등록하면 스프링 부트는 Bean Validator 를 글로벌
      Validator 로 등록하지 않는다. 따라서 애노테이션 기반의 빈 검증기가 동작하지 않는다.

    - 검증 순서
        1. @ModelAttribute 각각의 필드에 타입 변환 시도
            - 성공하면 다음으로
            - 실패하면 typeMismatch 로 FieldError 추가
        2. Validator 적용

    - 바인딩에 성공한 필드만 Bean Validation 적용 BeanValidator 는 바인딩에 실패한 필드는 BeanValidation 을 적용하지 않는다.

    - 방법 2가지
        - BeanValidation 의 groups 기능을 사용한다.
        - Item 을 직접 사용하지 않고, ItemSaveForm, ItemUpdateForm 같은 폼 전송을 위한 별도의 모델 객체를 만들어서 사용한다.

    - @ModelAttribute vs @RequestBody
      HTTP 요청 파리미터를 처리하는 @ModelAttribute 는 각각의 필드 단위로 세밀하게 적용된다. 그래서
      특정 필드에 타입이 맞지 않는 오류가 발생해도 나머지 필드는 정상 처리할 수 있었다.
      HttpMessageConverter 는 @ModelAttribute 와 다르게 각각의 필드 단위로 적용되는 것이 아니라,
      전체 객체 단위로 적용된다.
      따라서 메시지 컨버터의 작동이 성공해서 Item 객체를 만들어야 @Valid , @Validated 가 적용된다.

6.로그인 처리1 - 쿠키, 세션
    - 도메인 = 화면, UI, 기술 인프라 등등의 영역은 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을 말함
      향후 web 을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다.
      이렇게 하려면 web 은 domain 을 알고있지만 domain 은 web 을 모르도록 설계해야 한다. 이것을 web 은
      domain 을 의존하지만, domain 은 web 을 의존하지 않는다고 표현한다. 예를 들어 web 패키지를 모두
      삭제해도 domain 에는 전혀 영향이 없도록 의존관계를 설계하는 것이 중요하다. 반대로 이야기하면
      domain 은 web 을 참조하면 안된다.

    6.1 로그인 처리하기 - 쿠키 사용
        - 쿠키에는 영속 쿠키와 세션 쿠키가 있다.
          영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
          세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

        - 브라우저 종료시 로그아웃이 되길 기대하므로, 우리에게 필요한 것은 세션 쿠키이다.
        - @CookieValue 를 사용하면 편리하게 쿠키를 조회할 수 있다.

    6.2 쿠키와 보안 문제
        - 쿠키 값은 임의로 변경할 수 있다.
        - 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서
          토큰과 사용자 id를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다.
        - 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분)
          유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

    6.3 로그인 처리하기 - 세션 동작 방식
        - 생성된 세션 ID와 세션에 보관할 값( memberA )을 서버의 세션 저장소에 보관한다.
        - 서버는 클라이언트에 mySessionId 라는 이름으로 세션 ID 만 쿠키에 담아서 전달한다.
          클라이언트는 쿠키 저장소에 mySessionId 쿠키를 보관한다.

    6.4 로그인 처리하기 - 서블릿 HTTP 세션1
        - 서블릿을 통해 HttpSession 을 생성하면 다음과 같은 JSESSIONID 쿠키 생성

    6.5 로그인 처리하기 - 서블릿 HTTP 세션2
        - 스프링은 세션을 더 편리하게 사용할 수 있도록 @SessionAttribute 을 지원한다.

    6.6 세션 정보와 타임아웃 설정
        - 세션은 사용자가 로그아웃을 직접 호출해서 session.invalidate() 가 호출 되는 경우에 삭제된다.
          그런데 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료한다. 문제는 HTTP 가 비
          연결성(ConnectionLess)이므로 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지를
          인식할 수 없다. 따라서 서버에서 세션 데이터를 언제 삭제해야 하는지 판단하기가 어렵다.
          사용자가 서버에 최근에 요청한 시간을 기준으로 30분 정도 세션 유지.
          LastAccessedTime 이후로 timeout 시간이 지나면, WAS 가 내부에서 해당 세션을 제거한다.

        - 실무에서 주의할 점은 세션에는 최소한의 데이터만 보관해야 한다는 점이다. 보관한 데이터 용량 * 사용자
          수로 세션의 메모리 사용량이 급격하게 늘어나서 장애로 이어질 수 있다. 추가로 세션의 시간을 너무 길게
          가져가면 메모리 사용이 계속 누적 될 수 있으므로 적당한 시간을 선택하는 것이 필요하다. 기본이 30
          분이라는 것을 기준으로 고민하면 된다.

7.로그인 처리2 - 필터, 인터셉터
    7.1 서블릿 필터 - 소개
        - 공통 관심사는 스프링의 AOP 로도 해결할 수 있지만, 웹과 관련된 공통 관심사는 지금부터 설명할
          서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다. 웹과 관련된 공통 관심사를 처리할 때는 HTTP 의
          헤더나 URL 의 정보들이 필요한데, 서블릿 필터나 스프링 인터셉터는 HttpServletRequest 를 제공한다.

        - 필터 흐름
          HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러

        - 필터 제한
          HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 //로그인 사용자
          HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단, 서블릿 호출X) //비 로그인 사용자

        - 필터 체인
          HTTP 요청 -> WAS -> 필터1 -> 필터2 -> 필터3 -> 서블릿 -> 컨트롤러

        - 필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고, 관리한다.
          init(): 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
          doFilter(): 고객의 요청이 올 때 마다 해당 메서드가 호출된다. 필터의 로직을 구현하면 된다.
          destroy(): 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.

    7.2 서블릿 필터 - 요청 로그
        - chain.doFilter(request, response);
          이 부분이 가장 중요하다. 다음 필터가 있으면 필터를 호출하고, 필터가 없으면 서블릿을 호출한다.
          만약 이 로직을 호출하지 않으면 다음 단계로 진행되지 않는다.

        - 필터를 등록하는 방법은 여러가지가 있지만, 스프링 부트를 사용한다면 FilterRegistrationBean 을
          사용해서 등록하면 된다.
            - setFilter(new LogFilter()) : 등록할 필터를 지정한다.
            - setOrder(1) : 필터는 체인으로 동작한다. 따라서 순서가 필요하다. 낮을 수록 먼저 동작한다.
            - addUrlPatterns("/*") : 필터를 적용할 URL 패턴을 지정한다. 한번에 여러 패턴을 지정할 수 있다.

        - @ServletComponentScan @WebFilter(filterName = "logFilter", urlPatterns = "/*") 로
          필터 등록이 가능하지만 필터 순서 조절이 안된다. 따라서 FilterRegistrationBean 을 사용하자.

    7.3 서블릿 필터 - 인증 체크
        - isLoginCheckPath(requestURI)
          화이트 리스트를 제외한 모든 경우에 인증 체크 로직을 적용한다.

    7.4 스프링 인터셉터 - 소개
        - 서블릿 필터가 서블릿이 제공하는 기술이라면, 스프링 인터셉터는 스프링 MVC 가 제공하는 기술이다.
           웹과 관련된 공통 관심 사항을 처리하지만, 적용되는 순서와 범위, 그리고 사용방법이 다르다.

        - 스프링 인터셉터 흐름
          HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러

        - 스프링 인터셉터는 스프링 MVC 가 제공하는 기능이기 때문에 결국 디스패처 서블릿 이후에 등장하게 된다.
          스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과는 다르고, 매우 정밀하게 설정할 수 있다.

        - 스프링 인터셉터 제한
          HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러 //로그인 사용자
          HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터(적절하지 않은 요청이라 판단, 컨트롤러 호출 X) // 비 로그인 사용자

        - 스프링 인터셉터 체인
          HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> 컨트롤러

        - 스프링의 인터셉터를 사용하려면 HandlerInterceptor 인터페이스를 구현하면 된다.




