- 쿠키와 세션을 사용하는 이유가 무엇인가요?
    - HTTP의 비연결성, 비상태성이라는 특징때문에 클라이언트가 누구인지 어떤 권한을 가졌는지 등 기록하지 않기 때문에 필요합니다.


- 쿠키란 무엇인가요?
    - 쿠키란 일종의 클라이언트가 누구인지 , 어떤 상태인지등이 포함된 정보를 보관하는 것을 말합니다.
    - 쿠키를 통해 로그인을 하고 이후 데이터에 접근하는 방법은 아래와 같습니다.
        1) 클라이언트가 로그인을 시도합니다.
        2) 서버에서는 클라이언트 정보의 유효성을 판단하고 Response에 set-cookie라는 키에 쿠키값을 넣어서 클라이언트에게 보냅니다.
        3) 클라이언트는 Response 의 set-cookie 라는 키값에 해당되는 값을 브라우저의 cookie storage(쿠키저장소)에 저장합니다.
        4) 이후 클라이언트는 요청하는 메세지의 header에 cookie값을 넣어서 보내면 서버 입장에서는 어떤 클라이언트에서 온 요청인지 알 수 있게 됩니다.


- 쿠키의 단점은 무엇이 있을까요?
    - 쿠키에 클라이언트의 정보들이 존재하기 때문에 쿠키를 탈취당하면 클라이언트의 정보가 유출 될수 있다는 단점이 있습니다.
    - 클라이언트 정보를 쿠키에 보관하는 것이 아닌 세션ID를 보관하여 보완성을 높인 세션을 사용할 수 있습니다.


- 쿠키는 언제 사용하나요?
    - 쿠키는 쇼핑몰 장바구니기능이나 자동으로 아이디 패스워드를 입력해주는 기능등 브라우저 사용자의 정보를 입력해줄 때도 사용합니다.


- 그렇다면 세션은 무엇인가요?
    - 세션은 기본적으로 쿠키를 이용해서 구현합니다. 클라이언트를 구분하기 위해 각 클라이언트에게 세션 ID를 부여하고 클라이언트는 쿠키에 세션ID를 저장합니다.
    - 세션을 이용하여 로그인을 하고 이후 데이터에 접근하는 방법은 아래와 같습니다.
        1) 클라이언트가 로그인을 시도합니다.
        2) 서버에서는 클라이언트의 유효성을 판단하고 Response에 set-cookie 라는 키에 세션ID를 저장하고 서버는 세션ID에 해당하는 유저 정보를 메모리에 따로 저장합니다. (DB에 저장할 수도 있음) 그리고 클라이언트에게 전송합니다.
        3) 클라이언트는 Response의 set-cookie 라는 키값에 해당되는 값을 브라우저의 cookie storage에 저장합니다.
        4) 이후 클라이언트는 세션ID를 헤더에 포함 시켜서 요청을 보내고 서버는 세션ID를 가지고 어떤 유저인지 검색한 후 이후 로직을 처리합니다.


- 세션의 단점은 무엇이 있을 까요?
    - 세션은 쿠키보다 보안성은 좋지만 서버에 클라이언트의 접속 정보들을 계속 저장해야하기 때문에 트래픽이 많아진다면 서버 메모리에 과부하가 올 수도 있습니다.
    - session hijacking을 통해 세션 ID가 노출될 경우에 클라이언트가 해커인지 알 방법이 없습니다. 따라서 세션ID의 주기를 짧게 가져가거나 HTTPS를 통해 보안을 강화합니다.
    - session ID를 충분히 큰값으로 설정하는 것도 효과가 있습니다. 왜냐하면 해커입장에서 session ID가 간단하다면 임의의 session ID를 계속 탐색하여 우연히 session ID를 발견할 수도 있기 때문입니다.


- HTTP 가 무엇인가요?
    - 서버와 클라이언트 모델을 따르고 웹상에서 Request 와 Response 구조로 메세지를 주고받을 수 있는 프로토콜 입니다.
      TCP/IP를 기반으로 동작하며 가장 큰 특징은 Connectionless 와 StateLess 입니다.


- Request 구조는 어떻게 되어있나요?
    - Start line , Headers , Body 로 크게 3가지로 구성되어 있습니다.
    - Start line 에는 Methods , Path , Protocol 을 명시합니다.
    - Headers 에는 여러 정보가 있지만 대표적으로 Host와 Accept-Language가 있습니다.

    ex)
    GET /search HTTP/1.1   (methods , path , protocol)
    Host : www.google.com
    Accept-Language : ko, ko-KR


- Response 구조는 어떻게 되어있나요?
    - Status line , Headers , Body로 구성되어 있습니다.
    - Status line 에는 HttpVersion , status Code, status message 가 있습니다.

    ex)
    HTTP/1.1 200 OK
    Date : Mon, 07 Feb 2022 11:22:01 GMT
    Server : Apache


- GET , POST 는 어떤 차이가 있나요?
    - GET은 주로 클라이언트가 서버에게 데이터를 조회하는 경우 사용합니다. URL 뒤에 쿼리 스트링을 추가하여 정보를 조회합니다.
      반면 POST는 클라이언트가 서버에게 주로 데이터를 생성하는 경우 사용합니다. 전달할 데이터를 BODY에 포함해서 요청합니다.

    - GET은 URL을 이용하여 캐싱한후 같은 요청에 대해 좀더 빠른 응답을 할 수 있습니다.
      반면 POST는 BODY의 내용을 캐싱해야하는데 이는 어렵기 때문에 캐싱을 하지 않습니다.


- PUT과 POST의 차이가 무엇인가요?
    - PUT은 모든 리소스를 대체하기 위해 사용합니다. POST는 리소스 생성을 목적으로 하는 경우가 많기 때문에 멱등하지 않습니다.
      멱등하다란 매번 똑같은 요청을 해도 늘 같은 결과를 반환하는 것을 말합니다.


- PUT 과 PATCH의 차이는 무엇인가요?
    - PUT 은 모든 리소스를 대체하지만 PATCH는 일부 리소스만 대체해버립니다.


- www.google.com  에 접속하는 과정을 설명해주세요.
    1. 사용자가 브라우저에서 URL을 입력합니다.
    2. 응용계층에서 Request Message를 생성합니다.
    3. 응용계층에서 DNS 서버에 URL에 해당하는 IP주소를 검색합니다.
    4. HTTP요청 메세지를 완성하고 TCP 전송계층에 전달합니다.
    5. TCP 전송계층에서 TCP 헤더를 추가하고 IP계층에 IP헤더를 추가한 뒤 2계층과 1계층을 거쳐 서버로 패킷을 보냅니다.
    6. 서버의 전송계층에서 패킷을 UNPACK한 후 메세지를 복원합니다.
    7. 서버의 HTTP URL을 통해 응용계층에서 처리한 후 Response 메세지를 생성합니다.
    8. Request Message의 정보를 이용해 TCP 헤더와 IP헤더를 추가합니다.
    9. 2계층과 1계층을 거쳐 다시 클라이언트로 패킷을 보냅니다.
    10. 클라이언트는 Response Message가 브라우저로 전달되면  HTML 랜더링을 통해 모니터에 보여집니다.


- TCP가 무엇인가요?
    - 인터넷 상에서 데이터를 주고 받기 위해 사용하는 전송계층의 프로토콜입니다. 기존 IP방식에 연결지향적인 특징이 더해졌습니다.


- IP를 언급하셨는데 TCP와 IP의 차이가 무엇인가요?
    - IP는 출발지 IP와 목적지 IP 정보만 있습니다. 하지만 출발지 IP와 목적지 IP만 있다면 중간에 패킷이 유실되어도 패킷을 받는 입장에서는 유실되었는 지 알 길이 없습니다.
      이를 보완하기 위한 정보들이 TCP헤더에 포함되어 있습니다. 전송제어,순서정보,검증정보등이 포함되어 있어서 데이터를 받는 입장에서는
      어떤 데이터가 유실되었고 순서가 맞지 않는 지 알 수 있습니다.
    - 또한 TCP는 출발지 PORT와 목적지 PORT가 있는데 이는 같은 IP 내에서 다른 프로세스들을 구분해줍니다.
    - 결론은 IP는 출발지IP와 목적지IP만 가진 프로토콜이며 TCP는 그외 PORT정보와 여러 제어정보를 포함하고 있다는 차이가 있습니다.


- 연결지향적인 특징이 있다고 했는데 그게 무엇인가요?
    - 서로 연결되어 있는 것과 같은 특징을 말합니다. TCP는 이를 위해서 3 way handshaking을 제공합니다. 실제로 연결된 상태는 아니고 논리적으로 연결되어 있음을 의미합니다.


- 3 way handshake을 시작으로 연결종료까지 설명해주세요
    - 3 way handshake는 TCP/IP 프로토콜로 통신하기 전에 클라이언트와 서버의 일종의 세션을 수립하는 과정입니다.
        1) 클라이언트가 서버에게 SYN 을 보냅니다.
        2) 서버는 클라이언트에게 ACK + SYN 을 보냅니다.
        3) 클라이언트는 서버에게 ACK를 보냅니다.

        이러한 3-way handshake를 통해서 클라이언트와 서버는 난수로 구성된 일련번호를 주고 받습니다.
        일련번호를 통해 데이터의 순서와 정확성을 보증합니다.

        4) 서버와 클라이언트는 데이터를 주고 받습니다.

        연결을 종료하기 위해서는 4-way handshake를 통해 종료합니다.

        5) 클라이언트에서 서버로 FIN을 보냅니다.
        6) 서버는 클라이언트로 ACK를 보내고 서버 내 process에게 EOF를 보낸다음 종료될때까지 대기합니다.
        7) 서버의 process가 종료되면 클라이언트에게 FIN을 보냅니다.
        8) 클라이언트가 ACK를 서버에게 보냄으로써 연결이 종료됩니다.


- TCP 에서 제공하는 흐름제어와 오류제어에 대해서 설명해주세요
    - 흐름제어는 데이터를 보내는 속도와 받는 속도를 조절하는 것을 말합니다. 오류제어는 훼손된 세그먼트를 감지 및 재전송하고 순서에 맞지 않게 들어온 패킷에 대해서 제어합니다.




