- AOP
    - AOP 가 무엇일까
        - Aspect Oriented Programming
        - 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 반복 작업을 줄이고 핵심 비즈니스 로직 개발에만 집중할 수 있음

        - 사용 목적에 따라
            - 프록시 패턴: 클라이언트가 타깃에 접근하는 방법 제어
            - 데코레이터 패턴: 타깃에 부가적인 기능 부여

    - AOP 의 용어들
        - Target Object: 부가 기능을 부여할 대상
        - Aspect: 부가 기능을 정의한 Advice 와 어드바이스를 어디에 적용할 지 결정하는 Pointcut 을 함께 가짐.
        - Advice: 타깃에게 제공할 부여 기능을 담은 모듈. 애스팩트가 무엇을 언제 할지를 정의.
        - JoinPoint: 프로그램의 실행 내부에서 Advice 가 적용될 수 있는 위치. 부가 기능을 적용할 위치.
        - Pointcut: 어드바이스에 적용할 JoinPoint 를 선별하는 작업 또는 그 기능을 정의한 모듈.

    - AOP 구현 방법
        - 컴파일 시점에 코드에 공통 기능 삽입
        - 클래스 로딩 시점에 바이트 코드에 공통 기능 삽입
            - AOP 프레임워크인 AspectJ 가 제공하는 컴파일러나 클래스 로더 조작기 같은 새로운 것을 사용해야 하므로
              좀더 유연한 AOP 를 적용할 수 있지만, 부가적인 의존성을 추가해야 하는 단점 존재.
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            (런타임 시점은 자바 언어가 실행되고 난 이후 이므로 프록시 기능 활용.)

    - Spring 에서 AOP 를 구현한 방법
        - 런타임 시점에 프록시 객체를 생성하여 공통 기능 삽입
            - 컴파일러나 클래스 로더 조작기를 설정하지 않아도 됨.
            - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에, 스프링 AOP 는 메서드 실행 시점에만 AOP 를 적용할 수 있음.
            - 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 빈에만 AOP 적용 가능.
            - AspectJ 를 직접 사용하는 것이 아니라, AspectJ 의 문법을 차용하고 프록시 방식의 AOP 적용


- 쓰레드 풀
    - 프로그램: 어떤 목적을 달성하기 위해서 컴퓨터의 동작을 하나로 모아 놓은 것
    - 프로세스: 컴퓨터가 현재 실행중인 프로그램

    - 단순히 스레드만 사용해서 동시에 여러 작업을 실행시킬 수 있는 프로그램을 만들 수 있을까?
        - 문제
            - 스레드 생성비용이 크기 때문에 요청에 대한 응답시간이 늘어난다.
                1. Java 는 One-to-One Threading-model 로 Thread 생성한다.
                2. User Thread(Process 의 스레드) 생성시 OS Thread(OS 레벨의 스레드) 와 연결해야 한다.
                    - User Thread 는 OS Thread 에 대한 User Program 계층에서의 추상화
                3. 새로운 Thread 를 생성할 때 마다 OS Kernel 의 작업이 필요하다.
                4. Thread 는 생성 비용이 많이 든다.
                5. 작업 요청이 들어올 때마다 Thread 를 생성하면 최종적인 요청 처리 시간이 증가한다.

            - Thread 가 너무 많으면 여러가지 문제를 발생시킨다.
                1. Process 의 처리 속도보다 빠르게 요청이 쏟아져 들어오면
                2. 새로운 Thread 가 무제한적으로 계속 생성된다.
                3. Thread 가 많아 질수록 메모리를 차지하고 Context-Switching 이 더 자주 발생한다.
                4. 메모리 문제가 발생할 수 있고, CPU 오버헤드가 증가한다.

    - 그래서 나온 게 Thread Pool
        - Thread 를 허용된 개수 안에서 사용하도록 제한하는 시스템
        - Thread, 작업 큐로 이루어짐.
            1. 스레드풀에 작업 처리 요청
            2. 작업 큐에 작업들이 쌓이게 됨.
            3. 각 스레드로 작업을 보내고, 스레드는 작업을 처리함.
            4. 결과 전달

        - 해결
            - 미리 만들어 놓은 스레드를 재사용할 수 있기 때문에 새로운 스레드를 생성하는 비용을 줄일 수 있다.
            - 사용할 스레드 개수를 제한하기 때문에 무제한적으로 스레드가 생성되는 것을 방지

        => 여러 개의 작업을 동시에 처리하면서도 안정적으로 처리하고 싶을 때 Thread Pool 은 효과적

    - Java 의 Thread Pool
        - ThreadPoolExecutor 클래스르 이용해 스레드풀을 구현

        - maximumPoolSize
        - corePoolSize
        - keepAliveTime
            -> 항상 maximumPoolSize 만큼 유지하고 있지는 않음. 요청이 적을 때는 많은 양의 스레드를 계속 가지고 있을 이유가 없다.
               만약 작업이 없는데 스레드 개수가 최대이고, keepAliveTime 이후로도 계속 작업 요청이 없다면 스레드는 없어짐.
               무한히 없어지는게 아니라 corePoolSize 만큼 없어짐.
               따라서 최대 maximumPoolSize, 최소 corePoolSize 만큼 스레드를 가진다.

    - Tomcat 의 Thread Pool
        - Tomcat
            - SpringBoot 의 내장 Servlet Container 중 하나
            - Java 기반의 WAS
            - Java 의 스레드풀 클래스와 매우 유사한 자체 스레드풀 구현체를 가지고 있다.

        - Java 의 스레드풀과 다른점
            - Max-Connections
                - 톰캣이 최대로 동시에 처리할 수 있는 Connection 의 개수
                - Web 요청이 들어오면 톰캣의 Connector 가 Connection 을 생성하면서 요청된 작업을 스레드풀의 스레드에 연결한다.
            - Accept-Count
                - Max-Connections 이상의 요청이 들어왔을 때 사용하는 대기열 큐의 사이즈
                - Max-Connections 와 Accept-Count 이상의 요청이 들어왔을 때 추가적으로 들어오는 요청은 거절될 수 있다.

    - 어떻게 하면 스레드풀을 잘 설정해서 Server Application 을 효과적으로 구현할 수 있을까?
        - SpringBoot 설정을 통한 Tomcat Thread Pool 설정
            - server.tomcat.threads.max
                - 스레드풀에서 사용할 최대 스레드 개수, 기본 값은 200
                - 서버 어플리케이션이 동시에 처리할 수 있는 요청 개수와 관련있다.
                - 요청에 비해 너무 많게 설정 -> 놀고 있는 스레드가 많아져서 비효율 발생
                - 너무 적게 설정 -> 동시 처리 요청 수가 줄어든다. 평균응답시간, TPS 감소
                -> 기본적으로 스레드가 많아지면 CPU 오버헤드와 메모리에서 문제가 생길 수 있다.

            - server.tomcat.threads.min-spare
                - 스레드풀에서 최소한으로 유지할 스데르 개수, 기본값은 10
                - 너무 많이 설정 -> 스레드풀이 항상 유지해야 할 스레드 수가 너무 많아진다.
                - 적절하게 설정 -> 적은 수의 요청에서 새로운 스레드를 만들 필요없이 요청을 효과적을 처리할 수 있다.
                -> 잘못 설정했을 때 사용하지 않는 스레드가 메모리를 차지하면서 비효율을 발생시킨다.

            - server.tomcat.max-connections
                - 동시에 처리할 수 있는 최대 Connection 의 개수, 기본 값은 8192
                - 사실상 서버의 실질적인 동시 요청 처리 개수
                    - 톰캣의 커넥터 컴포넌트의 방식에 따라서 개수 설정
                        - Blocking IO: 1 Connection 1 Thread
                        - Non-Blocking IO: N Connection 1 Thread
                    - tomcat 8 버전 이후부터는 Non-Blocking IO 방식 사용
                - Non-Blocking IO 에서는 스레드풀을 최대 스레드 개수보다 많은 양의 Connection 을 유지할 수 있다.
                - Non-Blocking Io 에서는 최대 스레드 개수보다 적거나 같은 수의 max-connections 를 설정하는 것은 비효율적인
                  설정이 될 수 있다.

            - server.tomcat.accept-count
                - max-connections 이상의 요청이 들어왔을 때 사용하는 요청 대기열 큐의 사이즈, 기본 값은 100
                - 너무 크게 설정 -> 대기열이 커지면서 메모리 문제 유발
                - 너무 작게 설정 -> 요청이 몰렸을 때 들어오는 요청들을 거절해 버릴 수 있다.
                -> 이 설정을 하는 이유 중 하나는 부적절하거나 잘못된 요청이 한번에 너무 많이 들어와
                   서버에 장애를 발생시키는 것을 방지하기 위함도 있다.

    => 스레드풀을 설정해야 하는 이유
        - 스레드풀은 응답시간과 TPS 에 영향을 주는 하나의 요소이다.
        - 잘 조정된 스레드풀은 시스템의 성능을 끌어내고 안정적인 어플리케이션 운용을 가능하게 한다.
        - 부적절하게 설정된 스레드풀은 병목 현상, CPU 오버헤드, 메모리 문제를 유발할 수 있다.

- Blocking vs Non-Blocking, Sync vs Async
    - Blocking vs Non-Blocking
        - Blocking: 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것
        - Non-Blocking: 다른 주체의 작업에 관련없이 자신의 작업을 하는 것
        -> 다른 주체가 작업을 할 때 자신의 제어권이 있는지 없는지로 볼 수 있다.

    - Synchronous vs Asynchronous
        - Synchronous: 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작함을 의미
        - Asynchronous: 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음을 의미
        -> 결과를 돌려주었을 때, 순서와 결과에 관심이 있는지 아닌지로 판단할 수 있다.

    - Blocking/Sync
        ex) 자바에서 입력요청을 할 때

    - Non-Blocking/Sync
        - Blocking/Sync 와 큰 차이가 없다.

    - Blocking/Async
        - 보통 Non-Blocking/Async 로 하려다가 개발자의 실수로 혹은 기타 이유로 이와 같이 동작

    - Non-Blocking/Async
        ex) 자바스크립트에서 API 요청을 하고 다른 작업을 하다가 콜백을 통해서 추가적인 작업을 처리할 때

    


*AOP   https://www.youtube.com/watch?v=hjDSKhyYK14
*쓰레드 풀    https://www.youtube.com/watch?v=um4rYmQIeRE
*Blocking vs Non-Blocking, Sync vs Async   https://www.youtube.com/watch?v=oEIoqGd-Sns
*Process vs Thread   https://www.youtube.com/watch?v=1grtWKqTn50&t=507s
*데드락  https://www.youtube.com/watch?v=Ry_gB34cvwc
       https://www.youtube.com/watch?v=FXzBRD3CPl
       https://dncjf64.tistory.com/400
*추상클래스/인터페이스  https://www.youtube.com/watch?v=T1BJzC9xb0g
*stream vs for  https://www.youtube.com/watch?v=by8hb75i9X4
stream  https://www.youtube.com/watch?v=rbm87IFpwvQ
        https://www.youtube.com/watch?v=wsvhgrCGW78
*RESTful  https://www.youtube.com/watch?v=xWA1eTPSzDE
         https://www.youtube.com/watch?v=NODVCBmyaXs
*git 브랜치 전략  https://www.youtube.com/watch?v=wtsr5keXUyE
               https://www.youtube.com/watch?v=jeaf8OXYO1g
*DI/IOC  https://www.youtube.com/watch?v=8lp_nHicYd4
*        https://www.youtube.com/watch?v=_OI9mKuFb7c
*rest api  https://www.youtube.com/watch?v=Nxi8Ur89Akw
rest docs  https://www.youtube.com/watch?v=BoVpTSsTuVQ
*GC  https://www.youtube.com/watch?v=FMUpVA0Vvjw
    https://www.youtube.com/watch?v=Fe3TVCEJhzo
redis  https://www.youtube.com/watch?v=Gimv7hroM8A&t=205s
*DFS/BFS  https://www.youtube.com/watch?v=By77aC9Oe3Q
*람다  https://www.youtube.com/watch?v=sS-_Xr5Q4V4
*제네릭  https://www.youtube.com/watch?v=w5AKXDBW1gQ
       https://www.youtube.com/watch?v=Vv0PGUxOzq0
정렬 알고리즘  https://www.youtube.com/watch?v=8c-Q8anmJcM
멀티쓰레드와 동기화  https://www.youtube.com/watch?v=ktWcieiNzKs
데이터베이스 락   https://www.youtube.com/watch?v=ZXV6ZqMyJLg
                https://www.youtube.com/watch?v=onBpJRDSZGA
                https://www.youtube.com/watch?v=w6sFR3ZM64c
인덱스  https://www.youtube.com/watch?v=edpYzFgHbqs
       https://www.youtube.com/watch?v=P5SZaTQnVCA
캐싱  https://www.youtube.com/watch?v=H4J-8pPMvEU
     https://www.youtube.com/watch?v=JBFT4KyEvoY
필터/인터셉터  https://www.youtube.com/watch?v=v86B35pwk6s
리플렉션  https://www.youtube.com/watch?v=67YdHbPZJn4
쿠키/세션/토큰/캐시  https://www.youtube.com/watch?v=gA1KsJ2ak10
함수형 프로그래밍  https://www.youtube.com/watch?v=24tL6-YKz3I
@Transactional  https://www.youtube.com/watch?v=taAp_u83MwA
                https://www.youtube.com/watch?v=aX9c7z9l_u8
프로세스/스레드  https://www.youtube.com/watch?v=C_P0wHFp1o4
               https://www.youtube.com/watch?v=DmZnOg5Ced8
api/라이브러리/프레임워크  https://www.youtube.com/watch?v=G9Dl5FiaOQ4
                        https://www.youtube.com/watch?v=_j4u4ftWwhQ&t=1s
스프링 빈  https://www.youtube.com/watch?v=3gURJvJw_T4
Servlet & Spring Web MVC   https://www.youtube.com/watch?v=h0rX720VWCg
                           https://www.youtube.com/watch?v=calGCwG_B4Y&t=2s
상속/조합  https://www.youtube.com/watch?v=U4OSS4jJ9ns
          https://www.youtube.com/watch?v=clbpnp2xYOQ&t=1s
this  https://www.youtube.com/watch?v=DTX52Pv7PZM
싱글턴패턴/정적클래스  https://www.youtube.com/watch?v=5oUdqn7WeP0
                    https://www.youtube.com/watch?v=C6CczyrkYXU&t=5s
웹소켓/스프링  https://www.youtube.com/watch?v=rvss-_t6gzg
             https://www.youtube.com/watch?v=MPQHvwPxDUw&t=287s
CSR/SSR  https://www.youtube.com/watch?v=YuqB8D6eCKE
선형 자료구조  https://www.youtube.com/watch?v=xnURecIJk4g
Web Server vs WAS  https://www.youtube.com/watch?v=mcnJcjbfjrs&t=1s
                   https://www.youtube.com/watch?v=F_vBAbjj4Pk
spring/spring boot  https://www.youtube.com/watch?v=Y11h-NUmNXI
상태 패턴  https://www.youtube.com/watch?v=wYMN3sPIeHY
OOP  https://www.youtube.com/watch?v=3etKkkna-f0
빌드/배포  https://www.youtube.com/watch?v=zeDh2mMd_fc&t=1s
DTO/VO  https://www.youtube.com/watch?v=z5fUkck_RZM
도메인 주도 설계  https://www.youtube.com/watch?v=VIfNipL5KkU
Spring Webflux  https://www.youtube.com/watch?v=4x1QRyMIjGU
Java final과 불변 객체  https://www.youtube.com/watch?v=ej-bnXlHk-E
자바 직렬화  https://www.youtube.com/watch?v=3iypR-1Glm0
전략 패턴  https://www.youtube.com/watch?v=zGJzEBOELoU
          https://www.youtube.com/watch?v=vNsZXC3VgUA

string vs string builder

flux  https://www.youtube.com/watch?v=wQFBgKl1PYw
Sharding, Clustering, Replication   https://www.youtube.com/watch?v=y42TXZKFfqQ
scale up vs scale out, SPOF   https://www.youtube.com/watch?v=6wPr2jgdDxM