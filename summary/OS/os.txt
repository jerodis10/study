커널의 개념 : 컴퓨터가 켜진 후부터 메모리에 상주하는 운영체제의 실행 코드 모음으로, 하드웨어 및 사용자 프로그램 관리자 역할을 수행
커널의 프로세스 관리 방식 : Interrupt를 통해서 이루어짐.
I/O 요청을 할 때 : 사용자 프로그램이 인터럽트를 걸면 CPU가 OS에게 넘어가서 OS가 해당 인터럽트에 해당하는 코드(인터럽트 처리 루틴)를 실행
I/O 요청의 결과를 받았을 때 : I/O 디바이스의 컨트롤러가 CPU에게 인터럽트를 걸면 OS가 확인하고 결과값을 요청한 프로그램에게 제공한 다음 CPU가 작업을 끝내면 결과를 받은 프로그램에게 CPU를 할당

- 프로세스 / 스레드 / 커널
    - 프로세스
        기본적으로 컴퓨터에서 연속적으로 실행되고 있는 컴퓨트 프로그램을 의미
        프로그램이란 일반적으로 하드 디스크 등에 저장되어 있는 실행코드를 말하는데
        프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리에서 실행되는 일종의 작업단위
        하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행된다.

        프로세스는 항상 커널의 자원을 차지하기 위해 경쟁하고
        커널은 이들에게 효율적인 자원을 스케줄링하여 할당하고 회수하는 역할을 한다.

        동작 중인 컴퓨터 시스템은 커널과 프로세스 간의 관계에 의해 모든 것이 결정된다고 볼 수 있다.

    - 스레드
        프로세스는 최소 하나의 스레드를 갖는다.
        어떤 프로그램 내에서 프로세스 내에서 실행되는 흐름의 단위, 프로세스가 세분화된 작은 일들 하나 하나를 스레드라 한다.
        한 프로세스에 속한 각각의 스레드들은 프로세스가 가지는 자원을 공유하면서 각자는 자신의 실행환경,
        즉 프로그램 카운터로 표현되는 현재의 실행 위치와 스택, 레지스터 값들을 따로 가지게 된다.

        스위칭에 소요되는 시간과 비용이 프로세스 단위보다 빠르고 저렴하다.
        프로세스 간의 통신은 커널의 개입을 필요로 하지만, 스레드 간의 통신은 메모리와 파일을 공유하기 때문에 커널의 개입이 필요 없다.

        스레드 종류에는 지원하는 영역에 따라 2 가지가 있다.
            - 사용자 스레드 : 커널 영역의 상위에서 지원. 라이브러리를 통해 구현
            - 커널 스레드 : 운영체제가 지원하는 스레드 기능으로 구현

    - 커널
        커널이란 운영체제 프로그램 중에서 가장 핵심적인 부분, 기능을 묶은 것을 말한다.
        운영체제마다 그 커널의 특성이 다르기 때문에 커널이 운영체제의 정체성을 정하게 된다.
        하드웨어의 자원을 자원이 필요한 프로세스에 나눠주고 태스크 매니저, 메모리 제어, 시스템 콜 등을 수행하는 부분으로
        운영체제 맨 하부에서 돌아간다.
        현재 사용되고 있는 OS는 커널 위에 여러 가지 레이어를 올린 것이다.


- 동기, 비동기, Blocking, Non-Blocking   https://youngkyonyou.github.io/interview/2021/12/23/Interview-interview-07.html
    - Blocking vs Non-Blocking
        다른 주체가 작업을 할 때 자신의 제어권이 있는지 없는지로 볼 수 있다.
        - Blocking: 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것
        - Non-Blocking: 다른 주체의 작업에 관련없이 자신의 작업을 하는 것

    - Synchronous vs Asynchronous
        작업 완료를 누가 신경 쓰는가 이다.
        - Synchronous: 호출된 함수의 수행 결과 및 종료를 호출한 함수가 신경 쓴다.
        - Asynchronous: 호출되는 함수에게 callback을 전달해서 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행.
                        즉, 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.

    - 동기 / 블로킹
    - 동기 / 논블로킹
    - 비동기 / 블로킹
    - 비동기 / 논블로킹


- 힙 vs 스택
    - 메모리
        - 프로그램을 실행시키면 운영체제는 실행한 프로그램을 위해서 메모리 공간을 할당해줌. 이 때 할당되는 메모리 공간이 크게 코드, 데이터, 힙, 스택 영역으로 나누어짐.
          할당되는 장소는 메인 메모리(RAM)에 할당되며, 용도는 프로그램 실행 시 필요한 공간을 지정하기 위해서 할당된다.

        - 코드 영역
            - 실행할 프로그램의 코드가 저장되는 영역
            - CPU 는 코드 영역에서 저장된 명령을 하나씩 가져가서 처리하게 된다.
            - 프로그램이 시작하고, 종료될 떄까지 메모리에 계속 남아있는다.

        - 데이터 영역
            - 전역 변수와 정적(static) 변수가 저장되는 영역
            - 프로그램의 시작과 함께 할당되며 프로그램이 종료되면 소멸

        - 힙 영역
            - 사용자의 동적 할당 (프로그래머가 직접 공간을 할당, 해제)
            - 런타임에 크기가 결정됨
            - 제대로 반환하지 않으면 메모리 누수가 일어나서 메모리 손해를 볼 수 있다. (메모리 누수 - 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상)
            - 용량은 크지만 메모리 단편화의 위험성을 갖고 있다. (메모리 단편화 - 메모리를 100% 활용하지 못하는 경우)
            - 주로 동적할당 시 발생. 스택은 스택 오버플로우가 발생하면 바로 에러를 뱉어버리기 때문에 쉽게 알 수 있다.(용량도 적다.)
              하지만 동적할당이 이루어지는 힙 영역은 문제 없이 잘 동작할 수도 있기 때문에 이런 누수 현상이 발생하는 것. 힙 영역은 용량이 크기 때문에

        - 스택 영역
            - 지역변수, 매개 변수 (프로그램이 자동으로 사용하는 임시 메모리 영역)
            - 컴파일 타임에 크기가 결정됨
            - 접근이 매우 빠르고, 변수를 명시적으로 할당 해제할 필요 없다. 컴파일러에 의해 메모리 해제 할당
            - 메모리에 낭비되는 공간 없이 사용 가능. 스택의 의미대로 그냥 차례대로 쌓기 때문 (연속적 메모리 영역) 하지만 용량이 매우 적다.
            - 함수의 호출하는 위치도 저장
            - 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 영역이고, 함수 호출이 완료되면 사라진다.
              이때 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame) 이라고 한다.

            - 스택 프레임   https://www.jiwon.me/explain-heap-and-stack/    https://all-young.tistory.com/17
                - 스택 영역에 함수를 구분하기 위해 생성되는 공간
                - 컴퓨터가 프로그램을 실행할 때, 코드영역에서 코드를 읽으며 필요한 데이터를 데이터,힙,스택영역에서 레지스터로 가져온다.
                  cpu 는 레지스터 값을 가지고 연산을 하고, 결과물을 다시 저장영역에 돌려준다.
                - 데이터를 가져올 때 필요한 것이 스택이다. 데이터영역은 전역변수나 상수만 저장되기 때문에 한번 읽으면 끝이다.
                  나머지 변수는 코드를 실행할 때마다 다시 읽어야 한다. 왜냐하면 변수이기 때문에 이전에 읽어들인 값이 지금 값과 같지 않을 수 있기 때문이다.
                  힙 영역에 접근할때도 스택이 필요하다. 데이터가 힙에 저장 되어 있더라도, 그 데이터에 접근하기 위한 변수(포인터)는 스택에 저장되기 때문이다.
                - 스택은 스택 자료구조 형태로 저장되고 최상단에 있는 스택프레임이 현재 실행하고 있는 프로그램에 필요한 변수가 저장되어 있다.
                  즉 컴퓨터는 현재 연산을 수행할 때, 가장 위에 있는 스택프레임만 보면 되는 것이다.
                - 그렇다면 왜 스택구조(후입선출)로 쌓는 것일까?
                  프로그램은 순차적으로 실행하기 때문에 가장 최근에 할 일을 가장 위쪽에 위치하게 하는 것이다.

    - 오버 플로우 ??
        - 한정된 메모리 공간이 부족하여 메모리 안에 있는 데이터가 넘쳐 흐르는 현상
        - 힙은 메모리 낮은 주소부터 할당되고, 스택은 메모리 높은 주소부터 할당되기 때문에 각 영역이 상대 공간을 침범하는 일이 발생할 수 있다.
        - 힙 오버 플로우
            - 힙이 스택을 침범하는 경우
        - 스택 오버 플로우
            - 스택이 힙을 침범하는 경우


- 프로세스와 스레드의 차이
    프로세스는 운영체제로부터 자원을 할당 받는 작업의 단위이지만, 스레드는 할당 받은 자원을 이용하는 실행의 단위다.
    프로세스는 자신만의 고유 공간과 자원을 할당 받아 사용하는데 반해, 스레드는 다른 스레드와 공간 자원을 공유하면서 사용한다.
    하나의 프로세스 내에 1개 이상의 스레드를 가질 수 있다.


- 스레드는 왜 독립적인 스택 메모리를 가지나요?
    - 스택영역의 정의부터 정확하게 알아야합니다. 스택영역은 스레드가 프로세스 내에서 함수호출시 전달되는 인자, 함수의 리턴주소등을 저장하기 위한 메모리 영역입니다.
      스레드가 하나의 프로세스 내에서 독립적인 기능을 하기 위해서는 독립적인 함수를 호출해야함을 의미하며 이는 독립적인 스택 메모리를 가져야만 가능합니다.


- 멀티 프로세스와 멀티 스레드를 비교해주세요.
    - 문맥교환시 멀티스테드는 스택영역의 내용만 변경되면 되지만 멀티 프로세스의 경우 힙,데이터,코드 영역의 정보까지 바뀌므로 문맥교환의 비용이 멀티프로세스가 높습니다.
    - 멀티 프로세스는 많은 CPU시간과 메모리공간을 차지하며 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않습니다.
    - 멀티 스레드는 적은 메모리 공간을 차지하고 문맥교환 비용이 적으며 자원을 공유하기 때문에 동기화 문제가 발생할 수 있고 하나의 스레드 장애가 여러 스레드의 장애로 이어질 위험이 있습니다.


- 멀티 프로세스들이 실행되는 과정을 간략하게 표현해주세요.


- 프로세스 Context Switching이 일어날 때 운영체제 내에서 어떻게 동작하나요?
    현재 프로그램 코드에서 다른 프로그램 코드 영역으로 옮길 때, 현재 프로세스의 레지스터 정보와 PCB를 저장합니다.
    운영체제 내에서 레지스터 정보와 PCB를 저장하는 테이블에 등록합니다.
    그리고 다른 프로세스의 정보를 탐색해 불러옵니다. 다시 원래 프로세스로 돌아올 때 저장했던 테이블에서 탐색해 불러옵니다.


- 멀티 프로세스 , 스레드 환경에서 동기화 문제는 어떻게 해결하나요 ??
    - 해결하는 방법은 뮤텍스 또는 세마포어를 사용합니다.
    - 뮤텍스 : 1개의 스레드만 공유자원에 접근가능합니다.
    - 세마포어 : S개의 스레드만이 공유자원에 접근가능합니다. 스레드가 접근할 때 마다 S의 개수를 감소시키며 S가 0이라면 자원에 접근 할 수 없습니다.

    - critical section : 공유할 자원들 즉, 코드 영역에서 여러 스레드들이 접근 할 수 있는 부분을 통제하기 위해서 둘 이상의 프로세스 또는
      스레드가 접근하는 것을 막는 코드 부분을 임계영역 (critical section)이라고 합니다. 또한 임계영역내에서 코드들은 원자적으로 실행되어야 합니다.
    - entry section : 진입 허가 요청이 완료되어야 임계영역으로 갈수 잇습니다.
    - exit section : 임계영역 실행후 끝나는 부분
    - entry section -> critical secition -> exit section 으로 이동합니다.


- Race Condition이란?
    - 두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황
    - race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.


- race condition
    두 개 이상의 프로세스나 스레드가 하나의 데이터를 공유할 때 데이터가 동기화되지 않는 상황


- Critical Section(임계영역)에 대해 설명해주세요.??
    - 임계 영역이란 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말합니다.
    - 임계 영역 문제를 해결하기 위해서는 아래의 3가지 조건을 충족해야 합니다.
        - 상호 배제(Mutual exclution) - 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.
        - 진행(Progress) - 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 어느 것이 들어갈지 결정 해주어야 한다.
        - 한정 대기(Bounded waiting) - 다른 프로세스의 기아를 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 한다.


- 임계 영역
    공유 자원에 대하여 한 번에 하나의 프로세스만이 이에 접근할 수 있도록 통제해야 하는데, 그러한 통제가 필요한 영역을 임계 영역(Critical section)
    공유 자원에 접근하는 코드 영역


- 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.
    - 뮤텍스는 Lock을 사용해 하나의 프로세스나 쓰레드를 단독으로 실행하게 합니다.
      반면에 세마포어는 공유자원에 세마포어 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다.
    - 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있습니다.
      하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.


- 멀티 쓰레드 프로그래밍을 개발할 때 주의해야 할 점
    - 공유 데이터를 사용하는 코드 영역인 임계구역에서 서로 다른 쓰레드가 간섭하지 않도록 쓰레드를 동기화 시켜 신뢰성 있는 데이터와 로직이
      산출(?)될 수 있게끔 코드를 작성해야합니다. 락을 거는 행위는 성능에 영향을 미치고 데드락을 유발할 수도 있으니 조심해야 합니다.


- 스레드 동기화는 어떻게 이루어지나요?
    - 스레드 간에 객체를 공유하여 수정할 시, 다른 스레드에도 그 정보가 반영되지 않아 예상치 못한 오류가 일어날 수 있습니다.
      멀티 스레드 환경에서 단 하나의 스레드만 실행할 수 있는 코드 영역을 임계 영역이라고 합니다.
      자바에서는 이를 위해 동기화(synchronized) 메소드와 동기화 블록을 제공합니다.
      스레드 내부의 동기화 메소드 또는 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 해당 임계 영역 코드를 실행하지 못하도록 합니다.


- 프로그램 코드 실행을 하드웨어단에서 어떻게 하나요?
    프로그램을 실행할 때, 적당한 메모리 위치에 프로그램이 쓸 영역을 올립니다.
    프로그램이 사용할 영역은 방금 말씀드렸다시피 코드를 저장하는 영역, 전역 정적 변수들을 저장하는 영역, 지역 변수들을 저장하는 영역, 동적메모리 할당을 받을 영역으로 나누어져있습니다.

    그 다음 코드를 해석하고 실행하는 장소는 CPU 입니다.
    CPU 에서는 Program Counter 라는 레지스터 변수로 다음 실행할 위치의 코드를 저장하는데요.
    PC 위치에 있는 코드를 메모리로부터 읽어오고 명령어를 해석하여 적절한 행동을 실행합니다.
    다시 PC에 다음 코드의 위치를 저장하고 프로그램이 종료할 때 까지 반복합니다.

    - 프로그램을 실핼할 때, 적당한 메모리 위치에 프로그램이 쓸 영역을 올린다. 프로그램이 사용할 영역은 방금 말씀드렸다시피 코드를 저장하는 영역,
      전역 정적 변수들을 저장하는 영역, 지역 변수들을 저장하는 영역, 동적메모리 할당을 받을 영역으로 나누어져있습니다. 그 다음 코드를 해석하고 실행하는 CPU 이다.
      CPU 에서는 Program Counter 라는 레지스터 변수로 다음 실행할 위치의 코드를 저장한다. PC 위치에 있는 코드를 메모리부터 읽어오고
      명령어를 해석하여 적절한 행동을 실행한다. 다시 PC 에 다음 코드의 위치를 저장하고 프로그램이 종료될 때까지 반복한다.

    - 현재 프로그램 코드에서 다른 프로그램 코드 영역으로 옮길 때, 현재 프로세스의 레지스터 정보와 PCB 를 저장합니다.
      운영체제 내에서 레지스터 정보와 PCB 를 저장하는 테이블에 등록합니다. 그리고 다른 프로세스의 정보를 탐색해 불러옵니다. 다시 원래 프로세스로 돌아올 때 저장했던 테이블에서 탐색해 불러옵니다.


- 프로그램 코드를 읽어올 때 CPU에서 어떻게 효과적으로 읽을 수 있는지 생각해보셨나요?
    CPU와 메모리의 연산 속도는 다르기에 CPU 에서도 효과적으로 메모리로부터 데이터를 읽는 방법이 필요합니다. CPU 내부에 여러 캐시 메모리를 장착하고 있어
    최대한 CPU 사이클보다 느린 메모리로부터 데이터나 코드를 불러오는 것을 지양하면서 캐시 메모리를 적극 활용해 속도를 개선합니다.

    코드를 읽을 때, 메모리에서 다음에 실행할 코드 뭉치들을 미리 불러와 캐시 메모리에 저장합니다.
    캐시 메모리에 저장한 명렁어들을 소진될 때 까지 순차적으로 실행해 속도를 개선합니다.


    - CPU 와 메모리의 연산 속도는 다르기에 CPU 에서도 효과적으로 메모리로부터 데이터를 읽는 방법이 필요합니다. CPU 내부에 여러 캐시 메모리를 장착하고 있어
      최대한 CPU 사이클보다 느린 메모리로부터 데이터나 코드를 불러오는 것을 지양하면서 캐시 메모리를 적극 활용해 속도를 개선합니다.
      코드를 읽을 때, 메모리에서 다음에 실행할 코드 뭉치들을 미리 불러와 캐시 메모리에 저장합니다.
      캐시 메모리에 저장한 명렁어들을 소진될 때 까지 순차적으로 실행해 속도를 개선합니다.


- 스레드 개수가 많아지면 더 효율적일까요?
    과도한 스레드 개수로 애플리케이션의 성능이 저하될 수 있습니다.
    스레드 개수가 증가할수록, 스레드 생성과 스케줄링으로 CPU 점유율이 올라가고 메모리 사용량이 늘어납니다.

    스레드의 폭증을 막으려면 스레드풀(ThreadPool)을 사용해야 합니다.
    스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리합니다.
    작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리합니다.

    자바에서는 java.util.concurrent 패키지에서 ExecutorService 인터페이스와 Executors 클래스를 제공합니다.
    Executors 클래스의 정적 메소드로 다양한 ExecutorService 구현 객체인 스레드풀을 만들 수 있습니다.

    스레드풀의 종류는 세 가지가 있습니다.
    newCachedThreadPool()은 동적 크기로 처리할 작업이 있을 때 새 스레드를 생성합니다. 60초 동안 추가된 스레드가 아무 작업을 하지 않으면 추가된 스레드를 종료하고 풀에서 제거합니다.
    newFixedThreadPool()은 최대 스레드 개수를 설정하며, 유후 스레드가 있더라도 스레드 개수가 줄지 않습니다.
    newSingleThreadPool()은 하나의 스레드를 생성하며, 작업이 차례대로 실행되며 스레드 안전하다.


- 쓰레드를 구현하기 위한 인터페이스, 클래스
    Runnable 인터페이스를 사용하여 람다 혹은 내부클래스로 run() 메서드 구현
    새로운 클래스를 정의하고 Thread 클래스를 상속받은 후 run() 메서드 구현

    다른 클래스를 상속받지 않아도 될 때 => Thread 클래스 상속 후 구현
    Thread 클래스에 존재하는 다른 메소드들도 사용하고 싶을 때 => Thread 클래스 상속 후 구현
    그외는 Runnable 구현


- 자바에서 스레드의 상태를 제어하는 방법을 알려주세요.
      스레드는 다음과 같은 상태를 가집니다, NEW, RUNNABLE, TIMED_WAITING, BLOCKED, TERMINATED.
      스레드 객체를 생성하고 start() 메소드가 호출되지 않은 상태일 때 NEW 상태입니다.
      RUNNABLE 은 실행 상태로 언제든지 갈 수 있는 상태입니다.
      WAITING 은 다른 스레드가 notify 해줄 때 까지 기다리는 상태입니다.
      TIMED_WAITING 은 주어진 시간 동안 기다리는 상태입니다.
      BLOCKED 는 사용하고자 하는 객체의 락이 풀릴 때 까지 기다리는 상태입니다.
      TERMINATED 는 실행을 마친 상태입니다.

      1. 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행대기열에 저장되어 자신의 차례가 될 때까지 기다려야 합니다. (실행 대기열은 큐와 같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행됩니다.)
      2. 자기 차례가 되면 실행상태가 됩니다.
      3. 할당된 실행시간이 다되거나 yield()메소드를 만나면 다시 실행 대기상태가 되고 다음 쓰레드가 실행됩니다.
      4. 실행 중에 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있습니다.
          ※ I/O Block은 입출력 작업에서 발생하는 지연상태를 말합니다. 사용자의 입력을 받는 경우를 예로 들 수 있습니다.
      5. 지정된 일시정지시간이 다되거나, notify(), resume(), interrupt()가 호출되면 일시정지상태를 벗어나
         다시 실행 대기열에 저장되어 자신의 차례를 기다리게 됩니다.
      6. 실행을 모두 마치거나 stop()이 호출되면 쓰레드를 소멸됩니다.

      스레드의 wait() 메소드는 동기화 블록 내에서 스레드를 WAITING 상태로 만듭니다. 매개값으로 주어진 시간이 지나면 자동적으로 RUNNABLE 상태가 된다.
      주어지지 않으면, notify(), notifyAll() 메소드로 RUNNABLE 상태로 이동한다.
      notify(), notifyAll() 메소드는 동기화 블록 내에서 wait() 메소드에 의해 WAITING 상태에 있는 스레드들을 RUNNABLE 상태로 만든다.
      join() 메소드를 호출한 스레드는 WAITING 상태로 만든다. RUNNABLE 상태로 가기 위해서 join() 메소드를 호출 받은 스레드가 종료되거나, 매개값으로 주어진 시간이 지나야 한다.


- connection timeout/read timeout/socket timeout


- JDBC Timout
    - Timeout 계층 구조
        - timeout은 계층적 구조를 갖고 있다. 상위timeout은 하위timeout에 의존적
        - 즉, 하위 timeout이 제대로 동작해야지 상위 timeout 또한 제대로 동작한다.

        - Transaction Timeout
            - 애플리케이션의 한 트랙잭션에서 수행하는 모든 Statememt가 수행될 때 유효한 timeout
            - spring의 @Transactional(timeout = )으로 직접 설정이 가능하며 default로 시스템 timeout을 이용한다.
            - Thread Local에 Connection 정보를 저장한 뒤 경과 시간을 체크하여 예외를 발생시킨다.

        - Statement Timeout
            - 하나의 쿼리가 수행될 때 유효한 timeout 이다.
            - 쿼리생성부터 요청까지의 시간이므로 네트워크 장애와는 무관하다.

            - Connection.createStatement()를 이용해 Statement생성
            - executeQuery() 호출
            - DBMS로 쿼리 전송
            - 새로운 timeout처리 스레드를 생성하고 등록, 동일한 커넥션 정보로 커넥션 획득
            - timeout이 발생하면 timeout처리 스레드가 DBMS로 직전 쿼리 취소 쿼리 호출

        - JDBC Driver Socket Timeout
            - JDBC Driver가 DBMS와 통신하는 타입은 4가지가 있다. 그 중 소켓을 이용한 타입이 있고 소켓은 네트워크 통신을 담당
            - 적절히 socket timeout을 설정하여 네트워크 장애 또한 상대 서버 장애로 인한 무응답 상태에 대처할 수 있다.

        - OS Socket Timeout
            - JDBC도 결국 OS의 소켓을 이용하기 때문에 OS소켓의 timeout을 설정하면 애플리케이션에도 영향을 끼친다.
            - 위에서 언급한 timeout은 애플리케이션에서 설정한 논리적인 timeout이고 OS Socket Timeout은 시스템 전체에 미치는 timeout이다.


- 가시성 문제와 원자성 문제에 대해 설명하라.
    - 가시성 문제
        여러 개의 스레드가 사용됨에 따라, CPU Cache Memory 와 RAM 의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다.
        가시성을 보장되어야 하는 변수에 volatile 키워드를 붙여줘서 RAM 에서 바로 읽도록 해야 한다.
        그러나 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 해서 동시성이 보장되지 않는다.

    - 원자성 문제
        여러 스레드가 공유 자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미한다. 따라서 synchronized, atomic 을 통해 원자성을 보장해야 한다.


- 교착상태(데드락, Deadlock)의 개념과 조건 ??
    - DeadLock의 개념
        - 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생
        - 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황이 발생 할 수 있습니다. 어떤 프로세스가 자원을 요청 했을 때
          그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있고 그 때는 프로세스가 대기 상태로 들어 가게됩니다. 대기 상태로 들어간 프로세스들이
          실행 상태로 변경 될 수 없을 때 이러한 상황을 교착 상태라 합니다.

    - 데드락 (Dead lock)의 발생 조건
        - 교착 상태는 한 시스템 내에서 다음의 네 가지 조건이 동시에 성립 할 때 발생합니다
        - 따라서, 아래의 네 가지 조건 중 하나라도 성립하지 않도록 만든다면 교착 상태를 해결할 수 있습니다.
            - 상호 배제 (Mutual exclusion)
                - 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
            - 점유 대기 (Hold and wait)
                - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
            - 비선점 (No preemption)
                - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
            - 순환 대기 (Circular wait)
                - 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.

    - 데드락 (Dead lock) 처리
        - 교착 상태 예방(Prevention) 및 회피(Avoidance)
            <예방(Prevention)법> : 교착 상태 발생 조건 중 하나를 제거함으로써 해결하는 방법 - 자원의 낭비가 심하다.
            <회피(Avoidance)법> : 교착 상태가 발생하면 피해나가는 방법
            - 은행원 알고리즘 (Banker’s Algorithm)
                E,J,Dijkstra가 제안한 방법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법이다.프로세스가 자원을 요구할 때
                시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피하는 기법 안정 상태에 있으면 자원을 할당하고,
                그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기함 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법

        - 교착 상태 탐지 및 회복
            - 교착 상태가 되도록 허용한 다음에 회복시키는 방법 -> - 교착 상태 무시
            - 대부분의 시스템은 교착 상태가 잘 발생하지 않으며, 교착 상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

            <교착 상태 탐지 (Detection)>
            - 자원 할당 그래프를 통해 교착 상태를 탐지할 수 있다. - 자원을 요청할 때마다 탐지 알고리즘을 실행하면 그에 대한 오버헤드가 발생한다
            <교착 상태로부터 회복 (Recovery)> - 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 회복하는 것을 의미한다. - 프로세스를 종료하는 방법
            1. 교착 상태의 프로세스를 모두 중지
            2. 교착 상태가 제거될 때까지 한 프로세스씩 중지 - 자원을 선점하는 방법
            1. 교착 상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며, 해당 프로세스를 일시 정지 시키는 방법
            2. 우선 순위가 낮은 프로세스, 수행된 횟수가 적은 프로세스 등을 위주로 프로세스의 자원을 선점한다.



- thread save란?

- 갑자기 cpu가 높아지면?


- 오버 플로우 ??

- 멀티 프로세스 , 스레드 환경에서 동기화 문제는 어떻게 해결하나요 ??

- Critical Section(임계영역)에 대해 설명해주세요.??

- 교착상태(데드락, Deadlock)의 개념과 조건 ??