- 메모리 계층 (상-하층 순)
    - 레지스터
    - 캐시
    - 메모리
    - 하드디스크

- 외부 단편화와 내부 단편화란?
    - 외부 단편화 : 작업보다 많은 공간이 있더라도 실제로 그 작업을 받아들일 수 없는 경우 (메모리 배치에 따라 발생하는 문제)
    - 내부 단편화 : 작업에 필요한 공간보다 많은 공간을 할당받음으로써 발생하는 내부의 사용 불가능한 공간

- 사용자 수준 스레드 vs 커널 수준 스레드 차이는?
  #사용자 수준 스레드
  장점 : context switching이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)
  단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)

  #커널 수준 스레드
  장점 : 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음
  단점 : context switching이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.

- Race Condition이란?
    - 두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황
    - ace Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.

- 프로세스의 상태도 저장된다고 했는데 프로세스의 상태는 어떤것들이 있나요?
    - 실행 : CPU를 점유하고 있는 상태이며 실행되고 있는 상태입니다.
    - 준비 : CPU만 할당 받는다면 즉시 수행가능합니다.
    - 봉쇄 : CPU할당 받아도 실행못하는 상태입니다. 예를 들어 입출력 작업은 CPU가 할 수 있는일이 없기 때문에 다른 장치로부터 신호가 와야합니다.


- 스레드는 왜 독립적인 스택 메모리를 가지나요?
    - 스택영역의 정의부터 정확하게 알아야합니다. 스택영역은 스레드가 프로세스 내에서 함수호출시 전달되는 인자, 함수의 리턴주소등을 저장하기 위한 메모리 영역입니다.
      스레드가 하나의 프로세스 내에서 독립적인 기능을 하기 위해서는 독립적인 함수를 호출해야함을 의미하며 이는 독립적인 스택 메모리를 가져야만 가능합니다.


- 멀티 프로세스와 멀티 스레드를 비교해주세요.
    - 문맥교환시 멀티스테드는 스택영역의 내용만 변경되면 되지만 멀티 프로세스의 경우 힙,데이터,코드 영역의 정보까지 바뀌므로 문맥교환의 비용이 멀티프로세스가 높습니다.
    - 멀티 프로세스는 많은 CPU시간과 메모리공간을 차지하며 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않습니다.
    - 멀티 스레드는 적은 메모리 공간을 차지하고 문맥교환 비용이 적으며 자원을 공유하기 때문에 동기화 문제가 발생할 수 있고 하나의 스레드 장애가 여러 스레드의 장애로 이어질 위험이 있습니다.


- 멀티 프로세스들이 실행되는 과정을 간략하게 표현해주세요.

- 프로세스간 통신은 어떻게 하나요?
    - 스레드는 서로의 자원을 공유하고 있기 때문에 스레드간 통신은 별도의 자원을 사용하지 않아도 됩니다.
      하지만 프로세스의 경우 데이터를 공유하고 있지 않기 때문에 공유메모리를 사용하는 방법과 메세지전달 방법으로 2가지 방법이 있습니다.
    - 공유 메모리 : 프로세스들이 주소 공간 일부를 공유하는 것을 의미합니다. 커널이 메모리에 별도의 shared memory를 할당합니다.
      프로세스들은 shared memory의 정보를 이용해 서로 데이터를 전달 및 공유 합니다.
    - 메세지 전달 : 시스템 콜을 이용하여 구현합니다. 시스템 콜이란 커널영역에서 사용하는 명령어들이며 커널을 통해 메세지를 보내고 받습니다.
      즉, 프로세스들 사이에 커널이 데이터를 중재하는 것입니다. 예를 들어, pipe , socket , message queue 가 있습니다.
    - 2가지 방식의 장단점 역시 존재합니다. 공유메모리를 사용할 경우 간단하지만 메모리를 공유하기 때문에 자원 동기화의 문제가 있을 것이며 메세지를 전달한다면 동기화 문제는 없지만 속도가 느립니다.


- 멀티 프로세스 , 스레드 환경에서 동기화 문제는 어떻게 해결하나요?
    - 해결하는 방법은 뮤텍스 또는 세마포어를 사용합니다.
    - 뮤텍스 : 1개의 스레드만 공유자원에 접근가능합니다.
    - 세마포어 : S개의 스레드만이 공유자원에 접근가능합니다. 스레드가 접근할 때 마다 S의 개수를 감소시키며 S가 0이라면 자원에 접근 할 수 없습니다.

    - critical section : 공유할 자원들 즉, 코드 영역에서 여러 스레드들이 접근 할 수 있는 부분을 통제하기 위해서 둘 이상의 프로세스 또는
      스레드가 접근하는 것을 막는 코드 부분을 임계영역 (critical section)이라고 합니다. 또한 임계영역내에서 코드들은 원자적으로 실행되어야 합니다.
    - entry section : 진입 허가 요청이 완료되어야 임계영역으로 갈수 잇습니다.
    - exit section : 임계영역 실행후 끝나는 부분
    - entry section -> critical secition -> exit section 으로 이동합니다.


- 운영체제는 프로세스를 메모리로 올릴 때 메모리 관리를 어떻게 하나요?
    - 프로세스를 통째로 연속된 메모리에 올려놓는 일은 거의 없습니다. 이때까지 편의를 위해 그림으로 그렇게 표현했지만 프로세스들을 무작정 물리 메모리에 순서대로 올리면 많은 문제들이 발생합니다.
    - 효율적으로 프로세스들에게 메모리를 할당해주기 위한 기법이 생기기 시작했습니다. 바로 페이징과 세그멘테이션입니다.


- 페이징(Paging)은 무엇인가요?
    - 물리 메모리를 동일한 크기로 조각조각 냅니다. 이때 하나의 조각을 페이지라고 합니다. 메모리에 올릴 프로세스도 페이지의 크기만큼 조각내서
      물리 메모리에 저장하는 방식입니다. 그렇게 되면 물리 메모리에 연속되서 저장될 필요없이 페이지 단위로 분산되어 저장 가능합니다.
      프로세스 입장에서는 자신의 페이지들이 어디있는지 알아야하는데 이를 위해 페이지 테이블이라는 것이 존재합니다.
    - 프로세스당 하나의 페이지 테이블을 가집니다. 하나의 프로세스 내에서 페이지단위로 물리적메모리에 저장되기 때문에 주소를 바인딩하기위해 별도의 테이블이 필요합니다.
      물리메모리 주소를 프레임번호라고도 합니다.


- 페이징 기법에서 문제점이 있나요?
    - 메모리 내부 단편화 문제가 발생합니다. 프로세스를 페이지 단위로 쪼개다보면 페이지 안에 안쓰는 공간이 남습니다.
      예를 들어 100 크기의 프로세스를 30크기의 페이지로 쪼개면 4개의 페이지로 나오고 마지막 페이지는 20이 남습니다.
      이러한 페이지를 물리메모리에 할당하게 되면 20이라는 공간은 아무것도 안하고 남아있는 공간이 됩니다.
    - 외부 단편화 문제는 발생하지 않습니다. 외부단편화는 남아있는 공간은 작은데 그 공간보다 큰 프로세스를 집어넣으려고 할때 발생하는데
      프로세스를 페이지 단위로 나누기 때문에 페이지 단위로 무조건 할당됨을 보장하므로 메모리를 할당하지 못해서 나오는 외부단편화 문제는 발생하지 않습니다.


- 세그먼테이션(Segmentation)이 무엇인가요?
    - 페이지는 프로세스를 크기단위로 똑같이 나뉘었다면 세그먼테이션은 의미단위로 메모리를 나누는 것을 의미합니다.
      프로세스를 코드,데이터,힙,스택으로 기능 단위로 정의한다면 4가지로 조각내어 메모리에 저장합니다.
      세그먼테이션은 페이징과 마찬가지로 물리적 주소로 변환하기 위한 세그먼테이션테이블을 가지고 있습니다.
    - 만약 논리적 주소가 2 / 200 이라면 어떨까요? 2는 세그먼트 번호를 의미하고 200은 떨어진 거리를 의미합니다.
      따라서 세그먼트2번의 주소가 3500 부터 시작하고 3500에서 200떨어진 거리인 3700이 2/200 의 논리적주소가 변경된 물리적 주소입니다.
    - 이처럼 세그먼트는 모든 크기가 다르기 때문에 항상 시작점과 limit를 같이 표기해야합니다.


- 세그먼테이션의 단점이 있나요?
    - 세그먼테이션은 메모리의 내부단편화 문제가 없습니다. 왜냐하면 필요한 만큼 메모리를 정확하게 할당 받기 때문입니다.
    - 외부 단편화문제가 존재합니다. 세그먼트가 너무 커서 특정 공간에 할당 못할 수도 있습니다. 세그먼트를 쪼개면 가능하겠지만 이는 불가능합니다.


- 가상메모리가 무엇인가요?
    - 운영체제는 메모리를 더욱더 효율적으로 사용하기 위해서 도입한 개념입니다.
    - 정의 : 프로세스 전체가 메모리에 올라오지 않아도 실행이 가능하도록 하는 것입니다.

    - 이때까지 메모리에 프로세스 전체가 올라가는 그림이 그려졌습니다. 하지만 가상메모리는 프로세스 전체가 메모리로 올라오지 않습니다.
      어떻게 메모리에 전체 프로세스를 올리지 않더라도 프로세스를 실행할 수 있는 것일까요?
    - 운영체제는 가상메모리 기법을 통해서 프로그램의 논리적 주소 영역에서 필요한 부분만 물리 메모리에 적재하고 직접적으로 필요하지 않은 부분은 디스크(SWAP)에 저장하는 것을 말합니다.

    - 페이징 기법을 쓰는 운영체제에서 가상메모리를 사용한다고 가정해봅시다. 당장 사용될 주소 공간을 page단위로 메모리에 적재하는 방법을 요구페이징이라고 합니다.
      요구 페이징에서는 특정 페이지에 대해 cpu요청이 들어온 후에 해당 페이지를 메모리에 적재합니다. 당장 실행에 필요한 페이지만을 메모리에 적재하기 때문에
      메모리 사용량이 감소하고 프로세스 전체를 메모리에 적재하는 입출력 오버헤드도 감소합니다. 요구페이징 기법에서는 유효/무효 비트를 두어서 각 페이지가 메모리에 존재하는지 표시하게 됩니다.


- 요구페이징에서 CPU가 요청한 메모리에 없고 디스크에 있다면 어떻게 되나요?
    1) CPU가 페이지 참조
    2) 페이지 테이블을 보니 페이지 상태가 "무효" 상태
    3) MMU에서 페이지 폴트 트랩을 발생
    4) 디스크에서 메모리로 페이지를 가져온 후 "유효" 상태로 변경

    이와 같이 요청한 페이지가 없는 경우를 페이지 폴트(Page fault)라고 합니다.

- 페이지 폴트 발생 후 메모리로 페이지를 가져오려는 데 메모리도 부족한 경우라면 어떤 페이지를 교체하나요?
    - 이를 위한 알고리즘이 존재합니다. 바로 페이지교체 알고리즘입니다.
    - LRU : 가장 오랫동안 사용하지 않은 페이지를 메모리에서 디스크로 방출합니다.
    - LFU : 참조 횟수가 가장 적었던 페이지를 메모리에서 디스크로 방출합니다.