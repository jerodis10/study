- 버블 정렬(Bubble Sort)에 대해 설명해주세요.
    - 정의
        - 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘
        - 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.

    - 장점
        1. 추가적인 메모리 소비가 작다.
        2. 구현이 매우 쉽다.
        3. 안정정렬이 가능하다.

        - 구현이 매우 간단
    - 단점
        1. 다른 정렬 알고리즘에 비해 교환 과정이 많아 많은 시간을 소비한다.

        - 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
        - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
        - 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
        - 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.

    - 시간 복잡도
        - 비교횟수
            - 최상, 평균, 최악 모두 일정
            - n-1, n-2, … , 2, 1 번 = n(n-1)/2
        - 교환 횟수
            - 입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 (비교 횟수 * 3) 번 = 3n(n-1)/2
            - 입력 자료가 이미 정렬되어 있는 최상의 경우, 자료의 이동이 발생하지 않는다.
        - T(n) = O(n^2)


- 삽입 정렬(Injection Sort)에 대해 설명해주세요.
    - 정의
        - 삽입 정렬은 현재 비교하고자 하는 target(타겟)과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법이다.
        - 삽입 정렬은 두 번째 값부터 시작해 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
        - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘

    - 장점
        1. 추가적인 메모리 소비가 작다.
        2. 거의 정렬 된 경우 매우 효율적이다. 즉, 최선의 경우 O(N)의 시간복잡도를 갖는다.
        3. 안장정렬이 가능하다.

        - 안정한 정렬 방법(바로 옆의 데이터와 비교하기 때문)
        - 자료의 수가 적을 경우 알고리즘 구현이 매우 간단
        - 이미 정렬되어 있는 경우나 자료의 수가 적은 정렬에 매우 효율적
    - 단점
        1. 역순에 가까울 수록 매우 비효율적이다. 즉, 최악의 경우 O(N2)의 시간 복잡도를 갖는다.
        2. 데이터의 상태에 따라서 성능 편차가 매우 크다.

        - 비교적 많은 레코드들의 이동을 포함
        - 자료의 수가 많고 자료의 크기가 클 경우 적합하지 않음

    - 시간 복잡도
        - 최선의 경우
            - 비교 횟수
                - 이동 없이 1번의 비교만 이루어진다.
                - 외부 루프: (n-1)번
            - Best T(n) = O(n)
            -> 각 라운드에서 비교수행을 했는지를 판단할 수 있는 변수를 하나 두고 swap이 발생하지 않는 케이스
        - 최악의 경우(입력 자료가 역순일 경우)
            - 비교 횟수
                - 외부 루프 안의 각 반복마다 i번의 비교 수행
                - 외부 루프: n(n-1)/2 = O(n^2)
            - 교환 횟수
                - 외부 루프의 각 단계마다 (i+2)번의 이동 발생
                - n(n-1)/2 + 2(n-1) = O(n^2)
            - Worst T(n) = O(n^2)

        - 평균 시간복잡도는 O(n^2)이며, Best Case 의 경우 O(n)까지 높아질 수 있습니다.


- 선택 정렬(Selection Sort)에 대해 설명해주세요.
    - 정의
        - 선택 정렬은 첫 번째 값을 두번째 부터 마지막 값까지 차례대로 비교하여 최솟값을 찾아 첫 번째에 놓고,
          두 번째 값을 세 번째 부터 마지막 값까지 비교하여 최솟값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬하는 알고리즘

    - 장점
        1. 추가적인 메모리 소비가 작다.

        - 자료 이동 횟수가 미리 결정된다.

    - 단점
        1. 시간복잡도가 O(N2) 이다.
        2. 안정 정렬이 아니다.
            예로들어 학생을 관리하고자 할 때, 성적순으로 나열하되, 성적이 같으면 이름을 기준으로 정렬하고 싶다고 할 때.
            즉, 정렬 규칙이 다수이거나 특정 순서를 유지해야 할 때 문제가 될 수 있다.

        - 안정성을 만족하지 않는다. 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.


- 병합 정렬(Merge Sort)에 대해 설명해주세요.
    - 정의
        - 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법
            - 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
            - 정복(Conquer): 해당 부분리스트의 길이가 1이 아니라면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.
            - 결합(Combine): 인접한 부분리스트끼리 정렬하여 합친다.

    - 장점
        1. 항상 두 부분리스트로 쪼개어 들어가기 때문에 최악의 경우에도 O(NlogN) 으로 유지가 된다.
        2. 안정정렬이다.

        - 안정적인 정렬 방법
            - 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlog₂n)로 동일)
        - 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
            - 제자리 정렬(in-place sorting)로 구현할 수 있다.
        - 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.

    - 단점
        1. 정렬과정에서 추가적인 보조 배열 공간을 사용하기 때문에 메모리 사용량이 많다.
        2. 보조 배열에서 원본배열로 복사하는 과정은 매우 많은 시간을 소비하기 때문에 데이터가 많을경우 상대적으로 시간이 많이 소요된다.

        - 병합하는 과정에서 입력 자료들의 크기 n 만큼의 메모리가 추가적으로 필요
        - 레크드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

    - 시간 복잡도
        - 분할 단계
            - 비교 연산과 이동 연산이 수행되지 않는다.
        - 합병 단계
            - 비교 횟수
                - 재귀 호출의 깊이 (합병 단계의 수)
                    - 레코드의 개수 n 이 2의 거듭제곱이라고 가정(n=2^k)했을 때, n=2^3의 경우, 2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어
                      재귀 호출의 깊이가 3임을 알 수 있다. 이것을 일반화하면 k(k=log2n)임을 알 수 있다.
                - 각 합병 단계의 비교 연산
                    - 최대 n번
                - 재귀 호출의 깊이만큼의 합병 단계 * 각 합병 단계의 비교 연산 = nlog2n
            - 이동 횟수
                - 재귀 호출의 깊이 (합병 단계의 수)
                    - k = log2n
                - 각 합병 단계의 이동 연산
                    - 임시 배열에 복사했다가 다시 가져와야 하므로 이동 연산은 총 부분 배열에 들어 있는 요소의 개수가 n인 경우, 레코드의 이동이 2n번이 발생한다.
                - 재귀 호출의 깊이 만큼의 합병 단계 * 각 하병 단계의 이동 연산 = 2log2n
        - T(n) = nlog2n(비교) + 2nlog2n(이동) = 3nlog2n = O(nlog2n)


- 퀵 정렬(Quick Sort)에 대해 설명해주세요.
    - 정의
        하나의 리스트를 피벗(pivot)을 기준으로 두 개의 부분리스트로 나누어 하나는 피벗보다 작은 값들의 부분리스트,
        다른 하나는 피벗보다 큰 값들의 부분리스트로 정렬한 다음, 각 부분리스트에 대해 다시 위 처럼 재귀적으로 수행하여 정렬하는 방법이다.

        - 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
        - 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.
        - 피봇을 설정하고 피봇보다 큰 값과 작은 값으로 분할하여 정렬

    - 장점
        1. 특정 상태가 아닌 이상 평균 시간 복잡도는 NlogN이며, 다른 NlogN 알고리즘에 비해 대체적으로 속도가 매우 빠르다.
           유사하게 NlogN 정렬 알고리즘 중 분할정복 방식인 merge sort에 비해 2~3배정도 빠르다. (정리 부분의 표 참고)
        2. 추가적인 별도의 메모리를 필요로하지 않으며 재귀 호출 스택프레임에 의한 공간복잡도는 logN으로 메모리를 적게 소비한다.

        - 속도가 빠르다.
            - 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
        - 추가 메모리 공간을 필요로 하지 않는다.
            - 퀵 정렬은 O(logn)만큼의 메모리를 필요로 한다.

    - 단점
        1. 특정 조건하에 성능이 급격하게 떨어진다.
        2. 재귀를 사용하기 때문에 재귀를 사용하지 못하는 환경일 경우 그 구현이 매우 복잡해진다.

        - 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
        - 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.

    - 시간 복잡도
        - 최선의 경우 (2개의 n/2의 부분 문제로 나눌 때)
            - 비교 횟수
                - 재귀 호출의 깊이
                    - 레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, n=2^3의 경우, 2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어
                      순환 호출의 깊이가 3임을 알 수 있다. 이것을 일반화하면 n=2^k의 경우, k(k=log₂n)임을 알 수 있다.
                - 각 재귀 호출 단계의 비교 연산
                    - 각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 n번 정도의 비교가 이루어진다.
                    - 평군 n 번
                - 순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = nlog₂n
            - 이동 횟수
                - 비교 횟수보다 적으므로 무시할 수 있다.
            - Best T(n) = O(nlog₂n)
        - 최악의 경우 (n-1개와 0개짜리 부분 문제로 나눌 때)
            - 리스트가 계속 불균형하게 나누어지는 경우 (특히, 이미 정렬된 리스트에 대하여 퀵 정렬을 실행하는 경우)
            - 비교 횟수
                - 재귀 호출의 깊이
                    - 레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, 순환 호출의 깊이는 n임을 알 수 있다.
                - 각 재귀 호출 단계의 비교 연산
                    - 각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 n번 정도의 비교가 이루어진다.
                - 순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = n^2
            - 이동 횟수
                - 비교 횟수보다 적으므로 무시할 수 있다.
            - Worst T(n) = O(n^2)
        - 평균
            - 평균 T(n) = O(nlog₂n)
            - 퀵 정렬이 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문이다.


- 힙 정렬(Heap Sort)에 대해 설명해주세요.
    - 정의
        - 힙 정렬은 주어진 데이터를 힙 자료구조로 만들어 최댓값 또는 최솟값부터 하나씩 꺼내서 정렬하는 알고리즘

    - 장점
        - 시간 복잡도가 좋은 편
        - 힙 정렬이 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우

    - 시간 복잡도
        - 힙 트리의 전체 높이가 거의 log₂n(완전 이진 트리이므로)이므로 하나의 요소를 힙에 삽입하거나 삭제할 때 힙을 재정비하는 시간이 log₂n만큼 소요된다.
        - 요소의 개수가 n개 이므로 전체적으로 O(nlog₂n)의 시간이 걸린다.
        - O(nlog₂n)


- Big-O
    - 알고리즘의 효율성을 나타내는 지표.
    - big-O를 이용하여 내가 개선한 알고리즘이 빨라졌는지, 메모리를 많이 잡아 먹지는 않는지 등의 알고리즘의 성능을 판단.

    - 시간 복잡도(Time Complexity)
        - 알고리즘에 사용되는 연산횟수의 총량
        - big-O에 대한 시간 개념으로 알고리의 수행 시간이 얼마인지를 나타냅니다. 수행되는 연산의 수를 가지고 계산하며 알고리즘에서 중요하지 않는 값들은 최대한 무시합니다.
        - 알고리즘의 효율성은 데이터의 입력 값이 얼마나 큰지에 따라 영향을 받기 때문에 이런 사소한 부분을 무시할 수 있는 것입니다.

    - 공간 복잡도
        - 알고리즘에 사용되는 메모리 공간의 총량
        - 알고리즘이 공간을 얼마나 필요로 하는지를 나타냅니다. 요즘에는 데이터를 저장할 수 있는 메모리의 발전으로 중요도가 낮아졌다
        - 함수의 재귀적인 호출의 경우 스택 공간도 고려해야 합니다.


- Array(List)의 가장 큰 특징과 그로 인해 발생하는 장점과 단점에 대해 설명해주세요.
    - Array의 가장 큰 특징은 순차적으로 데이터를 저장한다는 점입니다.
    - 데이터에 순서가 있기 때문에 0부터 시작하는 index가 존재하며, index를 사용해 특정 요소를 찾고 조작이 가능하다는 것이 Array의 장점입니다.
    - 순차적으로 존재하는 데이터의 중간에 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점도 있습니다.
      이러한 이유로 Array는 정보가 자주 삭제되거나 추가되는 데이터를 담기에는 적절치 않습니다.


- Stack과 Queue, Tree와 Heap의 구조에 대해 설명해주세요.
    - Stack과 Queue는 선형 자료구조의 일종이며, Array와 LinkedList로 구현할 수 있습니다.
      Stack은 후입선출(LIFO)방식 즉, 나중에 들어간 원소가 먼저 나오는 구조이고
    - Queue는 선입선출(FIFO)방식 즉, 먼저 들어간 원소가 먼저 나오는 구조를 갖습니다.

    - Tree는 스택과 큐와 같은 선형 구조가 아닌 비선형 자료구조이며, 계층적 관계를 표현하기에 적합합니다.
    - Heap은 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로,
      각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리 입니다.


- Stack과 Queue의 실사용 예를 들어 간단히 설명해주세요.
    - Stack - 자바의 Stack 메모리 영역
        지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출시 메모리에 할당되고 종료되면 메모리가 해제되며, LIFO(Last In First Out)구조를 가집니다.

    - Queue - OS의 스케쥴러
        자원의 할당과 회수를 하는 스케쥴러 역할을 큐가 할 수 있습니다.
        메모리에 적재된 다수의 프로세스 중 어떤 프로세스에게 자원을 할당할 것인가 그 순서를 결정하는 것이 자원의 효율적인 사용에 있고,
        가장 단순한 형태의 스케쥴링 정책이 선입선처리(First Com First Served) 즉, 큐라고 볼 수 있습니다.


- Priority Queue(우선순위 큐)에 대해 설명해주세요.
    - 우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조
    - 우선순위 큐 구현 방식에는 배열, 연결 리스트, 힙이 있고, 그중 힙 방식이 worst case라도 시간 복잡도 O(logN)을 보장하기 때문에 일반적으로 완전 이진트리 형태의 힙을 이용해 구현


- Array와 ArrayList의 차이점에 대해 설명해주세요. ??
    - Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.
      Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고,
    - ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다.


- ArrayList vs 배열
    - ArrayList
        - 연속적인 데이터의 리스트 (데이터는 연속적으로 리스트에 들어있어야 하며 중간에 빈공간이 있으면 안된다)
        - ArrayList 클래스는 내부적으로 Object[] 배열을 이용하여 요소를 저장
        - 배열을 이용하기 때문에 인덱스를 이용해 요소에 빠르게 접근할 수 있다.
        - 크기가 고정되어있는 배열과 달리 데이터 적재량에 따라 가변적으로 공간을 늘리거나 줄인다.
        - 그러나 배열 공간이 꽉 찰때 마다 배열을 copy 하는 방식으로 늘리므로 이 과정에서 지연이 발생하게 된다.
        - 데이터를 리스트 중간에 삽입/삭제 할 경우, 중간에 빈 공간이 생기지 않도록 요소들의 위치를 앞뒤로 자동으로 이동시키기 때문에 삽입/삭제 동작은 느리다.
        - 따라서 조회를 많이 하는 경우에 사용하는 것이 좋다.

    - 배열
        - 처음 선언한 배열의 크기(길이)는 변경할 수 없다. 이를 정적 할당(static allocation)이라고 한다.
        - 데이터 크기가 정해져있을 경우 메모리 관리가 편하다.
        - 메모리에 연속적으로 나열되어 할당하기 때문에 index 를 통한 색인(접근)속도가 빠르다.
        - index 에 위치한 하나의 데이터(element)를 삭제하더라도 해당 index 에는 빈공간으로 계속 남는다.
        - 배열의 크기를 변경할 수 없기 때문에, 처음에 너무 큰 크기로 설정해주었을 경우 메모리 낭비가 될수 있고, 반대로 너무 작은 크기로 설정해주었을 경우 공간이 부족해지는 경우가 발생 할 수 있다.


- Array와 LinkedList의 장/단점에 대해 설명해주세요.
    - Array
        - 인덱스(index)로 해당 원소(element)에 접근할 수 있어 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있습니다.
          즉, RandomAccess가 가능해 속도가 빠르다는 장점
        - 삽입 또는 삭제의 과정에서 각 원소들을 shift 해줘야 하는 비용이 생겨 이 경우 시간 복잡도는 O(n)이 된다는 단점이 있습니다.

    - linkedlist
        - 연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.
        - 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)로 해결
        - LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함.
        - 데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함

    -> Array는 검색이 빠르지만, 삽입, 삭제가 느리다.
       LinkedList는 삽입, 삭제가 빠르지만, 검색이 느리다.


- ArrayList 는 내부적으로 어떻게 구현되어있을까요?
    - ArrayList 는 배열을 좀 더 편하게 쓸 수 있도록 Java 에서 제공해주는 Class 입니다. 일반 배열과는 다르게 메모리가 가능한 한
      추가할 수 있고 삭제에 대해서도 해당 index 를 비워두기만 하는게 아니라 재정렬해주는 기능을 기본으로 제공해주고 있습니다.
    - ArrayList 는 새 요소를 추가하고자 할 때, capacity 가 기존 배열의 크기와 같아지면 기존 용량의 1.5배만큼 증가시키고 그 크기가 늘어난
      배열에 기존 elementData 를 copy 한다. 실제로는 정적 배열을 사용하지만, 요소가 추가될 때마다 최소 증가량을 계산하여 크기를 늘리는 방식
    - 자료를 대량으로 추가하거나 삭제하면 내부 처리 작업이 늘어나서 성능이 떨어질 수 있다.

    - add: 실제로 배열의 크기를 재산정하고 기존(old)에 있던 정보를 새로운 배열(new)에 넣는 메서드입니다.
           크기를 재산정 할때는 원래크기만큼 새로운 배열에 복사를 해야하므로 시간복잡도 O(n)을 가지며 추가할 때 O(1)
    - remove: remove 메서드를 실행하면 가장 먼저 입력받은 index 가 적절한 값인지 체크합니다. 그리고 삭제되는 Object 의 값을 가져와서
              변수에 담습니다. 그 후 arraycopy 를 이용해 삭제되는 부분 + 1 ~ 마지막까지의 영역을 삭제되는 부분의 시작점을 기준으로
              해서 옮깁니다. 그러면 삭제될 부분의 값은 다음 index 의 값으로 겹쳐서 덮여 쓰여지게 됩니다. 그리고 size 의 마지막 index 는
              size - 1의 값과 중복되기 때문에 null 처리를 하여 GC가 삭제할 수 있도록 합니다. 그 후 임시 변수에 담아두었던
              삭제된 값을 리턴합니다.
              삭제를 할때 우리는 index + 1에서 부터의 값을 index 부터 시작하게끔 복사한다는 것을 알 수 있었습니다. 그때 O(n)의
              시간복잡도를 가지며 마지막 값을 null 로 변경해줍니다. 이때는 O(1)을 가지겠죠. 삭제에 대해서는 항상
              시간복잡도 O(n)을 가진다는 것을 알 수 있습니다.


- 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.
    - 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조
    - 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문
    - 각 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회
    - 하지만 index값이 충돌이 발생한 경우 Chanining에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다.


- Hash Map과 Hash Table의 차이점에 대해 설명해주세요.
    - 동기화 지원 여부와 null 값 허용 여부의 차이가 있습니다.

    - 해시 테이블(Hash Table)
        - 병렬 처리를 할 때 (동기화를 고려해야 하는 상황) Thread-safe 하다.
        - Null 값을 허용하지 않는다.

    - 해시 맵(Hash Map)
        - 병렬 처리를 하지 않을 때 (동기화를 고려하지 않는 상황) Thread-safe하지 않는다.
        - Null 값을 허용한다.


- HashMap vs HashTable vs ConcurrentHashMap
    - HashMap
        - key 와 value 에 null 을 허용
        - 동기화 보장x -> 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다.
          HashTable 과 ConcurrentHashMap 보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다. (thread-safe x)

    - HashTable
        - key 와 value 에 null 을 허용 x
        - 데이터를 다루는 메소드(get(), put(), remove() 등)에 synchronized 키워드가 붙어 있다.
          해당 키워드는 메소드를 호출하기 전에 쓰레드간 동기화 락을 건다.
          그러나, 쓰레드간 동기화 락은 매우 느린 동작이라는 단점이 있다.

    - ConcurrentHashMap
        - key 와 value 에 null 을 허용 x
        - 어떤 Entry 를 조작하는 경우에 해당 Entry 에 대해서만 락을 건다.
          그래서 HashTable 보다 데이터를 다루는 속도가 빠르다. 즉, Entry 아이템별로 락을 걸어 멀티 쓰레드 환경에서의 성능을 향상시킨다.

        - java 8 이전의 ConcurrentHashMap 은 ReentrantLock 을 상속 받는 Segment 를 이용하여 동기화를 구현하였었다. 이 때는 영역을 구분하여(기본 16개) 영역 별로 잠금을 하는 방식이었다.
          각 영역에서는 리사이징 되는 해시테이블을 갖는다. 하지만 java8 에서는 각 테이블 버킷을 독립적으로 잠그는 방식이다.
          빈 버킷으로의 노드 삽입은 lock 을 사용하지 않고 단순히 CAS 만을 이용해 삽입한다. 그 외의 업데이트(삽입, 삭제 및 교체)는 lock(synchronized) 을 이용하지만
          각 버킷의 첫 번째 노드를 기준으로 부분적인 잠금을 획득하여 스레드 경합을 최소화 하고 안전한 업데이트를 한다.


- HashMap 내부 구현   https://lordofkangs.tistory.com/78
    - 해싱 함수를 통해 인덱스를 산출
    - 인덱스를 통한 접근으로 시간복잡도 O(1)의 빠른 성능
    - key 는 무한하지만 인덱스는 한정되어 있어 충돌은 불가피
    - 충돌을 줄이기 위해 HashMap 은 버킷의 사이즈를 조절
    - 충돌이 일어날 시, 충돌 수가 적으면 LinkedList 방식으로 충돌된 객체들을 관리하다가 임계점을 넘으면 Red-Black Tree 방식으로 객체들을 저장


- HashMap vs HashTable vs ConcurrentHashMap   https://tecoble.techcourse.co.kr/post/2021-11-26-hashmap-hashtable-concurrenthashmap/
    - HashMap
        key와 value에 null을 허용한다.
        동기화를 보장하지 않는다.
            동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다.

    - HashTable
        key와 value에 null을 허용하지 않는다.
        동기화를 보장한다.
            데이터를 다루는 메소드(get(), put(), remove() 등)에 synchronized 키워드가 붙어 있다.
            해당 키워드는 메소드를 호출하기 전에 쓰레드간 동기화 락을 건다.
            그래서 멀티 쓰레드 환경에서도 데이터의 무결성을 보장한다. 그러나, 쓰레드간 동기화 락은 매우 느린 동작이라는 단점이 있다.

    - ConcurrentHashMap
        key와 value에 null을 허용하지 않는다.
        동기화를 보장한다.
            이 구현체는 HashMap의 동기화 문제를 보완하기 위해 나타났다.
            동기화 처리를 할 때, 어떤 Entry를 조작하는 경우에 해당 Entry에 대해서만 락을 건다. ??
            그래서 HashTable보다 데이터를 다루는 속도가 빠르다. 즉, Entry 아이템별로 락을 걸어 멀티 쓰레드 환경에서의 성능을 향상시킨다.


- HashMap 은 어떻게 구현되어 있길래 키와 값을 빠르게 매핑할 수 있을까?   https://velog.io/@dailyzett/HashMap
    - HashMap은 키를 해싱함수에 넣어 인덱스를 산출한 후, 해당 인덱스에 Map 데이터를 저장하는 것이 HashMap의 기본 원리
    - 인덱스를 통한 접근으로 시간복잡도 O(1)의 빠른 성능
    - Key는 무한하지만 인덱스는 한정되어 있어 충돌은 불가피 (Key는 문장부터 숫자까지 무한대로 존재, 인덱스는 배열의 크기보다 작은 정수로 한정되어 있다.)
    - 충돌을 줄이기 위해 HashMap은 버킷 사이즈 조절
    - 충돌이 일어날 시, 충돌 수가 적으면 LinkedList 방식으로 충돌된 객체들을 관리하다가, 임계점을 넘으면 Red-Black Tree 방식으로 객체들을 저장
    - 시간 복잡도는 Linked List 가 O(n), Red-Black Tree 가 O(logN) 이다.

    - 해시 충돌
        기본적으로 동일한 키에 동일한 해시가 있어야 되지만 다른 키에 동일한 해시가 있을 수 있다.
        다른 키이면서 동일한 해시인 경우 해당 키에 속한 값은 동일한 bucket에 저장된다.

        버킷 내부에서 값은 List에 저장되고 모든 요소를 순회하여 검색한다. 이 때의 시간 복잡도는 O(N)이 된다.
        Java 8 부터 버킷 한 개에 8개 이상의 값이 포함되는 경우 List 에서 balanced tree 로 변경되는데 시간 복잡도는 O(logN) 이다.

        해시코드 내부 구현을 잘하면 잘 할수록 HashMap의 성능을 좋아질 것입니다.(그만큼 충돌이 덜 발생하기 때문에)

    - key 의 적당한 갯수는?
        - 그렇다면 요소가 몇 개가 들어갈 지도 모르는 상황에서 키는 몇 개를 생성해야 할까?
            HashMap<Integer, String> map = new HashMap<>();

            Integer.MAX_VALUE 의 값은 2,147,483,647 이다. 아무리 데이터가 많다 해도 정수의 최댓값까지 모든 요소가 가득 차 있을 수는 없다.
            이 경우 할당된 메모리의 많은 부분이 사용되지 않은 상태가 되므로 공간이 낭비되고 검색 효율도 나빠진다.

            그래서 HashMap은 버킷(bucket)에 요소를 저장하고 이러한 버킷의 수를 용량(capacity) 라고 한다.
            bucket 을 우리말로 번역하면 양동이가 되는데 요소를 담는 양동이라고 생각하면 편하다.

            Map 컬렉션에 값을 넣을 때 키의 hashCode() 메서드는 값이 저장될 버킷을 결정하는 데 사용된다. 그리고 값을 검색하기 위해 HashMap 은
            hashCode()를 사용하여 동일 방식으로 버킷을 계산한다. 그런 다음 해당 버킷에서 찾은 객체를 순회해서 키의 equals() 메서드를 이용해 정확히 일치하는 항목을 찾는다.

            정리하면, HashMap 은 모든 요소를 순회하는 것이 아니라 키를 기반으로 값의 위치를 계산한다.


- BST(Binary Search Tree)와 Binary Tree에 대해 설명해주세요.
    - 이진트리(Binary Tree)는 자식 노드가 최대 두 개인 노드들로 구성된 트리이고,
      이진 탐색 트리(BST)는 이진 탐색과 연결 리스트를 결합한 자료구조
    - 이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하다는 장점
    - 이진 탐색 트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징
    - 이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h일 때 시간 복잡도는 O(h)이며,
      트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 O(n)의 시간 복잡도를 가집니다.
    - 이런 worst case를 막기 위해 나온 기법이 RBT(Red-Black Tree)입니다. ??


- RBT(Red-Black Tree)에 대해 설명해주세요. ??
    - RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식 자료구조이며,
      RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어졌습니다.
    - 노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장합니다. 이러한 NIL들을 leaf node로 간주합니다.
    - 모든 노드를 빨간색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않습니다.


- 선형 자료구조 (Linear Data Structure)
    - 연속된 데이터를 저장하기 위한 자료구조

    - 동적 배열
        - 새로운 연속된 공간에 데이터를 복사해서 생성하는 것
        - 중간에 데이터 삽입, 삭제 시 비효율
    - 연결 리스트
        - 연속된 공간에 데이터를 저장하지 않는 것
        - 조회가 느리다.
        - 중간에 추가, 삭제하는 동작도 그 지점까지 타고 가는 비용이 있다.
        - 다음 노드를 기억하는데 추가 메모리를 사용
        - 메모리가 퍼져 있으므로 캐시의 효과를 누리지 못한다.
        - 잦은 추가와 삭제가 이루어지는 경우 사용
        - 다른 자료 구조를 공부하는 기반 지식이 된다.

    - 스택
        - 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조
        - 사용 사례 : 웹 브라우저 방문기록 (뒤로가기) / 실행 취소 (undo) / 역순 문자열 만들기
        - 중간의 데이터는 알 수 없다. 만약 알고싶다면 제일 위부터 모두 꺼내야한다.

        - 시간복잡도
            push -> O(1)
            pop -> O(1)
            peek -> O(1)
            무조건 제일 위에 것을 기준으로 하니까 시간복잡도가 상수시간 1이 나옵니다.

            empty - > O(1)
            이게 널인지 아닌지만 확인해주면 되기 때문에 무조건 시간복잡도가 1이 나옵니다.

            size -> O(1) or O(n)
            스택의 구현방식에 따라 다릅니다.
            스택을 배열로 만들면 무조건 시간 복잡도가 1이나옵니다. [항상 size를 기재하기 때문]
            리스트로 구현할 경우 내부적으로 끝에서 끝까지 운행을 끝마쳐야 하기 때문에 시간복잡도는 O(n)이 됩니다.

    - 큐
        - 먼저 들어간 자료가 먼저 나오는 구조 FIFO(First In FIrst Out-선입선출) 구조
        - front(head)와 rear(tail)는 데이터의 위치를 가리킨다
        - 큐는 한 쪽 끝은 프런트(front)로 정하여 삭제 연산(Dequeue)만 수행함
        - 다른 한 쪽 끝은 리어(rear)로 정하여 삽입 연산(Enqueue)만 수행함
        - 큐가 꽉 차서 더 이상 자료를 넣을 수 없는 경우(put 할 수 없는 경우)를 오버플로우(Overflow),
          큐가 비어 있어 자료를 꺼낼 수 없는 경우(get 할 수 없는 경우)를 언더플로우(Underflow)라고 한다.

        - 선형 큐
            - 막대 모양으로 된 큐
            - 크기가 제한되어 있고 빈 공간을 사용하려면 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다는 단점이 있다.
        - 환형 큐
            - 선형 큐의 문제점(배열로 큐를 선언할 시 큐의 삭제와 생성이 계속 일어났을 때, 마지막 배열에 도달 후 실제로는 데이터 공간이 남아있지만 오버플로우 발생)을 보완한 것이 환형 큐
            - front가 큐의 끝에 닿으면 큐의 맨 앞으로 자료를 보내어 원형으로 연결하는 방식
            - 원형 큐라고도 한다.

        - 연결 리스트로 구현한 큐 (링크드 큐)
            - 연결 리스트를 사용한 것으로써, 큐의 길이를 쉽게 늘릴 수 있어 오버플로우가 발생하지 않는다.
            - 필요에 따라 환형으로 만들 수도 있으며, 환형으로 만들지 않아도 삽입과 삭제가 제한되지 않아 편리하다.

    - 덱/데크 (Deque)
        - 큐의 양쪽 끝에서 삽입과 삭제가 모두 발생할 수 있는 큐로서, 큐와 스택의 성질을 모두 가지고 있는 자료구조
        - 덱의 insertFront(), deleteFront() 연산은 Front 를 top으로 생각했을 때 스택의 push(), pop() 연산과 같고,
          insertRear(), deleteRear() 연산은 rear를 스택의 top으로 생각했을 때 스택의 push(), pop() 연산과 같다.
        - 덱의 insertRear(), deleteFront() 연산은 일반 큐의 enQueue(), deQueue() 연산과 같다.


- Graph (그래프)
    - 정의
        - 정점과 간선으로 이루어진 자료구조의 일종. G = (V, E)
        - 정점은 각 출발점 도착점과 같은 점이라고 보면 되고, 간선은 그 정점간 연결된 관계를 뜻한다.
        - 그래프의 탐색/순회 : 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것
            - 주어진 어떤 정점에서 출발하여 체계적으로 그래프의 모든 점점을 순회하는 것으로 깊이를 우선하는 깊이 우선 탐색(DFS)과 너비를 우선하는 너비 우선 탐색(BFS)이 있습니다.

    - 인접행렬
        - 인접행렬은 정점(V)이 n개일 때 N*N 이차원 배열로 나타낼 수 있다.
        - 크기가 정점과 간선의 갯수와 상관없이 정점갯수 * 정점갯수 이기 때문에 공간복잡도가 O(v^2) 이다.
        - 정점을 탐색하는 과정에서 무조건 1에서 n까지 루프를 돌았다.

    - 인접리스트
        - 필요한 공간만 쓰기 때문에 O(V+E)
        - 리스트 특성상 각 리스트마다 존재하는 정점만큼 존재한다. 그렇기에 i에서 n까지 돌지 않아도 되고, 존재하는 만큼만 탐색하면 된다.

    -> 인접행렬을 쓰는 것보다는 인접리스트가 효율적이다. ??
       dfs와 bfs의 시간 복잡도는 동일하다 모든 정점을 한 번씩 방문하며, 정점을 방문할 때마다 인접한 모든 간선을 검사하기 때문이다.


- DFS/BFS
    - 탐색 알고리즘의 개념과 필요성
         - 탐색 알고리즘: 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘
         - 그래프: 정점과 간선으로 구성된, 한정된 자료구조를 의미. 각각의 지점을 정점, 정점과 정점의 연결을 간선
         - 각 정점이 서로 연결되어 있는지, 정해진 시간 내에 효율적으로 할 수 있는가를 확인하는 알고리즘

    - DFS
        - 현재 정점과 연결된 정점들을 하나씩 갈 수 있는지 검사하고, 특정 정점으로 갈 수 있다면 그 정점에 가서 같은 행위를 반복
          시작점에서 한 갈래로 더 이상 갈 수 없을 때까지 탐색하고, 더 갈 곳이 없다면 이전의 경로로 되돌아간다.
          같은 정점을 다시 방문하지 않도록 정점에 방문했다는 것을 표시.
          재귀 함수를 통해 구현
        - 장점
            - 코드가 직관적이고 구현하기 쉽다.
        - 단점
            - 재귀 함수를 이용하기 때문에 함수 호출 비용이 추가로 들어감
            - 재귀 깊이가 지나치게 깊어지면 메모리 비용을 예측하기 어려움
            - 최단 경로를 알 수 없다.

    - BFS
        - 시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘
        - 큐를 이용하여 구현
            - 먼저 출발점을 큐에 넣는다.
            - 큐에 저장된 정점 하나를 Dequeue 한다.
            - Dequeue 된 정점과 연결된 모든 정점을 큐에 넣는다.
            - 큐가 비어있다면 반복을 종료
        - 장점
            - 효율적인 운영이 가능하고, 시간/공간 복잡도 면에서 안정적이다.
            - 간선의 비용이 모두 같을 경우, 최단 경로를 구할 수 있다.
        - 단점
            - DFS 에 비해 코드 구현이 어렵다.
            - 모든 지점을 탐색할 경우를 대비해, 큐의 메모리가 미리 준비되어 있어야 한다.


- 정렬 알고리즘 아는 대로 다 설명

- 데이터를 빠르게 정렬할려면?

- 링크드리스트와 배열의 차이점

- LinkedList 내부 구현

- 힙(자료구조)에 대해 설명

- 이진 트리에 대해 설명

- Queue와 Stack의 차이점, Queue는 언제 사용하면 좋을까?

- Collection 에 list , map들은 불변한가? 이유는?

- java hashtable의 암호화 기법은 ? -> 암호화에 대한 설명 (양방향등등) ??


- Array와 ArrayList의 차이점에 대해 설명해주세요. ??

- RBT(Red-Black Tree)에 대해 설명해주세요. ??

인접행렬을 쓰는 것보다는 인접리스트가 효율적이다. ??


