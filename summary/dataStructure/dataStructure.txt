- Array(List)의 가장 큰 특징과 그로 인해 발생하는 장점과 단점에 대해 설명해주세요.
    - Array의 가장 큰 특징은 순차적으로 데이터를 저장한다는 점입니다.
    - 데이터에 순서가 있기 때문에 0부터 시작하는 index가 존재하며, index를 사용해 특정 요소를 찾고 조작이 가능하다는 것이 Array의 장점입니다.
    - 순차적으로 존재하는 데이터의 중간에 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점도 있습니다.
    - 이러한 이유로 Array는 정보가 자주 삭제되거나 추가되는 데이터를 담기에는 적절치 않습니다.


- Stack과 Queue, Tree와 Heap의 구조에 대해 설명해주세요.
    - Stack과 Queue는 선형 자료구조의 일종이며, Array와 LinkedList로 구현할 수 있습니다.
      Stack은 후입선출(LIFO)방식 즉, 나중에 들어간 원소가 먼저 나오는 구조이고
    - Queue는 선입선출(FIFO)방식 즉, 먼저 들어간 원소가 먼저 나오는 구조를 갖습니다.

    - Tree는 스택과 큐와 같은 선형 구조가 아닌 비선형 자료구조이며, 계층적 관계를 표현하기에 적합합니다.
    - Heap은 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로,
      각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리 입니다.


- Stack과 Queue의 실사용 예를 들어 간단히 설명해주세요.
    - Stack - 자바의 Stack 메모리 영역
        지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출시 메모리에 할당되고 종료되면 메모리가 해제되며, LIFO(Last In First Out)구조를 가집니다.

    - Queue - OS의 스케쥴러
        자원의 할당과 회수를 하는 스케쥴러 역할을 큐가 할 수 있습니다.
        메모리에 적재된 다수의 프로세스 중 어떤 프로세스에게 자원을 할당할 것인가 그 순서를 결정하는 것이 자원의 효율적인 사용에 있고,
        가장 단순한 형태의 스케쥴링 정책이 선입선처리(First Com First Served) 즉, 큐라고 볼 수 있습니다.


- Priority Queue(우선순위 큐)에 대해 설명해주세요.
    - 우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조
    - 우선순위 큐 구현 방식에는 배열, 연결 리스트, 힙이 있고, 그중 힙 방식이 worst case라도 시간 복잡도 O(logN)을 보장하기 때문에 일반적으로 완전 이진트리 형태의 힙을 이용해 구현


- Array와 ArrayList의 차이점에 대해 설명해주세요.
    - Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.
      Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고,
    - ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다.


- Array와 LinkedList의 장/단점에 대해 설명해주세요.
    - Array
        - 인덱스(index)로 해당 원소(element)에 접근할 수 있어 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있습니다.
          즉, RandomAccess가 가능해 속도가 빠르다는 장점
        - 삽입 또는 삭제의 과정에서 각 원소들을 shift 해줘야 하는 비용이 생겨 이 경우 시간 복잡도는 O(n)이 된다는 단점이 있습니다.

    - linkedlist
        - 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)로 해결
        - LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점

    -> Array는 검색이 빠르지만, 삽입, 삭제가 느리다.
       LinkedList는 삽입, 삭제가 빠르지만, 검색이 느리다.


- 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.
    - 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조
    - 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문
    - 각 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회
    - 하지만 index값이 충돌이 발생한 경우 Chanining에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다.


- Hash Map과 Hash Table의 차이점에 대해 설명해주세요.
    - 동기화 지원 여부와 null 값 허용 여부의 차이가 있습니다.

    - 해시 테이블(Hash Table)
        - 병렬 처리를 할 때 (동기화를 고려해야 하는 상황) Thread-safe 하다.
        - Null 값을 허용하지 않는다.

    - 해시 맵(Hash Map)
        - 병렬 처리를 하지 않을 때 (동기화를 고려하지 않는 상황) Thread-safe하지 않는다.
        - Null 값을 허용한다.


- BST(Binary Search Tree)와 Binary Tree에 대해 설명해주세요.
    - 이진트리(Binary Tree)는 자식 노드가 최대 두 개인 노드들로 구성된 트리이고,
      이진 탐색 트리(BST)는 이진 탐색과 연결 리스트를 결합한 자료구조
    - 이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하다는 장점
    - 이진 탐색 트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징
    - 이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h일 때 시간 복잡도는 O(h)이며,
      트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 O(n)의 시간 복잡도를 가집니다.
    - 이런 worst case를 막기 위해 나온 기법이 RBT(Red-Black Tree)입니다.


- RBT(Red-Black Tree)에 대해 설명해주세요.
    - RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식 자료구조이며,
      RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어졌습니다.
    - 노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장합니다. 이러한 NIL들을 leaf node로 간주합니다.
    - 모든 노드를 빨간색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않습니다.


- ArrayList 는 내부적으로 어떻게 구현되어있을까요?
    - ArrayList 는 배열을 좀 더 편하게 쓸 수 있도록 Java 에서 제공해주는 Class 입니다. 일반 배열과는 다르게 메모리가 가능한 한
      추가할 수 있고 삭제에 대해서도 해당 index 를 비워두기만 하는게 아니라 재정렬해주는 기능을 기본으로 제공해주고 있습니다.
    - ArrayList 는 새 요소를 추가하고자 할 때, capacity 가 기존 배열의 크기와 같아지면 기존 용량의 1.5배만큼 증가시키고 그 크기가 늘어난
      배열에 기존 elementData 를 copy 한다. 실제로는 정적 배열을 사용하지만, 요소가 추가될 때마다 최소 증가량을 계산하여 크기를 늘리는 방식
    - 자료를 대량으로 추가하거나 삭제하면 내부 처리 작업이 늘어나서 성능이 떨어질 수 있다.
    - add: 실제로 배열의 크기를 재산정하고 기존(old)에 있던 정보를 새로운 배열(new)에 넣는 메서드입니다.
           크기를 재산정 할때는 원래크기만큼 새로운 배열에 복사를 해야하므로 시간복잡도 O(n)을 가지며 추가할 때 O(1)
    - remove: remove 메서드를 실행하면 가장 먼저 입력받은 index 가 적절한 값인지 체크합니다. 그리고 삭제되는 Object 의 값을 가져와서
              변수에 담습니다. 그 후 arraycopy 를 이용해 삭제되는 부분 + 1 ~ 마지막까지의 영역을 삭제되는 부분의 시작점을 기준으로
              해서 옮깁니다. 그러면 삭제될 부분의 값은 다음 index 의 값으로 겹쳐서 덮여 쓰여지게 됩니다. 그리고 size 의 마지막 index 는
              size - 1의 값과 중복되기 때문에 null 처리를 하여 GC가 삭제할 수 있도록 합니다. 그 후 임시 변수에 담아두었던
              삭제된 값을 리턴합니다.
              삭제를 할때 우리는 index + 1에서 부터의 값을 index 부터 시작하게끔 복사한다는 것을 알 수 있었습니다. 그때 O(n)의
              시간복잡도를 가지며 마지막 값을 null 로 변경해줍니다. 이때는 O(1)을 가지겠죠. 삭제에 대해서는 항상
              시간복잡도 O(n)을 가진다는 것을 알 수 있습니다.

    - ArrayList vs 배열
        - ArrayList
            - 연속적인 데이터의 리스트 (데이터는 연속적으로 리스트에 들어있어야 하며 중간에 빈공간이 있으면 안된다)
            - ArrayList 클래스는 내부적으로 Object[] 배열을 이용하여 요소를 저장
            - 배열을 이용하기 때문에 인덱스를 이용해 요소에 빠르게 접근할 수 있다.
            - 크기가 고정되어있는 배열과 달리 데이터 적재량에 따라 가변적으로 공간을 늘리거나 줄인다.
            - 그러나 배열 공간이 꽉 찰때 마다 배열을 copy 하는 방식으로 늘리므로 이 과정에서 지연이 발생하게 된다.
            - 데이터를 리스트 중간에 삽입/삭제 할 경우, 중간에 빈 공간이 생기지 않도록 요소들의 위치를 앞뒤로 자동으로 이동시키기 때문에 삽입/삭제 동작은 느리다.
            - 따라서 조회를 많이 하는 경우에 사용하는 것이 좋다.

        - 배열
            - 처음 선언한 배열의 크기(길이)는 변경할 수 없다. 이를 정적 할당(static allocation)이라고 한다.
            - 데이터 크기가 정해져있을 경우 메모리 관리가 편하다.
            - 메모리에 연속적으로 나열되어 할당하기 때문에 index 를 통한 색인(접근)속도가 빠르다.
            - index 에 위치한 하나의 데이터(element)를 삭제하더라도 해당 index 에는 빈공간으로 계속 남는다.
            - 배열의 크기를 변경할 수 없기 때문에, 처음에 너무 큰 크기로 설정해주었을 경우 메모리 낭비가 될수 있고, 반대로 너무 작은 크기로 설정해주었을 경우 공간이 부족해지는 경우가 발생 할 수 있다.


- HashMap vs HashTable vs ConcurrentHashMap
    - HashMap
        - key 와 value 에 null 을 허용
        - 동기화 보장x -> 동기화 처리를 하지 않기 때문에 데이터를 탐색하는 속도가 빠르다.
          HashTable 과 ConcurrentHashMap 보다 데이터를 찾는 속도는 빠르지만, 신뢰성과 안정성이 떨어진다. (thread-safe x)

    - HashTable
        - key 와 value 에 null 을 허용 x
        - 데이터를 다루는 메소드(get(), put(), remove() 등)에 synchronized 키워드가 붙어 있다.
          해당 키워드는 메소드를 호출하기 전에 쓰레드간 동기화 락을 건다.
          그러나, 쓰레드간 동기화 락은 매우 느린 동작이라는 단점이 있다.

    - ConcurrentHashMap
        - key 와 value 에 null 을 허용 x
        - 어떤 Entry 를 조작하는 경우에 해당 Entry 에 대해서만 락을 건다.
          그래서 HashTable 보다 데이터를 다루는 속도가 빠르다. 즉, Entry 아이템별로 락을 걸어 멀티 쓰레드 환경에서의 성능을 향상시킨다.

        - java 8 이전의 ConcurrentHashMap 은 ReentrantLock 을 상속 받는 Segment 를 이용하여 동기화를 구현하였었다. 이 때는 영역을 구분하여(기본 16개) 영역 별로 잠금을 하는 방식이었다.
          각 영역에서는 리사이징 되는 해시테이블을 갖는다. 하지만 java8 에서는 각 테이블 버킷을 독립적으로 잠그는 방식이다.
          빈 버킷으로의 노드 삽입은 lock 을 사용하지 않고 단순히 CAS 만을 이용해 삽입한다. 그 외의 업데이트(삽입, 삭제 및 교체)는 lock(synchronized) 을 이용하지만
          각 버킷의 첫 번째 노드를 기준으로 부분적인 잠금을 획득하여 스레드 경합을 최소화 하고 안전한 업데이트를 한다.


- HashMap 내부 구현   https://lordofkangs.tistory.com/78
    - 해싱함수를 통해 인덱스를 산출
    - 인덱스를 통한 접근으로 시간복잡도 O(1)의 빠른 성능
    - key 는 무한하지만 인덱스는 한정되어 있어 충돌은 불가피
    - 충돌을 줄이기 위해 HashMap 은 버킷의 사이즈를 조절
    - 충돌이 일어날 시, 충돌 수가 적으면 LinkedList 방식으로 충돌된 객체들을 관리하다가 임계점을 넘으면 Red-Black Tree 방식으로 객체들을 저장


* Java HashMap 은 어떻게 동작하는가?
    https://d2.naver.com/helloworld/831311


- 배열과 연결리스트 차이는?
  배열은 인덱스를 가짐. 원하는 데이터를 한번에 접근하기 때문에 접근 속도 빠름.

  크기 변경이 불가능하며, 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야 되는 단점 존재

  연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.

  크기는 가변적. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함. (따라서 배열보다 속도 느림)

  데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함

  데이터의 양이 많고 삽입/삭제가 없음. 데이터 검색을 많이 해야할 때 → Array
  데이터의 양이 적고 삽입/삭제 빈번함 → LinkedList


- 정렬 알고리즘
    - 정렬
        - 정렬이란? -> 데이터를 기준에 맞게 순서대로 배열하는 작업
        - 정렬을 하는 이유 -> 탐색에 용이하기 위해서

    - insertion Sort
    - Merge Sort
    - Quick Sort
    - java 에서의 Sort
        - Dual Pivot Quick Sort
            1. primitive 타입을 정렬할 때, Dual Pivot Quick Sort 를 사용
            2. 피봇을 하나만 쓰는 것보다 일반적으로 빠름
        - Tim Sort
            1. Object 타입을 정렬할 때, Tim Sort 를 사용
            2. 앞에서 봤던 Insertion Sort 와 Merge Sort 의 하이브리드한 형태
            3. Binary Insertion Sort 를 사용
            4. Merge Sort 와 같이 분할을 진행하다가 특정한 기준보다 작은 사이즈가 되면 분할을 멈춘 후, Binary Insertion Sort 를 이용
            5. 특정 병합 조건에 맞게 병합

- 선형 자료구조 (Linear Data Structure)
    - 연속된 데이터를 저장하기 위한 자료구조

    - 동적 배열
        - 새로운 연속된 공간에 데이터를 복사해서 생성하는 것
        - 중간에 데이터 삽입, 삭제 시 비효율
    - 연결 리스트
        - 연속된 공간에 데이터를 저장하지 않는 것
        - 조회가 느리다.
        - 중간에 추가, 삭제하는 동작도 그 지점까지 타고 가는 비용이 있다.
        - 다음 노드를 기억하는데 추가 메모리를 사용
        - 메모리가 퍼져 있으므로 캐시의 효과를 누리지 못한다.
        - 잦은 추가와 삭제가 이루어지는 경우 사용
        - 다른 자료 구조를 공부하는 기반 지식이 된다.
    - 큐
    - 스택
    - 덱

- DFS/BFS
    - 탐색 알고리즘의 개념과 필요성
         - 탐색 알고리즘: 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘
         - 그래프: 정점과 간선으로 구성된, 한정된 자료구조를 의미. 각각의 지점을 정점, 정점과 정점의 연결을 간선
         - 각 정점이 서로 연결되어 있는지, 정해진 시간 내에 효율적으로 할 수 있는가? 를 확인하는 알고리즘

    - DFS
        - 현재 정점과 연결된 정점들을 하나씩 갈 수 있는지 검사하고, 특정 정점으로 갈 수 있다면 그 정점에 가서 같은 행위를 반복
          시작점에서 한 갈래로 더 이상 갈 수 없을 때까지 탐색하고, 더 갈 곳이 없다면 이전의 경로로 되돌아간다.
          같은 정점을 다시 방문하지 않도록 정점에 방문했다는 것을 표시.
          재귀 함수를 통해 구현
        - 장점
            - 코드가 직관적이고 구현하기 쉽다.
        - 단점
            - 재귀 함수를 이용하기 문에 함수 호출 비용이 추가로 들어감
            - 재귀 깊이가 지나치게 깊어지면 메모리 비용을 예측하기 어려움
            - 최단 경로를 알 수 없다.

    - BFS
        - 시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘
        - 큐를 이용하여 구현
            - 먼저 출발점을 큐에 넣는다.
            - 큐에 저장된 정점 하나를 Dequeue 한다.
            - Dequeue 된 정점과 연결된 모든 정점을 큐에 넣는다.
            - 큐가 비어있다면 반복을 종료
        - 장점
            - 효율적인 운영이 가능하고, 시간/공간 복잡도 면에서 안정적이다.
            - 간선의 비용이 모두 같을 경우, 최단 경로를 구할 수 있다.
        - 단점
            - DFS 에 비해 코드 구현이 어렵다.
            - 모든 지점을 탐색할 경우를 대비해, 큐의 메모리가 미리 준비되어 있어야 한다.
