- Design Pattern
    - SW 재사용성, 호환성, 유지 보수성을 보장.

    - 생성 패턴 (Creational) : 객체의 생성 방식 결정
    - 구조 패턴 (Structural) : 객체간의 관계를 조직
    - 행위 패턴 (Behavioral): 객체의 행위를 조직, 관리, 연합


- 상태 패턴
    - 아키텍쳐 패턴 vs 디자인 패턴
      아키텍쳐 패턴은 디자인 패턴보다 상위 수준의 설계에 사용된다.
      아키텍쳐 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들끼리의 관계를 설계하기 위한 참조 모델이다.

    - 디자인 패턴
      반복적으로 나타난 문제에 대해 그것을 해결한 경험 및 노하우를 축적하여 재이용하기 좋은 형태로 이름을 붙여 해법을 제시하는 패턴 양식.
      객체지향 프로그래밍을 설계할 때 자주 발생하는 문제를 피하기 위해 사용되는 패턴. 객체 지향의 재사용과 유지보수성 등의 장점을
      이 디자인 패턴을 사용해 극대화할 수 있다.

    - GOF 디자인 패턴  https://4z7l.github.io/2020/12/25/design_pattern_GoF.html
        - 23 가지의 디자인 패턴을 목적에 따라 3가지 유형으로 분류
            - 생성 패턴: 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 하는 패턴
                       객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여 프로그램에 유연성을 더해준다.
                - 추상 팩토리 패턴, 빌더 패턴, 팩토리 메서드 패턴, 프로토타입 패턴, 싱글톤 패턴
            - 구조 패턴: 자료 구조나 인터페이스 등 프로그램의 구조를 설계하는데 활용하는 패턴. 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
                - 어댑터 패턴, 브리지 패턴, 컴포지트 패턴, 데코레이터 패턴, 파사드 패턴, 플라이웨이트 패턴, 프록시 패턴
            - 행위 패턴: 반복적으로 사용되는 객체들의 상호 작용을 패턴화. 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
                       행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 어떤 태스크, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지를 정의하는 패턴
                - 책임 체인 패턴, 커맨드 패턴, 인터프리터 패턴, 중재자 패턴, 메멘토 패턴, 옵저버 패턴, 상태 패턴
                  전략 패턴, 템플릿 메서드 패턴, 방문자 패턴

        -> 디자인 원칙을 떠올려보자. 변하는 것은 잘 변하지 않는 것과 분리해라. 즉, 변하는 녀석들을 캡슐화해라!

    - 상태 패턴
        - 객체 자신의 내부 상태에 따라 행위를 변경하도록 하는 패턴
        - 객체의 특정 상태를 클래스로 선언하고 해당 상태에서 할 수 있는 행위들을 메서드로 정의
          이러한 상태 클래스를 인터페이스로 캡슐화하여 클라이언트에서 인터페이스로 호출하는 방식으로 사용

    - 상태 패턴은 언제 사용할까
        1. 객체의 행동이 상태에 따라 달라질 수 있고, 객체의 상태에 따라 런타임 행동이 바뀌어야 한다.
        2. 객체에 상태에 따라 달라지는 다중 분기조건, 처리가 너무 많이 들어있을 때, 객체의 상태를 표현하기 위해 ENUM 으로 정의해야 한다.

    - 효과
        1. 상태에 따른 행동을 국소화하며 서로 다른 상태에 대한 행동을 별도의 객체로 관리한다.
           새로운 상태가 추가되더라도 context 코드가 받는 영향이 적다.
        2. 상태 전이를 명확하게 만든다. (상태 전이 - 입력에 따라 다음 상태로 바뀌는 것)
        3. 상태에 따른 동작을 구현한 코드를 수정하기 쉽다.

    - 상태 패턴과 전략 패턴의 차이
        - 목적에 따라 구분
            - 상태 패턴: 코드 내 조건문을 대체
            - 전략 패턴: 상속을 대체
        - 다음 상태를 자기 자신이 정하는가
            - 상태 패턴: 상태 객체 내부에서 다음 상태를 결정
            - 전략 패턴: 클라이언트(외부)에서 다음에 실행할 객체를 지정할 수 있다.
            -> 상태 패턴도 외부에서 설정될 수 있기 때문에 상태 기반인가, 방법 기반인가로 나뉘어야 한다.

        -> 전략 패턴 - 사용자가 쉽게 알고리즘 전략을 바꿀 수 있도록 유연성을 제공. 상속의 한계를 해결하기 위하여 나온 패턴
           상태 패턴 - 한 객체가 동일한 동작을 상태에 따라 다르게 수행해야 할 경우 사용하는 패턴


- 전략 패턴
    - 전략, 전략 패턴의 개념
        - 전략: 특정한 목표를 수행하기 위한 행동 계획
        - 전략 패턴: 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고 사용하며, 동적으로 전략 수정이 가능한 패턴
        - 동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만든다.

    - 전략 패턴 in JDK
        ex) Comparator - 개발 상황에 맞게 비교 전략을 구현할 수 이게 하여 기존 코드의 수정 없이 확장할 수 있음

    - 전략 패턴이란?
        - 소프트웨어 디자인 패턴중 하나
        - 동일 계열의 알고리즘을 정의하고, 각 알고리즘을 캡슐화하며, 이 알고리즘들을 상호 교체가 가능하게 만든다.

    - 전략 패턴의 장단점
        - 장점
            - 상속을 사용하지 않을 수 있음
            - if 문을 제거할 수 잇음
            - 구현의 선택이 가능
        - 단점
            - 객체 수 증가
            - 서로 다른 전략을 이해해야 함

    - 상태 패턴과의 비교
        - 공통점
            - 인터페이스를 사용해서 클래스르 캡슐화 한다. (구조가 같다)
            - 컨텍스트 클래스는 영향을 받지 않고 변경에 유연한 대처가 가능 (둘 다 OCP 를 따른다)
        - 차이점
            - 전략 패턴
                - 클라이언트 혹은 사용자에 의해 전략을 주입받는다.
                - 어떻게 객체가 이을 할지, 즉 알고리즘을 캡슐화한다.
                - 하나의 특정 작업만 처리
                - 원하는 알고리즘으로 언제든지 변경하고 싶을 때
            - 상태 패턴
                - 컨텍스트 스스로 상태를 변환할 수 있다.
                - 상태에 따른 행동을 캡슐화한다.
                - 컨텍스트 객체가 수행하는 대부분의 메서드에 대한 인터페이스가 제공
                - 상태 변화가 잦을 경우


- 팩토리_패턴(생성)
    - 객체를 생성하는 작업을 한 클래스에 캡슐화시켜 놓은 방식입니다.
        - 구현을 변경해야 하는 경우에 여기저기 흩어져 있는 소스를 고칠 필요없이 팩토리 클래스만 수정하면 된다.
        - 중복된 코드 제거


- 템플렛_메서드_패턴(행위)
    - 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법.
    - 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다

    - 자바8 부터는 인터페이스도 default 키워드를 사용하여 메소드의 구현부를 가질 수 있는데 꼭 추상클래스를 사용해야만 하나?
        - 템플릿 메소드 내부에서 사용되는 메소드들에 대한 (구현은 하위클래스에서 하고) 외부에서의 호출을 막고 싶다면 추상클래스로 사용
            - 추상클래스를 사용하면 protected, private 제어자를 지정할 수 있기 때문
            - 추상클래스가 같은 패키지 내에 있다면 protected 라도 접근 가능하지만, 템플릿메소드패턴이 적용된 추상클래스는 라이브러리 형태로
              외부패키지에서 제공되는 방식일 것이므로, 상속을 받지 않은 클래스에서는 호출하지 못하게 할 수 있다

            - 인터페이스는 기본적으로 변수필드는 public static final 이며, 모든 메소드는 public abstract 이므로 인터페이스로 구현할 경우,
              템플릿 메소드 내부에서만 호출되어야 할 메소드들이 public 제어자에 의해 의도치 않은 사용처에서 호출될 위험이 있다.
            - 자바는 다중상속을 허용하지 않기 때문에 템플릿 메소드 패턴이 적용된 추상클래스를 구현한 서브클래스는 다른 클래스를 상속받을 수 없다는 단점이 있다.
              반면, 인터페이스로 템플릿 메소드 패턴을 구현했다면 다른 클래스를 상속 받을 수 있는 가능성을 열어둘 수 있다.


- 전략 패턴(행위)
    - 전략패턴은 각각의 알고리즘군을 교환이 가능하도록 별도로 정의하고 각각 캡슐화 한 후 서로 교환해서 사용할 수 있는 패턴
    - 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에게 주입하는 패턴

    - 코드 중복 방지
    - 런타임(Runtime)시에 타겟 메소드 변경
    - 확장성(신규 클래스) 및 알고리즘 변경 용이

    - Strategy 패턴을 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
      알고리즘의 인터페이스(API) 부분만 규정해서 변경해서 사용할 수 있도록 하는 것을 전략 패턴[행동 자체를 구현이 아닌 inteface(API)로 정의해 사용하는 방식]이라 한다.

    - 전략 패턴과 템플릿 메소드 패턴
        - 템플릿 메소드 패턴은 반드시 추상 클래스의 템플릿 메서드에서 구현클래스의 메서드를 부르는 식으로 로직을 구성해야 합니다
        - 상속을 이용하는 템플릿 메서드 패턴과 객체주입을 통한 전략패턴 중에서 고민해보고 적용하면 됩니다.
        - 단일 상속만이 가능한 자바에서 상속이라는 제한이 있는 템플릿 메서드 패턴보다는 다양하게 많은 전략을 implements할 수 있는 전략패턴이 많이 사용됩니다.

    * 캡슐화
        - 객체의 필드(속성), 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것을 말한다.
        - 외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
        - 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다.
        - 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.


- 프록시 패턴(구조)
    - 프록시(Proxy)는 우리 말로 대리자, 대변인이라는 뜻을 가지고 있다.
    - 프록시는 어떤 일을 대신시키는 것이고 구체적으로 인터페이스를 사용하고 실행시킬 클래스에 대한 객체가 들어갈 자리에 대리자 객체,
      그러니까 프록시 객체를 대신 투입해 클라이언트 쪽에서 요청했을 때 바로 그 객체에 대한 처리를 하는 것이 아니라 대리자 객체를 통해 메서드를 호출하고 반환 해주는 역할

    - 실제 작업을 하는 Object 를 감싸서,
        - 실제 Object 를 요청하기 전이나 후에 인가처리(보호)
        - 생성 자원이 많이 드는 작업에 대해 백그라운드 처리(가상)
        - 원격 메서드를 호출하기 위한 작업(원격)
      등을 하는데 사용한다.

    - 클라이언트가 어떤 일에 대한 요청(RealSubject 의 request() 메서드 호출)을 하면, Proxy 가 대신 RealSubject 의 request() 메서드 호출을 하고 그 반환 값을 클라이언트에 전달한다.


- 싱글톤(Singleton) 패턴(생성)
    - 인스턴스를 하나만 만들어 사용하기 위한 패턴
    - 커넥션 풀이나, 스레드 풀, 디바이스 설정 객체와 같은 경우에 인스턴스를 여러 개 만들게 되면 Race Condition 문제나 리소스를 불필요하게 잡아먹는 문제가 발생할 수 있다.
    - 생성자를 private 로 선언하여 외부에서 new 를 통해 새로운 객체를 생성하는 것을 막고, 유일한 단일 객체를 반환할 수 있도록 정적메서드를 지원하는 방식

    - ver1 : private 키워도를 생성자에 걸어줌
        - Multi Thread 환경에서 이 코드를 사용했다면, 여러 스레드에서 동시에 객체를 요청한다면 여러 개의 객체가 생성될 수 있는 위험이다. 그렇기 때문에 동기화를 시켜주어야 한다.

    - ver2 : synchronized 키워드를 사용해서 동기화
        - 하지만 synchronized 키워드만 보면 느려진다는 느낌을 지울 수가 없다. (실제로 100배 정도 느려진다고 한다.)

    - ver3 : DCL(Double checking Locking)
        - 객체가 생성되지 않았을 때만 new 연산을 해주는데 생성되는 그 시점에만 synchronized 키워드를 사용해 동기화하는 부분의 영역을 줄였다.
        - 하지만 이 코드는 멀티코어 환경에서 동작할 때, 하나의 CPU 를 제외하고 나머지 CPU 에는 Lock 이 걸리게 된다.

    - ver4 : static volatile
        - Method 를 호출하면 그 때가 되어서야 객체를 생성하고 반환한다.
        - static volatile 은 클래스가 로드되는 시점에 미리 객체를 생성해두고 그 객체를 반환하게 된다.
        - 하지만 이렇게 되면 프로그램이 실행되고 나서 처음부터 끝까지 이 객체가 메모리에 적재되어 있다는 뜻이다.
          크기가 작다면 괜찮을 수 있겠지만 만약 크기가 큰 객체라면 메모리 낭비이다.

        * volatile 키워드
            동기화 문제를 해결해주는 키워드가 volatile 이다. 구체적으로 설명하자면 컴파일러가 특정 변수에 대해 옵티마이져가 캐싱을 적용하지 못하도록 하는 키워드이다.
            이게 무슨 말이냐면 멀티 스레드에서는 for 문이나 while 문 안에서 사용되는 변수에는 옵티마이져에 의해 캐싱을 사용하는데, 이 때 동기화 문제가 발생할 수 있다는 것이다.
            한 스레드에서 다른 스레드의 작업이 마치기를 기다린다고 가정했을 때, 최신의 변수를 읽어오지 못한다면 무한루프에 빠질 수도 있다.
            이러한 문제 발생을 volatile 키워드를 사용하여 모든 스레드에 대해 항상 최신의 값을 읽을 수 있게 해주는 것이다.

            그렇다면 이러한 volatile 과 synchronized 의 차이는 무엇인가하면 synchronized 는 작업 자체를 원자화해버리는 것이고,
            volatile 은 특정 변수에 대해서 최신 값을 제공해주는 것이다.

            보통 CPU 가 2개 이상일 때, 쓰레드는 메인메모리에서 값을 각자의 캐시에 복사해와서 사용한다. 이 때, 같은 값을 복사해와서 쓴다고 했을 때 문제가 발생한다.
            A라는 변수가 0일때, 쓰레드1 에서 ++ 을 하고 스레드 2에서 ++ 을 했을 때 기대 값을 A = 2 이다. 하지만 각자 0을 복사해와서 ++ 을 했기 때문에
            CPU 캐시들은 1로 기록한 상태이고 아직 메인 메모리에는 0인 상태가 된다. 이런 점 때문에 A는 기대한 값이 나오지 않을 가능성이 있다.
            이러한 문제를 volatile 키워드를 사용함으로 해결할 수 있다.

    - ver5 : Lazy Holder 의 방식
        - volatile 같은 경우에는 jdk 1.5 이상에서만 사용가능하지만 이 방법은 자바 버전에도 무관하고 성능 또한 뛰어나다.
        - 내부 클래스를 두고 static 영역에 초기화를 하지만 객체가 필요한 시점까지는 그 초기화를 미루는 방식
        - instance 가 생성되지 않은 시점에 동시 접근이 발생하면 두 개의 객체가 생성되지 않을까라는 의문이 생길 수도 있지만 VM 은 클래스를 초기화하기 위한 필드 접근에서는 동기화를 보장해준다.
          따라서 초기화가 된 이후에 new 하는 부분은 호출되지 않는다.
        - 또 다른 방법으로는 Enum 클래스를 이용한 싱글톤 패턴도 있다. Enum 은 static final 을 보장하기 때문에 멀티스레드로부터 안전하다는 점,
          단 한번의 인스턴스 생성을 보장한다는 점, enum value 에는 자바 전역에서 접근 가능하다는 장점이 있다. 또한 구현도 간단하다.
          effective java 에서는 enum 을 가장 좋다고 이야기힌다. 하지만 Enum 의 일반적인 쓰임새를 생각했을 때는 혼동될 수 있다는 것도 고려해볼 수 있다.


- lazeholder
- 싱글톤 패턴   https://gyoogle.dev/blog/design-pattern/Singleton%20Pattern.html
    - 정의
        - 애플리케이션이 시작될 때, 어떤 클래스가 최초 한 번만 메모리를 할당(static)하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴
        - 인스턴스가 필요할 때, 똑같은 인스턴스를 만들지 않고 기존의 인스턴스를 활용하는 것!
        - 생성자가 여러번 호출되도, 실제로 생성되는 객체는 하나이며 최초로 생성된 이후에 호출된 생성자는 이미 생성한 객체를 반환시키도록 만드는 것이다

    - 왜 쓰나요?
        - 먼저, 객체를 생성할 때마다 메모리 영역을 할당받아야 한다. 하지만 한번의 new를 통해 객체를 생성한다면 메모리 낭비를 방지할 수 있다.
        - 또한 싱글톤으로 구현한 인스턴스는 '전역'이므로, 다른 클래스의 인스턴스들이 데이터를 공유하는 것이 가능한 장점이 있다.

    - 많이 사용하는 경우가 언제인가요?
        - 주로 공통된 객체를 여러개 생성해서 사용해야하는 상황
            데이터베이스에서 커넥션풀, 스레드풀, 캐시, 로그 기록 객체 등

        - 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 때 사용함

    - 단점도 있나요?
        객체 지향 설계 원칙 중에 개방-폐쇄 원칙이란 것이 존재한다.
        만약 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유시키면 다른 클래스들 간의 결합도가 높아지게 되는데, 이때 개방-폐쇄 원칙이 위배된다.
        결합도가 높아지게 되면, 유지보수가 힘들고 테스트도 원활하게 진행할 수 없는 문제점이 발생한다.
        또한, 멀티 스레드 환경에서 동기화 처리를 하지 않았을 때, 인스턴스가 2개가 생성되는 문제도 발생할 수 있다.
        따라서, 반드시 싱글톤이 필요한 상황이 아니면 지양하는 것이 좋다고 한다. (설계 자체에서 싱글톤 활용을 원활하게 할 자신이 있으면 괜찮음)

    - 멀티스레드 환경에서 안전한 싱글톤 만드는 법
        1. #Lazy Initialization (게으른 초기화)
            private static으로 인스턴스 변수 만듬
            private으로 생성자를 만들어 외부에서의 생성을 막음
            synchronized 동기화를 활용해 스레드를 안전하게 만듬

            하지만, synchronized는 큰 성능저하를 발생시키므로 권장하지 않는 방법

        2. #Lazy Initialization + Double-checked Locking
            1번의 성능저하를 완화시키는 방법
            1번과는 달리, 먼저 조건문으로 인스턴스의 존재 여부를 확인한 다음 두번째 조건문에서 synchronized를 통해 동기화를 시켜 인스턴스를 생성하는 방법
            스레드를 안전하게 만들면서, 처음 생성 이후에는 synchronized를 실행하지 않기 때문에 성능저하 완화가 가능함

            하지만 완전히 완벽한 방법은 아님

        3. #Initialization on demand holder idiom (holder에 의한 초기화)
            클래스 안에 클래스(holder)를 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방법

            2번처럼 동기화를 사용하지 않는 방법을 안하는 이유는, 개발자가 직접 동기화 문제에 대한 코드를 작성하면서 회피하려고 하면 프로그램 구조가 그만큼 복잡해지고 비용 문제가 발생할 수 있음. 또한 코드 자체가 정확하지 못할 때도 많음
            이 때문에, 3번과 같은 방식으로 JVM의 클래스 초기화 과정에서 보장되는 원자적 특성을 이용해 싱글톤의 초기화 문제에 대한 책임을 JVM에게 떠넘기는 걸 활용함
            클래스 안에 선언한 클래스인 holder에서 선언된 인스턴스는 static이기 때문에 클래스 로딩시점에서 한번만 호출된다. 또한 final을 사용해서 다시 값이 할당되지 않도록 만드는 방식을 사용한 것

            실제로 가장 많이 사용되는 일반적인 싱글톤 클래스 사용 방법이 3번이다.


- 어댑터 패턴(구조)
    - 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.
      어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

    - 클래스를 바로 사용할 수 없는 경우가 있음 (다른 곳에서 개발했다거나, 수정할 수 없을 때)
      중간에서 변환 역할을 해주는 클래스가 필요 → 어댑터 패턴


- 데코레이터 패턴(구조)
    - Target Class에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 Proxy를 사용하는 패턴
    - 다이내믹하게 기능을 부가한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻
      즉, 데코레이터 패턴은 런타임중 다양하게 기능을 추가 할 수 있다라는 뜻
    - runtime에 real Object에 기능을 확장하고 싶을 때 사용
    - 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 합니다.
    - 핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다. 따라서 부가기능이 핵심기능을 사용하는 구조가 되는 것입니다.

    - 데코레이터 패턴과 프록시 패턴
        - 공통점
            - class의 구조가 비슷합니다. 둘다 동일한 Interface를 구현합니다. 그리고 Wrapper Class와 real class의 관계가 aggregation 즉, has A 관계를 띄고 있습니다.

        - 차이점
            - 프록시 패턴에서는 Wrapper Class와 Real Class의 관계가 컴파일타임에 정해집니다. 반면 데코레이터 패턴에서는 런타임에 정해지도록 되어있습니다.
            - 그리고 프록시 패턴은 Real Class의 접근에 대한 제어를 목적으로하며, 데코레이터 패턴은 Real Class의 기능에 다른 기능을 추가하는 목적으로합니다.

    - in java
        - BufferedWriter는 FileWriter에 Buffer를 추가해 disk IO의 횟수를 줄여주는 역할
        - 이 때 데코레이터 패턴 사용됨


- [디자인 패턴] 싱글톤이 안티 패턴이 될 수 있는 이유와 자바 싱글톤과 스프링 싱글톤의 차이
    https://mangkyu.tistory.com/153

- 싱글톤 패턴은 어떤 패턴인가, 어떤 상황에 사용하는가

- state 패턴과 싱글톤 패턴의 설명요구

- 전략 패턴 템플릿 메소드 패턴