- MSA   https://sihyung92.oopy.io/architecture/woowa-msa-travel
    - Why - 왜 MSA를 도입해야 했을까?
        사업적 요구사항을 처리하며 점점 비대해진 시스템은 많은 장애를 유발했고, 모놀리식 아키텍처였기에 각 도메인의 장애는 단일 장애점으로 동작
        bounded context (도메인의 범주)에 따라 서버를 분리한 패턴을 MSA(Micro Service Architecture)라고 부릅니다.

        1. 모놀리식 아키텍처 Monolithic architecture : 한 개의 서버 코드로 모든 비지니스 요구사항을 처리하는 아키텍처
        2. 단일 장애점 : 시스템 구성 요소 중, 동작하지 않으면 전체 시스템이 중단되는 요소
        3. bounded context : 각각의 도메인의 경계

        장애 전파를 막고 다수 트래픽의 고성능 조회를 위해서 이벤트 기반 아키텍처와 CQRS 아키텍처를 도입

    - What - MSA를 도입한 결과는?
        1. 시스템 일부 장애에 대한 저항력을 키워 시스템 신뢰성를 높이고,
        2. 리뷰 작성 이벤트, 쿠폰 이벤트 등 각 부문별에 증가할 트래픽에 맞서 자유로운 스케일링이 가능해졌습니다.

    - 이벤트 기반 아키텍처
        - why - REST api 중심에서 이벤트 중심으로 바꾼 이유는?
            MSA 아키텍처를 적용하면 서버 수가 늘어나고, 서버간의 소통을 위한 Rest API 호출이 빈번해집니다. 해당 API에서 장애가 나게 되면 어떻게 될까요?
            장애의 전파를 막기위해 도입한 MSA인데, 해당 API 요청이 실패함으로써 주문시스템도 어떤 식으로든 영향을 받게 됩니다.
            코드에 변경이 있을 때마다 이에 대한 여파를 고민해야 합니다.

            해당 난점을 극복하기 위해 서버간의 메시지를 전달하는 미들웨어인 메시징 큐를 도입하고,
            각각의 서버는 이벤트를 통해 소통하는 이벤트 기반 아키텍처를 구성합니다.

        - how - 어떻게 이벤트 기반 아키텍처를 구현할까?
            다른 어플리케이션에서 필요한 주문 정보를, 이벤트라는 이름으로 정의합니다.
            이후 메시징 큐에 이벤트를 발행하면, 필요한 어플리케이션에서 해당 이벤트를 구독해갑니다. (pub-sub 패턴)
            pub-sub 기반의 메시징 큐에는 Apache Kafka 등 다양한 종류가 있으나, 당시 개발팀에 AWS SNS(Simple Notification Service)와
            AWS SQS(Simple Queue Service)에 대한 이해도가 있었으므로 발행자 역할로SNS, 구독자 역할로 SQS를 활용합니다.

            - 이벤트 기반 아키텍처 장점
                1. 설사 리뷰 시스템이 다운 되더라도, 향후 복구되었을 때 SQS에 있는 이벤트를 재수신하여 처리할 수 있습니다.
                2. 주문 시스템에서 주문 생성이 실패하는 문제가 발생하면, 문제가 되었던 부분을 찾아 이벤트를 재발행하는 것으로 해소됩니다.
                3. 주문 시스템이 더이상 다른 시스템에 대해 자세히 알 필요가 없어집니다. 주문 이벤트를 발행하고 나면, 그 이벤트로 각 도메인에 특화된 비즈니스 로직을 수행하는 건 각 시스템의 역할로 맡겨집니다.

        - what - 이벤트 중심 아키텍처로 전환한 결과는?
            1. 각 서비스간의 의존성이 낮아지고
            2. 각 서비스가 다운되는 상황에서 이벤트를 통해 쉽게 페일 오버할 수 있습니다.

    - CQRS (명령과 조회 분리)
        - why - 왜 명령과 조회를 분리해야 했을까?
            CQRS 패턴은 데이터베이스에 대한 읽기와 수정, 삭제 작업은 명령 (command)으로, 조회 작업은 조회(query)로 정의하고
            두 작업을 분리하는 패턴을 의미합니다. (Command and Query Responsiblillity Segregation)
            분리라는 말의 의미는 데이터베이스 내부에서 동일한 도메인에 대해 조회용 모델과 명령용 모델을 분리하는 것을 의미합니다.
            DB 서버에 대한 스케일업(성능 향상)으로 대응했지만, 스케일업엔 물리적으로도 소프트웨어 적으로도 한계가 있습니다.
            이 상황을 해결하기 위해 CQRS 아키텍처를 도입

    - how - CQRS를 도입하기
        직접 조회용 DB를 만들어 고객의 요청에 응답
        명령형 시스템에 변경 사항이 생기면, 조회용 시스템이 이를 수신할 수 있도록 이벤트를 발행
        이 때 어떤 DB를 활용할지는 각각의 서비스에 특화하여 사용할 수 있습니다.
        데이터의 엄밀성이 중요한 가게/업주 시스템은 RDB를, 검색이 포함된 광고리스팅 서비스에선 ES를, 가게 노출엔 Redis나 다이나모 DB를 활용하는 자율성도 얻을 수 있습니다.

        데이터 동기화에도 장애 상황이 발생할 수 있습니다.
            1. 장애의 주체가 이벤트를 발행하는 서비스라면 문제가 생긴 이벤트를 재발행 해주면 됩니다.
            2. 간혹 이벤트를 전달해주는 큐 자체에 장애(SNS, SQS)가 생길 때가 있습니다. 상황을 대비해 최근 변경사항을 메시지 큐를 대신해 전달할 수 있는 Import API를 구현합니다.

            - AWS 다이나모 DB : key-value 형태로 값을 저장하는 NoSql 데이터베이스. 10밀리초 미만 기반의 응답과 무제한에 가까운 데이터 저장이 가능한 것이 특징이다.
            - ES, elastic search : 문자열 검색에 특화된 오픈소스 NoSQL 데이터베이스.
            - Redis : key-value 형식의 메모리 데이터베이스. 하드디스크가 아닌 메모리에 데이터를 저장하므로 데이터 조회가 빠르다는 특징이 있다.

    - what - CQRS 적용으로 얻은 것
        CQRS의 적용을 통해 대량 트래픽이 발생하는 시스템에서 조회와 명령간의 불균형을 해소
        이를 통해 성능이 중요한 외부 시스템과 비즈니스 명령이 많은 내부 시스템을 분리할 수 있고, 다양한 상황에 대해 유연하게 대처할 수 있습니다.

    * MSA를 도입하기 앞서 내 시스템이 어느 지점에 와있는가? 를 파악하는 것이 우선
         MSA를 구축하는 비용이 크기 때문에
         1. 고도화된 장애격리 정책 & 확장성이 더 중요한지,
         2. 비즈니스 로직을 구현해내는게 더 중요한지 판단하고 그에 맞춰 결정해야 한다.


- 고가용성을 확보하기 위한 아키텍처 설계
    https://hudi.blog/high-availability-architecture/


- Web Server와 WAS의 차이점
    - Web Server
        - HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능

        - 정적인 컨텐츠 제공
          WAS를 거치지 않고 바로 자원을 제공한다.

        - 동적인 컨텐츠 제공을 위한 요청 전달
          클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)한다.

        ex) Apache Server, Nginx 등

        - 사용 이유
            - WAS가 해야 할 일의 부담을 줄이기 위해서
                - WAS 앞에 웹 서버를 둬서 웹 서버에서는 정적인 문서만 처리하도록 하고, WAS는 애플리케이션의 로직만 수행하도록 기능을 분배하여 서버의 부담을 줄이기 위한 것
            - WAS의 환경설정 파일을 외부에 노출시키지 않도록 하기 위해서
                - 웹 서버와 WAS에 접근하는 포트가 다르기 때문에, WAS에 들어오는 포트에는 방화벽을 쳐서 보안을 강화할 수도 있다.


    - WAS(Web Application Server)
        - 정의
            - DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
            - “웹 컨테이너(Web Container)” 혹은 “서블릿 컨테이너(Servlet Container)”라고도 불린다.
            - Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다. 즉, WAS는 JSP, Servlet 구동 환경을 제공한다.

        - 역할
            - WAS = Web Server + Web Container
            - Web Server 기능들을 구조적으로 분리하여 처리하고자 하는 목적으로 제시
                - 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용

        - 주요 기능
            1) 프로그램 실행 환경과 DB 접속 기능 제공
            2) 여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능
            3) 업무를 처리하는 비즈니스 로직 수행

        - 예) Tomcat, JBoss, Jeus, Web Sphere 등

    - WAS와 Web Server를 따로 두는 이유
        - 기능을 분리하여 서버 부하 방지
            - WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트에 제공하는 것이 좋다.
        - 물리적으로 분리하여 보안 강화
            - SSL에 대한 암복호화 처리에 Web Server를 사용
        - 여러 대의 WAS를 연결 가능
            - Load Balancing을 위해서 Web Server를 사용할 수 있다.
            - 특히 대용량 웹 애플리케이션의 경우(여러 개의 서버 사용) Web Server와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응
        - 여러 웹 애플리케이션 서비스 가능
            - 예를 들어, 하나의 서버에서 PHP Application과 Java Application을 함께 사용하는 경우가 있다.
        - 접근 허용 IP관리 및 2대 이상의 서버에서의 세션 관리 등도 Web Server에서 처리하면 효율적

        -> 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 분리한다.

    - 왜 Tomcat이 아닌 Apache Tomcat이라고 부를까?
        - 정적 컨텐츠를 처리하는 웹 서버에는 Apache가 있고, 동적 컨텐츠를 처리하는 WAS 서버는 Tomcat이 있다.
        - Tomcat 5.5 버전부터 정적 컨텐츠를 처리하는 기능이 추가되었는데, 이 기능이 순수 Apache를 사용하는 것에 비해 성능적 차이가 전혀 없으며
          Tomcat이 Apache의 기능을 포함하고 있기 때문에 Apache Tomecat이라고 부르고 있다.


- System.out.println 메소드는 현업에서 절대 쓰지 말라고하는 메소드인데요. 그 이유가 무엇일까요?
    - 휘발된다.
        - System.out.println() 은 로그가 표준 출력으로 출력된다. 즉, 파일로 저장되지 않고 휘발된다는 의미이다.
          로그는 에러가 발생한 상황을 기록하고, 추후 확인하여 문제를 진단하고, 재현하고, 고치기 위해 사용된다.
          하지만 표준 출력으로 한번 출력되고 어디에도 저장되지 않으면 로그의 제 역할을 할 수 없다.

    - 에러 발생 시 추적할 수 있는 최소한의 정보가 남지 않는다.
        - System.out.println() 은 인자로 전달한 문자열만을 출력한다.
          문제가 발생한 날짜, 시각 그리고 문제의 수준, 로그가 발생한 위치 등 최소한의 정보가 기록되지 않는다는 것 이다.

    - 로그 출력 레벨을 사용할 수 없다.
        - 로컬에서 개발할 때에는 디버깅을 위한 아주 상세한 정보가 출력되어 확인할 수 있어야한다. 하지만, 프로덕션에서 동작하는 코드는
          에러/장애가 발생할 때 문제를 진단할 수 있는 정보만을 남겨야한다. 개발시에만 사용되는 정보와 문제 상황에 대한 정보가
          함께 로깅된다면 문제 해결을 위한 정작 중요한 정보를 얻기 힘들 뿐더러, 민감한 정보를 로그로 남길수도 있기 때문이다.
          또한 의미없는 로그가 쌓여 서버 용량을 차지할 수도 있다.
        - 따라서 로깅 라이브러리는 환경에 맞게(로컬 개발 환경, 개발 서버, 프로덕션 서버 등) 로그가 출력될 수 있도록 로그 출력 레벨이라는
          기능을 제공한다. 많이 사용되는 Logback 이라는 라이브러리에서는 TRACE, DEBUG, INFO, WARN, ERROR, FATAL 와
          같은 레벨을 제공한다. 하지만 System.out.println() 은 이런 기능을 제공하지 않는다. 어떤 환경에서든 동일한 로그가 출력된다.
          프로덕션에서 이런 로그를 제거하려면 코드를 일일히 제거하거나 주석처리하거나 별도의 조건문을 설정하는 등 번거로운 일들을 해야한다.

    - 성능저하의 원인이 될 수 있다.
        1. Synchronized
            - System.out.println() 의 구현을 한번 살펴보자.
            - println() 은 newLine() 을 호출한다. newLine() 의 구현도 살펴보자.
            - synchronized 키워드가 붙어있다. 이때 newLine() 메소드는 임계영역(critical section)이 된다. 멀티 쓰레드 환경에서
              A 쓰레드가 newLine() 메소드를 실행하면, 메소드는 잠기게 된다. 다른 쓰레드는 A 쓰레드가 모두 사용하고 잠금을 풀어준 뒤에서야
              newLine() 메소드를 실행할 수 있다. 오버헤드가 발생하게 되는 것이다.
            - 스프링을 실행하는 톰캣은 멀티 쓰레드로 동작한다. 요청이 오면 쓰레드 풀에서 쓰레드를 하나 가져와 요청을 처리한다. 그런데,
              System.out.println() 을 여러 쓰레드가 사용하면 그만큼 위에서 이야기한 오버헤드가 발생하고 처리가 느려질 것 이다.
              따라서 실제 프로덕트의 코드에서는 System.out.println() 을 절대 사용해서는 안된다.
            - 동기화는 멀티쓰레드를 운용하는 환경에서 데이터의 정합성을 유지시켜주어 프로그램의 안정성을 유지시켜주는 역할을 해주지만
              서비스를 안정적으로 유지시켜주는 것과는 관련이 없는 Log를 찍어주는 작업에는 불필요합니다.

    - 로그 사용시 장점
          1. 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
          2. 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 로그를 상황에
             맞게 조절할 수 있다.
          3. 시스템 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.
          4. 특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
          5. 성능도 일반 시스템 콘솔보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등)

    - synchronized 키워드는 왜 현업에서 큰 성능 저하를 일으킬 수 있을까요?
      Blocking IO는 왜 성능을 저하시킬 수 있을까요?
      synchronized 가 Blocking IO 와 만나면 어떻게 환장의 성능하락을 만들 수 있는걸까요?
      이 두 개가 만났을 때 스레드가 어떻게 동작할지, CPU 사용률은 어떻게 될지 시뮬레이션을 해보세요.

    - 올바른 로그 사용법
        // 틀린 예)
        log.trace("trace log=" + name);

        // 옳은 예)
        log.trace("trace log={}", name);

        첫번째와 같은 방식으로 trace 를 출력할 경우 로그 출력 자체에는 문제가 없다.
        하지만 자바 문법상 "trace log="+ name 이라는 문자열 더하기 연산이 먼저 일어난 후 log 레벨을 확인하기 때문에 만약 해당 프로젝트의
        log 레벨 설정이 debug 일 경우 trace 는 debug 이하의 log 레벨이므로 출력은 하지 않지만 이미 불필요한 연산 자체가 일어난 경우가 되어 버린다.
        두번째 방식은 SLF4J 치환문자를 사용하는 방식이다.
        문자열에 중괄호를 넣어 순서대로 출력하고자 하는 데이터들을 ' , '로 구분한 후 전달하여 치환해주는 방식으로 불필요한 연산이 발생하지 않도록 한다.


- api/라이브러리/프레임워크
    - api (Application Programming Interface)
        - 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
        - 구현과 독립적으로 사양만 정의되어 있다.
        - API 에 따라 접근 권한이 필요할 수 있다.
        - 구현과는 독립적으로 다양한 컴포넌트 간에 정보를 주고 받기 위한 규약
        ex) Java API, 여러 기업들의 오픈 API

    - Library
        - 응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어
        - 독립성을 가진다.
        - 응용 프로그램이 능동적으로 라이브러리를 사용한다.
        - 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임. 개발자가 응용 프로그램 흐름의 제어권을 가짐
        ex) Apache Commons, Guava, Lombok, jQuery

    - Framework
        - 응용 프로그램이나 소프트웨어의 솔류션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경
        - 상호협력하는 클래스와 인터페이스의 집합
        - 응용 프로그램이 수동적으로 프레임워크에 의해 사용된다. (프레임워크가 응용 프로그램 흐름의 제어권을 가짐)
        ex) Spring Framework, Junit, Ruby on Rails

    -> Library 와 API 의 차이점은 구현 로직의 유무이다.
       Library 와 Framework 의 차이점은 응용 프로그램의 흐름 주도권을 누가 가지고 있느냐 이다.


- 프레임워크와 라이브러리의 차이점
    - Framework(프레임워크)
        - Application 개발 시 필수적인 코드, 알고리즘, 데이터베이스 연동 등과 같은 기능들을 위해 어느정도 뼈대(구조)를 제공해주는 것
        - 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합

    - Library(라이브러리)
        - 프로그래머가 개발하는데 필요한 것들을 모아둔 것

    - Framework와 Library의 차이는 Flow(흐름)에 대한 제어 권한이 어디에 있느냐의 차이
    - 프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며, 프로그래머가 그 안에 필요한 코드를 작성하는
      반면에 라이브러리는 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것입니다.
      프레임워크에는 제어의 역전(Inversion Of Control)이 적용되어있다는 것

    - API란
        - 필요한 부분을 요청하여 응답을 받는 서비스간의 다리와 같은 역할
        - 구현과 독립적으로 사양만 정의 되어있음


- CSR/SSR
    - SPA: Single Page Application, 하나의 페이지로 구성된 웹 어플리케이션
      웹 어플리케이션에 필요한 정적 리소스를 초반 한 번에 모두 다운로드 하고 그 이후 새로운 페이지 요청이 있을 때 페이지 갱신에 필요한
      데이터만 전달받아서 클라이언트에서 페이지를 갱신하기 때문에 자연스럽게 렌더링 방식으로 CSR 을 사용
    - MPA: Multi Page Application, 탭을 이동할 때마다 서버로부터 새로운 html 을 받아와서 페이지 전체를 새로 렌더링
      새로운 요청이 있을 때마다 서버에서 이미 렌더링된 정적 리소스를 받아오기 때문에 렌더링 방식으로 SSR 을 사용
    - SPA -> CSR,  MPA -> SSR

    - CSR: Client Side Rendering
    - SSR: Server Side Rendering
    - SSG: Static Site Generation (Static Rendering)
        - 서버에서 html 을 보내준다는 측면에서 SSR 과 비슷하지만 언제 만들어 주느냐에 차이
        - SSR 은 요청 시 서버에서 즉시 html 을 만들어서 응답하기 때문에 데이터가 달라지거나 자주 바뀌어서 미리 만들어 두기 어려운 페이지에 적합
        - SSG 는 페이지들을 서버에 모두 만들어둔 뒤에 요청시에 해당 페이지를 응답하는 것이므로 바뀔 일이 거의 없는 캐싱 해두면 좋은 페이지에 적합


    - CSR 의 동작 과정과 특징
        - 동작 과정
            - 유저가 웹사이트에 방문하면 브라우저가 서버에 콘텐츠를 요청하고 서버는 빈 뼈대만 있는 html 을 응답으로 보내준다.
              브라우저가 연결된 JS 링크를 통해 서버로부터 다시 JS 파일을 다운로드 받고 JS 를 이용해 동적 페이지를 만들어서 브라우저에 띄어줌
        - 특징
            - CSR 은 브라우저가 JS 파일을 다운로드 받고 동적으로 DOM 을 생성하는 시간을 기다려야 하기 때문에 초기 로딩 속도가 느리다.
              하지만 초기 로딩 이후에 페이지 일부를 변경할 때는 서버에 해당 데이터만 요청하면 되기 때문에 이후 구동 속도는 빠르다.
            - 서버가 빈 뼈대만 있는 html 을 넘겨주는 역할만 수행하면 되기 때문에 서버측에 부하가 적다.
              클라이언트측에서 연산, 라우팅 등을 모두 직접 처리하기 때문에 반응 속도가 빠르고 UX 도 우수하다.
            - 브라우저들이 가지는 웹 크롤러는 html 을 읽어서 검색 가능한 색인을 만들어냄. 웹 크롤러 봇 입장에서 본 html 은 텅텅 비어있다.
              검색엔진이 색인을 할만한 콘텐츠가 존재하지 않는다. -> 검색엔진 최적화에 불리하다는 치명적인 단점 존재
               (구글의 크롤러 봇은 자바스크립트를 실행할 줄 안다. CSR 웹 크롤링도 가능)
            - 화면 깜빡임이 없고 서버 부하가 클라이언트로 분산된다.

    - SSR 의 동작 과정과 특징
        - 동작 과정
            - 유저가 웹사이트에 방문하면 브라우저에서 서버로 콘텐츠를 요청한다. 서버에서는 즉시 페이지에 필요한 데이터를 얻어와 모두 삽입하고
              css 까지 모두 적용해서 렌더링 준비를 마친 html 과 JS 코드를 브라우저에 응답으로 전달.
              브라우저에서는 바로 전달 받은 페이지를 띄운다. 이어 브라우저가 JS 코드를 다운로드하고 html 에 JS 로직을 연결한다.
        - 특징
            - 모든 데이터가 이미 html 에 담겨진채로 브라우저에 전달되기 때문에 검색엔진 최적화에 유리하다. JS 를 실행할 줄 모르는
              크롤러 봇도 무리없이 html 을 읽을 수 있다.
            - 자바스크립트 코드를 다운로드 받고 실행하기 전에 사용자가 화면을 볼 수 있다. JS 다운로드를 기다려야 했던 CSR 보다
              초기 구동 속도가 빠르다. 하지만 이 시점에는 사용자가 버튼을 클릭하거나 이동하려고 해도 아무런 반응이 없을 수 있다.
              인터랙션 가능한 페이지처럼 보이지만 그저 내용과 스타일이 입혀진 껍데기에 불과하고 실제로 클라이언트 측 JS 가 실행되고
              이벤트 핸들러가 첨부되어서 JS 로직이 모두 연결될 때까지 사용자 입력에 응답할 수 없기 때문이다.
              -> TTV(Time To View) 와 TTI(Time To Interact) 간에 시간 간격이 존재한다는 단점 존재
              -> 반면 CSR 은 JS 가 동적으로 DOM 을 생성하기 때문에 html 은 JS 로직이 모두 완전히 연결된 상태라 사용자가 보는 시점과
                 이용할 수 있느 시점이 동일하다.
            - 화면 깜빡임이 있고 매 페이지 로딩시마다 서버에 요청하므로 서버 부하가 있다.

    - CSR 단점 보완
        - 초기 로딩 속도 보완
            - code splitting, tree-shaking, chunk 분리 -> JS 번들 크기를 줄여서 초기 DOM 생성 속도를 줄이는 것
        - SEO 개선
            - pre-rendering -> 라이브러리나 웹팩 플러그인을 통해 각 페이지에 대한 html 파일을 미리 생성해둔 뒤 서버에서 요청하는 자가
              만약 크롤러라면 사전에 렌더링된 html 버전 페이지를 보여주는 방식을 통해 개선

        - SSR, SSG 도입
            - with 프레임워크
                - CSR 에 비해 코드 복잡도가 올라가고, 직접 제어할 수 없는 블랙박스 영역 존재
                ex) next.js, gatsby, nuxt.js, 앵귤러 유니버셜

        - CSR + SSR
            - 초기 렌더링 벙식으로 SSR 을 사용하고 그 이후에는 CSR 을 사용하는 앱이나 그 렌더링 방식
            - Isomorphic App: 서버와 클라이언트에서 동일한 코드가 동작하는 어플리케이션. 서버와 클라이언트가 모두 같은 코드로
              돌아가기 때문에 예상과는 다른 결과를 마주할 가능성도 있지만, 초기 로딩 속도와 SEO 를 해결하면서도 CSR 의 장점을
              그대로 가져갈 수 있는 좋은 대안이기 때문에 최근 많이 사용되고 있는 추세.
            - Universal Rendering

    - 무엇을 써야할까?
        - CSR
            사용자와의 상호 작용이 많고 대부분 페이지가 고객의 개인정보 데이터를 기준으로 구성되는 서비스라면 검색포털 상위 노출 되는 것보다
            오히려 고객의 데이터를 보호하는 것이 더 중요.
        - SSR
            만약 회사 홈페이지이기 때문에 상위 노출되어야 하고 누구에거나 동일한 내용을 노출하고 있다면, 그 페이지 데이터가 자주 바뀐다면
        - SSG
            만약 회사 홈페이지이기 때문에 상위 노출되어야 하고 누구에거나 동일한 내용을 노출하고 있다면, 내용을 업데이트 하는 일이 거의 없다면
        - CSR + SSR -> 유니버셜 렌더링
            만약 사용자에 따라 페이지 내용도 달라지고 빠른 인터랙션도 중요하고 검색엔진 최적화도 포기할 수 없다면


- TDD(Test-Driven-Development)의 개념에 대해 설명해주세요.
    - TDD란 작은 단위의 테스트 케이스를 작성하고 그에 맞는 코드를 작성하여 테스트를 통과한 후에
      상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 말합니다.

    - 이렇게 반복적인 단계가 진행되면서 자연스럽게 코드의 버그가 줄어들고, 코드는 간결해진다는 장점이 있습니다.


- 테스트 코드를 작성 해야하는 이유에 대해 아는대로 설명해주세요.
    1. 기능의 추가, 변경, 삭제로 인한 영향도를 쉽게 파악 가능
    2. 예상하지 못한 오류에 대한 피드백을 위해
    3. 좋은 설계로 작성되게끔 코드를 유도
    4. 기능 정의의 문서의 역할
    5. 실수를 줄여준다.


- DDD(Domain-Driven-Design)에서 얘기하는 계층과 각각의 역할에 대해 설명해 주세요.
    - 도메인은 서로 철저히 분리되고, 높은 응집력과 낮은 결합도로 변경과 확장에 용이한 설계
    - Layered Architecture의 주된 목표는 각각의 layer는 하나의 관심사에만 집중할 수 있도록 하는 것

    - Layered Architecture를 올바르게 구현하기 위한 두 가지 중요한 규칙이 있다.
        1. 위의 계층에서 아래 계층에는 접근이 가능하지만 아래에서 위로는 불가능한 것을 기본으로 한다.
        2. 한 계층의 관심사와 관련된 어떤 것도 다른 계층에 배치되어서는 안된다.

    - 계층
        - 표현 계층(Presentation layer) : 사용자의 요청에 대해 해석하고 응답하는 일을 책임지는 계층 (Controller)
            - Client로부터 request를 받고 response를 return 하는 API 정의

        - 응용 계층(Application layer) : 비즈니스 로직을 정의하고 정상적으로 수행될 수 있도록 도메인 계층과 인프라스트럭처 계층을 연결해주는 역할을 하는 계층 (Service)
            - transaction 관리, DTO 변환, 모듈간의 연계를 진행

        - 도메인 계층(Domain layer) : 비즈니스 규칙, 정보에 대한 실질적인 도메인에 대한 정보를 가지고 있으며 이 모든것을 책임지는 계층 (Entity)
            - 업무 상황을 반영하여 상태를 제어하는 역할에 집중하는 계층

        - 인프라스트럭처 계층(Infrastructure layer) : 외부와의 통신(ORM, DB, NoSQL)을 담당하는 계층 (Repository)
            - 해당 계층에서 얻어온 정보를 응용 계층 또는 도메인 계층에 전달하는 것을 주 역할로 담당

    - 장점
        - 핵심 비즈니스 로직을 순수하게 유지함으로써 유지보수와 확장성 측면에서 이득을 얻을 수 있다.
        - 각 레이어에 서로 다른 추상화 수준을 가진 상태와 행동을 위치시킴으로써 코드 재사용성을 높일 수 있다.

    - 단점
        - 레이어로 분리된 관심사 외에 다른 관심사가 생길 경우 패키지 분리 및 코드 배치가 어렵다.


- MSA(Microservice Architecture)가 뭔지 설명해주세요.
    - MSA는 1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할합니다. 각각의 서비스는 API를 통해 데이터를 주고 받으며 1개의 큰 서비스를 구성합니다.
    - 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장하게 되었습니다.

    - 장점
        - 일부 서비스에 장애가 발생해도 전체 서비스에 영향을 끼치지 않는다.
        - 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다.
        - 서비스의 확장이 용이하다.
    - 단점
        - 서비스가 분리되어 있어 테스트나 트랜잭션 처리 등이 어렵다.
        - 서비스 간에 API로 통신하기 때문에 그에 대한 비용이 발생한다.
        - 서비스 간의 호출이 연속적이기 때문에 디버깅 및 에러 트레이싱이 어렵다.


- Lombok 라이브러리에 대해 알고 있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는 시점은 언제인가요?
    - Lombok은 메소드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어냅니다. 이것을 어노테이션 프로세싱
      (Lombok 라이브러리를 추가할 때 CompileOnly, AnnotationProcessor를 추가하는 이유도 된다.)


- 스케일 업(Scale-Up)과 스케일 아웃(Scale-Out)이란
    - 스케일 업(Scale-Up)
        - 기존 서버의 사양을 업그레이드해 시스템을 확장하는 것
        - CPU나 RAM 등을 추가하거나 고성능의 부품, 서버로 교환하는 방법
        - 수직 확장이며, 성능 확장에 한계가 있음
        - 성능 증가에 따른 비용 증가폭이 큼
        - 한 대의 서버에 부하가 집중되어 장애 영향도가 큼

    - 스케일 아웃(Scale-Out)
        - 서버를 여러 대 추가하여 시스템을 확장하는 것
        - 서버가 여러 대로 나뉘기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 '로드밸런싱'이 필수적으로 동반되어야 한다.
        - 수평 확장이며, 지속적 확장 가능
        - 비교적 저렴한 서버 사용으로 비용 부담이 적음
        - 읽기/쓰기가 여러 대의 서버에서 분산처리.
          장애 시 전면 장애의 가능성이 적음


- git branch 전략
    - branch 전략이란?
        - 여러 명의 개발자가 1개의 저장소를 사용하는 환경에서 효과적으로 사용하기 위해 나온 개념
        - 대표적인 전략
            - GitHub flow
            - git flow
            - gitLab flow

    - GitHub flow 란?
        - GitHub 에서 만든 단순한 구조의 브랜치 전략
        - Master 브랜치를 중심으로 운영되며 기능 개발, 버그 수정 등의 작업용 브랜치를 구분하지 않는 단순한 구조
        - 수시로 배포가 일어나는 프로젝트에 유용

        1. 브랜치 생성
            - Master 로부터 기능 추가, 버그 수정 작업을 위한 새로운 브랜치를 생성
        2. 기능 개발, 버그 수정
            - 작업을 하며, 기능별로 commit 을 한다.
            - commit 메시지와 브랜치 이름은 정확하고 간결하게 작성
            - commit 은 서버의 동일한 브랜치에 push 해줘야 한다. (Git flow 와 차이점)
        3. Pull Request 생성
        4. 리뷰와 논의
        5. 공개 및 테스트
            - GitHub 에서는 master 에 합치기 전에 브랜치에서 코드를 공개 및 테스트 할 수 있다.
            - 오류가 발생할 경우 원래의 master 브랜치를 다시 배포하여 rollback 한다.
        6. Merge
            - 브랜치의 검증이 완료되면 master 브랜치에 합친다.
            - 이로써 GitHub flow 의 브랜치의 생명주기가 끝난다.

    - Git flow 란
        - 많은 기업에서 표준으로 사용하고 있는 대표적인 Git branch 전략
        - GitHub flow 와는 다르게 크게 5개의 브랜치를 운영하며 관리한다.
            - 메인 브랜치: master, develop
            - 보조 브랜치: feature, release, hotfix
        - 배포 주기가 길고 팀의 여력이 있는 경우 적합

        - 메인 브랜치의 특징
            - master, develop 두 개의 브랜치는 항상 남아있는다.
            - master 브랜치는 제품으로 배포할 수 있는 브랜치
            - develop 브랜치는 개발자들이 개발을 하는 브랜치

        - 보조 브랜치의 특징
            - 사용을 마치면 브랜치를 삭제한다.
            - feature: 기능 구현
              release: QA 진행
              hotfix: 버그의 빠른 수정

            - Feature 브랜치
                - 다음 버전을 위한 특정 기능 개발을 할 때는 develop 브랜치에서 직접 개발을 하는 것이 아닌
                  develop 으로부터 feature 브랜치를 생성하여 개발을 진행.
                  feature 브랜치에서 개발을 완료한 후에는 develop 으로 merge 한 후 브랜치를 삭제

                - 만약 feature 브랜치에서 개발한 후 merge 를 진행할 때 develop 과 conflict 되는 내용이 있으면
                  develop 으로부터 변경 내용을 불러와 수정을 한 후 merge 를 진행

                - 브랜치들 간의 merge 를 할 때는 --no-ff 옵션을 사용하여 다른 브랜치에서 merge 를 했다는 이력을 남겨주는 것을 권장
                  fast-forward 관계에 있어도 merge commit 을 생성하여 해당 브랜치가 존재하였다는 정보를 남길 수 있다.
                  코드 내에 오류가 발생했을 때, 개발한 기능을 제거하려고 할 때 commit 을 되돌리기 편해진다.
                  --no-ff 을 사용하지 않으면 브랜치의 존재 여부를 몰라 어떤 commit 부터 해당 기능을 구현했는지 확인하기 어렵다.
                  또한, 브랜치가 fast-forward 관계에 있을 때 develop 입장에서는 feature 의 commit 기록들을 동일하게 가져와도 문제가
                  없다고 판단하여 브랜치의 참조 값만 변경하여 merge commit 을 생성하지 않는다.
                  만약 이런 방식으로 commit 기록들이 나오면 어떤 특정 feature 와 관련된 commit 이 어디서부터 해당하는지 확인이 힘들다.

            - Release 브랜치
                - 프로덕션에 다음 버전 출시를 준비하기 위한 브랜치
                - develop 브랜치에서 개발이 완료된 코드를 master 로 merge 하기 이전에 QA 테스트 진행
                - QA 를 진행하기 위해 develop 으로부터 release 브랜치를 생성하여 해당 브랜치에서 QA 진행
                - 만약 오류가 발견된면 해당 브랜치 내에서 수정을 하고 QA 가 끝나고 배포할 준비가 완료되었다고 판단되면
                  release 브랜치를 master 브랜치와 develop 브랜치에 merge 하고 release 브랜치를 삭제
                - 이 때 develop 브랜치에 merge 할 때 그 사이에 develop 내에 추가적인 개발 상황이 있어 충돌이 발생할 수도 있다.
                - 이러한 경우 해당 내용을 수정하고 다시 merge 하는 방식으로 진행
                - merge 할 때 --no-ff 를 사용하여 기록을 그룹화
                - master 로 merge 후에는 tag 명령을 통해 버전을 명시

            - Hotfix 브랜치
                - production 에 버그가 발생하면 빠른 수정을 위해 생성하는 브랜치
                - master 에 올라가 실제 필드에 나가 있는 코드에서 오류가 발생한다면 긴급하게 hotfix 브랜치를 생성하여 오류를 수정한 후
                  변경사항을 master 에 merge 하여 오류를 수정
                - 이 때 발생한 오류들은 develop 과 release 로부터 거르지 못한 오류이기 때문에 현재 브랜치의 코드에도 반영을 해줘야 한다.
                - production 코드를 수정하는 중에도 develop 에서는 계속 개발을 할 수 있다는 장점
                - master 로 merge 후에는 tag 명령을 통해 이전 버전보다 높은 버전 명시

    - GitLab Flow
        github flow의 간단한 배포 이슈를 보안하기 위해 관련 내용을 추가로 덧붙인 flow 방식
        Production 브랜치가 존재하여 커밋 내용을 일방적으로 Deploy 하는 형태를 갖추고 있다.

    - 무슨 전략을 사용해야 할까?
        - 팀의 브랜칭 전략은 조직의 규모, 서비스의 특징 등을 고려하여 협의를 통해 전략을 결정해야 한다.
        - production 의 공식 배포 주기가 길고 QA, 테스트, hotfix 등의 여력이 있으면 Git flow 가 적합
        - 지속적으로 테스트 및 배포를 하는 팀의 경우 간단한 GitHub flow 를 사용하는 것이 적합


- api 개발시 중요하게 여기는 것   https://www.holaxprogramming.com/2015/01/01/devops-api-design/
    - API가 우선적으로 필요한 전제는 기능에 대한 요구사항을 충족해야 한다는 것
    - 여기에 사용자에게 좋은 API를 제공하기 위해 고려해야 점
        - 잘못 사용하기 어려울 것. 만약 사용자가 API의 의도대로 움직이지 않는다면 쉽게 어떤 부분이 잘못 되었는지 알려줄 수 있어야 한다. (에러 처리)
        - 많은 실수에 미리 노출 될 수 있도록해라. 테스트 코드를 많이 만들고 안정적인 버전이 배포되기 까지는 많은 사용자에게 노출시키는 것이 좋다.
          실수를 통해 API를 발전되어 간다.
        - API의 이름은 매우 중요하다. 프로그래밍 언어에 맞는 Convention을 지키고 일관적으로 API의 이름을 짓도록 한다.
        - private 키워드를 통해 불필요한 클래스나 메소드가 사용자에게 노출되지 않도록 한다. 이것은 사용자를 혼란스럽게 만든다.


- 리팩토링을 하는 경우 우선 고려할 점은    https://ikkison.tistory.com/82  https://nesoy.github.io/articles/2018-05/Refactoring
    - 리팩토링이란?
        - 가독성, 유지보수성
            - 기능을 유지하되 읽기 좋고 지속적으로 관리하기 편하게 소스코드를 재작성하는 것
            - 성능 최적화는 다른 문제

        - 사람, 협업
            - 내가 진행하는 프로젝트 중간에 참여하거나, 인수인계가 어려운 경우가 있다.
            - 이해하기 쉬운 코드를 작성하는 것이 중요

    - 목적
        - 보다 이해하기 쉽고, 수정하기 쉽도록 만드는 것
        - 겉으로 보이는 소프트웨어의 기능을 변경하지 않는다는 것

    - 리팩토링은 언제 할까?
        - 유사한 내용이 세번 이상 반복할 때
        - 새로운 기능을 추가할 때
            - 지금 작성된 설계, 소스코드에서 새로운 기능을 추가하기 어려워 보이면 리팩토링을 해야 한다.
              이러한 상황인 경우 유지보수성이 떨어지며, 가독성 역시 좋지 않을 가능성이 높다.
        - 코드리뷰를 할 때 (스프린트를 진행하면서)


- JUnit이란
    JUnit이란 java의 단위테스트를 위한 프레임워크를 말합니다. 객체의 인스턴스를 생성하여 로직 수행후 결과값이 기대값과 일치하는지 비교하거나
    파일이나 네트워크 상의 연결이나 데이터베이스 연동 테스트 등을 수행할 수 있습니다


- mock
    - 실제 객체를 만들어 사용하기에 시간, 비용 등의 Cost가 높거나 혹은 객체 서로간의 의존성이 강해 구현하기 힘들 경우 가짜 객체를 만들어 사용하는 방법이다.
    - 언제사용하는가?
        - 테스트 작성을 위한 환경 구축이 어려운 경우
        - 테스트가 특정 경우나 순간에 의존적인 경우
        - 테스트 시간이 오래 걸리는 경우
        - 개인 PC의 성능이나 서버의 성능문제로 오래 걸릴수 있는 경우 시간을 단축하기 위해 사용한다.


- Mockito
    - java mock framework


- @Spy와 @Mock의 차이
    - 둘의 가장 큰 차이점은 @Spy는 실제 인스턴스를 사용해서 mocking을 하고, @Mock은 실제 인스턴스 없이 가상의 mock 인스턴스를 직접 만들어 사용한다는 것이다.
    - 그래서 @Spy는 Mockito.when() 이나 BDDMockito.given() 메서드 등으로 메서드의 행위를 지정해 주지 않으면
    - @Spy 객체를 만들 때 사용한 실제 인스턴스의 메서드를 호출한다.


- 테스트의 종류
    - 단위 테스트
        - 가장 작은 단위의 테스트이다
        - 보통 메서드 레벨이다
        - A라는 함수가 실행되면 B라는 결과가 나온다 정도로 테스트한다
        - 즉각적인 피드백이 나온다는 것이 훌륭한 장점이다

    - 통합 테스트
        - 테스트 대상이 되는 모듈을 호출하여 준비한 테스트 데이터를 제공하고 모듈의 실행 결과를 받는 모듈
        - 일반적으로 상향식 테스트에서 아직 통합되지 않은 상위 컴포넌트의 동작을 시뮬레이션 하기 위해 사용.


- 빌드와 배포
    - 컴파일
        - 소스 코드를 기계가 읽을 수 있는 바이너리 코드로 변경하는 과정
        - 소스 코드 분석 및 문법 오류 분석이 이루어진다.
        - JVM: Java Byte Code 를 OS 에 맞게 실행. 자바의 높은 이식성에 큰 영향을 주게 됨.
          결과물로 .class

    - 빌드
        - 소스 코드를 실행 가능한 독립적인 소프트웨어 산출물로 만드는 과정

        1. 컴파일: 소스코드를 바이너리 코드로
        2. 링크: 클래스 파일들끼리 연결 (외부 라이브러리 포함)
        3. 패키징: 연결된 클래스 및 리소스 파일 묶어주기
        4. 테스트: 기능 테스트
        -> 독립적인 소프트웨어 산출물로 묶어줌 (JAR, WAR)
            - JAR (Java Archive): 자바에서 사용되는 압축 양식, 클래스 + 리소스 파일로 구성
            - WAR (Web Archive): 웹 어플리케이션을 압축하고 배포하는데 사용되는 파일 형태
                                 JAR 에 비해 자바 서블릿, XML 파일, 정적 파일 등 필요한 자원이 더 많다.

    - 빌드 툴
        - Ant
            - XML 형식으로 작성
            - 자유도가 높음
            - 절차적으로 작성이 됨
            - 스크립트 직접적으로 명시, 다양한 Task 가능
            - 스크립트 재사용 불가능
            - 복잡해질수록 구조 및 스크립트 파악이 힘듬
        - Maven
            - pom.xml 형식으로 작성
            - 전체적인 프로젝트 관리 가능
            - 편리한 의존성 관리 및 다운로드 가능
            - 표준화된 빌드 스크립트
            - Lib 가 존재하여 빌드 속도가 빨라짐
            - 지원하지 않는 복잡한 빌드 과정 추가 시에 난이도 상승
            - pom.xml 관리가 까다로워짐
            - Repository 관리 불편함
        - Gradle
            - Ant 의 장점과 Maven 의 장점을 모아 Gradle 이 만들어짐
            - JVM 위에서 동작하는 Groovy 기반으로 작성
            - 자바 문법과 유사하여 익히기가 쉬움
            - Maven 의 세팅 및 중앙 저장소를 활용 가능
            - 프로젝트를 설정 주입식으로 정의, 재사용이 용이
            - Wrapper 를 활용하여 Gradle 이 설치되어 있지 않아도 사용 가능
            - Maven 에 비해 커뮤니티 크기가 작음

            - src: 자바 소스 파일
            - .gradle: gradle 버전 및 설정 파일
            - settings.gradle: 프로젝트 정보 설정
                - 프로젝트 빌드 정보 설정은 보통 하나지만, 멀티 프로젝트 빌드 시에 프로젝트 정의 가능. 하위 프로젝트들이 어떻게 구성되어 있는지를 기록
            - build.gradle: 프로젝트 빌드에 대한 정의
            - gradlew, gradlew.bat: 작동될 gradle 명령 파일들
                - gradle wrapper 의 약자로, gradle 이 설치되어 있지 않아도, 빌드할 수 있게 하는 역할
                  자바의 특성은 다양한 운영체제에서 작동하는 것인데, gradle 도 동일

    - 배포
        - 사용자가 사용할 수 있도록 소프트웨어를 제공하는 과정

    - CI/CD
        - 협업 시 문제점
            - 마지막에 프로젝트 합칠 시에 Integration Hell 발생
            - 중간 중간 프로젝트 합칠 시에 지속적으로 시간 소모 (빌드, 테스트)
        -> 이런 문제들을 해결하기 위해서 만든 것이 CI

        - CI (Continuous Integration)
            - 지속적 통합이라고도 하며, 코드 변경사항마다 빌드, 테스트까지 자동으로 진행하고 결과물을 보고 받고
              리포지토리에 자동 통합되는 프로세스

            - 변경 사항이 클래스, 기능 더 나아가 전체 어플리케이션에서의 테스트를 수월하게 수행
            - 신규 코드와 기존 코드의 충돌을 빠르게 수정 가능
            - 협업 시에 어플리케이션이 최신 상태로 유지됨을 믿을 수 있음

            - CI Tools
                - Travis
                    - Github 와 연계가 매우 좋다
                    - 클라우드 기반으로 서버 없이 작동 가능
                    - yml 형식을 통하여 쉽게 설정 가능
                    - 모든 작업들이 독립적
                    - 유료 서비스
                    - 상대적으로 부조간 플러그인
                - Jenkins
                    - 다양한 IDE 를 지원
                    - 호스팅을 직접 하기 때문에 커스터마이징 가능
                    - 가장 커뮤니티가 크기 문에 문서가 다양
                    - 중구난방 플러그인 때문에 파편화된 세팅
                    - 규모가 작아도 서버를 운영해야 함
                    - 서버 운영 비용 발생

        - CD (Continuous Deployment)
            - 개발자들이 코드에 변경 사항을 줄 경우, 파이프 라인을 통해 이동하여 프로적션 단계까지 자동으로 배포되는 프로세슨

            - 어플리케이션을 프로덕션으로 빠르고 쉽게 배포
            - 소비자들의 요구를 빠르게 만족시키는 서비스 출시가 가능
            - 개발팀과 운영팀의 간극을 메워줄 생산성 향상

        -> 운영, 모니터링 그리고 문제점이나 새로운 기능들을 다음 기능 기획에 반영? => DevOps
        - DevOps
            - Development 와 Operation 을 결합한 단어
            - 개발과 운영이 연계하여 협력하여 서비스를 이끌어 나가는 방법론


- 순간에 많은 트래픽이 발생하면 대처방안 (sql튜님말고 , 로드밸런싱말고)

- 테스트 코드 작성시 실행시키는 속도가 느릴텐데 어떤방법이 있을까   https://tecoble.techcourse.co.kr/post/2022-10-15-test-code-optimization/
    - 테스트 피라미드를 참고해서 계층별 테스트 비율을 조절하자
        - 인수 테스트(UI Test)
            사용자 스토리(시나리오)에 맞춰 수행하는 테스트
            시나리오에서 요구하는 것은 누가, 어떤 목적으로, 무엇을 하는가이다.

        - 통합 테스트(Integration Test)
            단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트
            @SpringBootTest 를 사용하여 작성
            단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부 라이브러리)까지 묶어 검증할 때 사용
            이는 DB에 접근하거나 전체 코드와 다양한 환경이 제대로 작동하는지 확인하는데 필요한 모든 작업을 수행할 수 있다.

        - 단위 테스트(Unit Test)
            단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트이다.

    - 불필요한 설정을 제거하자 (ControllerTest → WebMvcTest 로 내린다든가)

    - 재사용 가능한 테스트 구조를 고민해보자
        테스트 격리를 위해서 사용했던 MockBean, SpyBean 이 객체마다 다르게 선언되어 있었던 점이 문제
        해당 어노테이션을 사용하면 대리 객체가 생성되어 실제 객체가 아니라, 대리 객체가 생성되고 있었어요. 따라서 당연하게 Context 에 생성되는
        기존 객체가 아닌 대리 객체가 추가 되기 때문에 고유 컨텍스트 구성이 오염되었다고 판단해서 새로운 Context 를 띄우게 되는 것.

        처음부터 필요한 대리 객체가 무엇인지 파악한 뒤 Mock, Spy 한번에 선언하여 Context 에 올려두고,
        Test Class 들이 상속 받아 사용하는 형태로 구현한다면 컨텍스트 초기화를 한번만 하는 것이 가능

    - 데이터 격리 방식으로 DirtiesContext 걷어내자 ??


- 대량용 요청을 고려한 api를 개발한다면?
    https://velog.io/@jiffydev/%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EC%84%B1%EB%8A%A5-%ED%8A%9C%EB%8B%9D-%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98

- 테스트 코드 커버리지는 어떤 기준으로 측정하는지? private 메서드는 테스트하는지?

- 상글톤 패턴은 안티패턴인가?

- maven vs gradle   https://binco.tistory.com/entry/Maven-VS-Gradle
    - 빌드 배포 툴
        프로젝트를 진행하다 보면 많은 라이브러리를 활용해서 개발을 하게 된다. 이 때 사용되는 라이브러리들의 수가 많아지면 그만큼 라이브러리들을
        관리하는 것이 힘들어지게 됩니다. Maven은 이러한 문제를 해결해주는 일종의 도구입니다. Maven은 내가 사용할 라이브러리뿐만 아니라
        해당 라이브러리가 작동하는데 필요한 다른 라이브러리들까지 관리하여 네트워크를 통해 자동으로 다운로드 해줍니다.

    - Gradle
        - 빌드 툴인 Ant Builder와 그루비 스크립트를 기반으로 구축되어 기존 Ant의 역할과 배포 스크립트의 기능을 모두 사용 가능
        - 기본 Maven의 경우 XML로 라이브러리를 정의하고 활용하도록 되어 있으나(pom.xml), Gradle의 경우 별도의 빌드 스크립트를 통하여 설정
        - 그루비 스크립트 언어로 구성되어 있기에 XML과 달리 변수 선언, if, else, for 등의 로직 구현이 가능하며 간결하게 구성 가능

    - 그루비
        - 그루비는 자바에 파이썬, 루비, 스몰토크 등의 특징을 더한 동적 객체 지향 프로그래밍 언어
        - JVM에서 작동하는 동적 타이핑 프로그래밍 언어
        - 러닝커브가 낮다.
        - 도메인 전문 언어와 단순화된 문법을 지원하여 코드를 읽고 유지 보수하기 편함

    - Gradle이 Maven보다 좋은 점
        - 스크립트 길이와 가독성 면에서 gradle이 우세
        - 의존성이 늘어날수록 성능과 스크립트 품질 차이가 심해짐
        - gradle은 그루비를 사용하기 때문에, 동적인 빌드는 그루비 스크립트 플러그인을 호출하거나 직접 코드를 짜면 된다.
        - 빌드 타임 소곧가 Maven보다 10 ~ 100배 빠르다.


- Gradle Java 플러그인과 implementation와 api의 차이   https://mangkyu.tistory.com/296
    1. Gradle Java 플러그인, Java-Library 플러그인
        - Java 플러그인이란?
            Gradle(그레이들)에서 Java 프로젝트를 빌드하려면 기본적으로 java 플러그인이 필요하다. java 플러그인을 통해 컴파일, 테스트, jar 파일 생성 등의 작업들(tasks)이 수행 가능하다.

            Compile classpath: Java 코드를 class 파일로 컴파일 할 때 탐색하는 경로
            Runtime classpath: 컴파일된 자바 코드(class 파일)을 JVM이 실행할 때 탐색하는 경로

            컴파일 시점에만 필요로 하는 의존성도 있고, 실행 시점에만 필요로 하는 의존성도 있다. 그래서 Gradle에서 의존성(dependency)를 추가할 때 어느 범위로 노출시킬 것인지 결정할 수 있도록 도와준다.
                complieOnly: 컴파일 경로에만 설정
                runtimeOnly: 런타임 경로에만 설정
                implementation: 두 경로에 모두 설정
                api: 두 경로에 모두 설정

        - Java-Library 플러그인이란?
            Java-Library 플러그인은 기존의 java 플러그인에 추가적인 정보를 제공함으로써 기능을 확장한 플러그인.
            이를 활용하면 Java 플러그인에 의해 노출되는 모든 source sets, tasks, configurations를 암시적으로 사용할 수 있다.

    2. Gradle implentation과 api의 차이
        - 전이 의존성 또는 추이 의존성(transitive dependency)이란?
            Gradle6 이전에는 compile도 사용 가능했는데, compile이 deprecated 되고 나온 것이 api이다. 그리고 runtime 대신 나온 것은 implementation이다.
            implementation과 api를 사용하면 모두 컴파일 경로와 런타임 경로에 노출된다.
            하지만 둘 사이에는 전이 의존성(transitive dependency)의 컴파일 경로 노출 여부에서 차이가 있다.

        - implentation과 api의 사용
            api는 전이 의존성을 허용
            implementation으로 선언된 전이 의존성은 사용이 불가능

        - implentation과 api의 차이 요약
            implementation은 api에 비해 몇 가지 장점
                의존성이 해당 모듈을 사용하는 컴파일 클래스 경로에 노출되지 않으므로, 실수로 전이 종속성에 빠지지 않음
                줄어든 클래스 패스 덕분에 컴파일이 빨라짐
                implementation하는 의존성들이 변경되었을 때, 재컴파일을 하지 않아도 되므로 재컴파일 횟수가 줄어듬
                새로운 maven-publish 플러그인을 함께 사용하면, java 라이브버리는 컴파일하는데 필요한 것과 런타임에 사용하는데 필요한 것을 정확히 구분하는 POM 파일을 생성하여 더욱 깔끔하게 publish 할 수 있음

            가능하다면 api 보다는 implementation을 우선시하는 것이 좋다.
            이렇게 하면 모듈을 사용하는 곳의 컴파일 클래스 경로에서 종속성을 유지할 수 있다.

            api는 애플리케이션 바이너리 인터페이스(ABI, Application Binary Interface)로 아래와 같은 경우에 사용하면 좋다.
                부모 클래스 또는 인터페이에 사용되는 타입
                제너릭 타입을 포함하여 public 메소드 파라미터로 사용하는 타입
                퍼블릭 필드에 사용되는 타입
                퍼블릭 애노테이션 타입

            반면에 아래와 같은 경우는 ABI에 해당하지 않으므로 implementation을 사용해야 한다.
                메소드의 바디에서만 사용되는 타입
                프라이빗 멤버로 사용되는 타입
                내부 클래스에서 발견되는 타입


- Private 메소드를 테스트하는 방법과 이를 지양해야 하는 이유   https://mangkyu.tistory.com/235
    - Private 메소드를 테스트하는 방법
        - Java Reflection API를 이용한 메소드 호출
            테스트하고자 하는 클래스로부터 Method를 추출하여 해당 메소드를 직접 invoke해주면 된다.
            해당 메소드를 얻어오기 위해서는 메소드의 이름과 타입 클래스를 넘겨주어야 하며, private 메소드는 기본적으로 접근 가능 여부가 false이므로
            이를 true로 변경해주어야 한다. 그리고 직접 메소드를 호출해보면 테스트가 성공함을 확인할 수 있다. 하지만 이러한 방식은 상당히 번거롭다.
            스프링 프레임워크를 이용중이라면 조금 더 간단히 이를 해결할 수 있다.

        - Spring의 ReflectionTestUtils를 이용한 메소드 호출
            스프링 프레임워크는 내부적으로 리플렉션을 상당히 많이 활용하고 있다. 그래서 직접 자바의 리플렉션 API를 하는 것 보다는
            효율적으로 리플렉션을 사용하기 위한 유틸성 클래스인 ReflectionTestUtils를 제공하고 있다.

    - private 메소드 테스트를 지양해야 하는 이유
        리플렉션은 런타임에 동작하는 기술로, 클래스와 메소드의 메타정보를 사용해서 애플리케이션을 동적으로 유연하게 만들 수 있다.
        그래서 리플렉션을 사용하면 private 메소드를 invoke 할 수 있다. 그런데 문제는 이렇게 작성한 private 메소드에 대한 테스트는 깨지 쉬운
        테스트가 된다는 것이다. private 메소드는 내부를 감추어 클라이언트와의 결합도를 낮춰주는데, 클라이언트인 테스트 클래스가 내부 메소드를 알고 있으니 결합도가 높아진다.
        그리고 이는 유지보수할 때 테스트에 대한 비용을 증가시키는 요인이 될 수 있는데, 메소드 이름이나 파라미터 등을 변경할 때 실패하게 된다.
        또한 리플렉션 자체 역시 컴파일 에러를 유발하지 못하므로 최대한 사용을 자제해야 한다. 물론 private 테스트가 정말 필요한 상황도 있다.
        리팩토링을 위해 혹은 기능의 동작 검증을 위해 임시로 작성해도 괜찮고, 남겨두어도 괜찮다. 다만 나중에 내부 구현이 바뀌어 테스트가 깨지는
        상황이 되었다면, 그때는 반드시 제거해주도록 하자.

    - 그렇다면 어떻게 테스트 해야하는가?
        그렇다면 위의 경우는 어떻게 해야하는가? 우선 테스트 대상은 private 메소드가 아닌 public 메소드인 getDisplayName이 되어야 한다.
        그리고 실패하는 케이스와 성공하는 케이스를 나누어 private 메소드까지 커버할 수 있는 여러 개의 파라미터로 돌리면 된다.
        Junit5에서는 @ParameterizedTest를 이용하면 동일한 테스트를 여러 개의 파라미터로 실행할 수 있다.

        private 메소드의 테스트는 테스트 클래스가 내부 메소드를 알고 있으니 결합도가 높아지고 깨지기 쉽다.
        그리고 이는 유지보수할 때 테스트에 대한 비용을 증가시키는 요인이 될 수 있다.
        그러므로 private 메소드를 테스트해야 하는 상황이라면 무언가 책임이 이상하거나 설계가 잘못되었다는 신호로 받아들이고 점검을 해볼 필요가 있다.
        이는 리팩토링의 신호이다.


- JPA 사용시 테스트 코드에서 @Transactional 주의하기   https://tecoble.techcourse.co.kr/post/2020-08-31-jpa-transaction-test/
    개발자의 서비스 코드의 메서드에서 @Transactional 을 깜빡하고 사용하지 않고 테스트 코드에서만 @Transactional을 사용한다면 어떻게 될까?
    테스트 코드는 통과하지만 실제로 프로덕션이 서비스 될 때는 런타임에 LazyInitializationException이 발생하는 것을 볼 수 있다.

    LazyInitailizationException이 발생하는 이유는 실제 서비스 코드에서는 @Transactional 이 없기 때문에 영속성 컨텍스트가 존재하지 않아서
    Lazy Loading이 불가능하지만, 테스트 코드는 @Transactional 이 존재하기 때문에 영속성 컨텍스트가 존재하면서 Lazy Loading이 가능했기 때문이다.
    따라서 서비스 코드에는 @Transactional 을 이용하지 않고 테스트 코드에만 @Transactional 을 이용한다면
    개발자의 실수로 런타임에서만 LazyInitailizationException이 발생하는 문제가 생길수 있다.

    그렇다면 서비스 코드에만 @Transactional 을 이용하고 테스트에서는 어떻게 하는 게 좋을까?
    테스트 코드에 @AfterEach 메서드를 만들고 직접 연관된 JpaRepository를 이용해서 deleteAll() 하는 것을 추천
    이렇게 하면 테스트 코드에서는 영속성 컨텍스트를 직접 관리하지 않기 때문에 위와 같은 오류를 방지할 수 있다.

    위 테스트 코드에서 @Transactional 을 제거하고 테스트를 수행하면 테스트가 통과하지 못한다.
    이는 테스트 코드에서 Lazy loading 을 사용했기 때문이다. 이전 코드에서는 @Transactional 로 인해 테스트 코드 전체에 영속성 컨텍스트가
    존재하면서 Lazy loading 이 가능했지만 이제 @Transactional 이 불가능해졌기 때문이다.
    Lazy loading 하도록 Entity를 가져오던 쿼리를 fetch join으로 바꿔주면 더 이상 Lazy loading이 필요하지 않게 되면서 정상적으로 테스트 코드가 통과할 것이다.


- Scale-up과 Scale-out에 대해 알아보자!   https://tecoble.techcourse.co.kr/post/2021-10-12-scale-up-scale-out/
    - 스케일 업(Scale-up)
        기존의 서버를 보다 높은 사양으로 업그레이드하는 것
        하드웨어적인 예를 들면, 성능이나 용량 증강을 목적으로 하나의 서버에 디스크를 추가하거나 CPU나 메모리를 업그레이드시키는 것을 말한다.
        소프트웨어적인 예로는 AWS의 EC2 인스턴스 사양을 micro에서 small, small에서 medium 등으로 높이는 것으로 생각하면 된다.

        스케일 업 아키텍처에서는 추가적인 네트워크 연결 없이 용량을 증강할 수 있다. 스케일 아웃보다 관리 비용이나 운영 이슈가 적고, 사양만 올리면 되는 것이기 때문에 비교적 쉽다.
        다만 성능 향상에 한계가 있으며 성능 향상에 따른 비용부담이 크고, 서버 한 대가 부담하는 양이 많아서 자연재해 등의 다양한 이유로 서버에 문제가 생기면 큰 타격을 입게 된다.
        또한 기존의 서버를 교체함으로써 성능을 올릴 때에는 서비스를 이용할 수 없는 다운타임이 불가피하다.

    - 스케일 아웃(Scale-out)
        장비를 추가해서 확장하는 방식을 말한다.
        기존 서버만으로 용량이나 성능의 한계에 도달했을 때, 비슷한 사양의 서버를 추가로 연결해 처리할 수 있는 데이터 용량이 증가할 뿐만 아니라
        기존 서버의 부하를 분담해 성능 향상의 효과를 기대할 수 있다.
        클라우드 서비스에서는 자원 사용량을 모니터링하여 자동으로 서버를 증설(Scale Out)하는 Auto Scaling 기능도 있다.

        스케일 아웃 아키텍처의 가장 큰 장점 중 하나는 확장의 유연성에 있다.
        스케일 업 시스템을 구축한 상황에서는 향후 확장 가능성에 대비해 서버를 현재 필요한 만큼보다 더 많은 용량이나 성능을 확보해놓는 경우가 많다.
        스케일 아웃 방식으로 시스템을 구축한 상황에서는 서버를 필요한 만큼만 도입해 놓고, 장기적인 용량 증가 추이를 예측할 필요 없이
        그때그때 필요한 만큼 서버를 추가해 용량과 성능을 확장(pay-as-you-grow)할 수 있게 된다.
        다만, 스케일 아웃도 장점만 있는 것은 아니다. 무엇보다 여러 노드를 연결해 병렬 컴퓨팅 환경을 구성하고 유지하려면 아키텍처에 대한 높은 이해도가 요구된다.
        서버의 수가 늘어날수록 관리가 힘들어지는 부분이 있고, 아키텍처의 설계 단계에서부터 고려되어야 할 필요가 있기 때문이다.
        여러 노드에 부하를 균등하게 분산시키기 위해 로드 밸런싱(load balancing)이 필요하고, 노드를 확장할수록 문제 발생의 잠재 원인 또한 추가한 만큼 늘어나게 된다.


- connection pool
    - 정의
        - 애플리케이션의 스레드에서 데이터베이스에 접근하기위해 Connection이 필요
        - 데이터베이스와 Connection한 객체들을 미리 생성해 Pool에 저장해두었다가, 클라이언트의 요청이 들어올 때마다 사용/반환하는 방식

    - 데이터베이스 접근 과정
        (1) 웹 컨테이너가 실행되면 데이터베이스와 연결된 Connection 객체들을 미리 생성해 Pool에 저장
        (2) 클라이언트 요청 시 Pool에서 Connection 객체를 가져와 데이터베이스 접근
        (3) 요청 처리가 끝나면 사용된 Connection 객체를 다시 Pool에 반환

    - 장점
        - 매 연결마다 Connection 객체를 생성/제거하는 비용 감소
        - 미리 생성된 Connection 객체를 사용하므로 데이터베이스 접근 시간 단축
        - Connection 수를 제한해 부하 조정

    - 단점
        - Connection 또한 객체이므로 메모리 차지
        - Connection 개수를 잘 못 설정할 경우, 쓸모없는 Connection이 발생할 수 있음

    - Connection이 부족할 경우
        - 모든 Connection이 요청을 처리 중일 때, 해당 클라이언트의 요청을 대기 상태로 전환
        - Pool에 Connection 객체가 반환되면 순차적으로 요청을 처리

    - Thread Pool과 Connection Pool
        - Thread Pool은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것
        - WAS(Web Application Server)에서 Thread Pool과 Connection Pool의 Thread와 Connection의 수는 메모리와 직접적으로 관련이 있음
        - Connection과 Thread 수를 많이 설정하면 메모리를 많이 차지하고, 반대로 적게 설정할 경우 처리하지 못하는 대기 요청이 많아짐


- 크롤링
    - 크롤링 하는법   https://yozm.wishket.com/magazine/detail/878/
    - 웹 크롤러 설계   https://lannstark.tistory.com/226
                     https://velog.io/@monkb/%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%9F%AC-%EC%84%A4%EA%B3%84
    - 자바스크립트와 DOM   https://www.codestates.com/blog/content/dom-javascript
    - DFS, BFS
        - 크롤링에서는 DFS 보다는 BFS 를 사용한다. (깊이가 어느정도가 될지 가늠할 수 없기 때문이다.)
        - 한 한페이지에서는 같은 링크를 포함하고 있는 경우가 많은데, 이 경우에는 요청을 보내지 않게 구현하여 impolite crawler 가 되지 않도록 해야된다.
        - Queue 로 구현하였기 때문에 우선순위 없이 처리하는데, page rank 나 트래픽의 양, 업데이트 빈도 등을 고려하여
          Priority queue 로 구현하는 것이 더욱 바람직할 것이다.


- 레거시 코드를 점진적으로 개선한 경험
    https://blog.sogoagain.com/posts/2020/continuous-improvement-legacy/

- 인프콘 2022 - (레거시 시스템) 개편의 기술
    https://zzang9ha.tistory.com/419

- 개발자에게 좋은 직장 혹은 좋은 환경
    http://www.chidoo.me/index.php/2018/12/31/good-company-or-good-environment-for-a-developer/
    https://kdohyeon.tistory.com/125
    https://taes-k.github.io/2020/04/08/good-development-culture/

- 개발 프로세스 개선
    https://techblog.woowahan.com/2521/

- 로드 밸런싱에 대해 알아보자!
    https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/

- MDD 개발 방법론

******* JVM warm up
    https://www.youtube.com/watch?v=CQi3SS2YspY

- 대용량 아키텍처와 성능 튜닝
    https://velog.io/@jiffydev/%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EC%84%B1%EB%8A%A5-%ED%8A%9C%EB%8B%9D-%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98

- 캐시를 활용한 대용량 트래픽 처리 성능 향상
    https://medium.com/coupang-engineering/%EC%BA%90%EC%8B%9C%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8A%B8%EB%9E%98%ED%94%BD-%EC%B2%98%EB%A6%AC-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81-a274f4731d07

- 효율적으로 로그 모니터링하기 - 로그 레벨 구분하기
    https://jojoldu.tistory.com/712

- Logback 으로 쉽고 편리하게 로그 관리를 해볼까요?
    https://tecoble.techcourse.co.kr/post/2021-08-07-logback-tutorial/

- msa
    https://gyoogle.dev/blog/computer-science/software-engineering/MSA.html

- TDD
    https://gyoogle.dev/blog/computer-science/software-engineering/TDD.html

- 클린코딩 & 리팩토링
    https://gyoogle.dev/blog/computer-science/software-engineering/Clean%20Code%20&%20Refactoring.html

- 클린코딩 & 시큐어 코딩
    https://gyoogle.dev/blog/computer-science/software-engineering/Clean%20Code%20&%20Secure%20Coding.html

- 애자일
    https://gyoogle.dev/blog/computer-science/software-engineering/Agile.html

- Git vs GitHub vs GitLab Flow
    https://gyoogle.dev/blog/github/Git%20vs%20GitHub%20vs%20GitLab%20Flow.html

- 서비스 장애, 예측할 수 있을까? (이벤트 패턴 탐지를 통한 장애 사전 감지 기술)
    https://medium.com/naver-cloud-platform/nbp-%EA%B8%B0%EC%88%A0-%EA%B2%BD%ED%97%98-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%9E%A5%EC%95%A0-%EC%98%88%EC%B8%A1%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%8C%A8%ED%84%B4-%ED%83%90%EC%A7%80%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%9E%A5%EC%95%A0-%EC%82%AC%EC%A0%84-%EA%B0%90%EC%A7%80-%EA%B8%B0%EC%88%A0-146eb97a6045

******* 네이버 메인 페이지의 트래픽 처리
    https://d2.naver.com/helloworld/6070967

******* 하나의 메모리 누수를 잡기까지
    https://d2.naver.com/helloworld/1326256

- maven vs gradle
    https://www.youtube.com/watch?v=3Jp9kGDb01g&t=7s

- 소나큐브
    https://joypinkgom.tistory.com/20

