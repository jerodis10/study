- [네이밍 컨벤션] 함수 이름 get vs find
    - get을 사용하는 경우
        - 데이터를 가져오는 시간이 짧다.
        - 로직이 간단하다.
        - 데이터를 가져오는데 오류가 발생하지 않는다.

        ex) function getUser() {};
            function getEmail() {};

    - find를 사용하는 경우
        - 검색 프로세스나 연산 알고리즘을 사용하며, 데이터를 가져오는데 걸리는 시간이 좀 더 길다.
        - 로직이 복잡하다.
        - 데이터를 가져오는데 오류가 발생한다.

        ex) function findUserFromDB() {};
            function findUserByEmail() {};
            function findPostOrderByDate() {};


- System.out.println 메소드는 현업에서 절대 쓰지 말라고하는 메소드인데요. 그 이유가 무엇일까요?
    - 휘발된다.
        - System.out.println() 은 로그가 표준 출력으로 출력된다. 즉, 파일로 저장되지 않고 휘발된다는 의미이다.
          로그는 에러가 발생한 상황을 기록하고, 추후 확인하여 문제를 진단하고, 재현하고, 고치기 위해 사용된다.
          하지만 표준 출력으로 한번 출력되고 어디에도 저장되지 않으면 로그의 제 역할을 할 수 없다.

    - 에러 발생 시 추적할 수 있는 최소한의 정보가 남지 않는다.
        - System.out.println() 은 인자로 전달한 문자열만을 출력한다.
          문제가 발생한 날짜, 시각 그리고 문제의 수준, 로그가 발생한 위치 등 최소한의 정보가 기록되지 않는다는 것 이다.

    - 로그 출력 레벨을 사용할 수 없다.
        - 로컬에서 개발할 때에는 디버깅을 위한 아주 상세한 정보가 출력되어 확인할 수 있어야한다. 하지만, 프로덕션에서 동작하는 코드는
          에러/장애가 발생할 때 문제를 진단할 수 있는 정보만을 남겨야한다. 개발시에만 사용되는 정보와 문제 상황에 대한 정보가
          함께 로깅된다면 문제 해결을 위한 정작 중요한 정보를 얻기 힘들 뿐더러, 민감한 정보를 로그로 남길수도 있기 때문이다.
          또한 의미없는 로그가 쌓여 서버 용량을 차지할 수도 있다.
        - 따라서 로깅 라이브러리는 환경에 맞게(로컬 개발 환경, 개발 서버, 프로덕션 서버 등) 로그가 출력될 수 있도록 로그 출력 레벨이라는
          기능을 제공한다. 많이 사용되는 Logback 이라는 라이브러리에서는 TRACE, DEBUG, INFO, WARN, ERROR, FATAL 와
          같은 레벨을 제공한다. 하지만 System.out.println() 은 이런 기능을 제공하지 않는다. 어떤 환경에서든 동일한 로그가 출력된다.
          프로덕션에서 이런 로그를 제거하려면 코드를 일일히 제거하거나 주석처리하거나 별도의 조건문을 설정하는 등 번거로운 일들을 해야한다.

    - 성능저하의 원인이 될 수 있다.
        1. Synchronized
            - System.out.println() 의 구현을 한번 살펴보자.
            - println() 은 newLine() 을 호출한다. newLine() 의 구현도 살펴보자.
            - synchronized 키워드가 붙어있다. 이때 newLine() 메소드는 임계영역(critical section)이 된다. 멀티 쓰레드 환경에서
              A 쓰레드가 newLine() 메소드를 실행하면, 메소드는 잠기게 된다. 다른 쓰레드는 A 쓰레드가 모두 사용하고 잠금을 풀어준 뒤에서야
              newLine() 메소드를 실행할 수 있다. 오버헤드가 발생하게 되는 것이다.
            - 스프링을 실행하는 톰캣은 멀티 쓰레드로 동작한다. 요청이 오면 쓰레드 풀에서 쓰레드를 하나 가져와 요청을 처리한다. 그런데,
              System.out.println() 을 여러 쓰레드가 사용하면 그만큼 위에서 이야기한 오버헤드가 발생하고 처리가 느려질 것 이다.
              따라서 실제 프로덕트의 코드에서는 System.out.println() 을 절대 사용해서는 안된다.
            - 동기화는 멀티쓰레드를 운용하는 환경에서 데이터의 정합성을 유지시켜주어 프로그램의 안정성을 유지시켜주는 역할을 해주지만
              서비스를 안정적으로 유지시켜주는 것과는 관련이 없는 Log를 찍어주는 작업에는 불필요합니다.

    - 로그 사용시 장점
          1. 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
          2. 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 로그를 상황에
             맞게 조절할 수 있다.
          3. 시스템 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.
          4. 특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
          5. 성능도 일반 시스템 콘솔보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등)

    - synchronized 키워드는 왜 현업에서 큰 성능 저하를 일으킬 수 있을까요?
      Blocking IO는 왜 성능을 저하시킬 수 있을까요?
      synchronized 가 Blocking IO 와 만나면 어떻게 환장의 성능하락을 만들 수 있는걸까요?
      이 두 개가 만났을 때 스레드가 어떻게 동작할지, CPU 사용률은 어떻게 될지 시뮬레이션을 해보세요.

    - 올바른 로그 사용법
        // 틀린 예)
        log.trace("trace log=" + name);

        // 옳은 예)
        log.trace("trace log={}", name);

        첫번째와 같은 방식으로 trace 를 출력할 경우 로그 출력 자체에는 문제가 없다.
        하지만 자바 문법상 "trace log="+ name 이라는 문자열 더하기 연산이 먼저 일어난 후 log 레벨을 확인하기 때문에 만약 해당 프로젝트의
        log 레벨 설정이 debug 일 경우 trace 는 debug 이하의 log 레벨이므로 출력은 하지 않지만 이미 불필요한 연산 자체가 일어난 경우가 되어 버린다.
        두번째 방식은 SLF4J 치환문자를 사용하는 방식이다.
        문자열에 중괄호를 넣어 순서대로 출력하고자 하는 데이터들을 ' , '로 구분한 후 전달하여 치환해주는 방식으로 불필요한 연산이 발생하지 않도록 한다.


- 빌드와 배포
    - 컴파일
        - 소스 코드를 기계가 읽을 수 있는 바이너리 코드로 변경하는 과정
        - 소스 코드 분석 및 문법 오류 분석이 이루어진다.
        - JVM: Java Byte Code 를 OS 에 맞게 실행. 자바의 높은 이식성에 큰 영향을 주게 됨.
          결과물로 .class

    - 빌드
        - 소스 코드를 실행 가능한 독립적인 소프트웨어 산출물로 만드는 과정

        1. 컴파일: 소스코드를 바이너리 코드로
        2. 링크: 클래스 파일들끼리 연결 (외부 라이브러리 포함)
        3. 패키징: 연결된 클래스 및 리소스 파일 묶어주기
        4. 테스트: 기능 테스트
        -> 독립적인 소프트웨어 산출물로 묶어줌 (JAR, WAR)
            - JAR (Java Archive): 자바에서 사용되는 압축 양식, 클래스 + 리소스 파일로 구성
            - WAR (Web Archive): 웹 어플리케이션을 압축하고 배포하는데 사용되는 파일 형태
                                 JAR 에 비해 자바 서블릿, XML 파일, 정적 파일 등 필요한 자원이 더 많다.

    - 빌드 툴
        - Ant
            - XML 형식으로 작성
            - 자유도가 높음
            - 절차적으로 작성이 됨
            - 스크립트 직접적으로 명시, 다양한 Task 가능
            - 스크립트 재사용 불가능
            - 복잡해질수록 구조 및 스크립트 파악이 힘듬
        - Maven
            - pom.xml 형식으로 작성
            - 전체적인 프로젝트 관리 가능
            - 편리한 의존성 관리 및 다운로드 가능
            - 표준화된 빌드 스크립트
            - Lib 가 존재하여 빌드 속도가 빨라짐
            - 지원하지 않는 복잡한 빌드 과정 추가 시에 난이도 상승
            - pom.xml 관리가 까다로워짐
            - Repository 관리 불편함
        - Gradle
            - Ant 의 장점과 Maven 의 장점을 모아 Gradle 이 만들어짐
            - JVM 위에서 동작하는 Groovy 기반으로 작성
            - 자바 문법과 유사하여 익히기가 쉬움
            - Maven 의 세팅 및 중앙 저장소를 활용 가능
            - 프로젝트를 설정 주입식으로 정의, 재사용이 용이
            - Wrapper 를 활용하여 Gradle 이 설치되어 있지 않아도 사용 가능
            - Maven 에 비해 커뮤니티 크기가 작음

            - src: 자바 소스 파일
            - .gradle: gradle 버전 및 설정 파일
            - settings.gradle: 프로젝트 정보 설정
                - 프로젝트 빌드 정보 설정은 보통 하나지만, 멀티 프로젝트 빌드 시에 프로젝트 정의 가능. 하위 프로젝트들이 어떻게 구성되어 있는지를 기록
            - build.gradle: 프로젝트 빌드에 대한 정의
            - gradlew, gradlew.bat: 작동될 gradle 명령 파일들
                - gradle wrapper 의 약자로, gradle 이 설치되어 있지 않아도, 빌드할 수 있게 하는 역할
                  자바의 특성은 다양한 운영체제에서 작동하는 것인데, gradle 도 동일

    - 배포
        - 사용자가 사용할 수 있도록 소프트웨어를 제공하는 과정

    - CI/CD
        - 협업 시 문제점
            - 마지막에 프로젝트 합칠 시에 Integration Hell 발생
            - 중간 중간 프로젝트 합칠 시에 지속적으로 시간 소모 (빌드, 테스트)
        -> 이런 문제들을 해결하기 위해서 만든 것이 CI

        - CI (Continuous Integration)
            - 지속적 통합이라고도 하며, 코드 변경사항마다 빌드, 테스트까지 자동으로 진행하고 결과물을 보고 받고
              리포지토리에 자동 통합되는 프로세스

            - 변경 사항이 클래스, 기능 더 나아가 전체 어플리케이션에서의 테스트를 수월하게 수행
            - 신규 코드와 기존 코드의 충돌을 빠르게 수정 가능
            - 협업 시에 어플리케이션이 최신 상태로 유지됨을 믿을 수 있음

            - CI Tools
                - Travis
                    - Github 와 연계가 매우 좋다
                    - 클라우드 기반으로 서버 없이 작동 가능
                    - yml 형식을 통하여 쉽게 설정 가능
                    - 모든 작업들이 독립적
                    - 유료 서비스
                    - 상대적으로 부조간 플러그인
                - Jenkins
                    - 다양한 IDE 를 지원
                    - 호스팅을 직접 하기 때문에 커스터마이징 가능
                    - 가장 커뮤니티가 크기 문에 문서가 다양
                    - 중구난방 플러그인 때문에 파편화된 세팅
                    - 규모가 작아도 서버를 운영해야 함
                    - 서버 운영 비용 발생

        - CD (Continuous Deployment)
            - 개발자들이 코드에 변경 사항을 줄 경우, 파이프 라인을 통해 이동하여 프로적션 단계까지 자동으로 배포되는 프로세슨

            - 어플리케이션을 프로덕션으로 빠르고 쉽게 배포
            - 소비자들의 요구를 빠르게 만족시키는 서비스 출시가 가능
            - 개발팀과 운영팀의 간극을 메워줄 생산성 향상

        -> 운영, 모니터링 그리고 문제점이나 새로운 기능들을 다음 기능 기획에 반영? => DevOps
        - DevOps
            - Development 와 Operation 을 결합한 단어
            - 개발과 운영이 연계하여 협력하여 서비스를 이끌어 나가는 방법론

- api/라이브러리/프레임워크
    - api (Application Programming Interface)
        - 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
        - 구현과 독립적으로 사양만 정의되어 있다.
        - API 에 따라 접근 권한이 필요할 수 있다.
        - 구현과는 독립적으로 다양한 컴포넌트 간에 정보를 주고 받기 위한 규약
        ex) Java API, 여러 기업들의 오픈 API

    - Library
        - 응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어
        - 독립성을 가진다.
        - 응용 프로그램이 능동적으로 라이브러리를 사용한다.
        - 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임. 개발자가 응용 프로그램 흐름의 제어권을 가짐
        ex) Apache Commons, Guava, Lombok, jQuery

    - Framework
        - 응용 프로그램이나 소프트웨어의 솔류션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경
        - 상호협력하는 클래스와 인터페이스의 집합
        - 응용 프로그램이 수동적으로 프레임워크에 의해 사용된다. (프레임워크가 응용 프로그램 흐름의 제어권을 가짐)
        ex) Spring Framework, Junit, Ruby on Rails

    -> Library 와 API 의 차이점은 구현 로직의 유무이다.
       Library 와 Framework 의 차이점은 응용 프로그램의 흐름 주도권을 누가 가지고 있느냐 이다.

- CSR/SSR
    - SPA: Single Page Application, 하나의 페이지로 구성된 웹 어플리케이션
      웹 어플리케이션에 필요한 정적 리소스를 초반 한 번에 모두 다운로드 하고 그 이후 새로운 페이지 요청이 있을 때 페이지 갱신에 필요한
      데이터만 전달받아서 클라이언트에서 페이지를 갱신하기 때문에 자연스럽게 렌더링 방식으로 CSR 을 사용
    - MPA: Multi Page Application, 탭을 이동할 때마다 서버로부터 새로운 html 을 받아와서 페이지 전체를 새로 렌더링
      새로운 요청이 있을 때마다 서버에서 이미 렌더링된 정적 리소스를 받아오기 때문에 렌더링 방식으로 SSR 을 사용
    - SPA -> CSR,  MPA -> SSR

    - CSR: Client Side Rendering
    - SSR: Server Side Rendering
    - SSG: Static Site Generation (Static Rendering)
        - 서버에서 html 을 보내준다는 측면에서 SSR 과 비슷하지만 언제 만들어 주느냐에 차이
        - SSR 은 요청 시 서버에서 즉시 html 을 만들어서 응답하기 때문에 데이터가 달라지거나 자주 바뀌어서 미리 만들어 두기 어려운 페이지에 적합
        - SSG 는 페이지들을 서버에 모두 만들어둔 뒤에 요청시에 해당 페이지를 응답하는 것이므로 바뀔 일이 거의 없는 캐싱 해두면 좋은 페이지에 적합


    - CSR 의 동작 과정과 특징
        - 동작 과정
            - 유저가 웹사이트에 방문하면 브라우저가 서버에 콘텐츠를 요청하고 서버는 빈 뼈대만 있는 html 을 응답으로 보내준다.
              브라우저가 연결된 JS 링크를 통해 서버로부터 다시 JS 파일을 다운로드 받고 JS 를 이용해 동적 페이지를 만들어서 브라우저에 띄어줌
        - 특징
            - CSR 은 브라우저가 JS 파일을 다운로드 받고 동적으로 DOM 을 생성하는 시간을 기다려야 하기 때문에 초기 로딩 속도가 느리다.
              하지만 초기 로딩 이후에 페이지 일부를 변경할 때는 서버에 해당 데이터만 요청하면 되기 때문에 이후 구동 속도는 빠르다.
            - 서버가 빈 뼈대만 있는 html 을 넘겨주는 역할만 수행하면 되기 때문에 서버측에 부하가 적다.
              클라이언트측에서 연산, 라우팅 등을 모두 직접 처리하기 때문에 반응 속도가 빠르고 UX 도 우수하다.
            - 브라우저들이 가지는 웹 크롤러는 html 을 읽어서 검색 가능한 색인을 만들어냄. 웹 크롤러 봇 입장에서 본 html 은 텅텅 비어있다.
              검색엔진이 색인을 할만한 콘텐츠가 존재하지 않는다. -> 검색엔진 최적화에 불리하다는 치명적인 단점 존재
               (구글의 크롤러 봇은 자바스크립트를 실행할 줄 안다. CSR 웹 크롤링도 가능)
            - 화면 깜빡임이 없고 서버 부하가 클라이언트로 분산된다.

    - SSR 의 동작 과정과 특징
        - 동작 과정
            - 유저가 웹사이트에 방문하면 브라우저에서 서버로 콘텐츠를 요청한다. 서버에서는 즉시 페이지에 필요한 데이터를 얻어와 모두 삽입하고
              css 까지 모두 적용해서 렌더링 준비를 마친 html 과 JS 코드를 브라우저에 응답으로 전달.
              브라우저에서는 바로 전달 받은 페이지를 띄운다. 이어 브라우저가 JS 코드를 다운로드하고 html 에 JS 로직을 연결한다.
        - 특징
            - 모든 데이터가 이미 html 에 담겨진채로 브라우저에 전달되기 때문에 검색엔진 최적화에 유리하다. JS 를 실행할 줄 모르는
              크롤러 봇도 무리없이 html 을 읽을 수 있다.
            - 자바스크립트 코드를 다운로드 받고 실행하기 전에 사용자가 화면을 볼 수 있다. JS 다운로드를 기다려야 했던 CSR 보다
              초기 구동 속도가 빠르다. 하지만 이 시점에는 사용자가 버튼을 클릭하거나 이동하려고 해도 아무런 반응이 없을 수 있다.
              인터랙션 가능한 페이지처럼 보이지만 그저 내용과 스타일이 입혀진 껍데기에 불과하고 실제로 클라이언트 측 JS 가 실행되고
              이벤트 핸들러가 첨부되어서 JS 로직이 모두 연결될 때까지 사용자 입력에 응답할 수 없기 때문이다.
              -> TTV(Time To View) 와 TTI(Time To Interact) 간에 시간 간격이 존재한다는 단점 존재
              -> 반면 CSR 은 JS 가 동적으로 DOM 을 생성하기 때문에 html 은 JS 로직이 모두 완전히 연결된 상태라 사용자가 보는 시점과
                 이용할 수 있느 시점이 동일하다.
            - 화면 깜빡임이 있고 매 페이지 로딩시마다 서버에 요청하므로 서버 부하가 있다.

    - CSR 단점 보완
        - 초기 로딩 속도 보완
            - code splitting, tree-shaking, chunk 분리 -> JS 번들 크기를 줄여서 초기 DOM 생성 속도를 줄이는 것
        - SEO 개선
            - pre-rendering -> 라이브러리나 웹팩 플러그인을 통해 각 페이지에 대한 html 파일을 미리 생성해둔 뒤 서버에서 요청하는 자가
              만약 크롤러라면 사전에 렌더링된 html 버전 페이지를 보여주는 방식을 통해 개선

        - SSR, SSG 도입
            - with 프레임워크
                - CSR 에 비해 코드 복잡도가 올라가고, 직접 제어할 수 없는 블랙박스 영역 존재
                ex) next.js, gatsby, nuxt.js, 앵귤러 유니버셜

        - CSR + SSR
            - 초기 렌더링 벙식으로 SSR 을 사용하고 그 이후에는 CSR 을 사용하는 앱이나 그 렌더링 방식
            - Isomorphic App: 서버와 클라이언트에서 동일한 코드가 동작하는 어플리케이션. 서버와 클라이언트가 모두 같은 코드로
              돌아가기 때문에 예상과는 다른 결과를 마주할 가능성도 있지만, 초기 로딩 속도와 SEO 를 해결하면서도 CSR 의 장점을
              그대로 가져갈 수 있는 좋은 대안이기 때문에 최근 많이 사용되고 있는 추세.
            - Universal Rendering

    - 무엇을 써야할까?
        - CSR
            사용자와의 상호 작용이 많고 대부분 페이지가 고객의 개인정보 데이터를 기준으로 구성되는 서비스라면 검색포털 상위 노출 되는 것보다
            오히려 고객의 데이터를 보호하는 것이 더 중요.
        - SSR
            만약 회사 홈페이지이기 때문에 상위 노출되어야 하고 누구에거나 동일한 내용을 노출하고 있다면, 그 페이지 데이터가 자주 바뀐다면
        - SSG
            만약 회사 홈페이지이기 때문에 상위 노출되어야 하고 누구에거나 동일한 내용을 노출하고 있다면, 내용을 업데이트 하는 일이 거의 없다면
        - CSR + SSR -> 유니버셜 렌더링
            만약 사용자에 따라 페이지 내용도 달라지고 빠른 인터랙션도 중요하고 검색엔진 최적화도 포기할 수 없다면


- TDD(Test-Driven-Development)의 개념에 대해 설명해주세요.
    - TDD란 작은 단위의 테스트 케이스를 작성하고 그에 맞는 코드를 작성하여 테스트를 통과한 후에
      상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 말합니다.

    - 이렇게 반복적인 단계가 진행되면서 자연스럽게 코드의 버그가 줄어들고, 코드는 간결해진다는 장점이 있습니다.


- 테스트 코드를 작성 해야하는 이유에 대해 아는대로 설명해주세요.
    1. 기능의 추가, 변경, 삭제로 인한 영향도를 쉽게 파악 가능
    2. 예상하지 못한 오류에 대한 피드백을 위해
    3. 좋은 설계로 작성되게끔 코드를 유도
    4. 기능 정의의 문서의 역할
    5. 실수를 줄여준다.


- DDD(Domain-Driven-Design)에서 얘기하는 계층과 각각의 역할에 대해 설명해 주세요.
    - 도메인은 서로 철저히 분리되고, 높은 응집력과 낮은 결합도로 변경과 확장에 용이한 설계
    - Layered Architecture의 주된 목표는 각각의 layer는 하나의 관심사에만 집중할 수 있도록 하는 것

    - Layered Architecture를 올바르게 구현하기 위한 두 가지 중요한 규칙이 있다.
        1. 위의 계층에서 아래 계층에는 접근이 가능하지만 아래에서 위로는 불가능한 것을 기본으로 한다.
        2. 한 계층의 관심사와 관련된 어떤 것도 다른 계층에 배치되어서는 안된다.

    - 계층
        - 표현 계층(Presentation layer) : 사용자의 요청에 대해 해석하고 응답하는 일을 책임지는 계층 (Controller)
            - Client로부터 request를 받고 response를 return 하는 API 정의

        - 응용 계층(Application layer) : 비즈니스 로직을 정의하고 정상적으로 수행될 수 있도록 도메인 계층과 인프라스트럭처 계층을 연결해주는 역할을 하는 계층 (Service)
            - transaction 관리, DTO 변환, 모듈간의 연계를 진행

        - 도메인 계층(Domain layer) : 비즈니스 규칙, 정보에 대한 실질적인 도메인에 대한 정보를 가지고 있으며 이 모든것을 책임지는 계층 (Entity)
            - 업무 상황을 반영하여 상태를 제어하는 역할에 집중하는 계층

        - 인프라스트럭처 계층(Infrastructure layer) : 외부와의 통신(ORM, DB, NoSQL)을 담당하는 계층 (Repository)
            - 해당 계층에서 얻어온 정보를 응용 계층 또는 도메인 계층에 전달하는 것을 주 역할로 담당

    - 장점
        - 핵심 비즈니스 로직을 순수하게 유지함으로써 유지보수와 확장성 측면에서 이득을 얻을 수 있다.
        - 각 레이어에 서로 다른 추상화 수준을 가진 상태와 행동을 위치시킴으로써 코드 재사용성을 높일 수 있다.

    - 단점
        - 레이어로 분리된 관심사 외에 다른 관심사가 생길 경우 패키지 분리 및 코드 배치가 어렵다.


- MSA(Microservice Architecture)가 뭔지 설명해주세요.
    - MSA는 1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할합니다. 각각의 서비스는 API를 통해 데이터를 주고 받으며 1개의 큰 서비스를 구성합니다.
    - 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장하게 되었습니다.

    - 장점
        - 일부 서비스에 장애가 발생해도 전체 서비스에 영향을 끼치지 않는다.
        - 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다.
        - 서비스의 확장이 용이하다.
    - 단점
        - 서비스가 분리되어 있어 테스트나 트랜잭션 처리 등이 어렵다.
        - 서비스 간에 API로 통신하기 때문에 그에 대한 비용이 발생한다.
        - 서비스 간의 호출이 연속적이기 때문에 디버깅 및 에러 트레이싱이 어렵다.


- 프레임워크와 라이브러리의 차이점
    - Framework(프레임워크)
        - Application 개발 시 필수적인 코드, 알고리즘, 데이터베이스 연동 등과 같은 기능들을 위해 어느정도 뼈대(구조)를 제공해주는 것
        - 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합

    - Library(라이브러리)
        - 프로그래머가 개발하는데 필요한 것들을 모아둔 것

    - Framework와 Library의 차이는 Flow(흐름)에 대한 제어 권한이 어디에 있느냐의 차이
    - 프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며, 프로그래머가 그 안에 필요한 코드를 작성하는
      반면에 라이브러리는 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것입니다.
      프레임워크에는 제어의 역전(Inversion Of Control)이 적용되어있다는 것

    - API란
        - 필요한 부분을 요청하여 응답을 받는 서비스간의 다리와 같은 역할
        - 구현과 독립적으로 사양만 정의 되어있음


- Lombok 라이브러리에 대해 알고 있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는 시점은 언제인가요?
    - Lombok은 메소드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어냅니다. 이것을 어노테이션 프로세싱
      (Lombok 라이브러리를 추가할 때 CompileOnly, AnnotationProcessor를 추가하는 이유도 된다.)


- 스케일 업(Scale-Up)과 스케일 아웃(Scale-Out)이란
    - 스케일 업(Scale-Up)
        - 기존 서버의 사양을 업그레이드해 시스템을 확장하는 것
        - CPU나 RAM 등을 추가하거나 고성능의 부품, 서버로 교환하는 방법
        - 수직 확장이며, 성능 확장에 한계가 있음
        - 성능 증가에 따른 비용 증가폭이 큼
        - 한 대의 서버에 부하가 집중되어 장애 영향도가 큼

    - 스케일 아웃(Scale-Out)
        - 서버를 여러 대 추가하여 시스템을 확장하는 것
        - 서버가 여러 대로 나뉘기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 '로드밸런싱'이 필수적으로 동반되어야 한다.
        - 수평 확장이며, 지속적 확장 가능
        - 비교적 저렴한 서버 사용으로 비용 부담이 적음
        - 읽기/쓰기가 여러 대의 서버에서 분산처리.
          장애 시 전면 장애의 가능성이 적음


- git branch 전략
    - branch 전략이란?
        - 여러 명의 개발자가 1개의 저장소를 사용하는 환경에서 효과적으로 사용하기 위해 나온 개념
        - 대표적인 전략
            - GitHub flow
            - git flow
            - gitLab flow

    - GitHub flow 란?
        - GitHub 에서 만든 단순한 구조의 브랜치 전략
        - Master 브랜치를 중심으로 운영되며 기능 개발, 버그 수정 등의 작업용 브랜치를 구분하지 않는 단순한 구조
        - 수시로 배포가 일어나는 프로젝트에 유용

        1. 브랜치 생성
            - Master 로부터 기능 추가, 버그 수정 작업을 위한 새로운 브랜치를 생성
        2. 기능 개발, 버그 수정
            - 작업을 하며, 기능별로 commit 을 한다.
            - commit 메시지와 브랜치 이름은 정확하고 간결하게 작성
            - commit 은 서버의 동일한 브랜치에 push 해줘야 한다. (Git flow 와 차이점)
        3. Pull Request 생성
        4. 리뷰와 논의
        5. 공개 및 테스트
            - GitHub 에서는 master 에 합치기 전에 브랜치에서 코드를 공개 및 테스트 할 수 있다.
            - 오류가 발생할 경우 원래의 master 브랜치를 다시 배포하여 rollback 한다.
        6. Merge
            - 브랜치의 검증이 완료되면 master 브랜치에 합친다.
            - 이로써 GitHub flow 의 브랜치의 생명주기가 끝난다.

    - Git flow 란
        - 많은 기업에서 표준으로 사용하고 있는 대표적인 Git branch 전략
        - GitHub flow 와는 다르게 크게 5개의 브랜치를 운영하며 관리한다.
            - 메인 브랜치: master, develop
            - 보조 브랜치: feature, release, hotfix
        - 배포 주기가 길고 팀의 여력이 있는 경우 적합

        - 메인 브랜치의 특징
            - master, develop 두 개의 브랜치는 항상 남아있는다.
            - master 브랜치는 제품으로 배포할 수 있는 브랜치
            - develop 브랜치는 개발자들이 개발을 하는 브랜치

        - 보조 브랜치의 특징
            - 사용을 마치면 브랜치를 삭제한다.
            - feature: 기능 구현
              release: QA 진행
              hotfix: 버그의 빠른 수정

            - Feature 브랜치
                - 다음 버전을 위한 특정 기능 개발을 할 때는 develop 브랜치에서 직접 개발을 하는 것이 아닌
                  develop 으로부터 feature 브랜치를 생성하여 개발을 진행.
                  feature 브랜치에서 개발을 완료한 후에는 develop 으로 merge 한 후 브랜치를 삭제

                - 만약 feature 브랜치에서 개발한 후 merge 를 진행할 때 develop 과 conflict 되는 내용이 있으면
                  develop 으로부터 변경 내용을 불러와 수정을 한 후 merge 를 진행

                - 브랜치들 간의 merge 를 할 때는 --no-ff 옵션을 사용하여 다른 브랜치에서 merge 를 했다는 이력을 남겨주는 것을 권장
                  fast-forward 관계에 있어도 merge commit 을 생성하여 해당 브랜치가 존재하였다는 정보를 남길 수 있다.
                  코드 내에 오류가 발생했을 때, 개발한 기능을 제거하려고 할 때 commit 을 되돌리기 편해진다.
                  --no-ff 을 사용하지 않으면 브랜치의 존재 여부를 몰라 어떤 commit 부터 해당 기능을 구현했는지 확인하기 어렵다.
                  또한, 브랜치가 fast-forward 관계에 있을 때 develop 입장에서는 feature 의 commit 기록들을 동일하게 가져와도 문제가
                  없다고 판단하여 브랜치의 참조 값만 변경하여 merge commit 을 생성하지 않는다.
                  만약 이런 방식으로 commit 기록들이 나오면 어떤 특정 feature 와 관련된 commit 이 어디서부터 해당하는지 확인이 힘들다.

            - Release 브랜치
                - 프로덕션에 다음 버전 출시를 준비하기 위한 브랜치
                - develop 브랜치에서 개발이 완료된 코드를 master 로 merge 하기 이전에 QA 테스트 진행
                - QA 를 진행하기 위해 develop 으로부터 release 브랜치를 생성하여 해당 브랜치에서 QA 진행
                - 만약 오류가 발견된면 해당 브랜치 내에서 수정을 하고 QA 가 끝나고 배포할 준비가 완료되었다고 판단되면
                  release 브랜치를 master 브랜치와 develop 브랜치에 merge 하고 release 브랜치를 삭제
                - 이 때 develop 브랜치에 merge 할 때 그 사이에 develop 내에 추가적인 개발 상황이 있어 충돌이 발생할 수도 있다.
                - 이러한 경우 해당 내용을 수정하고 다시 merge 하는 방식으로 진행
                - merge 할 때 --no-ff 를 사용하여 기록을 그룹화
                - master 로 merge 후에는 tag 명령을 통해 버전을 명시

            - Hotfix 브랜치
                - production 에 버그가 발생하면 빠른 수정을 위해 생성하는 브랜치
                - master 에 올라가 실제 필드에 나가 있는 코드에서 오류가 발생한다면 긴급하게 hotfix 브랜치를 생성하여 오류를 수정한 후
                  변경사항을 master 에 merge 하여 오류를 수정
                - 이 때 발생한 오류들은 develop 과 release 로부터 거르지 못한 오류이기 때문에 현재 브랜치의 코드에도 반영을 해줘야 한다.
                - production 코드를 수정하는 중에도 develop 에서는 계속 개발을 할 수 있다는 장점
                - master 로 merge 후에는 tag 명령을 통해 이전 버전보다 높은 버전 명시

        - 무슨 전략을 사용해야 할까?
            - 팀의 브랜칭 전략은 조직의 규모, 서비스의 특징 등을 고려하여 협의를 통해 전략을 결정해야 한다.
            - production 의 공식 배포 주기가 길고 QA, 테스트, hotfix 등의 여력이 있으면 Git flow 가 적합
            - 지속적으로 테스트 및 배포를 하는 팀의 경우 간단한 GitHub flow 를 사용하는 것이 적합


- api 개발시 중요하게 여기는 것   https://www.holaxprogramming.com/2015/01/01/devops-api-design/
    - API가 우선적으로 필요한 전제는 기능에 대한 요구사항을 충족해야 한다는 것
    - 여기에 사용자에게 좋은 API를 제공하기 위해 고려해야 점
        - 잘못 사용하기 어려울 것. 만약 사용자가 API의 의도대로 움직이지 않는다면 쉽게 어떤 부분이 잘못 되었는지 알려줄 수 있어야 한다. (에러 처리)
        - 많은 실수에 미리 노출 될 수 있도록해라. 테스트 코드를 많이 만들고 안정적인 버전이 배포되기 까지는 많은 사용자에게 노출시키는 것이 좋다.
          실수를 통해 API를 발전되어 간다.
        - API의 이름은 매우 중요하다. 프로그래밍 언어에 맞는 Convention을 지키고 일관적으로 API의 이름을 짓도록 한다.
        - private 키워드를 통해 불필요한 클래스나 메소드가 사용자에게 노출되지 않도록 한다. 이것은 사용자를 혼란스럽게 만든다.


- TDD에 대해 아는지


- 리팩토링을 하는 경우 우선 고려할 점은    https://ikkison.tistory.com/82  https://nesoy.github.io/articles/2018-05/Refactoring
    - 리팩토링이란?
        - 가독성, 유지보수성
            - 기능을 유지하되 읽기 좋고 지속적으로 관리하기 편하게 소스코드를 재작성하는 것
            - 성능 최적화는 다른 문제

        - 사람, 협업
            - 내가 진행하는 프로젝트 중간에 참여하거나, 인수인계가 어려운 경우가 있다.
            - 이해하기 쉬운 코드를 작성하는 것이 중요

    - 목적
        - 보다 이해하기 쉽고, 수정하기 쉽도록 만드는 것
        - 겉으로 보이는 소프트웨어의 기능을 변경하지 않는다는 것

    - 리팩토링은 언제 할까?
        - 유사한 내용이 세번 이상 반복할 때
        - 새로운 기능을 추가할 때
            - 지금 작성된 설계, 소스코드에서 새로운 기능을 추가하기 어려워 보이면 리팩토링을 해야 한다.
              이러한 상황인 경우 유지보수성이 떨어지며, 가독성 역시 좋지 않을 가능성이 높다.
        - 코드리뷰를 할 때 (스프린트를 진행하면서)


- JUnit이란
    JUnit이란 java의 단위테스트를 위한 프레임워크를 말합니다. 객체의 인스턴스를 생성하여 로직 수행후 결과값이 기대값과 일치하는지 비교하거나
    파일이나 네트워크 상의 연결이나 데이터베이스 연동 테스트 등을 수행할 수 있습니다


- mock
    - 실제 객체를 만들어 사용하기에 시간, 비용 등의 Cost가 높거나 혹은 객체 서로간의 의존성이 강해 구현하기 힘들 경우 가짜 객체를 만들어 사용하는 방법이다.
    - 언제사용하는가?
        - 테스트 작성을 위한 환경 구축이 어려운 경우
        - 테스트가 특정 경우나 순간에 의존적인 경우
        - 테스트 시간이 오래 걸리는 경우
        - 개인 PC의 성능이나 서버의 성능문제로 오래 걸릴수 있는 경우 시간을 단축하기 위해 사용한다.


- Mockito
    - java mock framework


- @Spy와 @Mock의 차이
    - 둘의 가장 큰 차이점은 @Spy는 실제 인스턴스를 사용해서 mocking을 하고, @Mock은 실제 인스턴스 없이 가상의 mock 인스턴스를 직접 만들어 사용한다는 것이다.
    - 그래서 @Spy는 Mockito.when() 이나 BDDMockito.given() 메서드 등으로 메서드의 행위를 지정해 주지 않으면
    - @Spy 객체를 만들 때 사용한 실제 인스턴스의 메서드를 호출한다.


- 테스트의 종류
    - 단위 테스트
        - 가장 작은 단위의 테스트이다
        - 보통 메서드 레벨이다
        - A라는 함수가 실행되면 B라는 결과가 나온다 정도로 테스트한다
        - 즉각적인 피드백이 나온다는 것이 훌륭한 장점이다

    - 통합 테스트
        - 테스트 대상이 되는 모듈을 호출하여 준비한 테스트 데이터를 제공하고 모듈의 실행 결과를 받는 모듈
        - 일반적으로 상향식 테스트에서 아직 통합되지 않은 상위 컴포넌트의 동작을 시뮬레이션 하기 위해 사용.


- 효율적으로 로그 모니터링하기 - 로그 레벨 구분하기
    https://jojoldu.tistory.com/712

- 테스크 코드 커버리지는 어떤 기준으로 측정하는지? private 메서드는 테스트하는지?

- 대량용 요청을 고려한 api를 개발한다면?

- 테스트 코드 작성시 실행시키는 속도가 느릴텐데 어떤방법이 있을까

- 순간에 많은 트래픽이 발생하면 대처방안 (sql튜님말고 , 로드밸런싱말고)

- 상글톤 패턴은 안티패턴인가?

- maven vs gradle