- 테스트
    - Rest-assured 와 Spring MVC Test Integration 을 이용해서 HTTP API 를 통합 테스트

    유지보수 기간의 생산성을 높여주고 새로 프로젝트에 투입될 사람에게도 이득을 주는 테스트
    프로젝트 오픈 일정 직전까지의 코드 변경과 버그 발견에 도움을 주는 테스트
    오늘 당장 프로그램을 목표한 곳까지 작성하는 일을 더 빨리 마치게 해주는 테스트

    실제로 테스트로 인한 긍정적인 경험을 쌓아가다 보면 더 넓은 범위와 다양한 기법으로 테스트 코드를 작성하는데 동기유발이 됩니다.

    처음에는 테스트가 쉬운 Utility 클래스에 대한 테스트부터 작성했습니다. 전에도 간단한 유틸리티에 대한 테스트는 main 메서드 안에서 하기도 했는데,
    그런 코드를 JUnit 안으로 옮기니 반복해서 실행하고 결과를 확인하기에 훨씬 편해졌습니다. 그 이후에는 Spring framework 의 통합테스트 기능을
    이용한 테스트를 작성하기 시작했습니다. 특히 테스트 코드에서 DB에 입력한 데이터를 자동으로 롤백시키는 기능이 DB와 연동된 테스트를 할 때 유용했었습니다.
    이후에 더 정교한 테스트를 하려다 보니 테스트용 객체를 만드는 프레임워크인 Mockito 를 사용하게 되었습니다. 테스트 코드를 먼저 작성하는 기법도 사용할 수 있게 되었습니다.

    - 왜 Test 코드를 작성하는가?
        - Test 코드를 작성하지 않고 결과를 검증하는 과정은 비용이 많이 든다.
            - Test 코드 사용 X
                검증 코드 작성
                애플리케이션 실행
                PostMan 혹은 브라우저 Request 요청
                log 혹은 print 로 결과 검증
                원하지 않는 결과 발생 시 애플리케이션 종료
                다시 코드 작성
            - Test 코드를 사용
                Test 코드 작성
                Test 코드 실행
                결과 검증
                Test 코드 수정
                -> 애플리케이션을 실행, 종료할 필요가 없습니다. 따라서 비용이 줄어들고, Test 코드를 통해서 명확한 결과 검증이 가능합니다.

        - 3 가지
            1. 코드를 수정하거나 기능을 추가할 때 수시로 빠르게 검증 할 수 있다.
            2. 리팩토링 시에 안정성을 확보할 수 있다.
            3. 개발 및 테스팅에 대한 시간과 비용을 절감할 수 있다.

            -> 테스트 코드를 작성하면 우리가 작성한 코드들에 대해 수시로 빠르게 검증을 받을 수 있으며, 유지보수 및 리팩토링을 할 때에도 안정성을 확보할 수 있다는 장점이 있다.
               하지만 그것보다 큰 장점으로 개발 및 테스팅에 대한 시간과 비용을 절감할 수 있다는 점에 주목해야 한다.
               우리는 개발이 끝난 뒤에 문제가 없는지 확인하기 위해 애플리케이션을 실행하고, 직접 수동 (통합) 테스트를 진행해야 한다.
               단위 테스트를 작성하지 않은 코드들은 테스트를 작성하지 않은 코드들 보다 버그가 있을 확률이 높은데, 문제는 직접 테스트 하는 비용이 너무 크다는 것이다.
               그 이유는 통합 테스트를 위해서는 캐시, 데이터베이스 등 외부 컴포넌트들과 연결 등 부가적인 시간이 필요하기 때문이다.
               테스트 코드를 작성하지 않았다면 여러 개의 버그가 잠재되어 있을 확률이 있고, 모든 버그들을 수정하고 테스트를 반복하는 비용은 기하급수적으로 늘어나게 된다.
               그러므로 우리는 개발 및 테스팅에 대한 비용을 줄이기 위해 단위 테스트를 작성해야 한다.

        - Spring 은 계층 구조로 일반적으로 아래와 같이 구성돼 있습니다.
            Controller : 클라이언트 요청을 받고 클라이언트에게 결과를 반환 (Presentation Layer)
            Service : 비즈니스 로직을 실행하고 결과 반환(Service Layer)
            Repository : database 에 쿼리를 이용해서 CRUD 를 하는 계층(Data Access Layer)
            Domain : Entity 클래스

            -> 그렇기에 애플리케이션을 실행해서 Test 를 진행한다면, 어느 계층에서 잘못된 코드가 있는지 파악하는데 많은 비용이 듭니다.
             하지만 Test 코드를 통해서 계층별로 Test 를 진행한다면 어느 부분이 잘못된 지 파악을 쉽게 할 수 있습니다.

    - SpringBoot Test
        - Spring Initializer 통해서 프로젝트를 생성하면 spring-boot-starter-test dependency 가 자동으로 추가됩니다. 저희는 이것을 이용해서 Test 코드를 작성하면 됩니다.

        - spring-boot-test-starter 구성요소
            1. spring-boot-test: 테스트에 필요한 핵심 기능 라이브러리
            2. spring-boot-test-autoconfigure: 테스트 진행 위한 Configuration 라이브러리

        - Junit 이란?
            1. Java 에서 독립된 단위 테스트를 지원해주는 프레임워크
            2. Assert(검증)을 이용해서 결과를 기댓값과 실제 값을 비교
            3. @Test 어노테이션마다 독립적으로 테스트가 진행

        - JUnit 만으로도 단위 테스트를 충분히 작성할 수 있다. 하지만 JUnit 에서 제공하는 assertEquals()와 같은 메소드는
          AssertJ가 주는 메소드에 비해 가독성이 떨어진다. 그렇기 때문에 순수 Java 애플리케이션에서 단위 테스트를 위해 JUnit5와 AssertJ 조합이 많이 사용된다.
        - @Test 는 해당 메소드가 단위 테스트임을 명시하는 어노테이션이다. JUnit 은 테스트 패키지 하위의 @Test 어노테이션이 붙은 메소드를
          단위 테스트로 인식하여 실행시킨다. 이 상태로 실행하면 테스트 이름이 함수 이름이 default 로 지정되는데, 우리는 @DisplayName 어노테이션을 사용하여 읽기 좋은 다른 이름을 부여할 수 있다.

        - 단위 테스트와 통합 테스트
            - 단위(unit) 테스트: 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위 테스트 -> 쉽게 말하면 하나의 기능 혹은 메서드라고 이해하면 됩니다.
                - 장점
                    새로운 기능에 대해서 빠르게 작성 가능
                    Test 코드 자체가 하나의 문서
                    시간과 비용의 절감
                - 단점
                    독립적인 테스트이므로 다른 객체와 상호작용 처리를 위해서 가짜 객체 정의 필요함
                    가짜 객체의 답변 작성 필요함
                    실제 운영 환경과 다른 답변을 내놓을 수 있는 가능성이 있음

            - 통합(integration) 테스트: 모듈을 통합화는 과정에서 모듈 간의 호환성을 확인하는 테스트 -> unit 이 하나였다면 반대로 여러 개의 계층이 테스트에 참여한 것이라고 생각하면 쉬울 거 같습니다.
                - 장점
                    실제 객체를 사용하므로 가짜 객체 사용하지 않아 정의하지 않아도 됨
                    실제 운영 환경과 같은 값을 도출 가능함
                - 단점
                    테스트 하나의 많은 비용이 들어감
                    어느 계층에서 발생한 문제인지 파악하기 힘듦

            -> 단위 테스트, 통합 테스트 모두 장단점이 명확합니다. 하지만 통합 테스트의 경우 비용을 절감할 수 있는 방법이 없습니다.
              단위 테스트는 단점들을 개선해 나갈 수 있습니다. 그래서 좋은 단위 테스트 작성에 대해서 알아보겠습니다.

        - 좋은 단위 테스트
            - 1개의 테스트는 1개의 기능에 대해서만 테스트
            - 테스트 주체와 협력자를 구분하기. ( 여기서 주체는 테스트를 할 객체이며, 협력자는 테스트를 진행하기 위해 정의하는 가짜 객체입니다.)
            - Given, when, then 으로 명확하게 작성하기
                Given: 테스트를 진행할 행위를 위한 사전 준비
                when: 테스트를 진행할 행위
                then: 테스트를 진행한 행위에 대한 결과 검증

        - AssertJ 라이브러리
            - Assertions 는 assertJ 라이브러리를 사용합니다. Junit jupiter 를 사용하지 않는 이유는 assertJ의 가독성이 좋기 때문입니다.
                1. assertThat 은 값 검증에 쓰입니다.
                    assertThat(실제값). isEqualTo(기댓값)
                    assertThat(실제 객체). isInstanceOf(객체 예상 타입)
                    assertThat(실제값). isNull()
                    등등 실제 값, 값의 타입을 비교하는 여러 연산자들과 쓰이는 메서드입니다.
                2. asserThatThrownBy는 예외 발생 검증에 쓰입니다.
                    asserThatThrownBy( () -> 예외를 발생시킬 로직). isInstanceOf(예외 클래스)
                    예외가 발생한다면 테스트를 통과하고 발생하지 않는다면 실패하는 메서드입니다.

        - Domain Test
            가장 단위가 작은 Member 객체에 대해서 단위 테스트입니다. 도메인에 대한 테스트가 가장 비용이 적게 듭니다.
            @Test 어노테이션이 반드시 필요하며, 반환하는 것이 없도록 void 여야 합니다.
            @DisplayName 을 통해서 테스트 진행 시 나오는 테스트명을 정할 수 있습니다.
            ex)
                Builder 를 이용해서 멤버를 생성했을 때 올바르게 생성됐는지 테스트
                Member 의 나이를 바꿨을 때 올바르게 바뀌는지 테스트

        - Jpa 를 사용하는 Repository Test
            @DataJpaTest: Jpa 를 사용하는 Repository 에 대한 검증을 수행할 때 사용하는 어노테이션입니다.
                - @DataJpaTest 는 @Transaction 을 포함하고 있어서 1개 의 테스트가 끝나면 Rollback 해 다른 테스트에게 영향을 미치지 않습니다.
                    JPA 관련된 설정만 로드한다. 그렇기 때문에 @Entity 클래스를 스캔하여 스프링 데이터 JPA 저장소를 구성한다.
                    기본적으로 인메모리 데이터베이스를 이용함.
                    데이터소스의 설정이 정상적인지, JPA 를 사용하서 데이터를 제대로 생성, 수정, 삭제하는지 등의 테스트가 가능함.
                    테스트가 끝날 때마다 자동으로 테스트에 사용한 데이터를 롤백
                - @DataJpaTest 로 검증할 수 있는 목록은 아래와 같습니다.
                    - DataSource 에 대한 설정
                    - CRUD 가 제대로 동작하는지
                - @Entity 가 있는 엔티티 클래스들을 스캔하며 테스트를 위한 TestEntityManager 를 사용해 JPA 레포지토리들을 설정해준다.
                  마찬가지로 @Component 나 @ConfigurationProperties 빈들은 스캔되지 않는다.
                - 앞서 설명하였듯 스프링은 테스트에 @Transactional 이 있으면 테스트가 끝난 후 자동으로 트랜잭션을 롤백한다.
                  @DataJpaTest 에는 @Transactional 어노테이션이 들어있어서 기본적으로 모든 테스트가 롤백된다. 만약 롤백을 원하지 않는다면 @Rollback(false)를 추가하면 된다.
                - 또한 만약 H2와 같은 내장 데이터베이스가 클래스 패스에 존재한다면 내장 데이터베이스가 자동 구성된다. spring-boot-test 의존성에는 기본적으로 H2가 들어있으므로
                  별다른 설정을 주지 않는다면 H2로 설정된다. 내장 데이터베이스로 설정되기를 원하지 않는다면 다음과 같이 AutoConfigureTestDatabase 의 replace 속성을 NONE 으로 주면 된다.
                        @AutoConfigureTestDataBase : 데이터 소스를 어떤 걸로 사용할지에 대한 설정
                            - Replace.Any : 기본적으로 내장된 데이터소스를 사용
                            - Replace.NONE : @ActiveProfiles 기준으로 프로파일이 설정됨
                        @AutoConfigurationDatabase 에 Replace.NONE 설정을 주면 실제 DB로 검증할 수 있습니다. 따로 명시하지 않을 시 내장된 임베디드 DB를 사용합니다.

            @RunWith(SpringRunner.class)
            @DataJpaTest
            @ActiveProfiles("test")
            @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
            public class BookJpaTest {

                @Autowired
                private BookRepository bookRepository;

                @Test
                public void book_save_test() {
                    final Book book = new Book("title", 1000D);
                    final Book saveBook = bookRepository.save(book);
                    assertThat(saveBook.getId(), is(notNullValue()));
                }

                @Test
                public void book_save_and_find() {
                    final Book book = new Book("title", 1000D);
                    final Book saveBook = bookRepository.save(book);
                    final Book findBook = bookRepository.findById(saveBook.getId()).get();
                    assertThat(findBook.getId(), is(notNullValue()));
                }
            }


        - Service 계층 Test
            Service 계층은 Repository 객체를 Spring 에게 주입받고 있습니다.
            따라서 Service 계층의 Test 는 주체가 Service 객체이며, 협력자는 Repository 객체입니다.
            그렇기에 Repository 는 가짜 객체로서 응답을 설정해줘야 합니다.
            Junit5 기능을 사용하고, Test 에서 가짜 객체를 사용하기 때문에 @ExtendWith(SpringExtension.class)를 붙여줘야 합니다.

            @ExtendWith(SpringExtension.class)
            public class MemberServiceTest {

                // Test 주체
                MemberService memberService;

                // Test 협력자
                @MockBean
                MemberRepository memberRepository;


                // Test 를 실행하기 전마다 MemberService 에 가짜 객체를 주입시켜준다.
                @BeforeEach
                void setUp(){
                    memberService = new MemberServiceImpl(memberRepository);
                }
            }

            @BeforeEach: Test 를 실행하기 전 항상 실행하도록 하는 어노테이션입니다. 여기서는 가짜 객체를 주입하는 데 사용됐습니다.
            @MockBean: 가짜 객체를 만드는 역할을 합니다. 물론 가짜 객체이므로 응답을 정의해줘야 합니다. Test 의 협력자 역할을 합니다.
            MemberService: Test 의 주체로서 가짜 객체를 주입받고, 자신의 로직을 실행하고 결과를 가지고 검증을 합니다.


            @Test
            @DisplayName("멤버 생성 성공")
            void createMemberSuccess(){
                /*
                given
                 */
                Member member3 = Member.builder().name("hi3").age(10).build();
                ReflectionTestUtils.setField(member3,"id",3l);

                Mockito.when(memberRepository.save(member3)).thenReturn(member3); // 가짜 객체 응답 정의
                /*
                when
                 */
                Long hi3 = memberService.createMember("hi3", 10);
                /*
                then
                 */
                assertThat(hi3).isEqualTo(3L);
            }

            Member 생성을 성공하는 Test 입니다.
            ReflectionTestUtils.setField() : test 를 진행하면서 private 로 선언된 필드 값을 넣어줄 수 있습니다.
            Mockito.when(가짜 객체의 로직 실행). thenReturn(실행되면 이것을 반환한다.)라고 말할 수 있습니다.


            @Test
            @DisplayName("멤버 생성시 member1 과 이름이 같아서 예외 발생")
            void createMemberFail(){
                /*
                given
                 */
                Member member1 = Member.builder().name("hi1").age(10).build();
                Mockito.when(memberRepository.findByName("hi1")).thenReturn(Optional.of(member1));

                /*
                when then
                 */
                assertThatThrownBy(() -> memberService.createMember("hi1",10)).isInstanceOf(IllegalStateException.class);
            }


        - Controller 계층
            - @WebMvcTest: Mvc 를 위한 테스트로서 컨트롤러가 설계대로 동작하는지에 대해 검증하는데 필요한 어노테이션입니다.
              아래 보이시는 것과 같이 Controller 를 구체적으로 적을 수 있고, ControllerAdvice, Filter 등을 포함과 제외시킬 수 있어
              Security 에 대한 Test 도 가능합니다.

              해당 어노테이션을 사용하면, @Controller, @ControllerAdvice, @JsonComponent 와 Filter, WebMvcConfiguer,
              HandlerMethodArgumentResolver 만 로드되기 때문에 전체 테스트보다는 가볍다. ( 물론, classes 를 이용하여 일부 빈만 등록하면 괜찮지만.... )

              내장된 서블릿 컨테이너가 랜덤 포트로 실행된다. @WebMvcTest 는 애플리케이션 컨텍스트를 만들 때 컨트롤러와 연관된 빈들만을 제한적으로 찾아서 등록한다.
              그러므로 일반적인 @Component 나 @ConfigurationProperties 빈들은 스캔되지 않는다.

              추가적인 설정이 필요하면 @Import 를 사용할 수 있고, @MockBean 이나 @SpyBean 역시 사용할 수 있다.
              또한 @WebMvcTest 는 컨트롤러 테스트이므로 @WebMvcTest 내부에 @AutoConfigureMockMvc 가 들어있다.
              그러므로 @Autowired 로 MockMvc 를 주입받을 수 있으며, 만약 웹플럭스를 이용중이라면 @WebFluxTest 를 사용하면 된다.

              @WebMvcTest 에는 특정 컨트롤러만을 빈으로 등록하도록 제한할 수 있다.

                  @WebMvcTest(UserController.class)
                  class UserControllerTest {

                  }

                  이를 통해 특정 컨트롤러만 테스트 가능하도록 하는데, 해당 컨트롤러가 의존하는 빈이 있다면 @MockBean 이나 @SpyBean 을 사용해주어야 한다.
                  문제는 이렇게 특정 컨트롤러만을 빈으로 띄우고 @MockBean 과 @SpyBean 으로 특정 빈을 바꾸는 것은 새로운 애플리케이션 컨택스트를 필요로 한다.
                  그래서 애플리케이션 컨텍스트의 수를 증가시키므로 주의해야 한다.



              @WebMvcTest(MemberController.class)
              public class MemberControllerTest {

                  @Autowired
                  MockMvc mvc;

                  @MockBean
                  MemberServiceImpl memberService;

              }

            - Test 의 주체는 MemberController 입니다. 따라서 WebMvcTest 에 선언을 해줍니다.
              MemberService 는 협력자이므로 @MockBean 을 등록해주고, Test 에 응답을 정의합니다.
              MockMvc 는 실제로 서블릿 컨테이너를 사용하지 않고, 테스트용으로 Mvc 기능을 사용할 수 있게 해주는 역할을 합니다.
              테스트 때 생성되는 WebApplicationContext 에서 주입받습니다.


            @Test
            @DisplayName("리스트 반환받기")
            void getList() throws Exception {
                /*
                given
                 */
                List<MemberResponseDto.ListDto> list = List.of(new MemberResponseDto.ListDto("asd", 10)
                        , new MemberResponseDto.ListDto("fsd", 12));
                Mockito.when(memberService.findAll()).thenReturn(list);

                /*
                when then
                 */
                mvc.perform(MockMvcRequestBuilders.get("/members").contentType(MediaType.APPLICATION_JSON))
                        .andDo(MockMvcResultHandlers.print())
                        .andExpect(MockMvcResultMatchers.status().isOk())
                        .andExpect(MockMvcResultMatchers.jsonPath("$[1].name").value("fsd"))
                        .andExpect(MockMvcResultMatchers.jsonPath("$[0].name").value("asd"));
            }

            협력자인 MemberService 의 findAll() 호출 시 반환하는 list 를 정의합니다.
            mvc.perform(MockMvcRequestBuilders.get(). contentType(): 컨트롤러에게 요청을 보내는 역할을 합니다. uri 를 만들고, contentType 을 지정합니다.
            andDo(): 요청에 대한 처리를 합니다. MockMvcResultHandler.print()를 인자로 넣었으므로 요청과 응답에 대한 것들을 콘솔에 출력해줍니다.
            andExpect(): 검증하는 로직입니다. MockMvcResultMatcher.status()는 HTTP 상태 코드를 검증하고, jsonPath 는 Json 로 넘어온 것들에 대한 값을 검증할 수 있습니다.
            jsonPath("$. name"). value("fsd"): 단일 객체에 대한 값 검증
            jsonPath("$[1]. name"). value("asd): 리스트를 반환받았을 때 지정하여 검증


        - REST 관련 테스트 - @RestClientTest
            - Rest 통신의 JSON 형식이 예상대로 응답을 반환하는지 등을 테스트 함
            - @RestClientTest : 테스트 대상이 되는 빈을 주입받음
              @Rule
              MockRestServiceServer : 클라이언트와 서버 사이의 REST 테스트를 위한 객체. 내부에서 RestTemplate 을 바인딩하여
              실제로 통신이 이루어지게끔 구성할 수 있음. 이 코드에서는 목 객체와 같이 실제 통신이 이루어지지는 않지만 지정한 경로에 예상되는 반환값을 명시함.

            @RunWith(SpringRunner.class)
            @RestClientTest(BookRestService.class)
            public class BookRestServiceTest {

                @Rule
                public ExpectedException thrown = ExpectedException.none();

                @Autowired
                private BookRestService bookRestService;

                @Autowired
                private MockRestServiceServer server;

                @Test
                public void rest_test() {

                    server.expect(requestTo("/rest/test"))
                            .andRespond(
                                    withSuccess(new ClassPathResource("/test.json", getClass()), MediaType.APPLICATION_JSON));

                    Book book = bookRestService.getRestBook();

                    assertThat(book.getId(), is(notNullValue()));
                    assertThat(book.getTitle(), is("title"));
                    assertThat(book.getPrice(), is(1000D));

                }
            }


        - Json 의 직렬화, 역직렬화 테스트 - @JsonTest
            - Gson, Jackson 의 테스트를 제공함.

            @RunWith(SpringRunner.class)
            @JsonTest
            public class BookJsonTest {

                @Autowired
                private JacksonTester<Book> json;

                @Test
                public void json_test() throws IOException {

                    final Book book = new Book("title", 1000D);

                    String content= "{\n" +
                            "  \"id\": 0,\n" +
                            "  \"title\": \"title\",\n" +
                            "  \"price\": 1000\n" +
                            "}";


                    assertThat(json.parseObject(content).getTitle()).isEqualTo(book.getTitle());

                    assertThat(json.write(book)).isEqualToJson("/test.json");
                }
            }


    - 통합 테스트
        단위 테스트와는 다르게 실제 spring 을 실행했을 때와 같은 운영환경에서 잘 동작하는지 확인하는 테스트입니다. 전체적인 플로우를 확인하므로 Spring 에 쓰이는 Bean 들이 등록됩니다.
        @SpringBootTest: 통합 테스트를 진행하기 위한 어노테이션입니다.
        (주의 @Transaction 을 포함하고 있지 않기 때문에 Repository 계층까지 사용된다면 @Transaction 도 붙여서 Rollback 을 실행해줘야 합니다.)
        스프링을 실제 띄워서 컨테이너를 띄우거나 DI를 하여 스프링과 동일한 환경에서 테스트할 수 있고, 단순 자바 코드로서 테스트가 아닌 DB 연동 등 통합 테스트에 자주 사용한다.
        @SpringBootTest 는 모든 빈들을 스캔하고 애플리케이션 컨텍스트를 생성하여 테스트를 실행한다.
        @SpringBootTest 의 어노테이션에는 다양한 값을 줄 수 있는데, 이를 살펴보면 다음과 같다.
            value 와 properties: 애플리케이션 실행에 필요한 프로퍼티를 key=value 형태로 추가할 수 있음
            args: 애플리케이션의 arguments 로 값을 전달할 수 있음
            classes: 애플리케이션을 로딩할 때 사용되는 컴포넌트 클래스들을 정의할 수 있음
            webEnvironment: 웹 테스트 환경을 설정할 수 있음
                - webEnvironment 는 enum 이며 총 4가지 값을 가지고 있는데, 각각의 기능과 특징을 정리하면 다음과 같다.
                    MOCK
                        웹 기반의 애플리케이션 컨텍스트를 생성하지만 MOCK 환경으로 제공하여 내장 서버가 시작되지 않음
                        웹 환경이 클래스패스에 없다면 웹이 아닌 애플리케이션 컨텍스트를 생성함
                        웹 기반의 Mock 테스트를 위해 @AutoConfigureMockMvc 또는 @AutoConfigureWebTestClient 와 함께 사용할 수 있음
                    RANDOM_PORT
                        웹 기반의 애플리케이션 컨텍스트를 생성하여 실제 웹 환경을 제공함
                        내장 서버도 실행되며 사용하지 않는 랜덤 포트를 listen 함
                    DEFINED_PORT
                        웹 기반의 애플리케이션 컨텍스트를 생성하고 실제 웹 환경을 제공함
                        내장 서버도 실행되며 지정한 포트(default 8080)를 listen 함
                    NONE
                        SpringApplication 로 애플리케이션 컨텍스트를 생성함
                        하지만 mock 이나 다른 것들을 포함해 어떠한 웹 환경도 제공하지 않음

                - webEnvironment 의 기본값은 MOCK 이므로 실제 웹 서버가 실행되지는 않는다. 또한 스프링은 @Transactional 이 있으면 테스트가 끝나고 트랜잭션을 롤백하는데,
                  RANDOM_PORT 나 DEFINED_PORT 를 사용하면 별도의 쓰레드에서 실제 서버가 구동되어 롤백되지 않는다. 그래서 테스트가 격리되지 않아 실패할 수 있는데,
                  이와 관련해서는 이 포스팅을 참고해 해결하도록 하자. 또한 RANDOM_PORT 나 DEFINED_PORT 를 사용하면 TestRestTemplate 이 의존성으로 추가되므로 API 호출이 필요할 때 이용할 수 있다.

                - @SpringBootTest 는 기본적으로 모든 빈을 탐색하고 등록한다. 그래서 특정 계층만 테스트가 필요한 상황에서 @SpringBootTest 를 사용하면
                  불필요하게 무거워지고 시간이 오래 걸린다. 그래서 스프링은 특정 부분만 테스트할 수 있는 슬라이스 테스트(SliceTest)를 위한 어노테이션들을 제공하는데,
                  이에 대해 알아보도록 하자. 물론 슬라이스 테스트도 스프링 컨텍스트를 구성하므로 통합 테스트이다.

       public class MemberServiceTest {
           @Autowired
           MemberService memberService;

           @Autowired
           MemberRepository memberRepository;
       }

       단위 테스트보다 쉽게 진행할 수 있습니다. SpringContainer 를 만들기 때문에 Bean 있어 따로 가짜 객체를 정의하지 않아도 됩니다.


    - 단위 테스트 VS 통합 테스트
        - 프로젝트를 진행하며, 테스트 코드가 적다면, 통합 테스트로 진행해도 많은 영향을 끼치진 않습니다. 하지만 애플리케이션이 커지면서,
          테스트 코드가 점점 많아진다면 통합 테스트 비용이 많이 발생할 것입니다.
          통합 테스트는 모든 빈을 등록하여 테스트를 진행한다. 그렇기 때문에 애플리케이션 규모가 크면 테스트가 많이 느려진다.

        - 단위 테스트의 경우 계층마다 나눠서 작성하기 때문에 오류가 발생해서 검증이 실패한다면, 그 부분만 수정하면 됩니다.
          반면에 통합 테스트는 어느 계층에서 오류가 발생한 지 색출하는데 오랜 시간이 걸립니다.

        -> 단위 테스트, 통합 테스트 모두 장단점이 존재합니다.
           단위 테스트의 단점은 테스트를 작성하는 노하우 등으로 커버가 가능합니다. 하지만 통합 테스트의 무거운 테스트로 인해서 발생하는 비용은 커버가 불가능합니다

        * @RunWith : 해당 어노테이션을 사용하면 JUnit 의 러너를 사용하는게 아니라 지정된 SpringRunner 클래스를 사용한다.
            @RunWith(SpringRunner.class)

    - 애플리케이션 컨텍스트 캐싱
        - 스프링 부트가 제공하는 테스트는 모두 애플리케이션 컨텍스트를 구성해주어야 한다. 하지만 모든 테스트마다 이를 구성하려면 비용이 커지므로
          스프링은 테스트 시에 내부적으로 스프링 컨텍스트를 캐싱해두고 동일한 설정이라면 재사용한다.
          그러므로 다음과 같이 애플리케이션 컨텍스트 설정에 변경을 주는 기능들은 테스트 시에 새로운 컨텍스트를 생성하도록 요구한다.
            @MockBean, @SpyBean
            @TestPropertySource
            @ConditionalOnX
            @WebMvcTest 에 컨트롤러 지정
            @Import
            기타 등등

    - 여기서 주의해야 할 점은 슬라이스 테스트가 단위 테스트는 아니라는 점이다. 해당 어노테이션으로 테스트를 진행하면 테스트를 위한 애플리케이션 컨텍스트가 준비된다.
      즉, 스프링이 준비되므로 해당 테스트들은 통합 테스트에 해당한다.
      추가로 위에서 언급한 슬라이스 테스트 어노테이션 외에도 @JsonTest, @RestClientTest, @DataJdbcTest 등도 있다.
      만약 json 관련 테스트를 위해 gson 이나 objectMapper 등의 의존성이 필요하다면 @JsonTest 를, RestTemplate 이 필요하다면 @RestClientTest 를 사용할 수 있다.
      또한 Datasource 와 JdbcTemplate 만 필요하다면 @JdbcTest 를 이용하면 된다.

    - JUnit5에 추가된 내용
        1. @DisplayName : method 명으로 표현하기 부족했다면 해당 어노테이션을 유용하게 사용할 수 있다.
        2. Lifecycle Method
            @BeforeClass, @AfterClass -> @BeforeAll, @AfterAll
            @Before, @After -> @BeforeEach, @AfterEach
        3. 중첩된 테스트 클래스 - @Nested
            @DisplayName("조회 테스트")
            @Nested
            class ReviewServiceTest {
            	@DisplayName("여러 seq 로 조회")
                @ParameterizedTest(name = "seq {0} 조회")
                @ValueSource(longs = { 1L, 2L })
                void getBySeq(Long seq){
                	Review review = reviewService.getByReviewSeq(seq);
                    assertThat(review).isNotNull();
                }
            }

    - 스프링부트 테스트를 위한 의존성
        - 스프링부트는 서블릿 기반의 웹 개발을 위한 spring-boot-starter-web, 유효성 검증을 위한 spring-boot-starter-validation 등
          spring-boot-starter 의존성을 제공하고 있다. 테스트를 위한 spring-boot-starter-test 역시 존재하는데, 다음과 같은 라이브러리들이 포함된다.
            - JUnit 5: 자바 애플리케이션의 단위 테스트를 위한 사실상의 표준 테스트 도구
            - Spring Test & Spring Boot Test: 스프링 부트 애플리케이션에 대한 유틸리티 및 통합 테스트 지원
            - AssertJ: 유연한 검증 라이브러리
            - Hamcrest: 객체 Matcher 를 위한 라이브러리
            - Mockito: 자바 모킹 프레임워크
            - JSONassert: JSON 검증을 위한 도구
            - JsonPath: JSON 용 XPath

        - 스프링부트는 spring-boot-test-autoconfigure 를 통해 특정 어노테이션을 붙여주면 해당 테스트를 위한 설정들을 자동으로 제공해준다.
          대표적으로 다음과 같은 어노테이션들을 제공하고 있다.
            - @SpringBootTest
            - @WebMvcTest
            - @DataJpaTest
            - @RestClientTest
            - @JsonTest
            - @JdbcTest
            - 기타 등등

    - 단위 테스트(Unit Test) 작성의 필요성
        - 단위 테스트의 문제점과 Stub
            어떤 객체가 자체적으로 모든 일을 처리한다면 문제가 없겠지만, 일반적인 애플리케이션에서는 1개의 기능을 처리하기 위해 다른 객체들과 메세지를 주고 받아야 한다.
            하지만 앞서 설명하였듯 단위 테스트는 해당 모듈에 대한 독립적인 테스트이기 때문에 다른 객체와 메세지를 주고 받는 경우에 문제가 발생한다.
            그렇기 때문에 다른 객체 대신에 가짜 객체(Mock Object)를 주입하여 어떤 결과를 반환하라고 정해진 답변을 준비시켜야 하는데, 이를 stub 이라고 한다.
            예를 들어 데이터베이스에 새로운 데이터를 추가하는 코드를 테스트한다고 하면, 가짜 데이터베이스(Mock Database)를 주입하여
            insert 처리 시에 반드시에 1을 반환하도록 해주는 것이 stub 이다.

        - 좋은 단위 테스트의 특징
            1개의 테스트 함수에 대해 assert 를 최소화하라
            1개의 테스트 함수는 1가지 개념 만을 테스트하라

        - FIRST 라는 5가지 규칙
            1. Fast: 테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한다.
            2. Independent: 각각의 테스트는 독립적이며 서로 의존해서는 안된다.
            3. Repeatable: 어느 환경에서도 반복 가능해야 한다.
            4. Self-Validating: 테스트는 성공 또는 실패로 bool 값으로 결과를 내어 자체적으로 검증되어야 한다.
            5. Timely: 테스트는 적시에 즉, 테스트하려는 실제 코드를 구현하기 직전에 구현해야 한다.

        * 개인적으로 단위 테스트의 가장 큰 장점은 내가 개발한 것들을 빠르게 검증받는 것이라고 생각합니다. 단위 테스트를 통해 내가 개발한 코드를 바로 검증받고,
          테스트를 통과하지 못하면 코드를 수정해 또 다시 빠르게 검증받는 것입니다. 이렇게 테스트를 작성하고 수시로 실행하며 검증하면서 버그를 잡고 개발 비용을 줄어나갈 때 테스트의 가치를 느낄 수 있었습니다.
          물론 프로토타입 또는 PoC 성향의 프로젝트라면 단위 테스트를 작성하지 않을 수도 있습니다. 반면에 신규로 개발된 프로젝트이거나
          계속해서 기능이 추가되고 유지보수가 필요한 프로젝트라면 단위 테스트를 작성하는게 좋을 것 같습니다. 만약 해당 프로젝트가
          이미 구현되어있는 상태라도 늦게나마 단위 테스트를 작성하는 것은 이후에 작업하는데 도움을 줄 것입니다!

    - Mockito 소개 및 사용법
        - Mockito 란?
            Mockito 는 개발자가 동작을 직접 제어할 수 있는 가짜(Mock) 객체를 지원하는 테스트 프레임워크이다.
            일반적으로 Spring 으로 웹 애플리케이션을 개발하면, 여러 객체들 간의 의존성이 생긴다. 이러한 의존성은 단위 테스트를 작성을 어렵게 하는데,
            이를 해결하기 위해 가짜 객체를 주입시켜주는 Mockito 라이브러리를 활용할 수 있다. Mockito 를 활용하면 가짜 객체에 원하는 결과를
            Stub 하여 단위 테스트를 진행할 수 있다. 물론 Mock 을 하지 않아도 된다면 하지 않는 것이 가장 좋다.

        - Mockito 사용법
            1. Mock 객체 의존성 주입
                @Mock: Mock 객체를 만들어 반환해주는 어노테이션
                @Spy: Stub 하지 않은 메소드들은 원본 메소드 그대로 사용하는 어노테이션
                @InjectMocks: @Mock 또는 @Spy 로 생성된 가짜 객체를 자동으로 주입시켜주는 어노테이션
            2. Stub 로 결과 처리
                의존성이 있는 객체는 가짜 객체(Mock Object)를 주입하여 어떤 결과를 반환하라고 정해진 답변을 준비시켜야 한다. Mockito 에서는 다음과 같은 stub 메소드를 제공한다.
                    doReturn(): Mock 객체가 특정한 값을 반환해야 하는 경우
                    doNothing(): Mock 객체가 아무 것도 반환하지 않는 경우(void)
                    doThrow(): Mock 객체가 예외를 발생시키는 경우
            3. Mockito 와 Junit 의 결합
                Mockito 도 테스팅 프레임워크이기 때문에 JUnit 과 결합되기 위해서는 별도의 작업이 필요하다.
                기존의 JUnit4에서 Mockito 를 활용하기 위해서는 클래스 어노테이션으로 @RunWith(MockitoJUnitRunner.class)를 붙여주어야 연동이 가능했다.
                하지만 SpringBoot 2.2.0부터 공식적으로 JUnit5를 지원함에 따라, 이제부터는 @ExtendWith(MockitoExtension.class)를 사용해야 결합이 가능하다.

        - Mock 이란?
            - 가짜 객체라고 불리며, 행위를 검증하기 위해 사용되는 객체입니다.
            - Spring 의 ApplicationContext 에 Mock 객체들을 넣어줍니다.
            - 실제 객체를 만드는데 드는 시간을 절약하기 위해서
              의존성의 연결고리가 많이 연결된 경우, 구현의 복잡함을 피하기 위해서 사용됨

            - @Mock
                - @InjectMocks 에 대해서만 해당 클래스안에서 정의된 객체를 찾아서 의존성을 해결합니다.
                - 의존성 주입 : @InjectMocks
            - @MockBean
                - mock 객체를 스프링 컨텍스트에 등록하는 것이기 때문에 @SpringBootTest 를 통해서 Autowired 에 의존성이 주입되게 됩니다.
                - 만약 @MockBean 으로 선언한 빈이 없다면 Mock 객체를 빈으로 등록하지만, 동일한 타입과 이름의 빈이 존재하면 해당 빈은 Mock 빈으로 대체된다.
                - 의존성 주입 : @Autowired

            -> Spring Boot Container 가 테스트 시에 필요하고, Bean 이 Container 에 존재한다면 @MockBean 을 사용하고 아닌 경우에는 @Mock 을 사용합니다.


    - Spring 컨트롤러 단위 테스트 작성 예시
        @ExtendWith(MockitoExtension.class)
        class UserControllerTest {

            @InjectMocks
            private UserController userController;

            @Mock
            private UserService userService;

        }

        이제 의존성 주입을 해주어야 한다. 먼저 테스트 대상인 UserController 에는 가짜 객체 주입을 위한 @InjectMocks 를 붙여주어야 한다.
        그리고 UserService 에는 가짜 Mock 객체 생성을 위해 @Mock 어노테이션을 붙여주면 된다.


    ***** 또한 테스트 코드는 앞서 설명한 given-when-then 구조로 흔히 작성되는데, 단위 테스트 내에 주석으로 이 단계를 명시해주면
    읽기 좋은 테스트 코드를 작성할 수 있다. (IntelliJ를 사용중이라면 live template 를 직접 설정해 빠르게 작성할 수 있다.)


* @Transactional 어노테이션 처리
  클래스 레벨으로는 @Transactional(readOnly = true) 어노테이션, 추가/수정/삭제 메소드에는 @Transactional 어노테이션을 추가해주었다.
  클래스 레벨에 적용된 트랜잭션 어노테이션은 메소드에 그대로 적용되고, 만약 메소드에 별도의 트랜잭션 어노테이션이 있으면 메소드의 어노테이션이 적용된다.
  그러므로 쓰기 또는 변경 작업이 있는 메소드에는 @Transactional 을 붙여 readOnly 속성이 있는 @Transactional 을 덮어 씌워주도록 하자.
  (다른 addMembership 이나 removeMembership 함수에도 붙여주어야 한다.)

  - 클래스 레벨에 @Transactional 을 붙여준 이유는 크게 3가지가 있다.
        - 서비스 계층과 트랜잭션 경계와의 일치
        - 읽기 전용 어노테이션을 통한 최적화 및 읽기 작업에 대한 안정성 확보
        - JPA 내부 동작 방식과의 결합

        -> 우선 트랜잭션이 중구난방으로 적용되는 것은 좋지 않다. 대신 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 좋은데,
           일반적으로 비지니스 로직을 담고 있는 서비스 계층은 다른 서비스 계층에 참조되는 경우가 많으므로 서비스 계층의 메소드와 결합시키는 것이 좋다.
           두 번째 이유는 클래스 레벨에 적용되는 읽기전용 트랜잭션 어노테이션은 클래스에 선언하고, 추가나 삭제 또는 수정과 같은 작업에는 쓰기가 가능한
           @Transactional 을 붙여줌으로써 읽기 작업에 성능의 최적화를 더해주고, 읽기 작업에서 데이터가 변경되는 실수들을 방지하는 안정성을 확보할 수 있다.
           마지막 이유는 JPA 의 내부 동작 방식 때문인데, MemberService 의 accumulateMembershipPoint 메소드에서 시작된 트랜잭션은
           MemberRepository 에서 Membership 객체를 조회하는 순간을 포함해 accumulateMembershipPoint 메소드가 종료될 때 까지 유지된다.
           그러면 Entity 는 내부적으로 1차 캐시를 관리하는데, 동일한 트랜잭션 상이므로 별도의 save()를 호출하지 않고도 처리되도록 도와준다. '
           (자세히 설명하기에는 내용이 길어지므로, 동일한 트랜잭션 상에서 DB 에서 조회한 엔티티를 수정하면 별도의 update 쿼리가 필요 없이
           트랜잭션 종료 시점에 객체가 변했을 경우에만 update 쿼리가 자동으로 수행된다고 기억하면 된다.)

- @Mock vs @MockBean
    상황에 맞게 쓰면된다.
    Spring 에서 제공하는 applicationContext 와 연계가 필요하면 @MockBean
    로직확인용 Mock 이 필요하다면 @Mock + @InjectMock
    따라서 대게는 @Mock 을 사용하고(이때 MockitoJUnitRunner 로 Runwith 한다) Spring 에서 제공되는 WebMvcTest 와 함께 사용될때는 @MockBean 을 사용하면 된다.

    https://cobbybb.tistory.com/16
    https://silvergoni.tistory.com/entry/use-MockBean-vs-Mock

- 테스트 더블
    - 최근에 테스트 코드를 짜기 시작하면서, Mock 객체를 가지고 어디서부터 어디까지 활용을 해야 하는지, 그리고 왜 Mock 객체를 사용하는지를
      모르고 얼레벌레 코드를 짜다 보니 목적성을 잃은 의미없는 테스트케이스를 짜게 되었다. 단순히 예상한 값을 나오게 하려고 테스트코드를 짜는 데에만 집중을 한 것이다.
      그치만 테스트케이스를 만드는 것도 설계가 필요하고 테스트에 대한 명확한 의도가 필요하다.
      검색해보니 테스트 코드를 위한 모의 객체들은 테스트 더블이라는 집합 아래 여러가지 방법론들이 있었다.
      이 중에서 대표적으로 구분되는 Mock 과 Stub 에 대해  핵심 내용만 간략하게 공부해보고 정리해보았다.
            테스트 대상 코드를 격리
            테스트 속도 개선
            예측 불가능한 실행 요소 제거
            특수한 상황 시뮬레이션

- Mock vs Stub
    - stub 을 포함한 다른 대역들은 상태 검증(state verification) 을 사용하고 Mock 오브젝트는 행위 검증(behavior verification) 을 사용합니다.
        - stub
            - 상태 검증이란 메소드가 수행된 후, 객체의 상태를 확인하여 올바르게 동작했는지를 확인하는 검증법입니다.
            - 사용하기 쉬우며 추가 종속성이 없습니다.
            - 메서드가 수행될 때 연관되어있는 협력 객체의 '상태'를 검증함으로써 제대로 기능이 동작하고 있는지를 검증하는 것이다.
            - 더미 객체를 생성하고 실제로 동작하는것처럼 보이게 만든 가짜 객체이다.
              호출된 요청에 대한 응답값을 미리 만들어놓고 전달한다.
              객체의 최소한의 기능만을 임의로 구현한다.
        - mock
            - 행위 검증이란 메소드의 리턴 값으로 판단할 수 없는 경우, 특정 동작을 수행하는지 확인하는 검증법입니다.
            - 특정 메서드의 호출 등을 검증하기 때문에 구현에 의존적입니다.
              즉 프로덕션 코드가 변경되면 테스트코드가 변경될 확률이 높아진다는 것을 의미한다
            - 테스트하고자 하는 메소드가 참조하고 있는 협력 객체의 메소드를 제대로 콜 하는지에 대한 '행위'를 검증하는 것이다.
            - 특정 동작을 수행하는지(= 메소드를 제대로 콜 하는지)에 대한 검증을 한다.
              즉 행위검증을 추구한다는 점에서 다른 테스트 더블들과 구분된다.

    -> 언제 Stub, Mock 을 사용하나요? 기본적으로 적합하다고 판단될 때 선택해야 합니다.

    https://joont92.github.io/tdd/%EC%83%81%ED%83%9C%EA%B2%80%EC%A6%9D%EA%B3%BC-%ED%96%89%EC%9C%84%EA%B2%80%EC%A6%9D-stub%EA%B3%BC-mock-%EC%B0%A8%EC%9D%B4/
    https://azderica.github.io/00-test-mock-and-stub/
    https://algopoolja.tistory.com/119

- @SpyBean @MockBean 의도적으로 사용하지 않기
    https://jojoldu.tistory.com/320

- Stub 을 이용한 Service 계층 단위 테스트 하기
    https://jojoldu.tistory.com/637

- Test Stub 이란 ?
    https://beomseok95.tistory.com/294

- Mock, Mockito - 사용법
    https://greedy0110.tistory.com/57

- Mockito 사용법
    https://effortguy.tistory.com/141  ~  145
    https://kim-solshar.tistory.com/60

- Mockito-사용하기
    https://velog.io/@znftm97/Mockito-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B01


* SQL 에서 직접 데이터를 처리하거나 로직(NOW(), DATE_SUB(), PASSWORD() 등)을 담고 있으면 테스트 구현과 기능 확장에 취약하다.
  가능하다면 SQL 에서는 로직을 담지 말고, 저장소로서의 역할에만 충실하도록 구현하는 것이 좋다.
  그래야만 테스트 구현이 쉽고, 기능 확장에 유리하다.

    - Springboot Test 코드 작성
        https://dingdingmin-back-end-developer.tistory.com/entry/Springboot-Test-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-1

    - 올바른 단위 테스트 작성 - 독립적인 테스트
        https://mangkyu.tistory.com/159

    - 단위 테스트(Unit Test) 작성의 필요성 (1/3)
        https://mangkyu.tistory.com/143

    - JUnit 을 활용한 Java 단위 테스트 코드 작성법 (2/3)
        https://mangkyu.tistory.com/144

    - JUnit 과 Mockito 기반의 Spring 단위 테스트 코드 작성법 (3/3)
        https://mangkyu.tistory.com/145

    * TDD 로 멤버십 삭제 및 포인트 적립 API 구현 예제 - (1/5)
        https://mangkyu.tistory.com/182    ~     186

    * 다양한 의존성 주입 방법과 생성자 주입을 사용해야 하는 이유 - (2/2)
        https://mangkyu.tistory.com/125

    * [Spring] 스프링부트 테스트를 위한 의존성과 어노테이션, 애플리케이션 컨택스트 캐싱(@SpringBootTest, @WebMvcTest, @DataJpaTest)
        https://mangkyu.tistory.com/242

    * 스프링 부트 설정/테스트 작성 시의 주의사항(스프링 부트 테스트가 오래 걸리는 이유)
        https://mangkyu.tistory.com/243

    * [Spring] @WebMvcTest 에 의해 느려지는 테스트 속도와 해결 방법(컨트롤러에 대한 단위 테스트 작성하기)
        https://mangkyu.tistory.com/244

    * @WebMvcTest 와 @MockBean 에 의한 테스트 성능 문제 해결을 위한 커스텀 라이브러리 구현 및 소개(feat. AutoMock)
        https://mangkyu.tistory.com/245
        https://github.com/MangKyu/spring-boot-test-automock

    * Writing Your F.I.R.S.T Unit Tests
        https://galid1.tistory.com/772

    * Mock Object 란
        https://medium.com/@SlackBeck/mock-object%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-85159754b2ac

    * 여러 값으로 단위 테스트 반복하기 ( @ParameterizedTest )
        https://sas-study.tistory.com/320
        https://velog.io/@ohzzi/junit5-parameterizedtest

    슬라이스 테스트 vs 단위 테스트 ??

    doReturn ? when? verify?
    @InjectMocks ?
    @ParameterizedTest?

     @ColumnDefault("0")


  또 위와 같이 Service나 Repository를 테스트할 때 더미 데이터를 롤백하기 위해 @SpringBootTest + @Transactional 조합을 쓰거나
  @DataJpaTest를 사용했는데요.
  (@DataJpaTest 안에도 @Transactional이 있습니다)
  팀에서는 테스트 코드를 작성할 때 @Transactional을 사용하지 않는다고 조언해 주셨습니다!

  롤백되는 기능은 편리하지만, 만약 트랜잭션이 보장되지 않았을 경우 실패하는 테스트를 작성했을 때 오히려 성공하는 경우가 많아서 사용하지 않는다고 하셨습니다.
  그래서 다음과 같이 @SpringBootTest와 함께 @After절에서 모든 데이터를 직접 삭제하는 방식으로 테스트를 작성한다고 가이드해 주셨습니다.


도메인 레이어는 단위 테스트하고, 나머지 모든 레이어를 묶어서 통합 테스트를 진행했는데요.
이렇게 하니 사실 상 서비스 레이어나 custom한 repository 레이어의 테스트가 없어 매번 수동 확인 작업을 거쳐야 했습니다.

그래서 다음과 같이 테스트 방식을 바꾸고 빠진 테스트를 모두 추가했습니다.

Presentation Layer : Service Layer를 mocking한 API 확인 테스트
Service Layer : 사실 상 이 친구가 통합 테스트
Repository : (querydsl같은) custom한 repository에 대한 쿼리 테스트
그 외 도메인, 유틸 클래스 등 단위 테스트


  https://happyer16.tistory.com/entry/Spring-Boot-Test-%EC%A2%85%ED%95%A9-%EC%A0%95%EB%A6%AC


@TestConfiguration
    static class TestConfig {

        @PersistenceContext
        private EntityManager entityManager;

        @Bean
        public JPAQueryFactory jpaQueryFactory() {
            return new JPAQueryFactory(entityManager);
        }
    }

- TDD
    - Junit4와 Junit5의 차이점
        - Junit4는 junit 라이브러리만 정의하면 되지만 junit5는 3가지의 모듈을 정의해야 한다.
            - junit platform : 테스트를 실행해주는 런처를 제공(일종의 컨텍스트), TestEngine API 제공(실제 구현체는 별도)
            - junit jupiter : TestEngine API 구현체
            - junit vintage : Junit4와 3을 지원하는 TestEngine 구현체
        - Spring Boot 2.2.0 버전부터 JUnit5가 기본으로 채택
        - Junit4는 자바5이상, Junit5는 자바 8이상 사용 가능
        - 어노테이션
            @Before	@BeforeEach
            @After 	@AfterEach
            @BeforeClass	@BeforeAll
            @AfterClass	@AfterAll
            @Ignore	@Disabled
            @RunWith	@ExtendWith
        - junit5에서는 public 을 사용하지 않아도 된다

    - 좋은 테스트
        - 좋은 테스트와 커버리즈는 완전별개, 테스트코드를 이상하게 짜놓고 초록불을 보는건 의미가 없음
          코드가 수정되었을때 만약에 발생하는 오류를 빨리 캐치할 수 있는 코드가 좋은 테스트 코드
        - 단위, 통합, 인수 테스트 존재
        - TDD 는 좋은 테스트를 판단하는 척도는 아닌듯(개발자 취향인듯) > 순서와 상관없이 테스트코드를 짜기만 하면 된다고 생각함
        - 테스트코드만을 봐도 로직을 이해할 수 있도록 좋은 네이밍, 깔끔한 코드작성 등을 지켜야 함

    - 테스트 코드를 어떻게 작성하는지
        Spring Rest Docs 작성을 위해 Mock 객체와 Fixture 데이터를 이용하여 컨트롤러 테스트를 작성합니다.
        유효성 검증같은 경우 단순 @NotNull 처리가 아닌 특정 필드값의 조건에 따라 유효성 검증 유무를 조사하는 등 복잡한 유효성 검증에 대해서만 테스트 코드를 작성합니다.
        비즈니스 로직을 위한 단위테스트를 작성합니다.
        public 메소드만을 테스트하며 private 는 따로 테스트하지 않습니다.
        마지막으로 H2 DB를 사용하거나 필요시 TestContainers 라이브러리를 사용하여 실제 운영 DB 환경과 동일하게 맞춘 후에 인수테스트를 작성합니다.


@DisplayName("예외 테스트 : 비어있거나 null인 이름이 들어오면 예외가 발생한다.")
    @NullAndEmptySource
    @ParameterizedTest
    void invalidNameTest(String invalidName) {
        Book book = Book.builder()
                .isbn("978-3-16-148410-0")
                .name(invalidName)
                .content("내용")
                .build();

        assertThatThrownBy(() -> bookRepository.save(book))
                .isInstanceOf(ConstraintViolationException.class);
    }

- 통합 테스트는 일반적으로 '외부 시스템 모킹(mocking)이 어렵다', '유지 보수에 비용이 많이 든다'


- 테스트하기 좋은 코드
    1. 테스트하기 어려운 코드
        - 테스트 코드 작성 경험, 테스트 프레임워크 숙련도로 인한 어려움은 생각보다 큰 이유가 아니다. 경험상 대부분은 테스트를 작성하기 어려운 구현체 때문이다.
        - 테스트하기 어렵도룩 구현되었기 때문에 테스트 코드 작성이 어려운 것이지, 도구의 숙련도의 문제인 경우가 별로 없다.
          좀 더 극단적으로는 테스트 코드 작성이 쉽게 구현된 코드라면 별도의 Mock 라이브러리 등의 도움 없이도 테스트 코드 작성이 쉽다.

        - 테스트 코드가 구현 코드의 설계를 바꿀 정도로 중요한것인가?
            - "테스트를 위해 구현 설계가 변경될 수 있다.
            - 테스트 코드는 구현의 보조적인 수단이 아니며, 같은 레벨로 봐야한다.
            - 좋은 디자인으로 구현된 코드는 대부분 테스트 하기가 쉽다.
            - 테스트 하기 어렵게 구현 되었다면, 코드 확장성 / 의존성 등 코드 디자인, 설계가 잘못되었을 확률이 굉장히 높다."

            - 테스트 코드는 구현의 보조 수단이 절대 아니다. 오히려 구현 설계 Smell을 맡게 해주는 좋은 수단이다.

        - 그렇다면 테스트하기 좋은 코드란 무엇일까?
            - 경험상 몇번을 수행해도 항상 같은 결과가 반환되는 함수 (멱등성이 보장되는 순수함수) 가 테스트하기 좋은 코드였다.
            - 몇번을 수행해도 항상 같은 결과가 나오기 위해서는 아래 2가지 요소를 최대한 피해해야만 한다.
                - 제어할 수 없는 값에 의존하는 경우
                    - Random(), new Date() (LocalDate.now()) 와 같이 실행할때마다 결과가 다른 함수에 의존하는 경우
                    - readLine 혹은 inputBox 등 사용자들의 입력에 의존하는 경우
                    - 전역 함수, 전역 변수 등에 의존하는 경우
                    - PG사 라이브러리등 외부 SDK에 의존하는 경우

                - 외부에 영향을 주는 코드
                    - console.log, System.out.println() 과 같은 표준 출력
                    - Logger 등을 사용하는 경우
                    - 이메일 발송, 메세지큐 등 외부로의 메세지 발송
                    - 데이터베이스 등에 의존하는 경우
                    - 외부 API에 의존하는 경우

                    - 특히, 데이터베이스를 사용하는 테스트들은 느린 테스트의 주범이다.
                    - 특히, 데이터베이스를 사용하는 테스트들은 느린 테스트의 주범이다.
                    - 수백 ~ 수천개의 테스트 코드들을 수행하기 위해서 테스트 속도는 중요한데, 데이터베이스와 같이 외부환경을 사용하는 테스트가 많을수록 테스트 시간은 기하급수적으로 늘어난다.


    2. 제어할 수 없는 코드 개선
        - 문제 상황
            - 테스트하기 어려운 코드가 도메인 로직으로 되어있음을 의미
            - 도메인 로직이 테스트하기 어려운 것은 다른 계층에서 테스트가 어려운것 보다 훨씬 더 문제가 있다. 해당 로직의 테스트만 어려운게 아니라, 계층 전반의 테스트가 어려워진다
            - Order 의 테스트와 마찬가지로 제어할 수 없는 now() 로 인해 Repository, Service, Controller 등의 도메인 로직에 의존하는 모든 계층의 테스트가 어렵다.
            - 즉, 테스트의 어려움은 전파가 된다는 것이다.
            - 일반적인 계층형 아키텍처에서는 Controller -> Service -> Repository로 호출이 이어진다. 테스트하기 어려운 코드가 있다면 해당 코드에 의존하는 모든 코드들이 다 테스트하기 어렵다.
            - 그렇기 때문에 테스트하기 어려운 코드와 테스트하기 쉬운 코드를 분리해야만 한다. 둘을 분리해서, 테스트 하기 어려운 코드에 오염되는 영역을 최소화하는 것이 중요하다.

        - 해결 방법
            - 가장 쉬운 방법은 생성자, 함수(메소드)의 인자로 테스트하기 어려운 코드의 결과를 받는 것이다.
            - 이렇게 할 경우 다음과 같이 제어할 수 없는 시간이라는 값을 내가 원하는 값으로 지정해서 테스트를 작성할 수 있게 된다.
            - 물론 이렇게 할 경우 함수의 인자가 너무 많아지는 것은 아닌지 부담스럽게 느낄 수 있다.
                - 같은 Context 라고 생각되는 함수 인자들은 Dto 패턴 으로 묶어서 전달하거나
                - 의존성 주입을 통해 제어할 수 없는 값을 다루는 객체들은 생성자 주입을 받아서 사용하거나
                - (언어에 따라 다르지만) 함수 인자의 기본값을 사용하는 방법이 있다.

        - 제어할 수 없는 코드의 위치
            - 그럼 함수 인자의 기본값을 지원하지 않는 언어에서는 테스트하기 어려운 코드 (now()) 을 어디까지 미루면 좋을까?
              일반적으로 구조를 해치지 않는 범위 내에선 의존하는 코드가 가장 적은 영역까지 밀어내는 것이 좋다.

            - 가장 바깥쪽으로 밀어내기
                - 즉, 프로그램의 진입점이 되는 영역에 최대한 테스트하기 어려운 코드를 모아두고, 그 다음 계층부터 테스트 하기 좋은 코드로만 이루어지도록 한다.
                  최대한 제어할 수 없는 코드를 바깥으로 밀어내, 해당 코드에 의존하는 범위를 좁히는 것이다.

            - 의존성 주입
                - 다만, 위 방식에도 몇가지 문제가 있다.
                    - 진입 계층인 Controller의 테스트가 여전히 어렵다.
                    - Service, Repository, Component 등 여러 영역의 모든 함수가 제어할 수 없는 값을 항상 함수/메소드 인자로 받아야만 한다.
                - 그래서 이런 문제를 의존성 주입 패턴으로 풀때가 많다.
                - 제어할 수 없는 값을 반환하는 인터페이스를 두고, 이를 테스트와 메인코드에서 활용하는 것이다.


    3. 외부에 의존하는 코드 개선
        - Active Record 패턴은 금지하고, Data Mapper 패턴을 쓰도록 권장

        문제점 1. 복잡한 테스트 환경 구축
            - 간단한 주문 취소 정보를 생성하는 로직인데도 테스트 환경 구축에 많은 리소스가 필요

        문제점 2. 낮은 테스트 리팩토링 내구성
            - 이 테스트 코드는 외부 의존 대상이 교체될 때마다 많은 변화가 필요하다.
            - 만약 로직의 마지막 단계가 RDBMS로 저장하는 것이 아니라 아래와 같이 다른 저장소를 사용하는 방법으로 변경된다고 가정해보자.
                - 외부 API 호출로 변경되어야 한다면
                - NoSQL 등의 다른 데이터 솔루션으로 변경되어야 한다면
                - JSON 파일로 변경해서 S3 업로드로 변경되어야 한다면
            - 메소드의 마지막이 RDBMS라는 외부 의존성에 저장하는 기능이기 때문에 테스트 코드 역시 RDBMS라는 외부 의존성에서 결과물을 가져오는 것이 유일한 검증방법이다.
            - 마지막 검증 단계가 RDBMS에서 데이터를 꺼내와 비교하는 현재의 방법이라면 외부 의존성이 교체만 되어도 모든 테스트는 수정 대상이다.

            - 취소 주문 생성이라는 로직을 검증하는 테스트 코드이지만, 최종 저장하는 장소가 변경됨에 따라 테스트 코드 전반이 영향을 받게 된다.
              그만큼 테스트 리팩토링 내구성이 떨어짐을 의미한다.

        문제점 3. 지키기 어려운 일관성
            - 좋은 함수/메소드는 언제 실행해도 동일한 결과를 반환한다.
            - 외부 시스템에 의존하고 있다면 외부의 상황에 따라 언제든 다른 결과가 반환된다.

        문제점 4. 느린 테스트
            - RDBMS를 비롯한 외부 의존성이 있는 테스트는 수행속도가 느리다.
            - 테스트 환경에서 데이터베이스를 실행하고, 기존에 적재된 데이터가 있다면 테스트 수행전에 비워두어야 하고,
              매 테스트마다 대상 객체로 인해 insert, update 쿼리가 수행되어야하고, 테스트가 끝나면 데이터베이스를 종료해야 하는등 의
              작업으로 인해 도저히 테스트가 빠를 수가 없다.

        - 해결 방법
            - RDBMS에 저장하는 로직을 제외하면 나머지들은 검증하기가 쉽다. 결국 모든 문제가 로직 안에 외부 의존성이 포함되어있기 때문이다.
            - 원인을 알고 있으니, 해결 방법은 쉽다. 외부 의존성을 로직에서 떨어뜨려 놓는 것이다.

            - 도메인 로직과 외부 의존성의 거리가 멀수록 테스트하기가 쉽다.


    4. 검증이 필요한 비공개 함수
        - 지금까지 글들의 결론은 간단하다.
          테스트 하기 어려운 코드와 테스트 하기 쉬운 코드를 분리하되, 테스트 하기 어려운 코드는 최대한 바깥으로 몰아넣는다.

        - private 메소드/함수의 테스트 코드는 작성하지 않는 것이 좋을때가 많다. -> 테스트 코드에서 내부 구현 검증 피하기
        - 그럼에도 불구하고 private 메소드/함수를 검증해야할 경우가 있다.
            - 테스트가 없는 기존 private 코드를 리팩토링 해야하는 경우
            - 테스트하기 어려운 코드를 몰아넣은 Presentation (Controller, Handler 등), Service Infra 계층의 private 로직일 경우

        - 문제 상황
            - 만약 다음과 같이 HTTP API로 받은 값들을 검증하고, DB에 저장하는 코드가 있다고 해보자.
            - 이를 테스트 하기 위해서는 테스트하기 쉬운 코드와 어려운 코드를 분리해야만 한다.
              하지만 이미 서비스 인프라 계층에서 강하게 묶여있는 상황에서 어떻게 리팩토링 해야만 둘을 분리할 수 있을까?

        - 해결 방법
            - 해결책 1
                - 해당 로직이 도메인과 관련된 로직이라면 도메인 클래스에 위임한다.
                - 다만, 이 해결책을 사용할 수 없는 경우도 있다.
                - 검증하고자 하는 로직이 기존 도메인 로직에 담기에 모호하거나 여러 도메인이 공통적으로 필요로 하는 경우
                - 이를테면 이번 같이 금액 검증 로직은 Order 도메인에만 필요한 로직이 아니다
                  Order (주문) 외에 Billing (결제), Settle (정산), Menu (메뉴) 등등 여러 도메인이 금액 검증 로직이 필요하다.

            - 해결책 2
                - 이 경우 비공개 메소드/함수 (private) 들을 로직에 맞게 공개 함수 혹은 클래스로 묶어서 추출하는 방법이 있다.
                - 예를 들어 이번 테스트의 대상인 금액 검증 로직들은 도메인 측면에서 금액 (Money)에서 관리하도록 추출할 수 있다.
                - 기존 도메인 클래스인 Order 에서는 Money 객체를 메소드의 파라미터로 혹은 멤버변수로 사용하면 된다.


    5. SQL
        - 최근엔 ORM (혹은 ODM) 사용이 대중화되었지만, 여전히 많은 프로젝트에서는 SQL Builder를 통해서 Native Query를 작성한다.
        - SQL Builder를 통해서 Native Query를 작성하는 것은 복잡한 조회 조건이 필요한 환경에서는 굉장히 효율적인 방법이다.
        - 예를 들어, 통계/정산/물류 등 복잡한 조회 Query가 필요하거나, Bulk Insert등 쿼리 성능 개선이 필요한 경우에 Native Query가 계속 필요하다.

        - 문제 상황
            return queryBuilder.query(`
                SELECT *
                FROM blog
                WHERE publish_at <= NOW()
            `);

            - 실행할때마다 변경되는 현재 시간 SQL 함수 (NOW()) 가 쿼리 내부에 존재
            - 오늘이라는 조건이 고정되어있어, 특정 일자의 조회와 같은 기능 확장에 취약

        - 해결 방법
            - 쿼리문 내에서 비즈니스 로직을 파라미터로 받는다.
                return queryBuilder.query("
                    SELECT *
                    FROM blog
                    WHERE publish_at <= :now", {
                        now: now.toDate() // Date로 변환
                    }
                );

        - 마무리
            - SQL에서 직접 데이터를 처리하거나 로직(NOW(), DATE_SUB(), PASSWORD() 등)을 담고 있으면 테스트 구현과 기능 확장에 취약하다.
            - 가능하다면 SQL에서는 로직을 담지 말고, 저장소로서의 역할에만 충실하도록 구현하는 것이 좋다. 그래야만 테스트 구현이 쉽고, 기능 확장에 유리하다.

- 테스트 어려운 부분 끌어올리기   https://creampuffy.tistory.com/161
    테스트하기 어려운 부분을 더 상위로 끌어올려 테스트 가능하게 만들어보자 입니다.

    도메인 객체 Room에게 비밀번호 검증 책임을 맡기되,
    책임을 수행하는 과정에서 협력할 인터페이스를 함께 전달하도록 구성하여,
    Room이 비밀번호 암호화, 비교의 책임은 인터페이스에게 느슨하게 의존하였고,
    이로써 도메인 객체 Room에 대한 테스트가 쉬워졌습니다.

    추가로 서비스 레이어에서도 Room에게 메시지를 보내는 객체지향적 코드가 가능해졌습니다.

******** Effective Unit Testing
    https://velog.io/@beonit/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0

***** Effective Unit Testing -> 위 테스트의 전반적인 이야기를 예제코드와 함께 잘 소개
    http://www.yes24.com/Product/goods/11361087?scode=032&OzSrank=1

******* test code tip
    https://dev.gmarket.com/38

****** 회원가입 test code
    https://velog.io/@ililil9482/%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85-api-%EB%A7%8C%EB%93%A4%EA%B8%B0

******* spring security 적용 로그인
    https://github.com/sosow0212/ApiStudy/blob/master/src/main/java/self/study/controller/BoardController.java

****** 그저-그런-REST-API로-괜찮은가-진정한-REST-API-구현해보기
    https://velog.io/@carrykim/%EC%82%AC%EC%9D%B4%EB%93%9C%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B7%B8%EC%A0%80-%EA%B7%B8%EB%9F%B0-REST-API%EB%A1%9C-%EA%B4%9C%EC%B0%AE%EC%9D%80%EA%B0%80-%EC%A7%84%EC%A0%95%ED%95%9C-REST-API-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0-Event-Controller-Event-Exception-Handler

***** test tip
    롤백되는 기능은 편리하지만, 만약 트랜잭션이 보장되지 않았을 경우 실패하는 테스트를 작성했을 때 오히려 성공하는 경우가 많아서 사용하지 않는다고 하셨습니다.
    그래서 다음과 같이 @SpringBootTest와 함께 @After절에서 모든 데이터를 직접 삭제하는 방식으로 테스트를 작성한다고 가이드해 주셨습니다.

****** JPA 기반 테스트 코드 작성 팁
    https://cheese10yun.github.io/jpa-test-support/

***** Spring Guide - 테스트 전략
    https://cheese10yun.github.io/spring-guide-test-1/

****** JWT Spring-Security-Test로 테스트시 인증정보 주입
    https://shrewd.tistory.com/m/49

******* [TDD] 단위 테스트(Unit Test) 작성의 필요성
    https://mangkyu.tistory.com/143
    https://mangkyu.tistory.com/144
    https://mangkyu.tistory.com/145

***** 컨트롤러 테스트
    https://velog.io/@dooboocookie/%EC%9A%B0%ED%85%8C%EC%BD%94-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC%EC%97%90-%EB%8C%80%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8

- 메소드 시그니처를 변경하지 않고, 테스트 가능한 구조 만들기
    https://tecoble.techcourse.co.kr/post/2020-04-28-test-without-method-change/

- 메서드 시그니처를 수정하여 테스트하기 좋은 메서드로 만들기
    https://tecoble.techcourse.co.kr/post/2020-05-07-appropriate_method_for_test_by_parameter/

- 테스트코드 성능 개선기
    https://tecoble.techcourse.co.kr/post/2022-10-15-test-code-optimization/

- 외부 서버와의 통신을 테스트해보자
    https://tecoble.techcourse.co.kr/post/2020-09-30-mocking-server/

- 제네릭을 사용하여 테스트 중복 제거하기!
    https://tecoble.techcourse.co.kr/post/2020-09-20-test-refactor-generic/

- 서비스 추상화
    https://tecoble.techcourse.co.kr/post/2022-10-10-Service/

- LINE에서 테스트를 최적화하는 방법
    https://engineering.linecorp.com/ko/blog/testing-optimization

********** test code 속도 개선
    https://aroundck.tistory.com/6134

********** Effective Unit Testing
    https://aroundck.tistory.com/6107

********* gradle test log 설정
    https://somuchthings.tistory.com/105
    https://blog.hkwon.me/gradle-test-task-logging/

********* 유용한 테스트 코드 작성 팁
    https://dev.gmarket.com/38

********* mock vs stub
    https://azderica.github.io/00-test-mock-and-stub/
    https://ducktyping.tistory.com/17

- Mock은 Stub이 아니다(Mocks Aren't Stubs)
    https://jaime-note.tistory.com/330

- Test Double
    Dummy 객체는 전달되지만 실제로 사용되지는 않습니다. 일반적으로 매개변수 목록을 채우는 데만 사용됩니다.
    Fake 객체는 실제로 작동하는 구현을 가지고 있지만 일반적으로 프로덕션에는 적합하지 않은 방식을 취합니다. (메모리 기반 데이터베이스가 좋은 예시)
    Stub은 테스트 중에 만들어진 호출에 미리 준비된 답변을 제공하고 일반적으로 테스트를 위해 프로그래밍된 것 외에는 전혀 응답하지 않습니다.
    Spy는 그들이 어떻게 호출되었는지에 따라 일부 정보를 기록하는 Stub 입니다.
    Mock은 호출될 것으로 예상되는 사양을 형성하는 기대값으로 미리 프로그래밍 된 객체입니다.

- mockito 인터뷰 질문
    https://ko.myservername.com/top-12-mockito-interview-questions

- [Spring] 테스트를 위한 애플리케이션 컨텍스트 관리
    https://withseungryu.tistory.com/85

******* SpringBootTest @MockBean의 실행과정과 context reload
    https://taes-k.github.io/2022/02/02/spring-mockbean/


- 무엇을 테스트할 것인가? 어떻게 테스트할 것인가?
    https://www.youtube.com/watch?v=YdtknE_yPk4

Spring 에서는 보통 객체생성시 직접 생성하지 않고 Dependency Injection(DI)을 통해 프레임워크에 위임하여 생성하기 때문에
직접적으로 Mocking 테스트환경을 만드는것이 쉽지 않습니다.
이러한 어려움을 도와주는것이 바로 @MockBean과 @SpyBean입니다. Bean등록 과정에서 테스트에 필요한 Mocking객체를 기존 객체 대신에 Bean으로
등록시켜 사용할수 있게 만들어주기때문에 해당 Bean을 의존 하는 모든 다른 객체들에 DI하여 손쉽게 Mocking객체를 사용 할 수 있도록 해줍니다.


성능 테스트시 하지 말아야 할 Mocking 방식
1. 객체 Mocking

객체 Mocking은 테스트 코드를 작성할 때 가장 많이 사용하는 방식이라 친숙할 것 입니다. 그러나 로직에 대해 검증을 하는 테스트와 달리, 성능 테스트는 어플리케이션 동작과 자원의 사용을 모두 보아야만 하는 테스트입니다.

객체 Mocking 은 해당 객체의 행위 뒤로 들어가야 할 동작들을 무시해버리게 됩니다. 예를 들어 Spring Profile 을 사용하여 RestOpertation 을 객체를 Mock 처리하였을 때

http connection Pool 미사용
connection thread 미사용
io가 발생하지 않음
등등 성능 테스트에서 중요한 관점인 Thread 사용, 리소스 사용을 전부 무시하게 됩니다.

외부 인터페이스를 Mocking 하는 것처럼 보이지만, 내부 인터페이스도 Mocking 해버리는 객체 Mocking 은 성능 테스트에서 피해야 합니다.

