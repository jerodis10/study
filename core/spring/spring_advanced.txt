- 쓰레드 로컬 - ThreadLocal
    - 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결할 때 사용하는 것이 바로 쓰레드 로컬.
    - 쓰레드 로컬을 사용하면 각 쓰레드마다 별도의 내부 저장소를 제공한다. 따라서 같은 인스턴스의 쓰레드
      로컬 필드에 접근해도 문제 없다.
    - 쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

- 빌더 패턴


- 템플릿 메서드 패턴
    - 템플릿 메서드 패턴은 이렇게 다형성을 사용해서 변하는 부분과 변하지 않는 부분을 분리하는 방법.

    - 템플릿 메서드 패턴은 상속을 사용한다. 따라서 상속에서 오는 단점들을 그대로 안고간다. 특히 자식
      클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다. 이것은 의존관계에 대한 문제이다.
      자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는다.
      자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는데, 부모 클래스를 알아야한다. 이것은
      좋은 설계가 아니다. 그리고 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있다.

      상속 구조를 사용하기 때문에, 별도의 클래스나 익명 내부 클래스를 만들어야 하는 부분도 복잡하다.

    - 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 전략 패턴.


- 전략 패턴
    - 탬플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서
      상속을 사용해서 문제를 해결했다.
    - 전략 패턴은 변하지 않는 부분을 Context 라는 곳에 두고, 변하는 부분을 Strategy 라는 인터페이스를
      만들고 해당 인터페이스를 구현하도록 해서 문제를 해결한다. 상속이 아니라 위임으로 문제를 해결하는
      것이다.

    - ContextV1 은 필드에 Strategy 를 저장하는 방식으로 전략 패턴을 구사했다.
        - 선 조립, 후 실행 방법에 적합하다.
        - Context 를 실행하는 시점에는 이미 조립이 끝났기 때문에 전략을 신경쓰지 않고 단순히 실행만 하면 된다.
    - ContextV2 는 파라미터에 Strategy 를 전달받는 방식으로 전략 패턴을 구사했다.
        - 실행할 때 마다 전략을 유연하게 변경할 수 있다.
        - 단점 역시 실행할 때 마다 전략을 계속 지정해주어야 한다는 점이다.


- 템플릿 콜백 패턴
    - callback 은 코드가 호출( call )은 되는데 코드를 넘겨준 곳의 뒤( back )에서
      실행된다는 뜻이다.

    - 참고로 템플릿 콜백 패턴은 GOF 패턴은 아니고, 스프링 내부에서 이런 방식을 자주 사용하기 때문에,
      스프링 안에서만 이렇게 부른다. 전략 패턴에서 템플릿과 콜백 부분이 강조된 패턴이라 생각하면 된다.

    - 스프링에서는 JdbcTemplate , RestTemplate , TransactionTemplate , RedisTemplate 처럼 다양한
      템플릿 콜백 패턴이 사용된다. 스프링에서 이름에 XxxTemplate 가 있다면 템플릿 콜백 패턴으로 만들어져
      있다 생각하면 된다.


- 프록시 패턴
    - 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공


- 데코레이터 패턴
    - 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공


* 인터페이스 기반 프록시 vs 클래스 기반 프록시
    - 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
      부모 클래스의 생성자를 호출해야 한다.(앞서 본 예제)
      클래스에 final 키워드가 붙으면 상속이 불가능하다.
      메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.

    - 인터페이스 기반의 프록시는 상속이라는
      제약에서 자유롭다. 프로그래밍 관점에서도 인터페이스를 사용하는 것이 역할과 구현을 명확하게 나누기
      때문에 더 좋다.
      인터페이스 기반 프록시의 단점은 인터페이스가 필요하다는 그 자체이다. 인터페이스가 없으면 인터페이스
      기반 프록시를 만들 수 없다.


- 동적 프록시
    - 리플렉션
        - 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.
        - 리플렉션 기술은 런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다.
        - 그러나 해당 코드를 직접 실행하는 시점에 발생하는 오류인 런타임 오류가 발생한다.
        - 리플렉션은 프레임워크 개발이나 또는 매우 일반적인 공통 처리가 필요할 때 부분적으로 주의해서 사용해야 한다.

    - JDK 동적 프록시
        - JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다. 따라서 인터페이스가 필수이다.

    - CGLIB
        - 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리.
        - CGLIB 를 사용하면 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다.

        - 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
            - 부모 클래스의 생성자를 체크해야 한다. CGLIB 는 자식 클래스를 동적으로 생성하기 때문에 기본
              생성자가 필요하다.
            - 클래스에 final 키워드가 붙으면 상속이 불가능하다. CGLIB 에서는 예외가 발생한다.
            - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다. CGLIB 에서는 프록시
              로직이 동작하지 않는다

    - 프록시 팩토리
        - 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB 를 사용한다. 그리고 이 설정을 변경할 수도 있다.

        - 두 기술을 함께 사용할 때 부가 기능을 적용하기 위해 JDK 동적 프록시가 제공하는
          InvocationHandler 와 CGLIB 가 제공하는 MethodInterceptor 를 각각 중복으로 따로 만들어야 할까?
            -> 스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 Advice 라는 새로운 개념을 도입했다. 개발자는
               InvocationHandler 나 MethodInterceptor 를 신경쓰지 않고, Advice 만 만들면 된다.
               결과적으로 InvocationHandler 나 MethodInterceptor 는 Advice 를 호출하게 된다.
               프록시 팩토리를 사용하면 Advice 를 호출하는 전용 InvocationHandler , MethodInterceptor 를
               내부에서 사용한다
               둘을 개념적으로 추상화 한 것이다.

    - 프인트컷, 어드바이스, 어드바이저
        - 포인트컷: 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직이다.
                  주로 클래스와 메서드 이름으로 필터링 한다.
        - 어드바이스: 프록시가 호출하는 부가 기능이다. 단순하게 프록시 로직이라 생각하면 된다
        - 어드바이저: 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게 이야기해서 포인트컷1 + 어드바이스1이다.

        정리하면 부가 기능 로직을 적용해야 하는데, 포인트컷으로 어디에? 적용할지 선택하고, 어드바이스로 어떤
        로직을 적용할지 선택하는 것이다. 그리고 어디에? 어떤 로직?을 모두 알고 있는 것이 어드바이저이다.

        - target 에 여러 AOP 가 동시에 적용되어도, 스프링의 AOP 는 target 마다 하나의 프록시만 생성한다.

        - 너무 많은 설정, 컴포넌트 스캔을 사용하는 경우 프록시 적용 불가능
          -> 두 가지 문제를 한번에 해결하는 방법이 바로 다음에 설명할 빈 후처리기이다.

    - 빈 후처리기 (BeanPostProcessor)
        - 빈을 생성한 후에 무언가를 처리하는 용도로 사용

        - 빈 등록 과정을 빈 후처리기와 함께 살펴보자
            1. 생성: 스프링 빈 대상이 되는 객체를 생성한다. (@Bean , 컴포넌트 스캔 모두 포함)
            2. 전달: 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
            3. 후 처리 작업: 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바뀌치기 할 수 있다.
            4. 등록: 빈 후처리기는 빈을 반환한다. 전달 된 빈을 그대로 반환하면 해당 빈이 등록되고, 바꿔치기 하면
            다른 객체가 빈 저장소에 등록된다.

        - 정리
          빈 후처리기는 빈을 조작하고 변경할 수 있는 후킹 포인트이다.
          이것은 빈 객체를 조작하거나 심지어 다른 객체로 바꾸어 버릴 수 있을 정도로 막강하다.
          여기서 조작이라는 것은 해당 객체의 특정 메서드를 호출하는 것을 뜻한다.
          일반적으로 스프링 컨테이너가 등록하는, 특히 컴포넌트 스캔의 대상이 되는 빈들은 중간에 조작할 방법이
          없는데, 빈 후처리기를 사용하면 개발자가 등록하는 모든 빈을 중간에 조작할 수 있다. 이 말은 빈 객체를
          프록시로 교체하는 것도 가능하다는 뜻이다.

          빈 후처리기 덕분에 프록시를 생성하는 부분을 하나로 집중할 수 있다. 그리고 컴포넌트 스캔처럼 스프링이
          직접 대상을 빈으로 등록하는 경우에도 중간에 빈 등록 과정을 가로채서 원본 대신에 프록시를 스프링
          빈으로 등록할 수 있다.

        - 결과적으로 포인트컷은 다음 두 곳에 사용된다.
            1. 프록시 적용 대상 여부를 체크해서 꼭 필요한 곳에만 프록시를 적용한다. (빈 후처리기 - 자동 프록시 생성)
            2. 프록시의 어떤 메서드가 호출 되었을 때 어드바이스를 적용할 지 판단한다. (프록시 내부)

        - 프록시를 모든 곳에 생성하는 것은 비용 낭비이다. 꼭 필요한 곳에 최소한의 프록시를 적용해야 한다.
          그래서 자동 프록시 생성기는 모든 스프링 빈에 프록시를 적용하는 것이 아니라 포인트컷으로 한번
          필터링해서 어드바이스가 사용될 가능성이 있는 곳에만 프록시를 생성한다.

        - 자동 프록시 생성기는 2가지 일을 한다.
          1. @Aspect 를 보고 어드바이저( Advisor )로 변환해서 저장한다.
          2. 어드바이저를 기반으로 프록시를 생성한다.


    - 소프트웨어 개발에서 변경 지점은 하나가 될 수 있도록 잘 모듈화 되어야 한다. 그런데 부가 기능처럼 특정
      로직을 애플리케이션 전반에 적용하는 문제는 일반적인 OOP 방식으로는 해결이 어렵다.

    - AspectJ 프레임워크는 스스로를 다음과 같이 설명한다.
    - 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
      횡단 관심사의 깔끔한 모듈화
      오류 검사 및 처리
      동기화
      성능 최적화(캐싱)
      모니터링 및 로깅

    - AOP 적용 방식
        컴파일 시점
        클래스 로딩 시점
        런타임 시점(프록시)

        - 컴파일 시점 - 위빙
            .java 소스 코드를 컴파일러를 사용해서 .class 를 만드는 시점에 부가 기능 로직을 추가할 수 있다.
            이때는 AspectJ가 제공하는 특별한 컴파일러를 사용해야 한다. 컴파일 된 .class 를 디컴파일 해보면
            애스펙트 관련 호출 코드가 들어간다. 이해하기 쉽게 풀어서 이야기하면 부가 기능 코드가 핵심 기능이 있는
            컴파일된 코드 주변에 실제로 붙어 버린다고 생각하면 된다. AspectJ 컴파일러는 Aspect 를 확인해서 해당
            클래스가 적용 대상인지 먼저 확인하고, 적용 대상인 경우에 부가 기능 로직을 적용한다.
            참고로 이렇게 원본 로직에 부가 기능 로직이 추가되는 것을 위빙(Weaving)이라 한다.

            - 단점
              컴파일 시점에 부가 기능을 적용하려면 특별한 컴파일러도 필요하고 복잡하다.

        - 클래스 로딩 시점
            자바를 실행하면 자바 언어는 .class 파일을 JVM 내부의 클래스 로더에 보관한다. 이때
            중간에서 .class 파일을 조작한 다음 JVM 에 올릴 수 있다.

            - 단점
              로드 타임 위빙은 자바를 실행할 때 특별한 옵션( java -javaagent )을 통해 클래스 로더 조작기를
              지정해야 하는데, 이 부분이 번거롭고 운영하기 어렵다

        - 런타임 시점
            런타임 시점은 컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 말한다.
            자바의 메인( main ) 메서드가 이미 실행된 다음이다. 따라서 자바 언어가 제공하는 범위 안에서
            부가 기능을 적용해야 한다. 프록시 방식의 AOP 가 이 방식이다.

    - AOP 적용 위치
        - AOP 는 지금까지 학습한 메서드 실행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용할 수 있다.
        - 적용 가능 지점(조인 포인트): 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
          이렇게 AOP 를 적용할 수 있는 지점을 조인 포인트(Join point)라 한다.
        - AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP 는 바이트코드를 실제 조작하기
          때문에 해당 기능을 모든 지점에 다 적용할 수 있다.
        - 프록시 방식을 사용하는 스프링 AOP 는 메서드 실행 지점에만 AOP 를 적용할 수 있다.
            - 프록시는 메서드 오버라이딩 개념으로 동작한다. 따라서 생성자나 static 메서드, 필드 값 접근에는
            - 프록시 개념이 적용될 수 없다.
            - 프록시를 사용하는 스프링 AOP 의 조인 포인트는 메서드 실행으로 제한된다.
        - 프록시 방식을 사용하는 스프링 AOP 는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP 를 적용할 수 있다.