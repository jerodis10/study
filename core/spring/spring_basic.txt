- 스프링
    - 스프링 버전

    - 스프링이란
        - 좋은 객체 지향 어플리케이션을 개발할 수 있도록 도와주는 프레임워크
        - 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트
        - 웹 기술: 스프링 MVC, 스프링 WebFlux
        - 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
        - 테스트: 스프링 기반 테스트 지원

    - 스프링과 스프링 부트 차이 (스프링 부트 이점)
        - 스프링을 편리하게 사용할 수 있도록 지원
        - Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
        - 스타터를 통해 필요한 라이브러리들을 묶어서 패키지처럼 제공
        - @SpringBootApplication 으로 복잡한 환경설정 없이도 웹 어플리케이션을 만들고 실행.
          이 애노테이션으로 인해 자동설정 기능이 동작하여 수많은 빈들이 등록되고 동작.(@EnableAutoConfiguration)
        - https://wiper2019.tistory.com/207

    - 객체 지향 프로그래밍이란
        - 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로
          파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
        - 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

    - 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
        1.SRP: 단일 책임 원칙
            - 한 클래스는 하나의 책임만 가져야 한다.
            - 하나의 책임이라는 것은 모호하다.
                - 클 수 있고, 작을 수 있다.
                - 문맥과 상황에 따라 다르다.
            - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
                ex) UI 변경, 객체의 생성과 사용을 분리

        2.OCP: 개방-폐쇄 원칙
            - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
            - 다형성 활용

        3.LSP: 리스코프 치환 원칙
            - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
            - 다향성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다향성을 지원하기 위한 원칙
            - 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
            - 단순히 컴파일에 성공하는 것을 넘어서는 이야기
            ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함.

        4.ISP: 인터페이스 분리 원칙
            - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
            ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
                사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트
            - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
            - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

        5.DIP: 의존관계 역전 원칙
            - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다."
            - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻.
            - 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.
            - 구현체에 의존하게 되면 변경이 아주 어려워 진다.

        * 인터페이스를 통한 다형성, 스프링의 DI 를 통해 역할과 구현을 분리하고
          그로 인해 OCP , DIP 원칙을 지킬 수 있다.
        => 이상적으로는 모든 설계에 인터페이스를 부여하자.
        => 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
        => 기능을 확장할 가능성이 없다면, 구현 클래스를 직접 사용하고, 향후 꼭 필요한 리팩터링해서 인터페이스를 도입하는 것도 방법.

    - DI
        자바 객체들을 컨테이너 안에 넣어두고 의존관계를 연결해주고 주입해주는 기능

    - AOP
        - 관심사의 분리
        - 제어의 역전 IoC
            - 프로그램 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것

    - 스프링 빈
        - 스프링 컨테이너와 스프링 빈
            - BeanFactory 라는 스프링 컨테이너의 최상위 인터페이스가 존재.
            - 스프링 빈을 관리하고, 조회하는 역할을 담당
            - BeanFactory 기능을 모두 상속받아서 국제화, 환경변수, 이벤트 등 부가 기능을 제공하는 것이 ApplicationContext
            - 스프링 컨테이너는 다양한 형식의 설정 정보를 BeanDefinition 으로 추상화해서 사용.
            - BeanDefinition 를 통해 빈 메타 정보를 생성하고 이걸 기반으로 스프링 빈 생성.

        - 싱글톤 컨테이너
            - 싱글톤 패턴
                - 클래스의 인스턴스가 한 자바 서버 안에서 딱 1개만 생선되는 것을 보장하는 디자인 패턴.
                - 싱글톤 패턴의 문제점
                    - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어감
                    - DIP, OCP 원칙을 위반할 가능성이 높음.
                    - 테스트하기 어렵다.
                    - 내부 속성을 변경하거나 초기화 하기 어렵다.
                    - private 생성자로 자식 클래스를 만들기 어렵다.

            - 싱글톤 컨테이너
                - 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리

            - @Configuration 과 싱글톤
                - 스프링이 CGLIB 라는 바이트코드 조작 라이브러리를 사용해서 Config 클래스를 상속받은
                  임의의 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것.
                - 이 임의의 다른 클래스가 바로 싱글톤이 보장.
                - @Bean 이 붙은 메서드마다 이미 스프링 빈이 존재하면 빈을 반환하고, 스프링 빈이 없으면 생성해서
                  스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.

        - 빈 등록
            - 자동 빈 등록 -> @ComponentScan
                - includeFilters, excludeFilters 옵션으로 필터 가능
                - 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, 개인적으로는 옵션을 변경하면서 사용하기보다는 스프링의 기본 설정에
                  최대한 맞추어 사용하는 것을 권장
            - 수동 빈 등록 -> @Configuration

            - @Bean vs @Component
                - @Bean 은 메소드 레벨에서 선언하며, 반환되는 객체(인스턴스)를 개발자가 수동으로 빈으로 등록하는 애노테이션이다.
                - @Component 는 클래스 레벨에서 선언함으로써 스프링이 런타임시에 컴포넌트스캔을 하여
                  자동으로 빈을 찾고(detect) 등록하는 애노테이션이다.
                - 개발자가 컨트롤이 불가능한 외부 라이브러리를 빈으로 등록하고 싶을때 @Bean 을 사용하며,
                  개발자가 직접 컨트롤이 가능한 클래스의 경우 @Component 를 사용

                - @Configuration 을 따로 만든 이유는 CGLib 으로 프록시 패턴을 적용해 수동으로 등록하는 스프링 빈이 반드시
                  싱글톤으로 생성됨을 보장하기 위해서
                - @Component 를 이용해 자동으로 빈 등록을 한다면 스프링이 해당 클래스의 객체의 생성을 제어하게 되고(제어의 역전, IoC)
                  1개의 객체만 생성되도록 컨트롤할 수 있다. 하지만 위의 클래스를 @Bean 을 사용해 직접 빈으로 등록해준다고 하자.
                  그러면 우리는 다음과 같이 해당 빈 등록 메소드를 여러 번 호출할 수 있게 된다.

                - https://mangkyu.tistory.com/75   https://mangkyu.tistory.com/234

            - 탐색 위치와 기본 스캔 대상
                - @Controller: 스프링 MVC 컨트롤러로 인식
                    - @Controller 의 역할은 Model 객체를 만들어 데이터를 담고 View 를 반환하는 것.
                    - @RestController 는 단순히 객체만을 반환하고 객체 데이터는 JSON 또는 XML 형식으로 HTTP 응답에 담아 전송
                        - RESTful 웹 서비스의 컨트롤러인 @RestController 의 주요한 차이점은 HTTP Response Body 가 생성되는 방식
                - @Repository: 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
                - @Configuration: 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.
                - @Service: 사실 @Service 는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고
                  비즈니스 계층을 인식하는데 도움이 된다.

            - 중복 등록과 충돌
                - 자동 빈 등록 vs 자동 빈 등록
                    - 이름이 같은 경우 스프링은 오류를 발생시킨다.
                - 수동 빈 등록 vs 자동 빈 등록
                    - 수동 빈이 자동 빈을 오버라이딩 해버린다.
                    - 하지만 보통 여러 설정들이 꼬여서 버그가 발생하는 경우가 많다.

            - 조회 빈이 2개 이상 - 문제
                - @Autowired
                    - 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 매칭
                - @Qualifier
                    - @Qualifier 끼리 매칭
                    - 빈 이름 매칭
                    - noSuchBeanDefinitionException 예외 발생
                - @Primary
                    - @Autowired 시에 여러 빈이 매칭되면 @Primary 가 우선권을 가진다.

            => 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로 나타나게 하는
               것이 유지보수 하기 좋다.

        - 빈 생명주기 콜백
            - 스프링 빈의 이벤트 라이프사이클
                스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
                (생성자 주입의 경우 스프링 빈 생성시, 필드나 세터 주입의 경우 의존관계 주입시 스프링 빈이 들어옴.)

            * 객체의 생성과 초기화를 분리하자
                - 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에 초기화는
                  이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행한다.
                  따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분
                  을 명확하게 나누는 것이 유지보수 관점에서 좋다. 물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단
                  순한 경우에는 생성자에서 한번에 다 처리하는게 더 나을 수 있다.

            - 애노테이션 @PostConstruct, @PreDestroy
                - 스프링에 종속적인 기술이 아니라 JSR-250 라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
                - 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면
                  @Bean 의 initMethod , destroyMethod 를 사용하자.

        - 빈 스코프
            - 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
            - 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
            - 웹 관련 스코프
                - request: 웹 요청이 들어오고 나갈 때까지 유지되는 스코프
                - session: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
                - application: 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

            - 프로토타입 스코프
                - 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다. 클라이언트에 빈을 반환하고,
                  이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다. 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은
                  클라이언트에 있다. 그래서 @PreDestroy 같은 종료 메서드가 호출되지 않는다.

                - 싱글톤 빈과 함께 사용시 문제점
                    - 싱글톤에서 프로토타입 빈을 사용하게 되면 싱글톤 빈은 생성 시점에만 의존관계가 주입을 받기 때문에,
                      프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제다.
                    - 지정한 빈을 컨테이너 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider.
                      ObjectProvider 을 통해서 항상 새로운 프로토타입 빈을 생성


    - 디자인 패턴
    - TDD
    - REST API
    - MSA
    - POST, GET 리다이렉트 문제