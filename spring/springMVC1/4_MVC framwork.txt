4.MVC 프레임워크 만들기
    4.1 프론트 컨트롤러 패턴 소개
        - FrontController 패턴 특징
            - 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
            - 프론트 컨트롤러 요청에 맞는 컨트롤러를 찾아서 호출
            - 입구를 하나로
            - 공통 처리 가능
            - 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨
            - spring web MCV 의 핵심도 바로 FrontController
            - spring web MCV 의 DispatcherServlet 이 FronController 패턴으로 구현되어 있음

    4.2 프론트 컨트롤러 도입 - v1
        - 프론트 컨트롤러 분석
            - urlPatterns
              urlPatterns = "/front-controller/v1/*" : /front-controller/v1 를 포함한 하위 모든 요청은 이 서블릿에서 받아들인다.
              예) /front-controller/v1 , /front-controller/v1/a , /front-controller/v1/a/b

            - controllerMap
              key: 매핑 URL
              value: 호출될 컨트롤러

            - service()
              먼저 requestURI 를 조회해서 실제 호출할 컨트롤러를 controllerMap 에서 찾는다. 만약 없다면 404(SC_NOT_FOUND) 상태 코드를 반환한다.
              컨트롤러를 찾고 controller.process(request, response); 을 호출해서 해당 컨트롤러를 실행한다.

            - JSP
              JSP 는 이전 MVC 에서 사용했던 것을 그대로 사용한다.

    4.3 View 분리 - v2
        - MyView 객체의 render() 를 호출하는 부분을 모두 일관되게 처리할 수 있다.
          각각의 컨트롤러는 MyView 객체를 생성만 해서 반환하면 된다.

    4.4 Model 추가 - v3
        - 서블릿 종속성 제거
            - 컨트롤러 입장에서 HttpServletRequest, HttpServletResponse 이 꼭 필요할까?
              요청 파라미터 정보는 자바의 Map 으로 대신 넘기도록 하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작할 수 있다.
              그리고 request 객체를 Model 로 사용하는 대신에 별도의 Model 객체를 만들어서 반환하면 된다.
              우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 변경해보자.
              이렇게 하면 구현 코드도 매우 단순해지고, 테스트 코드 작성이 쉽다.

            - ModelView
                - 지금까지 컨트롤러에서 서블릿에 종속적인 HttpServletRequest 를 사용했다. 그리고 Model 도
                  request.setAttribute() 를 통해 데이터를 저장하고 뷰에 전달했다.
                  서블릿의 종속성을 제거하기 위해 Model 을 직접 만들고, 추가로 View 이름까지 전달하는 객체를 만들어보자.
                  (이번 버전에서는 컨트롤러에서 HttpServletRequest 를 사용할 수 없다. 따라서 직접
                  request.setAttribute() 를 호출할 수 도 없다. 따라서 Model 이 별도로 필요하다.)

        - 뷰 이름 중복 제거
            - 컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인할 수 있다.
              컨트롤러는 뷰의 논리 이름을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화 하자.
              이렇게 해두면 향후 뷰의 폴더 위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다.

    4.5 단순하고 실용적인 컨트롤러 - v4
        - 기본적인 구조는 V3와 같다. 대신에 컨트롤러가 ModelView 를 반환하지 않고, ViewName 만 반환한다.

    4.6 유연한 컨트롤러1 - v5
        - 어댑터 패턴
            - 지금까지 우리가 개발한 프론트 컨트롤러는 한가지 방식의 컨트롤러 인터페이스만 사용할 수 있다.
              ControllerV3 , ControllerV4 는 완전히 다른 인터페이스이다. 따라서 호환이 불가능하다. 마치 v3는
              110v이고, v4는 220v 전기 콘센트 같은 것이다. 이럴 때 사용하는 것이 바로 어댑터이다.
              어댑터 패턴을 사용해서 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경해보자.

            - 핸들러 어댑터: 중간에 어댑터 역할을 하는 어댑터가 추가되었는데 이름이 핸들러 어댑터이다. 여기서
                           어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.

            - 핸들러: 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경했다. 그 이유는 이제 어댑터가 있기 때문에 꼭
                     컨트롤러의 개념 뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문이다.

            - 컨트롤러(Controller) 핸들러(Handler)
                - 이전에는 컨트롤러를 직접 매핑해서 사용했다. 그런데 이제는 어댑터를 사용하기 때문에, 컨트롤러 뿐만
                  아니라 어댑터가 지원하기만 하면, 어떤 것이라도 URL 에 매핑해서 사용할 수 있다. 그래서 이름을
                  컨트롤러에서 더 넒은 범위의 핸들러로 변경했다.

            - 생성자
                - 핸들러 매핑과 어댑터 초기화

            - 매핑 정보
                - 매핑 정보의 값이 ControllerV3 , ControllerV4 같은 인터페이스에서 아무 값이나 받을 수 있는 Object 로 변경되었다.

            - 핸들러 매핑
                - 핸들러 매핑 정보인 handlerMappingMap 에서 URL 에 매핑된 핸들러(컨트롤러) 객체를 찾아서 반환한다.

            - 핸들러를 처리할 수 있는 어댑터 조회
                - handler 를 처리할 수 있는 어댑터를 adapter.supports(handler) 를 통해서 찾는다.
                  handler 가 ControllerV3 인터페이스를 구현했다면, ControllerV3HandlerAdapter 객체가 반환된다.

            - 어댑터 호출
                - 어댑터의 handle(request, response, handler) 메서드를 통해 실제 어댑터가 호출된다.
                  어댑터는 handler(컨트롤러)를 호출하고 그 결과를 어댑터에 맞추어 반환한다.

    4.7 유연한 컨트롤러2 - v5
        - 어댑터가 호출하는 ControllerV4 는 뷰의 이름을 반환한다. 그런데 어댑터는 뷰의 이름이 아니라
          ModelView 를 만들어서 반환해야 한다. 여기서 어댑터가 꼭 필요한 이유가 나온다.
          ControllerV4 는 뷰의 이름을 반환했지만, 어댑터는 이것을 ModelView 로 만들어서 형식을 맞추어 반환한다.

    4.8 정리
        - v1: 프론트 컨트롤러 도입
            - 기존 구조를 최대한 유지하면서 프론트 컨트롤러를 도입

        - v2: View 분류
            - 단순 반복되는 뷰 로직 분리

        - v3: Model 추가
            - 서블릿 종속성 제거
            - 뷰 이름 중복 제거

        - v4: 단순하고 실용적인 컨트롤러
            - v3와 거의 비슷
            - 구현 입장에서 ModelView 를 직접 생성해서 반환하지 않도록 편리한 인터페이스 제공

        - v5: 유연한 컨트롤러
            - 어댑터 도입
            - 어댑터를 추가해서 프레임워크를 유연하고 확장성 있게 설계

        - 작성한 코드는 스프링 MVC 프레임워크의 핵심 코드의 축약 버전이고, 구조도 거의 같다.

    * tip
        - 구조적인 큰걸 개선할 때랑, 디테일한 부분을 개선할 때랑 서로 레벨이 다른 상황을 개선할 때는 같은 레벨끼리만 먼저 개선하는게 낫다.
          구조적인 걸 개선할 때는 구조적인 것만 먼저.

        - 프레임워크나 공통 기능이 수고로워야 사용하는 개발자가 편리해진다.
