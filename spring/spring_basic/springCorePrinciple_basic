1.객체 지향 설계와 스프링
    1.1 스프링 프레임워크
        - 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
        - 웹 기술: 스프링 MVC, 스프링 WebFlux
        - 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원,XML 지원
        - 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
        - 테스트: 스프링 기반 테스트 지원
        - 언어: 코틀린, 그루비
        - 최근에는 스프링 부트를 통해서 스프링 프레임워크 기술들을 편리하게 사용

    1.2 스프링 부트
        - 스프링을 편리하게 사용할 수 있도록 지원
        - 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
        - Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
        - 손쉬운 빌드 구성을 위한 starter 종속성 제공
        - 스프링과 3rd part(외부) 라이브러리 자동 구성
        - 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
        - 관례에 의한 간결한 설정

    1.3 스프링의 진짜 핵심
        - 스프링은 자바 언어 기반의 프레임워크
        - 자바 언어의 가장 큰 특징 - 객체 지향 언어
        - 스프링은 객체 지향 언어가 가진 가장 강력한 특징을 살려내는 프레임워크
        - 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크

    1.4 객체 지향 프로그래밍
        - 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로
          파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
        - 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

    1.5 객체 지향 특징
        - 다형성
            - 역할과 구현으로 세상을 구분
            - 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.
                - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
                - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
                - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
                - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
            - 역할 = 인터페이스,  구현 = 인터페이스를 구현한 클래스, 구현 객체
            - 객체 설계시 역할(인터페이스)를 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기
            - 다형성의 본질
                - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
                - 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함.
                - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
            - 정리
                - 유연하고, 변경이 용이
                - 확장 가능한 설계
                - 클라이언트에 영향을 주지 않는 변경 가능
                - 인터페이스를 안정적으로 잘 설계하는 것이 중요
            - 단점
                - 역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다.
            - 스프링과 객체지향
                - 다형성이 가장 중요하다.
                - 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
                - 스프링에서 얘기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원
        - 추상화, 캡슐화, 상속

    1.6 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
        1.SRP: 단일 책임 원칙
            - 한 클래스는 하나의 책임만 가져야 한다.
            - 하나의 책임이라는 것은 모호하다.
                - 클 수 있고, 작을 수 있다.
                - 문맥과 상황에 따라 다르다.
            - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
                ex) UI 변경, 객체의 생성과 사용을 분리

        2.OCP: 개방-폐쇄 원칙
            - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
            - 다형성 활용

        3.LSP: 리스코프 치환 원칙
            - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
            - 다향성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다향성을 지원하기 위한 원칙
            - 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
            - 단순히 컴파일에 성공하는 것을 넘어서는 이야기
            ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함.

        4.ISP: 인터페이스 분리 원칙
            - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
            ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
                사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트
            - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
            - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

        5.DIP: 의존관계 역전 원칙
            - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다."
            - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻.
            - 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.
            - 구현체에 의존하게 되면 변경이 아주 어려워 진다.

        * 다형성 만으로는 OCP, DIP 를 지킬 수 없다. 뭔가 더 필요하다.

    1.7 객체 지향 설계와 스프링
        - 스프링은 다음 기술로 다형성 + OCP, DIP 를 가능하게 지원
            - DI: 의존관계 주입
            - DI 컨테이너 제공 - 자바 객체들을 컨테이너 안에 넣어두고 의존관계를 연결해주고 주입해주는 기능
        - 클라이언트 코드의 변경 없이 기능 확장

        => 모든 설계에 역할과 구현을 분리하자.
        => 이상적으로는 모든 설계에 인터페이스를 부여하자.
        => 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
        => 기능을 확장할 가능성이 없다면, 구현 클래스를 직접 사용하고, 향후 꼭 필요한 리팩터링해서 인터페이스를 도입하는 것도 방법.


2.스프링 핵심 원리 이해 - 객체 지향 원리 적용
    - 관심사의 분리
        - AppConfig 활용
    - 제어의 역전 IoC
        - 프로그램 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것
            - 프레임워크: 내가 작성한 코드를 제어하고, 대신 실행
            - 라이브러리: 내가 작성한 코드가 직접 제어의 흐름을 담당
        - 의존 관계는 정적인 클래스 의존 관계와 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.


3.스프링 컨테이너와 스프링 빈
    - 스프링 컨테이너 생성
        - 스프링 컨테이너는 XML 을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.

        1.스프링 컨테이너 생성
            - new AnnotationConfigApplicationContext(AppConfig.class)
            - 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다.
            - 여기서는 AppConfig.class 를 구성 정보로 지정했다.
        2.스프링 빈 등록
            - 빈 이름은 항상 다른 이름을 부여해야 한다. 같은 이름을 부여하면, 다른 빈이 무시되거나, 기존 빈을 덮어버리거나
              설정에 따라 오류가 발생한다.
        3.스프링 빈 의존관계 설정

    - BeanFactory 와 ApplicationContext
        - BeanFactory
            - 스프링 컨테이너의 최상위 인터페이스다.
            - 스프링 빈을 관리하고, 조회하는 역할을 담당한다.
            - getBean()을 제공한다.
            - 지금까지 우리가 사용했던 대부분의 기능은 BeanFactory 가 제공하는 기능이다.
        - ApplicationContext
            - BeanFactory 기능을 모두 상속받아서 제공한다.
            - 빈을 제공하고 검색하는 기능을 BeanFactory 가 제공
            - 그외 부가기능 제공
                - 메시지소스를 활용한 국제화 기능
                - 환경변수: 로컬, 개발, 운영 등을 구분해서 처리
                - 애플리케이션 이벤트: 이벤트를 발행하고 구독하는 모델을 편리하게 지원
                - 편리한 리소스 조회: 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

        - 스프링 빈 설정 메타 정보 - BeanDefinition
            - 역할과 구현을 개념적으로 나눈 것
            - 스프링 컨테이너 -> BeanDefinition -> AppConfig.class
                                             -> AppConfig.xml
                                             -> AppConfig.xxx
            - 자바 코드, xml 등을 읽어서 BeanDefinition 을 만들면 된다.
            - @Bean, <bean> 당 각각 하나씩 메타 정보가 생성된다.
            - 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.
            - AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서
              AppConfig.class 를 읽고 BeanDefinition 을 생성한다.
            - GeneficXmlApplicationContext 는 XmlBeanBeanDefinitionReader 를 사용해서
              Appconfig.xml 설정 정보를 읽고 BeanDefinition 을 생성한다.


4.싱글톤 컨테이너
    - 스프링 없는 순수한 DI 컨테이너인 AppConfig 는 요청을 할 때마다 객체를 새로 생성한다.
    - 고객 트래픽이 초당 100이 나오면 초당 100개 객체가 생성되고 소멸된다. -> 메모리 낭비가 심하다.
    - 싱글톤 패턴
        - 클래스의 인스턴스가 한 자바 서버 안에서 딱 1개만 생선되는 것을 보장하는 디자인 패턴
        - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.
        - 싱글톤 패턴 문제점
            - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어감
            - 의존관계상 클라이언트가 구체 클래스에 의존 -> DIP 위반
            - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
            - 테스트하기 어렵다.
            - 내부 속성을 변경하거나 초기화 하기 어렵다.
            - private 생성자로 자식 클래스를 만들기 어렵다.
            - 결론적으로 유연성이 떨어진다.
            - 안티패턴으로 불리기도 한다.

    - 싱글톤 컨테이너
        - 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리
        - 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리

    * 싱글톤 방식의 주의점
        - 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에
          싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
        - 무상태(stateless)로 설계해야 한다. -> 쓰레드 세이프한 방식
            - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
            - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
            - 가급적 읽기만 가능해야 한다.
            - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
        - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.
        - 예제 코드 p.74

    - @Configuration 과 싱글톤
        - 내가 만든 클래스가 아니라 스프링이 CGLIB 라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은
          임의의 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것
        - 이 임의의 다른 클래스가 바로 싱글톤이 보장되도록 해준다.
        - @Bean 이 붙은 메서드마다 이미 스프링 빈이 존재하면 빈을 반환하고, 스프링 빈이 없으면 생성해서
          스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.


5.컴포넌트 스캔
    - 컴포넌트 스캔과 의존관계 자동 주입
        @ComponentScan, @Autowired

    - 탐색 위치와 기본 스캔 대상
        - @Controller: 스프링 MVC 컨트롤러로 인식
        - @Repository: 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
        - @Configuration: 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.
        - @Service: 사실 @Service 는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고
          비즈니스 계층을 인식하는데 도움이 된다.

    - 필터
        - includeFilters, excludeFilters
        - 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, 개인적으로는 옵션을 변경하면서 사용하기보다는 스프링의 기본 설정에
          최대한 맞추어 사용하는 것을 권장

    - 중복 등록과 충돌
        - 자동 빈 등록 vs 자동 빈 등록
            - 이름이 같은 경우 스프링은 오류를 발생시킨다.
        - 수동 빈 등록 vs 자동 빈 등록
            - 수동 빈이 자동 빈을 오버라이딩 해버린다.
            - 하지만 보통 여러 설정들이 꼬여서 버그가 발생하는 경우가 많다.
            - Consider renaming one of the beans or enabling overriding by setting
              spring.main.allow-bean-definition-overriding=true


6.의존관계 자동 주입
    - 다양한 의존관계 주입 방법
        - 생성자 주입
            - 생성자 호출시점에 딱 1번만 호출되는 것이 보장된다.
            - 불변, 필수 의존관계에 사용

        - 수정자 주입
            - 선택, 변경 가능성이 있는 의존관계에 사용

        - 필드 주입
            - 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.
            - DI 프레임워크가 없으면 아무것도 할 수 없다.
            - 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

        - 일반 메서드 주입

        * 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false)

        - 생성자 주입을 선택해라
            - 불변
                - 대부분의 의존 관계는 애플리케이션 종료 전까지 변하면 안된다.
            - 누락
                - 생성자 주입을 사용하면 주입 데이터를 누락 했을 때 컴파일 오류가 발생한다.
                - 생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다.
                - 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용할 수 없다.

        * @Bean 은 메소드 레벨에서 선언하며, 반환되는 객체(인스턴스)를 개발자가 수동으로 빈으로 등록하는 애노테이션이다.
          반면 @Component 는 클래스 레벨에서 선언함으로써 스프링이 런타임시에 컴포넌트스캔을 하여 자동으로 빈을 찾고(detect)
          등록하는 애노테이션이다.

        - 조회 빈이 2개 이상 - 문제
            - @Autowired
                - 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 매칭
            - @Qualifier
                - @Qualifier 끼리 매칭
                - 빈 이름 매칭
                - noSuchBeanDefinitionException 예외 발생
            - @Primary
                - @Autowired 시에 여러 빈이 매칭되면 @Primary 가 우선권을 가진다.

            - @Primary, @Qualifier 활용
                - 코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈이 있고, 코드에서 특별한 기능
                  으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 빈이 있다고 생각해보자. 메인 데이터
                  베이스의 커넥션을 획득하는 스프링 빈은 @Primary 를 적용해서 조회하는 곳에서 @Qualifier 지정 없이
                  편리하게 조회하고, 서브 데이터베이스 커넥션 빈을 획득할 때는 @Qualifier 를 지정해서 명시적으로 획
                  득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다. 물론 이때 메인 데이터베이스의 스프링 빈을 등
                  록할 때 @Qualifier 를 지정해주는 것은 상관없다.

            - 우선순위
                - @Primary 는 기본값 처럼 동작하는 것이고, @Qualifier 는 매우 상세하게 동작한다.

            - 자동, 수동의 올바른 실무 운영 기준
                - 편리한 자동 기능을 기본으로 사용
                - 업무 로직 빈: 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는
                  리포지토리등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
                - 기술 지원 빈: 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공
                  통 로그 처리 처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.
                => 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로 나타나게 하는
                   것이 유지보수 하기 좋다.


7.빈 생명주기 콜백
    - 빈 생명주기 콜백
        - 스프링 빈의 이벤트 라이프사이클
            스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
             (생성자 주입의 경우 스프링 빈 생성시, 필드나 세터 주입의 경우 의존관계 주입시 스프링 빈이 들어옴.)

        * 객체의 생성과 초기화를 분리하자
            - 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에 초기화는
              이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행한다.
              따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분
              을 명확하게 나누는 것이 유지보수 관점에서 좋다. 물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단
              순한 경우에는 생성자에서 한번에 다 처리하는게 더 나을 수 있다.

    - 인터페이스 InitializingBean, DisposableBean
        - InitializingBean 은 afterPropertiesSet() 메서드로 초기화를 지원
        - DisposableBean 은 destroy() 메서드로 소멸을 지원

        - 초기화, 소멸 인터페이스 단점
            - 이 인터페이스는 스프링 전용 인터페이스다. 해당 코드가 스프링 전용 인터페이스에 의존
            - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
            - 내가 코드를 코칠 수 없는 외부 라이브러리에 적용할 수 없다.

    - 빈 등록 초기화, 소멸 메서드 지정
        - 설정 정보에 @Bean(initMethod = "init", destroyMethod = "close") 처럼 초기화, 소멸 메서드를 지정할 수 있다.
        - 메서드 이름을 자유롭게 줄 수 있다.
        - 스프링 빈이 스프링 코드에 의존하지 않는다.
        - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
        - 종료 메서드 추론
            - @Bean 의 destroyMethod 속성에는 아주 특별한 기능이 있다.
            - 라이브러리는 대부분 close , shutdown 이라는 이름의 종료 메서드를 사용한다.
            - @Bean 의 destroyMethod 는 기본값이 (inferred) (추론)으로 등록되어 있다.
            - 이 추론 기능은 close , shutdown 라는 이름의 메서드를 자동으로 호출해준다. 이름 그대로 종료 메서드를 추론해서 호출해준다.
            - 따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.
            - 추론 기능을 사용하기 싫으면 destroyMethod="" 처럼 빈 공백을 지정하면 된다.

    - 애노테이션 @PostConstruct, @PreDestroy
        - 최신 스프링에서 가장 권장하는 방법이다.
        - 애노테이션 하나만 붙이면 되므로 매우 편리하다.
        - 패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니라 JSR-250
          라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
        - 컴포넌트 스캔과 잘 어울린다.
        - 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면 @Bean 의 기능을 사용하자.
        - 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod 를 사용하자.


8.빈 스코프
    - 빈 스코프란
        - 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
        - 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
        - 웹 관련 스코프
            - request: 웹 요청이 들어오고 나갈 때까지 유지되는 스코프
            - session: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
            - application: 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

    - 프로토타입 스코프
        - 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다. 클라이언트에 빈을 반환하고, 이후
          스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다. 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다.
          그래서 @PreDestroy 같은 종료 메서드가 호출되지 않는다.

    - 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
        - 싱글톤에서 프로토타입 빈을 사용하게 되면 싱글톤 빈은 생성 시점에만 의존관계가 주입을 받기 때문에, 프로토타입 빈이 새로 생성되기는
          하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제다.

    - 싱글톤 빈과 함께 사용시 Provider 로 문제 해결
        - ac.getBean()을 통해서 항상 새로운 프로토타입 빈을 생성
        - 의존관계를 외부에서 주입(DI)받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을
          Dependency Lookup(DL) 의존관계 조회(탐색) 이라한다.
        - 그런데 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고,
          단위 테스트도 어려워 진다.
        - 지금 필요한 기능은 지정한 프로토타입 빈을 컨테이너 대신 찾아서 딱 DL 정도의 기능만 제공하는 게 필요.
        - ObjectFactory, ObjectProvider
            - 지정한 빈을 컨테이너 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider 이다.
              참고로 과거에는 ObjectFactory 가 있었는데, 여기에 편의 기능을 추가해서 ObjectProvider 가 만들어졌다.
            - ObjectProvider 의 getObject() 를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)
            - ObjectFactory: 기능이 단순, 별도의 라이브러리 필요 없음, 스프링에 의존
            - ObjectProvider: ObjectFactory 상속, 옵션, 스트림 처리등 편의 기능이 많고, 별도의 라이브러리 필요 없음, 스프링에 의존
        - JSR-330 Provider
            - 마지막 방법은 javax.inject.Provider 라는 JSR-330 자바 표준을 사용하는 방법이다.
            - 이 방법을 사용하려면 javax.inject:javax.inject:1 라이브러리를 gradle 에 추가해야 한다.
            - get() 메서드 하나로 기능이 매우 단순하다.
            - 별도의 라이브러리가 필요하다.
            - 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다.

    - 웹 스코프
        - Provider
            - request scope 빈의 생성 지연
        - 프록시
            - @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
            - CGLIB 라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.

            - 정리
                - 가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.
                - 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope 를 사용할 수 있다.
                - 사실 Provider 를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.
                - 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.
                - 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.
            - 주의점
                - 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 결국 주의해서 사용해야 한다.
                - 이런 특별한 scope 는 꼭 필요한 곳에만 최소화해서 사용하자, 무분별하게 사용하면 유지보수하기 어려워진다.
