4.스프링과 문제 해결 - 트랜잭션
    4.1 문제점들
    4.2 트랜잭션 추상화
    4.3 트랜잭션 동기화
    4.4 트랜잭션 문제 해결 - 트랜잭션 매니저1
    4.5 트랜잭션 문제 해결 - 트랜잭션 매니저2
    4.6 트랜잭션 문제 해결 - 트랜잭션 템플릿
    4.7 트랜잭션 문제 해결 - 트랜잭션 AOP 이해
    4.8 트랜잭션 문제 해결 - 트랜잭션 AOP 적용
    4.9 트랜잭션 문제 해결 - 트랜잭션 AOP 정리
    4.10 스프링 부트의 자동 리소스 등록


    4.1 문제점들
        - 애플리케이션 구조
            - 프레젠테이션 계층 (@Controller: UI 관련 처리)
                - UI와 관련된 처리 담당
                  웹 요청과 응답
                  사용자 요청을 검증
                  주 사용 기술: 서블릿과 HTTP 같은 웹 기술, 스프링 MVC
            - 서비스 계층 (@Service: 비즈니스 로직)
                - 비즈니스 로직을 담당
                  주 사용 기술: 가급적 특정 기술에 의존하지 않고, 순수 자바 코드로 작성
            - 데이터 접근 계층 (@Repository: DB 접근 처리)
                - 실제 데이터베이스에 접근하는 코드
                  주 사용 기술: JDBC, JPA, File, Redis, Mongo ...
            - DB 서버

        - 순수한 서비스 계층
            - 서비스 계층이 특정 기술에 종속되지 않기 때문에 비즈니스 로직을 유지보수 하기도 쉽고, 테스트 하기도 쉽다.
              이렇게 하면 향후 구현 기술이 변경될 때 변경의 영향 범위를 최소화 할 수 있다.

        - 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작하는 것이 좋다.
        - 그런데 문제는 트랜잭션을 사용하기 위해서 javax.sql.DataSource , java.sql.Connection ,
          java.sql.SQLException 같은 JDBC 기술에 의존해야 한다는 점이다.
        - 트랜잭션을 사용하기 위해 JDBC 기술에 의존한다. 결과적으로 비즈니스 로직보다 JDBC 를 사용해서
          트랜잭션을 처리하는 코드가 더 많다.

        - 문제 정리
            - 트랜잭션 문제
                - JDBC 구현 기술이 서비스 계층에 누수되는 문제
                - 트랜잭션 동기화 문제
                    - 같은 트랜잭션을 유지하기 위해 커넥션을 파라미터로 넘겨야 한다.
                    - 이때 파생되는 문제들도 있다. 똑같은 기능도 트랜잭션용 기능과 트랜잭션을 유지하지 않아도 되는
                      기능으로 분리해야 한다.
                - 트랜잭션 적용 반복 문제
            - 예외 누수 문제
                - 데이터 접근 계층의 JDBC 구현 기술 예외가 서비스 계층으로 전파된다.
                - SQLException 은 체크 예외이기 때문에 데이터 접근 계층을 호출한 서비스 계층에서 해당 예외를 잡아서
                  처리하거나 명시적으로 throws 를 통해서 다시 밖으로 던져야한다.
                - SQLException 은 JDBC 전용 기술이다. 향후 JPA 나 다른 데이터 접근 기술을 사용하면, 그에 맞는 다른
                  예외로 변경해야 하고, 결국 서비스 코드도 수정해야 한다.
            - JDBC 반복 문제
                - try , catch , finally ...
                - 커넥션을 열고, PreparedStatement 를 사용하고, 결과를 매핑하고... 실행하고, 커넥션과 리소스를
                  정리한다.

    4.2 트랜잭션 추상화
        - 구현 기술마다 트랜잭션을 사용하는 방법이 다르다.
          JDBC : con.setAutoCommit(false)
          JPA : transaction.begin()

        - 우리는 스프링이 제공하는 트랜잭션 추상화 기술을 사용하면 된다.
          심지어 데이터 접근 기술에 따른 트랜잭션 구현체도 대부분 만들어두어서 가져다 사용하기만 하면 된다.

        - 스프링 트랜잭션 추상화의 핵심은 PlatformTransactionManager 인터페이스이다.

    4.3 트랜잭션 동기화
        - 스프링이 제공하는 트랜잭션 매니저는 크게 2가지 역할을 한다.
            - 트랜잭션 추상화
            - 리소스 동기화
                - 스프링은 트랜잭션 동기화 매니저를 제공한다. 이것은 쓰레드 로컬( ThreadLocal )을 사용해서 커넥션을
                  동기화해준다. 트랜잭션 매니저는 내부에서 이 트랜잭션 동기화 매니저를 사용한다.

                - 트랜잭션 동기화 매니저는 쓰레드 로컬을 사용하기 때문에 멀티쓰레드 상황에 안전하게 커넥션을 동기화 할
                  수 있다. 따라서 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득하면 된다. 따라서
                  이전처럼 파라미터로 커넥션을 전달하지 않아도 된다.

                - 동작 방식을 간단하게 설명하면 다음과 같다.
                    1. 트랜잭션을 시작하려면 커넥션이 필요하다. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고
                       트랜잭션을 시작한다.
                    2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다.
                    3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 따라서 파라미터로 커넥션을
                       전달하지 않아도 된다.
                    4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을
                       종료하고, 커넥션도 닫는다.

                - 쓰레드 로컬을 사용하면 각각의 쓰레드마다 별도의 저장소가 부여된다. 따라서 해당 쓰레드만 해당
                  데이터에 접근할 수 있다.

    4.4 트랜잭션 문제 해결 - 트랜잭션 매니저1
        - 트랜잭션 동기화를 사용하려면 DataSourceUtils 를 사용해야 한다.
            - DataSourceUtils.getConnection()
              트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환한다.
              트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 새로운 커넥션을 생성해서 반환한다.

            - DataSourceUtils.releaseConnection()
                - 커넥션을 con.close() 를 사용해서 직접 닫아버리면 커넥션이 유지되지 않는 문제가 발생한다. 이
                  커넥션은 이후 로직은 물론이고, 트랜잭션을 종료(커밋, 롤백)할 때 까지 살아있어야 한다.

                - DataSourceUtils.releaseConnection() 을 사용하면 커넥션을 바로 닫는 것이 아니다.
                  트랜잭션을 사용하기 위해 동기화된 커넥션은 커넥션을 닫지 않고 그대로 유지해준다.
                  트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 해당 커넥션을 닫는다.

    4.5 트랜잭션 문제 해결 - 트랜잭션 매니저2
        - 트랜잭션 매니저1 - 트랜잭션 시작
            -  클라이언트의 요청으로 서비스 로직을 실행한다.
            1. 서비스 계층에서 transactionManager.getTransaction() 을 호출해서 트랜잭션을 시작한다.
            2. 트랜잭션을 시작하려면 먼저 데이터베이스 커넥션이 필요하다. 트랜잭션 매니저는 내부에서 데이터소스를
               사용해서 커넥션을 생성한다.
            3. 커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작한다.
            4. 커넥션을 트랜잭션 동기화 매니저에 보관한다.
            5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 따라서 멀티 쓰레드 환경에 안전하게
               커넥션을 보관할 수 있다.

        - 트랜잭션 매니저2 - 로직 실행
            6. 서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드들을 호출한다. 이때 커넥션을 파라미터로
               전달하지 않는다.
            7. 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. 리포지토리는
               DataSourceUtils.getConnection() 을 사용해서 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서
               사용한다. 이 과정을 통해서 자연스럽게 같은 커넥션을 사용하고, 트랜잭션도 유지된다.
            8. 획득한 커넥션을 사용해서 SQL 을 데이터베이스에 전달해서 실행한다.

        - 트랜잭션 매니저3 - 트랜잭션 종료
            9. 비즈니스 로직이 끝나고 트랜잭션을 종료한다. 트랜잭션은 커밋하거나 롤백하면 종료된다.
            10. 트랜잭션을 종료하려면 동기화된 커넥션이 필요하다. 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.
            11. 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백한다.
            12. 전체 리소스를 정리한다.
                트랜잭션 동기화 매니저를 정리한다. 쓰레드 로컬은 사용후 꼭 정리해야 한다.
                con.setAutoCommit(true) 로 되돌린다. 커넥션 풀을 고려해야 한다.
                con.close() 를 호출해셔 커넥션을 종료한다. 커넥션 풀을 사용하는 경우 con.close() 를
                호출하면 커넥션 풀에 반환된다.

        - 정리
            - 트랜잭션 추상화 덕분에 서비스 코드는 이제 JDBC 기술에 의존하지 않는다.
              java.sql.SQLException 이 아직 남아있지만 이 부분은 뒤에 예외 문제에서 해결하자.
            - 트랜잭션 동기화 매니저 덕분에 커넥션을 파라미터로 넘기지 않아도 된다.

    4.6 트랜잭션 문제 해결 - 트랜잭션 템플릿
        - 트랜잭션을 시작하고, 비즈니스 로직을 실행하고, 성공하면 커밋하고, 예외가 발생해서 실패하면 롤백한다.
        - 다른 서비스에서 트랜잭션을 시작하려면 try , catch , finally 를 포함한 성공시 커밋, 실패시 롤백
          코드가 반복될 것이다.
        - 이런 형태는 각각의 서비스에서 반복된다. 달라지는 부분은 비즈니스 로직 뿐이다.
        - 이럴 때 템플릿 콜백 패턴을 활용하면 이런 반복 문제를 깔끔하게 해결할 수 있다.

        - 스프링은 TransactionTemplate 라는 템플릿 클래스를 제공한다.
            - execute() : 응답 값이 있을 때 사용한다.
            - executeWithoutResult() : 응답 값이 없을 때 사용한다.

        - 트랜잭션 템플릿의 기본 동작은 다음과 같다.
            - 비즈니스 로직이 정상 수행되면 커밋한다.
            - 언체크 예외가 발생하면 롤백한다. 그 외의 경우 커밋한다. (체크 예외의 경우에는 커밋하는데, 이
              부분은 뒤에서 설명한다.)
            - 코드에서 예외를 처리하기 위해 try~catch 가 들어갔는데, bizLogic() 메서드를 호출하면
              SQLException 체크 예외를 넘겨준다. 해당 람다에서 체크 예외를 밖으로 던질 수 없기 때문에 언체크
              예외로 바꾸어 던지도록 예외를 전환했다.

    4.7 트랜잭션 문제 해결 - 트랜잭션 AOP 이해
        - 지금까지 트랜잭션을 편리하게 처리하기 위해서 트랜잭션 추상화도 도입하고, 추가로 반복적인 트랜잭션
          로직을 해결하기 위해 트랜잭션 템플릿도 도입했다.
          트랜잭션 템플릿 덕분에 트랜잭션을 처리하는 반복 코드는 해결할 수 있었다. 하지만 서비스 계층에 순수한
          비즈니스 로직만 남긴다는 목표는 아직 달성하지 못했다.
          이럴 때 스프링 AOP 를 통해 프록시를 도입하면 문제를 깔끔하게 해결할 수 있다.

        - 프록시를 통한 문제 해결
            - 프록시 도입 전: 서비스에 비즈니스 로직과 트랜잭션 처리 로직이 함께 섞여있다.
            - 프록시 도입 후: 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다. 그리고 트랜잭션을 시작한 후에
              실제 서비스를 대신 호출한다. 트랜잭션 프록시 덕분에 서비스 계층에는 순수한 비즈니즈 로직만 남길 수 있다.

        - 스프링이 제공하는 트랜잭션 AOP
            - 개발자는 트랜잭션 처리가 필요한 곳에 @Transactional 애노테이션만 붙여주면 된다. 스프링의
              트랜잭션 AOP 는 이 애노테이션을 인식해서 트랜잭션 프록시를 적용해준다.

            - 스프링 AOP 를 적용하려면 어드바이저, 포인트컷, 어드바이스가 필요하다. 스프링은 트랜잭션 AOP 처리를
              위해 다음 클래스를 제공한다. 스프링 부트를 사용하면 해당 빈들은 스프링 컨테이너에 자동으로 등록된다.

    4.8 트랜잭션 문제 해결 - 트랜잭션 AOP 적용
        - @Transactional 애노테이션은 메서드에 붙여도 되고, 클래스에 붙여도 된다. 클래스에 붙이면 외부에서
          호출 가능한 public 메서드가 AOP 적용 대상이 된다.

        - @SpringBootTest : 스프링 AOP 를 적용하려면 스프링 컨테이너가 필요하다. 이 애노테이션이 있으면
          테스트시 스프링 부트를 통해 스프링 컨테이너를 생성한다. 그리고 테스트에서 @Autowired 등을 통해
          스프링 컨테이너가 관리하는 빈들을 사용할 수 있다.

        - @TestConfiguration : 테스트 안에서 내부 설정 클래스를 만들어서 사용하면서 이 에노테이션을 붙이면,
          스프링 부트가 자동으로 만들어주는 빈들에 추가로 필요한 스프링 빈들을 등록하고 테스트를 수행할 수 있다.

        - TestConfig
            - DataSource 스프링에서 기본으로 사용할 데이터소스를 스프링 빈으로 등록한다. 추가로 트랜잭션
              매니저에서도 사용한다.
            - DataSourceTransactionManager 트랜잭션 매니저를 스프링 빈으로 등록한다.
              스프링이 제공하는 트랜잭션 AOP 는 스프링 빈에 등록된 트랜잭션 매니저를 찾아서 사용하기
              때문에 트랜잭션 매니저를 스프링 빈으로 등록해두어야 한다.

    4.9 트랜잭션 문제 해결 - 트랜잭션 AOP 정리
        - 트랜잭션 AOP 적용 전체 흐름
            1. 프록시 호출
            2. 스프링 컨테이너를 통해 트랜잭션 매니저 획득
            3. transactionManager.getTransaction()
            4. 데이터소스 -> 커넥션 생성
            5. con.setAutoCommit(false)
            6. 커넥션 보관 (트랜잭션 동기화 매니저에 보관)
            7. 실제 서비스 호출 (비스니스 로직 -> 데이터 접근 로직 -> 트랜잭션 동기화 매니저)
            8. 트랙잭션 동기화 커넥션 획득

        - 선언적 트랜잭션 관리 vs 프로그래밍 방식 트랜잭션 관리
            - @Transactional 애노테이션 하나만 선언해서 매우 편리하게 트랜잭션을 적용하는 것을 선언적 트랜잭션 관리라 한다.
            - 트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용해서 트랜잭션 관련 코드를 직접 작성하는 것을
              프로그래밍 방식의 트랜잭션 관리라 한다.

    4.10 스프링 부트의 자동 리소스 등록
        - 기존에는 이렇게 데이터소스와 트랜잭션 매니저를 직접 스프링 빈으로 등록해야 했다. 그런데 스프링
          부트가 나오면서 많은 부분이 자동화되었다.

        - 데이터소스 - 자동 등록
            - 자동으로 등록되는 스프링 빈 이름: dataSource
            - 이때 스프링 부트는 다음과 같이 application.properties 에 있는 속성을 사용해서 DataSource 를
              생성한다. 그리고 스프링 빈에 등록한다.
            - 스프링 부트가 기본으로 생성하는 데이터소스는 커넥션풀을 제공하는 HikariDataSource 이다.
              커넥션풀과 관련된 설정도 application.properties 를 통해서 지정할 수 있다.
            - spring.datasource.url 속성이 없으면 내장 데이터베이스(메모리 DB)를 생성하려고 시도한다.

        - 트랜잭션 매니저 - 자동 등록
            - 스프링 부트는 적절한 트랜잭션 매니저( PlatformTransactionManager )를 자동으로 스프링 빈에 등록한다.
            - 자동으로 등록되는 스프링 빈 이름: transactionManager
            - 어떤 트랜잭션 매니저를 선택할지는 현재 등록된 라이브러리를 보고 판단하는데, JDBC 를 기술을 사용하면
              DataSourceTransactionManager 를 빈으로 등록하고, JPA 를 사용하면 JpaTransactionManager 를
              빈으로 등록한다. 둘다 사용하는 경우 JpaTransactionManager 를 등록한다.
              JpaTransactionManager 는 DataSourceTransactionManager 가 제공하는 기능도 대부분 지원한다.












