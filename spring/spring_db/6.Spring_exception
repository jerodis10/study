6.스프링과 문제 해결 - 예외 처리, 반복
    6.1 체크 예외와 인터페이스
    6.2 런타임 예외 적용
    6.3 데이터 접근 예외 직접 만들기
    6.4 스프링 예외 추상화 이해
    6.5 스프링 예외 추상화 적용
    6.6 JDBC 반복 문제 해결 - JdbcTemplate


    6.1 체크 예외와 인터페이스
        - 체크 예외 코드에 인터페이스 도입시 문제점 - 구현 클래스
            - 인터페이스의 구현체가 체크 예외를 던지려면, 인터페이스 메서드에 먼저 체크 예외를 던지는 부분이 선언
              되어 있어야 한다. 그래야 구현 클래스의 메서드도 체크 예외를 던질 수 있다.

    6.2 런타임 예외 적용
        - 정리
          체크 예외를 런타임 예외로 변환하면서 인터페이스와 서비스 계층의 순수성을 유지할 수 있게 되었다.
          덕분에 향후 JDBC 에서 다른 구현 기술로 변경하더라도 서비스 계층의 코드를 변경하지 않고 유지할 수 있다.

        - 남은 문제
          리포지토리에서 넘어오는 특정한 예외의 경우 복구를 시도할 수도 있다. 그런데 지금 방식은 항상
          MyDbException 이라는 예외만 넘어오기 때문에 예외를 구분할 수 없는 단점이 있다. 만약 특정 상황에는
          예외를 잡아서 복구하고 싶으면 예외를 어떻게 구분해서 처리할 수 있을까?

    6.3 데이터 접근 예외 직접 만들기
        - 정리
            - SQL ErrorCode 로 데이터베이스에 어떤 오류가 있는지 확인할 수 있었다.
            - 예외 변환을 통해 SQLException 을 특정 기술에 의존하지 않는 직접 만든 예외인
              MyDuplicateKeyException 로 변환 할 수 있었다.
            - 리포지토리 계층이 예외를 변환해준 덕분에 서비스 계층은 특정 기술에 의존하지 않는
              MyDuplicateKeyException 을 사용해서 문제를 복구하고, 서비스 계층의 순수성도 유지할 수 있었다.

        - 남은 문제
            - SQL ErrorCode 는 각각의 데이터베이스 마다 다르다. 결과적으로 데이터베이스가 변경될 때 마다
              ErrorCode 도 모두 변경해야 한다.
                - 예) 키 중복 오류 코드
                  H2: 23505
                  MySQL: 1062
            - 데이터베이스가 전달하는 오류는 키 중복 뿐만 아니라 락이 걸린 경우, SQL 문법에 오류 있는 경우 등등
              수십 수백가지 오류 코드가 있다. 이 모든 상황에 맞는 예외를 지금처럼 다 만들어야 할까? 추가로 앞서
              이야기한 것 처럼 데이터베이스마다 이 오류 코드는 모두 다르다.

    6.4 스프링 예외 추상화 이해
        - 스프링은 앞서 설명한 문제들을 해결하기 위해 데이터 접근과 관련된 예외를 추상화해서 제공한다.
        - 각각의 예외는 특정 기술에 종속적이지 않게 설계되어 있다. 따라서 서비스 계층에서도 스프링이 제공하는
          예외를 사용하면 된다. 예를 들어서 JDBC 기술을 사용하든, JPA 기술을 사용하든 스프링이 제공하는
          예외를 사용하면 된다.
        - JDBC 나 JPA 를 사용할 때 발생하는 예외를 스프링이 제공하는 예외로 변환해주는 역할도 스프링이 제공한다.

        - DataAccessException 은 크게 2가지로 구분하는데 NonTransient 예외와 Transient 예외이다.
            - Transient 는 일시적이라는 뜻이다. Transient 하위 예외는 동일한 SQL 을 다시 시도했을 때
              성공할 가능성이 있다.
              예를 들어서 쿼리 타임아웃, 락과 관련된 오류들이다. 이런 오류들은 데이터베이스 상태가
              좋아지거나, 락이 풀렸을 때 다시 시도하면 성공할 수 도 있다.
            - NonTransient 는 일시적이지 않다는 뜻이다. 같은 SQL 을 그대로 반복해서 실행하면 실패한다.
              SQL 문법 오류, 데이터베이스 제약조건 위배 등이 있다.

        - 스프링은 데이터베이스에서 발생하는 오류 코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공한다.
        - 이전에 살펴봤던 SQL ErrorCode 를 직접 확인하는 방법이다. 이렇게 직접 예외를 확인하고 하나하나
          스프링이 만들어준 예외로 변환하는 것은 현실성이 없다. 이렇게 하려면 해당 오류 코드를 확인하고
          스프링의 예외 체계에 맞추어 예외를 직접 변환해야 할 것이다. 그리고 데이터베이스마다 오류 코드가
          다르다는 점도 해결해야 한다. 그래서 스프링은 예외 변환기를 제공한다.

        - SQLExceptionTranslator exTranslator = new
          SQLErrorCodeSQLExceptionTranslator(dataSource);
          DataAccessException resultEx = exTranslator.translate("select", sql, e);

        - translate() 메서드의 첫번째 파라미터는 읽을 수 있는 설명이고, 두번째는 실행한 sql, 마지막은 발생된
          SQLException 을 전달하면 된다. 이렇게 하면 적절한 스프링 데이터 접근 계층의 예외로 변환해서
          반환해준다.

        - 눈에 보이는 반환 타입은 최상위 타입인 DataAccessException 이지만 실제로는
          BadSqlGrammarException 예외가 반환된다.

        - 각각의 DB 마다 SQL ErrorCode 는 다르다. 그런데 스프링은 어떻게 각각의 DB가 제공하는 SQL
          ErrorCode 까지 고려해서 예외를 변환할 수 있을까?

        - org.springframework.jdbc.support.sql-error-codes.xml
          스프링 SQL 예외 변환기는 SQL ErrorCode 를 이 파일에 대입해서 어떤 스프링 데이터 접근 예외로
          전환해야 할지 찾아낸다. 예를 들어서 H2 데이터베이스에서 42000 이 발생하면 badSqlGrammarCodes
          이기 때문에 BadSqlGrammarException 을 반환한다.

    6.5 스프링 예외 추상화 적용
        - 스프링이 제공하는 데이터 접근 예외 추상화와 SQL 예외 변환기를 적용해보자.

        - 정리
          드디어 예외에 대한 부분을 깔끔하게 정리했다.
          스프링이 예외를 추상화해준 덕분에, 서비스 계층은 특정 리포지토리의 구현 기술과 예외에 종속적이지
          않게 되었다. 따라서 서비스 계층은 특정 구현 기술이 변경되어도 그대로 유지할 수 있게 되었다. 다시 DI를
          제대로 활용할 수 있게 된 것이다.
          추가로 서비스 계층에서 예외를 잡아서 복구해야 하는 경우, 예외가 스프링이 제공하는 데이터 접근 예외로
          변경되어서 서비스 계층에 넘어오기 때문에 필요한 경우 예외를 잡아서 복구하면 된다.

    6.6 JDBC 반복 문제 해결 - JdbcTemplate
        - JDBC 반복 문제
          커넥션 조회, 커넥션 동기화
          PreparedStatement 생성 및 파라미터 바인딩
          쿼리 실행
          결과 바인딩
          예외 발생시 스프링 예외 변환기 실행
          리소스 종료

        - 정리
          완성된 코드를 확인해보자.
          서비스 계층의 순수성
          트랜잭션 추상화 + 트랜잭션 AOP 덕분에 서비스 계층의 순수성을 최대한 유지하면서 서비스
          계층에서 트랜잭션을 사용할 수 있다.
          스프링이 제공하는 예외 추상화와 예외 변환기 덕분에, 데이터 접근 기술이 변경되어도 서비스 계층의
          순수성을 유지하면서 예외도 사용할 수 있다.
          서비스 계층이 리포지토리 인터페이스에 의존한 덕분에 향후 리포지토리가 다른 구현 기술로
          변경되어도 서비스 계층을 순수하게 유지할 수 있다.
          리포지토리에서 JDBC 를 사용하는 반복 코드가 JdbcTemplate 으로 대부분 제거되었다.


















