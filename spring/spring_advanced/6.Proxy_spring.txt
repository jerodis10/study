6.Proxy_spring
	6.1 프록시 팩토리 - 소개
	6.2 프록시 팩토리 - 예제 코드1
	6.3 프록시 팩토리 - 예제 코드2
	6.4 포인트컷, 어드바이스, 어드바이저 - 소개
	6.5 예제 코드1 - 어드바이저
	6.6 에제 코드2 - 직접 만든 포인트컷
	6.7 에제 코드3 - 스프링이 제공하는 포인트컷
	6.8 예제 코드4 - 여러 어드바이저 함께 사용
	6.9 프록시 팩토리 - 적용1
	6.10 프록시 팩토리 - 적용2
	6.11 정리
	
	
	6.1 프록시 팩토리 - 소개
		- 문제점
			- 인터페이스가 있는 경우에는 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면
			  어떻게 해야할까?
				- 스프링은 유사한 구체적인 기술들이 있을 때, 그것들을 통합해서 일관성 있게 접근할 수 있고, 더욱 편리하게
				  사용할 수 있는 추상화된 기술을 제공한다.
				- 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리( ProxyFactory )라는 기능을 제공한다.
				- 이전에는 상황에 따라서 JDK 동적 프록시를 사용하거나 CGLIB를 사용해야 했다면, 이제는 이 프록시
				  팩토리 하나로 편리하게 동적 프록시를 생성할 수 있다.
				- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를
				  사용한다. 그리고 이 설정을 변경할 수도 있다.  
				  
			- 두 기술을 함께 사용할 때 부가 기능을 제공하기 위해 JDK 동적 프록시가 제공하는 InvocationHandler
			  와 CGLIB가 제공하는 MethodInterceptor 를 각각 중복으로 만들어서 관리해야 할까?
				- 스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 Advice 라는 새로운 개념을 도입했다. 개발자는
				  InvocationHandler 나 MethodInterceptor 를 신경쓰지 않고, Advice 만 만들면 된다.
				- 결과적으로 InvocationHandler 나 MethodInterceptor 는 Advice 를 호출하게 된다.
				- 프록시 팩토리를 사용하면 Advice 를 호출하는 전용 InvocationHandler , MethodInterceptor 를
				  내부에서 사용한다.    
			  
			- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?  
				- 앞서 특정 메서드 이름의 조건에 맞을 때만 프록시 부가 기능이 적용되는 코드를 직접 만들었다. 스프링은
				  Pointcut 이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.
				  
	6.2 프록시 팩토리 - 예제 코드1
		- Advice 만들기
			- Advice 는 프록시에 적용하는 부가 기능 로직이다. 이것은 JDK 동적 프록시가 제공하는
			  InvocationHandler 와 CGLIB가 제공하는 MethodInterceptor 의 개념과 유사한다. 둘을 개념적으로
			  추상화 한 것이다. 프록시 팩토리를 사용하면 둘 대신에 Advice 를 사용하면 된다.
		
		- MethodInvocation invocation
			- 내부에는 다음 메서드를 호출하는 방법, 현재 프록시 객체 인스턴스, args , 메서드 정보 등이
			  포함되어 있다. 기존에 파라미터로 제공되는 부분들이 이 안으로 모두 들어갔다고 생각하면 된다.		  
			- MethodInterceptor 는 Interceptor 를 상속하고 Interceptor 는 Advice 인터페이스를 상속한다.
		
		- Object result = invocation.proceed()
			- invocation.proceed() 를 호출하면 target 클래스를 호출하고 그 결과를 받는다.
			- 그런데 기존에 보았던 코드들과 다르게 target 클래스의 정보가 보이지 않는다. target 클래스의
			  정보는 MethodInvocation invocation 안에 모두 포함되어 있다.
			- 그 이유는 바로 다음에 확인할 수 있는데, 프록시 팩토리로 프록시를 생성하는 단계에서 이미 target
			  정보를 파라미터로 전달받기 때문이다.
			
			- new ProxyFactory(target) : 프록시 팩토리를 생성할 때, 생성자에 프록시의 호출 대상을 함께
			  넘겨준다. 프록시 팩토리는 이 인스턴스 정보를 기반으로 프록시를 만들어낸다. 만약 이 인스턴스에
			  인터페이스가 있다면 JDK 동적 프록시를 기본으로 사용하고 인터페이스가 없고 구체 클래스만 있다면
			  CGLIB를 통해서 동적 프록시를 생성한다. 여기서는 target 이 new ServiceImpl() 의 인스턴스이기
			  때문에 ServiceInterface 인터페이스가 있다. 따라서 이 인터페이스를 기반으로 JDK 동적 프록시를 생성한다.	
			- proxyFactory.addAdvice(new TimeAdvice()) : 프록시 팩토리를 통해서 만든 프록시가 사용할 부가
			  기능 로직을 설정한다. JDK 동적 프록시가 제공하는 InvocationHandler 와 CGLIB가 제공하는
			  MethodInterceptor 의 개념과 유사하다. 이렇게 프록시가 제공하는 부가 기능 로직을 어드바이스
			  ( Advice )라 한다. 번역하면 조언을 해준다고 생각하면 된다.
			- proxyFactory.getProxy() : 프록시 객체를 생성하고 그 결과를 받는다.  
			
			- 프록시 팩토리를 통한 프록시 적용 확인
				- AopUtils.isAopProxy(proxy) : 프록시 팩토리를 통해서 프록시가 생성되면 JDK 동적 프록시나, 
				  CGLIB 모두 참이다.
				- AopUtils.isJdkDynamicProxy(proxy) : 프록시 팩토리를 통해서 프록시가 생성되고, JDK 동적
			  	  프록시인 경우 참  
			  	- AopUtils.isCglibProxy(proxy) : 프록시 팩토리를 통해서 프록시가 생성되고, CGLIB 동적 프록시인
				  경우 경우 참
				- 물론 proxy.getClass() 처럼 인스턴스의 클래스 정보를 직접 출력해서 확인할 수 있다.
			  
	6.3 프록시 팩토리 - 예제 코드2		  
		- proxyTargetClass 옵션
			- 프록시 팩토리는 proxyTargetClass 라는 옵션을 제공하는데, 이 옵션에 true 값을 넣으면 인터페이스가
			  있어도 강제로 CGLIB를 사용한다. 그리고 인터페이스가 아닌 클래스 기반의 프록시를 만들어준다.
			  
		- 정리
			- 프록시 팩토리의 서비스 추상화 덕분에 구체적인 CGLIB, JDK 동적 프록시 기술에 의존하지 않고, 매우
			  편리하게 동적 프록시를 생성할 수 있다.
			- 프록시의 부가 기능 로직도 특정 기술에 종속적이지 않게 Advice 하나로 편리하게 사용할 수 있었다. 
			  이것은 프록시 팩토리가 내부에서 JDK 동적 프록시인 경우 InvocationHandler 가 Advice 를
			  호출하도록 개발해두고, CGLIB인 경우 MethodInterceptor 가 Advice 를 호출하도록 기능을
			  개발해두었기 때문이다.  	  	
			
	6.4 포인트컷, 어드바이스, 어드바이저 - 소개		
		- 포인트컷( Pointcut ): 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는
		  필터링 로직이다. 주로 클래스와 메서드 이름으로 필터링 한다. 이름 그대로 어떤 포인트(Point)에 기능을
		  적용할지 하지 않을지 잘라서(cut) 구분하는 것이다.
		- 어드바이스( Advice ): 이전에 본 것 처럼 프록시가 호출하는 부가 기능이다. 단순하게 프록시 로직이라
		  생각하면 된다.  
		- 어드바이저( Advisor ): 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게
		  이야기해서 포인트컷1 + 어드바이스1이다.
		- 정리하면 부가 기능 로직을 적용해야 하는데, 포인트컷으로 어디에? 적용할지 선택하고, 어드바이스로 어떤
		  로직을 적용할지 선택하는 것이다. 그리고 어디에? 어떤 로직?을 모두 알고 있는 것이 어드바이저이다.
		  
		- 이렇게 구분한 것은 역할과 책임을 명확하게 분리한 것이다.  
			- 포인트컷은 대상 여부를 확인하는 필터 역할만 담당한다.  
		    - 어드바이스는 깔끔하게 부가 기능 로직만 담당한다.
		    - 둘을 합치면 어드바이저가 된다. 스프링의 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다.
		    
	6.5 예제 코드1 - 어드바이저	    
		- 프록시 팩토리를 통해 프록시를 생성할 때 어드바이저를 제공하면 어디에 어떤 기능을 제공할 지 알 수 있다.	    
		- new DefaultPointcutAdvisor : Advisor 인터페이스의 가장 일반적인 구현체이다. 생성자를 통해
		  하나의 포인트컷과 하나의 어드바이스를 넣어주면 된다. 어드바이저는 하나의 포인트컷과 하나의
		  어드바이스로 구성된다.  
		- Pointcut.TRUE : 항상 true 를 반환하는 포인트컷이다. 이후에 직접 포인트컷을 구현해볼 것이다.
		- new TimeAdvice() : 앞서 개발한 TimeAdvice 어드바이스를 제공한다.
		- proxyFactory.addAdvisor(advisor) : 프록시 팩토리에 적용할 어드바이저를 지정한다. 어드바이저는
		  내부에 포인트컷과 어드바이스를 모두 가지고 있다. 따라서 어디에 어떤 부가 기능을 적용해야 할지
		  어드바이스 하나로 알 수 있다. 프록시 팩토리를 사용할 때 어드바이저는 필수이다.
		- 그런데 생각해보면 이전에 분명히 proxyFactory.addAdvice(new TimeAdvice()) 이렇게
		  어드바이저가 아니라 어드바이스를 바로 적용했다. 이것은 단순히 편의 메서드이고 결과적으로 해당 메서드
		  내부에서 지금 코드와 똑같은 다음 어드바이저가 생성된다.
		  DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice())  
		  
	6.6 에제 코드2 - 직접 만든 포인트컷	    
		- 포인트컷은 크게 ClassFilter 와 MethodMatcher 둘로 이루어진다. 이름 그대로 하나는 클래스가
		  맞는지, 하나는 메서드가 맞는지 확인할 때 사용한다. 둘다 true 로 반환해야 어드바이스를 적용할 수 있다.
		- 일반적으로 스프링이 이미 만들어둔 구현체를 사용하지만 개념 학습 차원에서 간단히 직접 구현해보자.
		
	6.7 에제 코드3 - 스프링이 제공하는 포인트컷
		- 스프링은 우리가 필요한 포인트컷을 이미 대부분 제공한다.
		- NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
		  pointcut.setMappedNames("save");
		- NameMatchMethodPointcut 을 생성하고 setMappedNames(...) 으로 메서드 이름을 지정하면
		  포인트컷이 완성된다.	  
		  
		- 스프링이 제공하는 포인트컷
			- NameMatchMethodPointcut : 메서드 이름을 기반으로 매칭한다. 내부에서는 PatternMatchUtils 를 사용한다.
			  예) *xxx* 허용
			- JdkRegexpMethodPointcut : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다.
			- TruePointcut : 항상 참을 반환한다.
			- AnnotationMatchingPointcut : 애노테이션으로 매칭한다.
			- AspectJExpressionPointcut : aspectJ 표현식으로 매칭한다.
			
			- 가장 중요한 것은 aspectJ 표현식
				- 여기에서 사실 다른 것은 중요하지 않다. 실무에서는 사용하기도 편리하고 기능도 가장 많은 aspectJ 
				  표현식을 기반으로 사용하는 AspectJExpressionPointcut 을 사용하게 된다.
				  
	6.8 예제 코드4 - 여러 어드바이저 함께 사용
		- 하나의 target 에 여러 어드바이스를 적용하려면 어떻게 해야할까?
			- 여러 프록시
				- 이 방법이 잘못된 것은 아니지만, 프록시를 2번 생성해야 한다는 문제가 있다. 만약 적용해야 하는
			      어드바이저가 10개라면 10개의 프록시를 생성해야한다.		  
		- 스프링은 이 문제를 해결하기 위해 하나의 프록시에 여러 어드바이저를 적용할 수 있게 만들어두었다.	  
			- 프록시 팩토리에 원하는 만큼 addAdvisor() 를 통해서 어드바이저를 등록하면 된다.
			- 등록하는 순서대로 advisor 가 호출된다. 여기서는 advisor2 , advisor1 순서로 등록했다.
		- 스프링은 AOP를 적용할 때, 최적화를 진행해서 지금처럼 프록시는 하나만 만들고, 하나의 프록시에 여러
		  어드바이저를 적용한다.	
		- 정리하면 하나의 target 에 여러 AOP가 동시에 적용되어도, 스프링의 AOP는 target 마다 하나의
		  프록시만 생성한다.
		  
	6.9 프록시 팩토리 - 적용1
	6.10 프록시 팩토리 - 적용2	  
		  	
	6.11 정리				  
		- 남은 문제		  
			- 프록시 팩토리와 어드바이저 같은 개념 덕분에 지금까지 고민했던 문제들은 해결되었다. 프록시도 깔끔하게
			  적용하고 포인트컷으로 어디에 부가 기능을 적용할지도 명확하게 정의할 수 있다. 원본 코드를 전혀 손대지
			  않고 프록시를 통해 부가 기능도 적용할 수 있었다.
			  그런데 아직 해결되지 않는 문제가 있다.
			
			- 문제1 - 너무 많은 설정  
				- 예를 들어서 애플리케이션에 스프링 빈이 100개가 있다면 여기에 프록시를 통해 부가 기능을 적용하려면
				  100개의 동적 프록시 생성 코드를 만들어야 한다! 무수히 많은 설정 파일 때문에 설정 지옥을 경험하게 될 것이다.
			
			- 문제2 - 컴포넌트 스캔
				- 애플리케이션 V3처럼 컴포넌트 스캔을 사용하는 경우 지금까지 학습한 방법으로는 프록시 적용이 불가능하다.
				  왜냐하면 실제 객체를 컴포넌트 스캔으로 스프링 컨테이너에 스프링 빈으로 등록을 다 해버린 상태이기 때문이다.
				- 프록시를 적용하려면, 실제 객체를 스프링 컨테이너에 빈으로 등록하는 것이 아니라 ProxyFactoryConfigV1 에서 
				  한 것 처럼, 부가 기능이 있는 프록시를 실제 객체 대신 스프링 컨테이너에 빈으로 등록해야 한다.
				  
			- 두 가지 문제를 한번에 해결하는 방법이 바로 다음에 설명할 빈 후처리기이다.	  
				  
				  
				  	  
				  
				    
			    
		  
		    
		  
	
				  
				      
			  
			  