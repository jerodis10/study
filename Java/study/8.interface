8.interface
	8.1 인터페이스란
	8.2 인터페이스 정의
	8.3 인터페이스 구현
	8.4 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
	8.5 인터페이스 상속
	8.6 인터페이스의 기본 메소드 (Default Method), 자바8
	8.7 인터페이스의 static 메소드, 자바8
	8.8 함수형 인터페이스
	8.9 인터페이스의 private 메소드, 자바9
	8.10 Constant Interface
	8.11 추상 클래스가 필요한가?
	
	
	8.1 인터페이스란
		- 인터페이스는 일종의 추상클래스이다.
		- 인터페이스를 추상클래스처럼 추상메소드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 
		  일반 메소드 또는 멤버변수를 구성원으로 가질 수 없다.
		- 오직 추상메소드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.
		- 즉, 추상클래스보다 더욱 강력한 추상화를 제공하는 도구이고, 
		  그를 통해 다형성을 더욱 강력하게 해주는 도구라 볼 수 있다.
		※ 추상 클래스 : 추상 메서드를 포함하는 일반 클래스
		  - 생성자, 인스턴스 변수 등을 멤버로 가질 수 있다.
		
		- 인터페이스의 역할 : 개발 코드와 객체가 서로 통신하는 접점
		  개발 코드가 인터페이스의 메소드를 호출하면 -> 인터페이스는 객체의 메소드를 호출한다.
		  이렇게 되면, 개발 코드는 객체의 내부 구조를 알 필요가 없고, 인터페이스의 메소드만 알면 된다는 장점을 가진다.
		  
		- 인터페이스의 장점  
			- 표준화 가능 
				- 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 
				  프로그램을 작성하도록 하면 보다 일관되고 정형화된 프로그램의 개발이 가능하다. 
				  예) JDBC...
				  
			- 서로 관계없는 클래스들 간의 관계를 맺어준다.
				- 하나의 인터페이스를 공통적으로 구현하도록 하여 관계를 맺어 줄 수 있다.
				
				1.첫번째 방법 : 메서드 오버로딩(수리가 필요한 클래스를 매개변수로 설정)
					void repair(SCV s){}
					void repair(Tank t){}
					void repair(Dropship d){}
				2.두번째 방법 : (다형성 이용)SCV,Tank의 부모인 GroundUnit을 repair의 매개변수 타입으로 설정
					void repair(GroundUnit gu){}
				3. 세번째 방법 : (인터페이스 이용) 빈 인터페이스를 작성하여, SCV, Tank, Dropshop가 
				              해당 인터페이스를 implements하게 한다.	
					interface Repairable{}
					
					class SCV extends GroundUnit implements Repairable{}
					class Tank extends GroundUnit implements Repairable{}
					class Dropship extends AirUnit implements Repairable{}
					
					...
					void repair(Repairable r){} 
					// 인터페이스를 매개변수로 하여, Repairable 구현클래스만 올 수 있게함	
					
					- repairable 인터페이스는 아무런 내용도 없지만 이를 구현한 클래스들에 공통점이 생김	
					  즉, 서로 관계 없는 클래스들의 관계를 맺어줌
					- 인터페이스를 repair 메서드의 매개변수로 설정
					  해당 인터페이스 구현 클래스만 repair 메서드를 사용할 수 있게함.  
		
		- 독립적인 프로그래밍이 가능하다.		  
			- 인터페이스를 이용하여 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제 구현에 
			  독립적인 프로그램을 작성하는 것이 가능하다.			  
				
	8.2 인터페이스 정의			
		- interface에도 class와 같이 접근제어자로 public 또는 default를 사용할 수 있다.
		- 인터페이스는 다중 상속이 가능하다.(extends 이용)
		- 인터페이스는 static final 필드만 가질 수 있다. 필드를 선언할 때 public static final이 생략되어 있다.
		- 인터페이스에 적는 모든 메소드들은 추상 메소드로 간주된다.
		- 인터페이스 내에 존재하는 메소드는 무조건 "public abstract"로 선언되며, 이를 생략할 수 있다.
		
		- 추상클래스 vs 인터페이스
			- 공통점
				- 자기 자신을 객체화할 수 없으며 다른 객체가 상속, 구현을 하여 객체를 생성할 수 있다.
				- 상속, 구현을 한 하위 클래스에서는 상위에서 정의한 추상 메서드를 반드시 구현하여야 한다.
			- 차이점 
				- 추상클래스 
					- 일반 메서드 포함 가능
					- 다중상속 불가능
					- 상수, 변수 필드 포함 가능
				- 인터페이스
					- 모든 메서드는 추상 메서드 (자바8 이후부터 default, static 메서드 추가 가능)
					- 다중상속 가능
					- 상수필드만 포함 가능
				
			- 자바는 클래스의 다중상속이 금지되어 있다. 부모들이 메서드가 자손에서 충돌나는 문제를 방지하기 위해서이다. 
			  하지만 인터페이스 존재하는 추상메서드는 선언부(head)만 존재하기 때문에 충돌날 가능성이 없다. 
			  따라서 다중상속이 가능하다. 
			- 인터페이스의 조상은 인터페이스만 가능
			
	8.3 인터페이스 구현		
		1. implements 키워드 사용
			- 인터페이스를 구현하기 위해서는, 정의된 모든 추상메서드를 구현해야 한다.
			- 일부 추상메서드만 구현할 경우 해당 클래스는 abstract class가 된다.
			
			- 인터페이스의 모든 메서드는 public 접근제어를 가진다.
			- 구현 클래스에서 메서드를 오버라이딩 할 때, 오버라이딩 메서드 접근 제어 범위가 조상보다 좁아서는 안된다.
			
		2. 익명 구현 객체 사용
			- 인터페이스는 원칙적으로는 객체화 될 순 없지만, 
			  익명 객체를 통해서 인터페이스를 구현하는 일회용 객체를 만들 수 있다.	
				Fightable fight = new Fightable() {
				      @Override
				      public void void() {
				          System.out.println("moving");
				      }
				  }
				  
			- java의 인터페이스에는 생성자가 없으므로, 항상 Fightable()의 괄호는 빈 상태
			- 단순히 인터페이스의 구현역할을 하는 익명객체일뿐, 상속이나 또다른 인터페이스를 구현하는 것은 불가능하다.
			- 또한, 이것은 expresison의 일종이므로 뒤에 세미콜론을 붙여야 한다.
			
			응용버전

			List<Runnable> actions = new ArrayList<Runnable>();
			actions.add(new Runnable() {
			    @Override
			    public void run() {
			        ...
			    }
			});
			
	8.4 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
		- 다형성을 공부하면 자손클래스의 인스턴스를 부모타입의 참조변수로 참조하는 것이 가능하다는 것을 알 수 있다.
		- 인터페이스도 이를 구현한 클래스의 부모라 할 수 있으므로 해당 인터페이스 타입의 참조변수클래스의 인스턴스를 
		  참조할 수 있으며, 인터페이스 타입으로 형변환도 가능하다.		
			
	8.5 인터페이스 상속
		- 인터페이스는 extends키워드를 통해 상속이 가능하다.
		- 인터페이스 자식은 상속된 상위 인터페이스가 가지고 있는 메서드까지 모두 구현해야 한다.
		- 다중상속 또한 가능하다.
					  
	8.6 인터페이스의 기본 메소드 (Default Method), 자바8		
		- 자바8 이전까지의 인터페이스는 기능에 대한 선언만 가능하기 때문에, 실제 코드를 구현한 로직은 포함될 수 없다.
		- 하지만 자바8 이후부터나온 디폴트 메서드는 인터페이스 내부에 존재할 수 있는 구현 메서드이다. 
		  인터페이스를 implements 하면 메소드 구현없이 바로 사용할 수 있다.
		  
		- 사실 인터페이스는 기능에 대한 구현보다는, 기능에 대한 '선언'에 초점을 맞춰서 사용하는데, 
		  디폴트 메소드는 왜 등장했을까?  => 하위 호환성 때문이다.
		- 기존에 존재하던 인터페이스를 이용하여서 구현된 클래스를 만들고 사용하고 있는데,
		  인터페이스를 보완하는 과정에서 추가적으로 구현해야 할, 혹은 필수적으로 존재해야 할 메소드가 있다면,		  	
		  이미 이 인터페이스를 구현한 클래스와의 호환성이 떨어지게 된다. 이러한 경우 default메소드를 추가하게 된다면
		  하위 호환성은 유지되고 인터페이스의 보완을 진행할 수 있다.
		
		- default method 선언 방식  
			- 클래스의 인스턴스 메소드와 형태는 동일, default 키워드가 리턴 타입 앞에 붙음
			- public의 특성을 가짐 (public 키워드를 생략해도 컴파일 과정에서 자동으로 붙음)
			
		- default method 사용	
			- 디폴트 메소드는 인터페이스에 선언되지만, 인터페이스에서 바로 사용할 수 없다.
			- 디폴트 메서드는 추상 메소드가 아닌 인스턴스 메소드이다.
			- 따라서, 구현 객체가 있어야 사용 가능하다.
			- 어떤 구현 객체는 디폴트 메소드의 내용이 맞지 않아, 수정이 필요할 수도 있다.
			- 구현 클래스를 작성할 때 디폴트 메소드를 재정의(오버라이딩)해서 자신에게 맞게 수정하면 
			  디폴트 메소드가 호출될 때 자신을 재정의한 메소드가 호출된다.
			
		=> 결론은 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서 필요하다.
			- 기존 인터페이스의 이름과 추상 메소드의 변경없이 디폴트 메소드만 추가할 수 있기 때문에 이전에 
			  개발한 구현 클래스를 그대로 사용할 수 있으면서 새롭게 개발하는 클래스는 디폴트 메소드를 활용할 수 있다.
			  
		- default method가 있는 interface 상속	  
			1. 디폴트 메서드를 단순히 상속만 받음	  
			2. 디폴트 메서드를 재정의해서 실행 내용을 변경
			3. 디폴트 메소드를 추상 메소드로 재선언
		
		- 과거와 현재의 인터페이스
			- 과거 인터페이스의 Default 메소드가 제공되지 않은 자바8 이전의 형태
				- 인터페이스의 여러가지 메소드 중에서 전체가 아닌 일부의 메소드만 구현해야될때 
				  중간에 추상 클래스를 둔다.
				  예) 대표적인 예제가 스프링의 HandlerInterceptor
				  	- 자바8로 바뀌면서 디폴트 메서드 사용
				  	
	8.7 인터페이스의 static 메소드, 자바8
		- 인터페이스의 static 메서드는 인스턴스 생성과 상관없이 인터페이스 타입으로 호출하는 메소드이다.
		- 인터페이스 내에서 이미 body를 구현한 메소드이다(default 메서드와 동일).
		- 하지만 구현 클래스에서 오버라이딩하여 사용할 수 없다.
		- 정적 메소드는 public 특성을 가짐(public 키워드는 생략해도 컴파일 과정에서 자동으로 붙는다.)
		
		- 인터페이스의 정적 메소드는 인터페이스로 바로 호출이 가능하다.
		- 인터페이스 안의 static메서드는 오버라이딩이 되지 않는다. 
		- 인스턴스로 접근하면 static메서드가 호출되지 않는다.
					  	
	8.8 함수형 인터페이스
		- 자바 8에서는 함수를 '1급 시민'처럼 다룰 수 있도록, 함수형 인터페이스를 제공
			- 변수에 값을 할당할 수 있다.
				Addition add = (i1, i2) -> i1 + i2; // 함수 형태로 변수에 값을 넣음.
				System.out.println(add.addition(1,2)); // 3
			
			- 함수를 파라미터로 넘겨줄 수 있다.
				public static void main(String[] args) {
				    test((i1, i2) -> i1 + i2);// 함수가 파라미터로 들어갔습니다.
				} 
				
				static void test(Addition addition) {
				    System.out.println(addition.addition(1,2));
				}
			
			- 함수의 반환값이 될 수 있다.
				public static void main(String[] args) {
				    Addition add = test();
				    System.out.println(add.addition(1,2));
				}
				
				static Addition test() {
				    return (i1, i2) -> i1 + i2; // 함수가 리턴값에 들어갔습니다.
				}
				
		- 한개의 추상 메소드만 가져와야 한다.
		- @FunctionalInterface 어노테이션을 붙여야 한다.				  
				  
	8.9 인터페이스의 private 메소드, 자바9	
		- 자바8에서의 default method와 static method는 여전히 불편하다.
		- 왜냐하면 단지 특정 기능을 처리하는 내부 method일뿐인데도, 
		  외부에 공개되는 public method로 만들어야 하기 때문이다.	
		- interface를 구현하는 다른 interface 혹은 class가 해당 method에 액세스 하거나 
		  상속할 수 있는 것을 원하지 않아도, 접근할 수 있는 여지가 있다.  
		
		- java9에서는 위와 같은 사항으로 인해 
		  private method와 private static method라는 새로운 기능을 제공해준다.  	
		  	- 외부에 공개하지 않으면서도 코드의 중복을 피할 수 있다.
		  	- private 메소드는 오직 해당 인터페이스 내에서만 접근 가능하며, 
		  	  인터페이스를 상속받은 클래스나 서브 인터페이스에서는 접근할 수 없다.
			- private method를 이용하면 해당 메소드를 인터페이스를 구현하는 
			  클래스에 노출하지 않아도 된다 -> 캡슐화
							
		- private [static] method 선언 방식
			- private 접근 지시자를 반드시 사용해야 한다.
			- private과 abstract 키워드를 동시에 사용할 수 없다. (동시에 사용시 컴파일 에러)
			- private method는 해당 클래스에서만 사용 가능하다. 결국 하위 클래스가 상속할 수 없고, 
			  이 메소드를 재정의할 수 없다는 의미이기 때문에 추상 메소드가 될 수 없다.
			- 즉, 구현이 되어 있어야만 한다.
			- 추상 메소드는 구현부가 없는 메소드라는 의미.
			
		- private static method는 static & non-static 인터페이스 메소드 안에서 사용할 수 있다.
		- private non-static method는 private static method 내에서 사용할 수 없다.
		
	8.10 Constant Interface		  
		- Constant Interface는 사용을 추천하지 않는 Anti패턴이다.
		- Constant Interface는 오직 상수만 정의한 인터페이스이다. 인터페이스에서 변수를 등록할 때 자동으로 
		  public static final이 붙어 상수처럼 어디서든 접근할 수 있다.		  
		- 또한, 하나의 클래스에 여러 개의 인터페이스를 implement를 할 수 있는데, Constant Interface를 
		  implement 할 경우, 인터페이스의 클래스명을 네임스페이스로 붙이지 않고 바로 사용할 수 있다.	  
		- 사용을 추천하지 않는 이유는 여러가지가 있지만 핵심은 애초에 인터페이스를 정의하는 목적은 상수를 
		  쓰라는 것이 아니라 메서드를 통해 규약을 정의하라고 쓴다.	 
		
		- 전역적인 상수 사용을 원하면 상수만 모아놓을 클래스를 만드는게 좋다. 
		  또한, private으로 인스턴스 생성을 막는다.  
		- enum을 써도 괜찮을까요? No!!!
		- enum은 상수로 쓰는것이 아닌 선택가능한 값들을 고정하기 위해 사용한다.
		
	8.11 추상 클래스가 필요한가?	  
		- 우선 추상클래스에서 가능한 모든것들을 인터페이스에서 할 수 있을지 생각해봐야함
		- 결론은 많이 인터페이스로 가긴 했지만 아직도 추상클래스의 효용가치가 있다.
		  상태존재의 여부에 따라 골라서 사용하면 됨	  
		
		- 상속과 인터페이스 모두 다형성을 구현하는 기술
	    - 상속
	    	- 같은 종류의 하위 클래스를 만드는 기술
	    - 인터페이스
	    	- 사용 방법이 동일한 클래스를 만드는 기술   
		
		
		  		
		
				
				