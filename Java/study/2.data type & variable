2.data type & variable
	2.1 프리미티브 타입 종류와 값의 범위 그리고 기본 값
	2.2 프리미티브 타입과 레퍼런스 타입
	2.3 리터럴
	2.4 변수 선언 및 초기화하는 방법
	2.5 변수의 스코프와 라이프타임
	2.6 타입 변환, 캐스팅 그리고 타입 프로모션
	2.7 1차 및 2차 배열 선언하기
	2.8 타입 추론, var

	
	2.1 프리미티브 타입 종류와 값의 범위 그리고 기본 값
		- 프리미티브 타입(=기본형 타입=원시형 타입)이란 변수의 주소값에 값이 그 자체로 저장되는 데이터 타입이다.
		- 기본형 타입은 단어 그대로 기본 값이 있기 때문에 NULL이 존재하지 않는다.
		- 만약 NULL을 넣고 싶다면 기본 자료타입을 객체로 다루기 위해서 사용하는 Wrapper클래스를 사용하면 된다.
		- 해당 데이터 타입은 값이 할당되면 Stack 영역에 값이 저장되며 사용하는 타입의 값의 범위를 벗어난 
		  데이터를 넣으면 컴파일 에러가 발생한다. 
		  
		- 정수형 데이터 저장시 일반적으로 int를 쓰는 이유는?
			- JVM의 피연산자 스택이 피연산자를 4 Byte단위로 저장하기 때문에 크기가 4 Byte보다 작은 byte나 short의 값을 
			  계산할 때는 4 Byte로 변환하여 연산이 수행된다고 한다.
			- 그래서 자바에서는 정수형 연산을 int형으로만 진행한다.(short + short 할시 둘다 int형으로 변환하여 수행한다)
			- 따라서 변환과정을 거치지 않는 int형을 쓰는게 훨씬 더 효율적이다.
		
		- boolean
		  Java가 데이터를 다루는 최소 범위가 1 Byte이기 때문에 true와 false를 저장하는데 1bit면 충분하지만 어쩔수 없이 
		  1 Byte를 사용한다.	
		  
		- char
		  Java는 유니코드를 사용하여 모든 문자를 지원한다. Java에서 유일하게 제공하는 unsigned 형태이다.
		  
		- 자바는 문자코드를 유니코드로 사용한다. 왜 유니코드를 사용할까?
		  아스키코드를 이용해 다른 언어를 표현하기에는 7비트로는 부족했기 때문에
		  8비트로 확장한 아스키 코드를 사용하여 다른 언어 또한 지원하기 위해 그렇다고 한다.
		  (모든 언어 입력가능 : 자바의 특징중 하나)  
		  
		- floar과  double
		  float는 소수점 이하 7자리의 정밀도를 가지고 있고, double은 소수점 이하 15자리의 정밀도를 가지고 있다.
		  float타입은 부호(1비트) + 지수(8비트) + 가수(23비트) = 32비트를 사용하고
		  double타입은 부호(1비트) + 지수(11비트) + 가수(52비트) = 64비트를 사용한다.
		
		- byte 자료형의 메모리 크기는 1byte이다.
		  즉 8비트이다. 8비트로 표현 가능한 값의 개수는 2의 8제곱이다. 
		  2의 8제곱은 256인데 왜 표현범위가 0 ~ 255가 아니고 -128 ~ +127 까지 일까?
		  
		  컴퓨터에서 음수를 표현하기 위해 MSB라는 것을 사용한다
		  MSB는 Most Significant Bit의 줄임 말로 최상위 비트를 뜻한다.
		  최상위 비트란 일반적으로 가장 왼쪽에 위치한 비트를 뜻한다. 이 값이 1이면 음수, 0이면 양수라고 판단한다.
		  
		  즉, 부호가 있는 자료형의 경우 1비트를 부호를 표현하기 위해 사용하기 때문에
		  현재 예시를 기준으로 -128 ~ 127까지의 값 표현 범위를 가진다.
		  양수는 0이 포함되기 때문에 128이 아니다.
		  
		  만약 0 ~ 255까지 표현하고 싶다면, 다시 말해 부호 비트의 자리도 데이터로 취급하려 한다면 
		  unsigned(부호가 없는)자료형을 사용하면 된다. 음수는 표현하지 못하는 대신 양수 표현 범위가 두배 늘어난다.
		  
		  자바에는 unsigned타입의 자료형을 지원하지 않는다.
		  그래서 보통 표현 범위를 넘을 때 더 큰 자료형을 사용하고는 한다.
		  
	2.2 프리미티브 타입과 레퍼런스 타입
		- 프리미티브 타입은 위의 설명처럼 특정 데이터 값을 가지는 타입이다. 그럼 레퍼런스 타입은 뭘까? 
		  레퍼런스(reference)는 참조의 뜻을 가지고 있으며 이는 실제 값이 저장되어 있는 곳의 위치(=주소값)를 저장한다.
		  
		- 레퍼런스 타입의 종류로는 클래스, 인터페이스, 열거형, 배열 등 프리미티브 타입을 제외한 것들이다.
		  기본적으로 Java.Lang.Object를 상속받을 경우 참조형이 된다.
		  
		- 참조 타입 선언시 생성된 변수는 스택(Stack)영역에 생성되고, 객체는 힙(Heap) 영역에 생성된다.
		    
		- int[] scores = new int[]{10, 20, 30}
			1. scores라는 변수는 스택에 저장된다.  
			2. 배열은 참조타입 즉, 객체이기 때문에 new int[]를 통해 힙영역에 생성해준다. 위처럼 3번지라고 하자.
			3. 3번지에는 배열생성시 초기화한 데이터 10, 20, 30이 담긴다.
			4. 생성한 힙영역의 주소를 scores 변수에 담아준다.
		
		- List<String> listArgument = new ArrayList<>();
		  listArgument.add("yaboong");
			1.new 키워드를 통해 생성하려는 객체를 저장할 수 있는지 힙영역의 빈공간을 찾은 다음, 빈 List를 참조하는 
			  listArgument라는 변수를 스택에 할당한다.
			2.listArgument.add("yaboong")는 listArgument.add(new String("yaboong"));과 같다고 한다. 
			  이것 또한 new 키워드로 힙영역에 생성해주고 yaboong를 String이라는 객체에 데이터를 할당한다. 
		      List내부의 인덱스에 하나씩 add()된 데이터가 존재하는 주소값을 가지게 된다. 
		      
	2.3 리터럴
		- 리터럴은 실제로 저장되는 그 자체로 값을 의미하는 것이다. 다시한번 말하자면 데이터 그 자체가 리터럴이다.
		
		- 원래는 상수라 불렀지만, 프로그래밍에서는 상수를 '값을 한 번 저장하면 변경할 수 없는 저장공간'으로 정의하였기 때문에 
		  이와 구분하기 위해 리터럴이라 정의하였다.	      
		
		- final이 붙으면 상수가 된다.
		
		- 정수 리터럴
		- 실수 리터럴
			- 실수 타입 리터럴은 double 타입으로 컴파일 되므로 float 타입인 경우 명시적으로 f 또는 F를 명시해줘야 한다.
			- double 타입도 d나 D를 명시해줘도 되지만, 안해줘도 상관없다. 
		- 문자 리터럴
		- 문자열 리터럴
			- String a= "abc";  //큰 따옴표로 표현
			  String은 프리미티브 타입이 아니고 레퍼런스 타입이다. 그럼에도 리터럴을 지원하는데 리터럴 방식으로 
			  String에 값을 주면 Heap영역안의 String constant pool영역에 저장된다. 만약 리터럴 방식으로 동일한 값을
			  할당할 시 일반적인 레퍼런스 타입처럼 Heap에 객체를 생성하는게 아닌 String constant pool에 만들어진 
			  기존의 리터럴을 참조하는 방식이다.
			  
	2.4 변수 선언 및 초기화하는 방법
		- 변수 선언		  
			- 변수를 선언한다는 것은, 저장공간을 확보하겠다는 의미이다.
		  	  숫자로 시작해서는 안된다.
		      특수문자는 '_'와 '$'만을 허용한다. 
			
		- 변수의 초기화
			- 변수의 초기화란 변수를 사용하기 전 값을 할당하는 것을 뜻한다.
			- Stack은 자동초기화를 지원하지 않는다. 그러기 때문에 Stack에 선언한 변수에는 쓰레기 값이 채워진다.
			
		※ 쓰레기 값이란?
		  메모리는 독점하는게 아닌 공유하는 자원이다.
		  Stack은 LIFO 구조를 가지고 있다. 객체의 메서드가 실행되면 메서드 사용을 위한 메모리가 Stack에 할당된다.
		  (push) Stack안에 할당된 메소드는 지역변수들이 저장된다. 메소드 실행을 끝마치면 메소드를 반환한다.(pop) 이때, 
		  반환한다는 것은 메모리를 지우는게 아니다.(메모리는 공유자원이다) 메소드가 더이상 참조되지 않는 것이므로 주소값을 
		  지우는 것이다. 그럼으로, 메소드가 사용한 지역변수 등의 데이터를 그대로 남아있고 새로 호출된 메서드가 같은 
		  메모리 공간을 할당받는다. 즉, 이전 메서드의 데이터를 쓰레기 값이라고 한다.    
		  
		- 인스턴스 변수는 자동으로 기본값으로 초기화 해준다. 하지만 지역변수는 초기화하지 않고 사용시 컴파일 에러가 발생
		
		1. 지역변수는 메서드 내에서 일부 계산을 위해 쓰이는 경우가 많다. 따라서, 기본값을 적용하면 예상치 못한 값이 
		   될 수 있으므로 컴파일러는 프로그래머가 변수에 액세스하기 전에 일부 값으로 초기화하도록 요청합니다.   	 
		2. 클래스의 멤버변수는 사용되기 전에는 초기화 됐는지 컴파일러가 체크할 수 없지만, 로컬 변수는 컴파일러가 체크할 수 
		   있으므로 명시적으로 초기화를 강제했다. + 컴파일러단에서 최대한 오류를 잡아내기 위해서다.  
		3. 기존 C언어에 비해 메모리를 자동으로 관리하는 장점을 가진 자바에서는 런타임 환경에서 메모리참조 오류를 
		   가능한 막아야 한다. 그래서 컴파일환경에서 가능한한 초기화하는것을 강제한것이다.
		   로컬변수는 스택에 올라가므로 컴파일타임에 컴퓨터가 미리 로직에 대해 검증이 가능하여 컴파일 오류로 잡아낼 수 있다. 
		   
		- LazyHolder 기법    
			- LazyHolder 기법이란 JVM에게 객체의 초기화를 떠넘기는 방식으로, 멀티스레드 환경에서도 객체의 단일성을 보장할 수 있다.
			- 객체 생성을 담당할 내부클래스를 하나 정의하는데, 이것이 LazyHolder 다.
			- Temp클래스에는 LazyHolder 클래스의 변수가 없으므로, Temp클래스 로딩 시에
			  Temp클래스를 초기화하지 않지만, getInstance 메서드가 호출될 때 LazyHolder가 로딩되며 초기화가 진행된다.
			- 클래스의 내부의 클래스는 외부의 클래스가 초기화될때 초기화되지 않고, 클래스의 static 변수는 
			  클래스를 로딩할 때 초기화되는 것을 이용한 기법이다.
			- Class 를 로딩하고 초기화하는건 JVM 의 영역이고 Thread Safe 를 보장하기 때문에 
			  volatile이나 synchronized 같은 키워드가 없어도 된다.
			  (synchronized 키워드를 사용하면 성능이 100배 이하로 떨어진다고 한다.)
			  
	2.5 변수의 스코프와 라이프타임
		- 변수의 스코프란 변수들이 사용 가능한 범위
		- 다시 말해서, 변수에 대한 접근과 변수가 존재할 수 있는 영역을 의미
		
		- 멤버 변수(인스턴스 변수)	  
			- 클래스 영역에 선언되며 클래스의 인스턴스를 생성할 때 만들어진다. 
			- 인스턴스 변수값을 사용하기 위해서는 인스턴스를 생성해야한다.
			- 인스턴스 별로 별도의 저장공간을 확보함으로 인스턴스별로 다른값을 가질 수 있다.
			- Car car1 = new Car();
			  Car car2 = new Car();
		      => 힙영역에 car1객체와 car2객체가 생성되어있다.
		    - 생성한 객체가 Heap영역에 살아있을때 까지 존재한다.
		
		- 클래스 변수
			- 멤버변수에 static 키워드가 붙혀진 변수로서, 모든 클래스에 값을 공유한다.
			- 클래스가 메모리(Method 영역)에 올라갔을때 선언되기 때문에 인스턴스를 생성하지 않고 사용할 수 있다.
			- 프로그램종료시까지 살아있다.
			- 클래스가 처음 로딩될 때 단 한번 초기화 된다.
		
		- 지역변수
			- 메서드 내에 선언되는 변수이다.
			- 메소드 종료와 함께 소멸된다.
		
		* 멤버 변수와 지역변수의 변수명이 같다면?
			=> 지역변수를 선택한다. 
			
		* for문의 ()는 상위 지역 변수의 영향을 받는다. 
		
	2.6 타입 변환, 캐스팅 그리고 타입 프로모션
		- 타입 프로모션(자동 형변환)
			- 자동형변환의 경우 자료형의 크기가 큰 방향으로 형변환이 일어난다.	
		- 캐스팅(명시적 형변환)
		  
	2.7 1차 및 2차 배열 선언하기
		- 배열의 길이는 최초 생성시 선언한 길이에서 정적이므로 생성 후 변경할 수 없다.
		  애초에 List타입을 생성하면 되지만 피치못할 경우엔 새로운 배열을 생성해준뒤
		  System.arraycopy()를 사용하여 기존배열의 내용을 새로운 배열로 복사해준다.
		  
	2.8 타입 추론, var
		- 타입 추론이란 정적 타이핑을 지원하는 언어에서, 타입이 정해지지 않은 변수에 대해서 컴파일러가 변수의 타입을
		  스스로 유추하는 것이다.(Type Interface)
		  즉, 타입을 명시하지 않아도 되며, 코드량을 줄이고 코드의 가독성을 높일 수 있다.
		  var은 자바10부터 생겼으며 자바11부터는 이를 통한 람다 타입 지원도 생겼다.
		  컴파일러는 개발자가 입력한 초기화 값을 통해 타입을 유추하는데 즉 var은 컴파일러가 유추할 수 있도록 반드시 데이터를 
		  초기화 해야 한다.	    
		  
		  