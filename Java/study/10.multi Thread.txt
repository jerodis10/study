10.멀티쓰레드 프로그래밍
	10.1 Thread 클래스와 Runnable 인터페이스
	10.2 쓰레드의 상태
	10.3 쓰레드의 우선순위
	10.4 Main 쓰레드
	10.5 동기화
	10.6 데드락
	
	
	10.1 Thread 클래스와 Runnable 인터페이스
		- Process란?
			- 단순히 실행중인 프로그램
			- 프로그램을 실행하면 운영체제에 의해 메모리 공간을 할당 받아 실행 중인 것을 말한다.
			- 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리(자원) 그리고 쓰레드로 구성이 된다.
		
		- Multi-Process란?
			- 하나 이상의 프로세서가 서로 협력하여 일을 처리하는 것을 말합니다.
			- 프로세스는 메모리 공간을 독립적으로 사용하고 있기 때문에, context switching을 
			  하려고 하면 비용이 비싸고, 프로세스간 커뮤니케이션도 까다롭습니다.
			  
		- Context Switching이란?
			- 멀티 프로세서 환경에서 cpu가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 
			  다음 우선 순위의 프로세스가 실행되어야 할 때 기존 프로세스의 상태 또는 레지스터의 값을 저장하고, 
			  cpu가 다음 프로세스를 실행하도록 새로운 프로세스의 상태 또는 레지스터의 값을 교체하는 작업	
			  
		- 멀티 쓰레드의 오버헤드? (Context Switching)
			- 멀티쓰레드 환경은 잘못 자칫 하면 오버헤드를 발생시킬 수도 있다. 
			  결국 컴퓨터도 이전의 작업에 대한 기억을 해야 된다는 것이다.	    	
		
		- interrupt란?
			- 운영 체제에서 컴퓨터에 예기치 않은 일이 발생하더라도 작동이 중단되지 않고 
			  계속적으로 업무 처리를 할 수 있도록 해 주는 기능.
			  
		- Thread란?	  
			- 프로세스 내의 자원을 이용해서 실제로 작업을 수행하는 주체를 의미
			- 모든 프로세스에는 1개 이상의 쓰레드가 존재하여 작업을 수행
			- 두 개 이상의 쓰레드를 가지는 프로세스를 멀티 쓰레드 프로세스라고 한다.
			- 경량 프로세스라고 불리며 가장 작은 실행 단위이다.
		
		- Multi-Thread란?
			- 쓰레드는 하나의 프로세스에 메모리 영역을 공유한다. 
			  상대적으로 context switching 비용이 저렴하고 여러 쓰레드 간 통신도 비교적 쉽다.
			- CPU의 코어가 한 번에 단 하나의 작업만 수행할 수 있으므로, 실제로 동시에 처리되는 작업의 개수와 일치.
			  대부분 쓰레드의 수는 코어의 개수보다 훨씬 많기 때문에 각 코어가 아주 짧은 시간 동안 여러 작업을 
			  번갈아 가며 수행함으로써 여러 작업들이 모두 동시에 수행되는 것처럼 보인다.  
			  
		- 동시성(concurrency)과 병렬성(parallelism)
			- 멀티 쓰레드가 실행될 때 이 두 가지 중 하나로 실행된다. 이것은 cpu의 코어의 수와도 연관이 있는데,
			  하나의 코어에서 여러 쓰레드가 실행되는 것을 동시성,
			  멀티 코어를 사용할 때 각 코어별로 개별 쓰레드가 실행 되는 것을 병렬성이라고 한다.
			- 만약 코어의 수가 쓰레드의 수보다 많다면, 병렬성으로 쓰레드를 실행하면 되는데
			  코어의 수보다 쓰레드의 수가 더 많을 경우 동시성을 고려하지 않을 수 없다.
			- 동시성을 고려 한다는 것은, 하나의 코어에서 여러 쓰레드를 실행할 때 병렬로 실행하는 것처럼 보이지만
			  사실 병렬로 처리하지 못하고 한 순간에는 하나의 쓰레드만 처리할 수 있어서 번갈아 가면서 처리하게 되는데
			  그 번갈아 가면서 수행하느게 워낙 빠르기 때문에 각자 병렬로 실행 되는 것처럼 보일 뿐이다.
			  
		※ 시스템 리소스를 극한으로 끌어내는 코딩 방법	  
			/**
			 * 스레드풀에 스레드를 많이 만들어 봤자
			 * 하드웨어가 지원하는 CPU의 개수보다는 더 많이 돌릴 수 없음
			 * 그래서 스레드풀의 스레드에는 CPU 개수만큼만 만들기
			*/
			ExecutorService service = Executors.newFixedThreadPool(8);
			
			// 15개의 스레드를 관리하는 latch
			CountDownLatch latch = new CountDownLatch(15);
			
			...
			
			for(int index = 1; index <= 15; index++){
				service.execute(new Runnable(){
			    	@Override
			        public void run(){ 
			        	//비즈니스 로직
			            latch.countDown(); //latch 하나씩 내려주기, 이걸 하지 않으면 작업이 안끝남
			        }
			    });
			}
			
			...
			
			latch.await(); //모든 latch가 다끝날때까지 기다리기
			service.shutdown(); // 스레드 풀 종료	  
			  
		- Java에서의 쓰레드		  
			- 일부 쓰레드에서 실행중인 코드가 새로운 Thread 객체를 생성할 때 새로운 쓰레드는 자신을 생성한 쓰레드의 
			  우선 순위와 동일하게 설정된 우선 순위를 가지며 생성 쓰레드가 데몬쓰레드인 경우 데몬 쓰레드가 된다.
			
			- JVM은 다음 중 하나가 발생할때 까지 쓰레드를 유지한다.
				- Runtime 클래스의 종료 메소드가 호출되었으며, 보안관리자가 종료 조작이 발생하도록 허용할 때
				- 데몬 쓰레드가 아닌 모든 쓰레드는 실행된 후 run() 메소드의 작업이 끝나거나 
				  run 메소드 이외에서 예외를 throw 했을 때 종료
			
			- 모든 쓰레드에는 식별 목적으로 이름이 있다.
			- 둘 이상의 쓰레드가 동일한 이름을 가질 수 있다.
			- 쓰레드가 생성될 때 이름이 지정되지 않은 경우 새 이름이 생성된다.
			  ("Thread-숫자" 형식으로 생성된다. 숫자는 0부터 시작해서 생성할 때 마다 1씩 증가한다.)
			  
		- Thread 클래스와 Runnable 인터페이스
			- run() 메소드 말고도 다른 메소드를 오버라이딩 해야 할 필요가 있을 때 Thread를 상속받는다.
			- 아니라면, Runnable 인터페이스를 사용한다. 왜냐하면 run() 메소드밖에 존재하지 않기 때문이다.
			- 혹은 다른 클래스를 상속해야될 때 Runnable인터페이스를 사용한다.
			
		- run() 메소드와 start()메소드
			- 구현과 실행에 관련된 run() 메소드와 start() 메소드
			- public void run() : 쓰레드가 실행되면 run() 메소드를 호출하여 작업을 한다.
			- public synchronized void start() : 쓰레드를 실행시키는 메소드. start 메소드가 
			  호출되었다고 해서 바로 실행되는 것이 아니라, 일단 실행 대기 상태에 있다가 자신의 차례가 되어야 실행.
			  
		- run() 메소드와 start()메소드의 차이점
			- 쓰레드를 시작할 때 run() 메소드를 호출하면 되는 것 같은데, 실제로는 start() 메소드를 호출해서 
			  쓰레드를 실행한다. main메소드에서 run() 메소드를 호출하는 것은 생성된 쓰레드를 실행시키는 것이 
			  아니라 단순히 메소드를 호출하는 것이다. 반면에 start() 메소드를 호출하면 새로운 쓰레드가 작업을 
			  실행하는데 필요한 새로운 호출 스택(call stack)을 생성한 다음에 run()을 호출한다. 
			  즉, 새로 생성된 호출 스택에 run()이 첫 번째로 올라가게 한다. run() 메소드의 수행이 종료된 쓰레드는 
			  호출스택이 모두 비워지면서 생성된 호출 스택도 소멸된다.	  
			  
			- 한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다. 즉, 하나의 쓰레드에 대해 start()가 한 번만 
			  호출될 수 있다는 뜻이다. 하나의 쓰레드 객체에 대해 start() 메소드를 두 번 이상 호출하면 실행시에 
			  IllegalThreadStateException이 발생한다.
			  
		※ 한 쓰레드에서 예외가 발생해서 종료하더라도 다른 쓰레드의 실행에는 영향을 미치지 않는다.
		
		- thread.start() 메소드가 끝날 때까지 기다리지 않고, 그 다음 줄에 있는 thread라는 
		  객체의 start() 메소드를 실행한다. 새로운 쓰레드를 시작하므로 run() 메소드가 종료될 때까지 
		  기다리지 않고 다음 줄로 넘어가게 된다.
		  
		- Thread는 순서대로 동작할까?  
			- 순서대로 실행하지 않는다. 실행결과는 컴퓨터의 성능에 따라 매번 달라질 수도 있다.
			- run() 메소드가 끝나지 않으면 애플리케이션은 종료되지 않는다.
			
		- Thread sleep메소드	
			- sleep 메소드는 주어진 시간 만큼 대기를 하게 된다.	
			- Thread.sleep() 메소드를 사용할 때는 항상 try-catch로 묶어줘야 한다. 적어도 InterruptedException으로 
			  예외 처리를 해줘야 한다. 왜냐하면 sleep() 메소드는 InterruptedException 예외를 던질 수도 있다고 
			  선언되어 있기 때문이다.  
			  
	10.2 쓰레드의 상태
		- Thread의 실행시점은 .start() 메소드로 실행을 하는 것처럼 보이지만 실제로는 그렇지 않다. start() 메소드를 실행하게 되면, 
		  스레드의 실행 대기 상태가 되고, 스케줄러가 스레드를 실행시키는 방식으로 되어있다.		
		  	- NEW: 쓰레드 객체는 생성되었지만, 아직 시작되지 않은 상태
		  	- RUNNABLE: 쓰레드가 실행중인 상태
		  	- BLOCKED: 쓰레드가 실행 중지 상태이며, 모티러락이 풀리기를 기다리는 상태
		  	- WAITING: 쓰레드가 대기중인 상태
		  	- TIMED_WAITING: 특정 시간만큼 쓰레드가 대기중인 상태
		  	- TERMINATED: 쓰레드가 종료된 상태
		  	
		1. 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행대기열에 저장되어 자신의 차례가 될 때까지 기다려야 합니다. (실행 대기열은 큐와 같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행됩니다.)
		2. 자기 차례가 되면 실행상태가 됩니다.
		3. 할당된 실행시간이 다되거나 yield()메소드를 만나면 다시 실행 대기상태가 되고 다음 쓰레드가 실행됩니다.
		4. 실행 중에 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있습니다.  	  
			※ I/O Block은 입출력 작업에서 발생하는 지연상태를 말합니다. 사용자의 입력을 받는 경우를 예로 들 수 있습니다.
		5. 지정된 일시정지시간이 다되거나, notify(), resume(), interrupt()가 호출되면 일시정지상태를 벗어나 
		   다시 실행 대기열에 저장되어 자신의 차례를 기다리게 됩니다.
		6. 실행을 모두 마치거나 stop()이 호출되면 쓰레드를 소멸됩니다.
		
		- 쓰레드의 상태와 스케줄링에 관련된 메소드들
			- sleep()
				- sleep()에 의해 일시정지 상태가 된 쓰레드는 지정된 시간이 다 디거나 interrupt()가 
				  호출되면(InterruptedException 발생), 잠에서 깨어나 실행대기 상태가 된다.
				- sleep()을 호출 할 때는 항상 try-catch문으로 InterruptedException을 예외처리 해줘야 한다.
				- sleep()은 항상 현재 실행 중인 쓰레드에 대해 작동한다. 때문에 static으로 선언되어 있으며 참조변수를 이용해서 
				  호출하기 보다는 Thread.sleep(2000)과 같이 호출해야 한다.
				- th1.sleep(4000)과 같이 호출해도 실제로 영향을 받는 것은 main 메소드를 실행하는 main 쓰레드 입니다.
				
			- interrupt()
				- sleep()에 의해 멈춰 있을 때 interrupt()를호출하면 InterruptedException이 발생하고 
				  쓰레드의 Interrupted 상태는 false로 자동 초기화 됩니다.
				  
			- suspend(), resume(), stop()
				- suspend() : sleep()처럼 쓰레드를 일시정지 합니다.
				- resume() : suspend()에 의해 일시정지 상태에 있는 쓰레드를 실행대기 상태로 만듭니다.
				- stop() ; 호출되는 즉시 쓰레드가 종료됩니다.
				
				- suspend(), resume(), stop()은 쓰레드의 실행을 제어하는 가장 손쉬운 방법이지만, suspend()와 stop()이 
				  교착상태(deadlock)를 일으키기 쉽게 작성되어 있으므로 이 메소드들은 
				  모두 '@Deprecated' (사용 권장 X)이 됬습니다. 	  
				
			- stop()은 사실상 없다고 생각하면 좋다. 즉, 자바가 스레드를 종료시키는 방법은 없다고 생각해라. stop()를 사용한다는 것은
			  JVM이 직접 스레드를 종료시키는 건데, 이렇게 시스템적인 레벨로 처리를 한다면 스레드가 들고있던 lock이 풀리면서 알수없는 
			  데이터 구조가 생성되는 등 복잡한 문제들이 발생한다.
			  따라서, 개발자가 스레드가 사용하고 있는 데이터를 확인 후 코딩으로 직접 종료를 해야한다. (상태값을 true -> false)
			  
			  
			- yield()
				- 쓰레드 자신에게 주어진 실행시간을 다음 차례의 쓰레드에게 양보(yield)합니다.
				- yield()와 interrupt()를 적절히 사용하면, 
				  프로그램의 응답성을 높이고 보다 효율적인 실행이 가능하게 할 수 있습니다.
				  
			- join()	  
				- 쓰레드는 자신이 하던 작업을 잠시 멈추고 다른 쓰레드가 지정된 시간동안 작업을 수행하도록 할 때 사용합니다.
				- 시간을 지정하지 않으면, 해당 쓰레드가 작업을 모두 마칠 때까지 기다립니다.
				- 작업중에 다른 쓰레드의 작업이 먼저 수행되어야 할 필요가 있을 때 join()을 사용합니다.
				- join 메소드도 sleep 메소드처럼 interrupt()에 의해 대기상태에서 벗어날 수 있으며, join()이 호출 되는 부분을 
				  try-catch문으로 감싸서 interruptedException을 catch 해야합니다.
				ex) JVM의 가비지 컬렉터 
					(최대 메모리가 1000인 상태에서 사용된 메모리가 60%를 초과한 경우 gc 쓰레드가 깨어나서 메모리를 비우는 작업)
					
		- Object 클래스에 선언된 쓰레드와 관련된 메소드들
			- 직접 멀티 스레드를 코딩하면 개발이 매우 힘들었을 것이다. 
			- 이러한 멀티 스레드 코딩은 다 서블릿 컨테이너에 들어가 있다. (톰캣, 제티, 네티, 언더토우 등)
			- 스레드는 서버의 리소스를 극한으로 활용할 때 사용한다. 하지만 이것두 서블릿 컨테이너들이 다 해준다.
			- 만약 여러 요청이 들어온다면 서버가 가지고 있는 모든 리소스와 스레드를  활용해서 실행을 해준다. 
			  다시 말해서, 개발자가 멀티스레딩 코딩을 하지 않았지만, 서블릿 컨테이너에 의해 멀티스레드 코딩으로 돌아간다.
			- 멀티스레드 코딩으로 한다면 서버의 리소스를 효율적으로 사용 및 동시에 여러 CPU 까지 돌리게 되므로, 속도가 빨라진다.
			  
	10.3 쓰레드의 우선순위
		- 쓰레드 스케쥴링은 우선순위 방식과 순환할당 방식이 있다.
		
		- 순환 할당: 각자 시간 할당량을 정해서 하나의 쓰레드를 정해진 시간만큼만 실행하고 다시 다른 쓰레드를 실행하는 것을 말하는데, 
		  이런 순환 할당 방식은 JVM이 정하기 때문에 코드로 제어할 수는 없다.
		- Java에서 각 쓰레드는 우선순위(Priority)에 관한 자신만의 필드를 가지고 있다. 
		  이러한 우선순위에 따라 특정 쓰레드가 더 많은 시간동안 작업을 할 수 있도록 설정한다.  
		- getPriority()와 setPriority() 메소드를 통해 쓰레드의 우선순위를 반환하거나 변경할 수 있다. 
		  쓰레드의 우선순위가 가질 수 있는 범위는 1부터 10까지이며, 숫자가 높을 수록 우선순위 또한 높아진다.
		- 하지만 쓰레드의 우선순위는 비례적인 절댓값이 아닌 어디까지나 상대적인 값일 뿐이다. 우선순위가 10인 쓰레드가 
		  우선순위가 1인 쓰레드보다 더 빨리 수행되는 것이 아니다. 단지 우선순위가 10인 쓰레드는 우선순위가 1인 쓰레드보다 
		  좀 더 많이 실행 큐에 포함되어, 좀 더 많은 작업 시간을 할당받을 뿐이다.  
		※ main 메소드를 수행하는 쓰레드는 우선순위가 5이므로 main메소드내에서 생성하는 쓰레드의 우선순위는 기본적으로 5가 된다.
		
		- 같은 우선순위를 가지는 쓰레드를 실행시키는 경우 번갈아가면서 실행함을 확인할 수 있다. 원래 소스코드 실행은 순차적으로 실행되지만 
		  쓰레드의 경우 순차적으로 실행하는 것이 아닌 번갈아 가면서 실행되는 것을 볼 수 있다.
		- 하지만 우선순위를 부여하는 경우 상대적으로 우선순위가 높은 쓰레드가 좀더 빠르게 실행된다.
		  출력 결과를 보면 순서가 정확히 일치하지는 않는것을 볼 수 있는데, 우선순위가 높다고 해서 무조건 먼저 실행되는 것이 아니라 
  		  실행 기회를 더 많이 가지는 것이기 때문에 정확히 일치하지는 않는다.
  		- 또한, 쿼드코어에선 4개의 쓰레드가 병렬성으로 실행될 수 있기 때문에 
  		  4개 이하의 쓰레드에서는 크게 영향이 없고 5개 이상일 때 의미가 생긴다.
  		  
  	10.4 Main 쓰레드
  		- Java는 실행 환경인 JVM에서 돌아가게 된다. 이것이 하나의 프로세스이고 Java를 실행하기 위해 
  		  우리는 main() 메소드가 메인 쓰레드이다. 
		- 따로 쓰레드를 실행하지 않고 main() 메소드만 실행하는 것을 싱글쓰레드 애플리케이션이라고 한다.
		- 메인 쓰레드에서 쓰레드를 생성하여 실행하는 것을 멀티 쓰레드 애플리케이션이라고 한다. 
		- 싱글 쓰레드 애플리케이션에서는 메인쓰레드가 종료되면 프로세스도 종료되지만 
		  멀티 쓰레드 애플리케이션은 실행중인 쓰레드가 하나라도 있다면 종료되지 않는다.
		  
		※ Main 쓰레드에서 join()을 하면 데드락에 걸린다.
		
		- Daemon Thread
			- Main 쓰레드의 작업을 돕는 보조적인 역할을 하는 쓰레드이다.
			- Main 쓰레드가 종료되면 데몬 쓰레드는 강제적으로 자동 종료가 된다.
			  (어디까지나 Main 쓰레드의 보족 역할을 수행하기 때문에, Main 쓰레드가 없어지면 의미가 없어지기 때문이다.)
			- Java의 Garbage Collector가 데몬 쓰레드입니다.
				ex) 크롬이라는 메인 메소드가 실행이 되면서, 유튜브의 백그라운드 재생, 
				    google docs의 문서 자동저장 등을 데몬 쓰레드라고 볼 수 있다.
			  
	10.5 동기화
		- 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 임계구역(Critical section)이라고 합니다.
		- 임계구역 해결 조건
			- 상호 배제(mutual exclusion) : 한 쓰레드가 임계구역에 들어가면 다른 쓰레드는 임계구역에 들어갈 수 없습니다. 
			  이것이 지켜지지 않으면 임계구역을 설정한 의미가 없습니다.
			- 한정 대기(bounded waiting) : 한 쓰레드가 계속 자원을 사용하고 있어 다른 쓰레드가 사용하지 못한 채 계속 기다리면 
			  안됩니다. 어떤 쓰레드도 무한 대기하지 않아야 합니다. 즉 특정 쓰레드가 임계구역에 진입하지 못하면 안됩니다.
			- 진행의 융통성(progress flexibility) : 한 쓰레드가 다른 쓰레드의 작업을 방해해서는 안됩니다.
			
			- 우리는 임계 구역(critical section)과 잠금(lock)의 개념을 활용해서 한 쓰레드가 특정 작업을 마치기 전까지 
			  다른 쓰레드에 의해 방해받지 않도록 수행할 수 있게 됩니다.
			  
			- 공유 데이터를 사용하는 코드 영역을 임계구역으로 지정해놓고, 공유 데이터(객체)가 가지고 있는 lock을 획득한 
			  단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 합니다. 그리고 해당 쓰레드가 임계 구역 내의 모든 코드를 
			  수행하고 벗어나서 lock을 반납해야만 다른 쓰레드가 반납된 lock을 획득하여 임계구역의 코드를 수행할 수 있게 됩니다.
			  
			- 이처럼 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화(synchronization)라고 합니다. 
			  쓰레드에 안전하다고 표현합니다(thread-safe)  
			    
			- 자바에서는 synchronized블럭을 이용해서 쓰레드의 동기화를 지원했지만, JDK1.5부터는 'java.util.concurrent.locks'와 'java.util.concurrent.atomic'패키지를 통해서 
			  다양한 방식으로 동기화를 구현할 수 있도록 지원하고 있습니다.
			  
			- 기아(starvation) 상태란?
			  어떤 쓰레드가 다른 쓰레드들이 CPU시간을 모두 잡고 있어 CPU시간을 사용할 수 없게 되는 현상을 "기아 상태"라고 한다. 
			  + lock을 얻지못하고 오랫동안 기다리게 되는 현상
			  
			- Race Condition이란?
			  여러 쓰레드가 lock을 얻기 위해 경쟁하는 것을 '경쟁 상태(race confition)' 라고 합니다.
			  Ex) 공유하는 자원에 어떤 순서로 접근하냐에 따라 결과가 달라질 수도 있다. 이러한 현상의 원인을
			  "race condition 때문에 발생했다" 라고 말하기도 한다.
			  
			- Critical Path란?
			  동시에 실행하는 작업들 중 가장 긴 작업시간, 전체 수행시간을 줄이기 위해 우선적으로 개선할 부분
			  
			- 자바에서 동기화 하는 방법은 3가지로 분류된다
				- Synchronized 키워드
					- 가장 간단한 동기화 방법으로 synchronized키워드를 이용해서 임계구역을 설정하는 방법입니다.
					
					- 메소드 전체를 임계구역으로 설정
						- 메소드가 호출된 시점부터 lock을 얻어서 작업하고 메소드가 종료되면 lock을 반환합니다.
					- 특정한 영역을 임계구역으로 지정
						- 참조변수는 lock을 걸고자 하는 객체를 지정해주며 이 블럭의 영역 안으로 들어가면서 부터 
						  쓰레드는 지정된 객체의 lock을 얻게 되고, 이 블럭을 벗어나면 lock을 반납합니다.  
					
					- 두 가지 방법 모두 lock의 획득과 반납이 자동적으로 이루어지므로 
					  우리가 해야 할 일은 그저 임계구역만 지정해주는 것입니다.
					- 임계 영역은 멀티쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 메소드 전체에 락을 거는 것보다 synchronized 블럭으로 
					  임계구역을 최소화해서 보다 효율적인 프로그램이 되도록 노력해야 한다.  
					    
				- Atomic 클래스
				- Volatile 키워드
				
	10.6 데드락
		- 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 
		  작업을 더 이상 진행하지 못하는 상태를 교착 상태(dead lock)라고 합니다.
		  ex) 식사하는 철학자 문제
		- 교착 상태가 발생하는 원인  
			- 교착 상태의 필요조건
				1.상호배제 : 철학자들은 서로 포크를 공유할 수 없습니다.
				  -> 자원을 공유하지 못하면 교착 상태가 발생합니다. 여기서 자원은 배타적인 자원이어야 합니다. 
				  배타적인 자원은 임계구역에서 보호되기 때문에 다른 프로세스(쓰레드)가 동시에 사용할 수 없습니다.
				
				2.비선점 : 각 철학자는 다른 철학자의 포크를 빼앗을 수 없습니다.
				  -> 자원을 빼앗을 수 없으면 자원을 놓을 때 까지 기다려야 하므로 교착상태가 발생합니다.

				3.점유와 대기 : 각 철학자는 왼쪽 포크를 잡은 채 오른쪽 포크를 기다립니다.
				  -> 자원 하나를 잡은 상태에서 다른 자원을 기다리면 교착 상태가 발생합니다.

				4.원형 대기 : 자원 할당 그래프가 원형입니다.
				  -> 자원을 요구하는 방향이 원을 이루면 양보를 하지 않기 때문에 교착상태가 발생합니다.
				
				- 이 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이중 순환대기 조건은 점유대기 조건과 
				  비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.  
			  
		- 교착상태를 관리 하기 위해 예방, 회피, 무시할 수 있다고 한다.
			- 교착상태의 예방
				- 상호배제 조건의 제거
					- 교착 상태는 두 개 이상의 프로세스가 공유가능한 자원을 사용할 때 발생하는 것이므로 공유 불가능한, 
					  즉 상호 배제 조건을 제거하면 교착 상태를 해결할 수 있다.
				- 점유와 대기 조건의 제거
					- 한 프로세스에 수행되기 전에 모든 자원을 할당시키고 나서 점유하지 않을 때에는 다른 프로세스가 자원을 
					  요구하도록 하는 방법이다. 자원 과다 사용으로 인한 효율성, 프로세스가 요구하는 자원을 파악하는 데에 대한 비용, 
					  자원에 대한 내용을 저장 및 복원하기 위한 비용, 기아 상태, 무한대기 등의 문제점이 있다.
				- 비선점 조건의 제거
					- 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다.
				- 환형 대기 조건의 제거
					- 자원 유형에 따라 순서를 매긴다.	      
			    	  
			    - 이 교착 상태의 해결 방법들은 자원 사용의 효율성이 떨어지고 비용이 많이 드는 문제점이 있다.
			    
			- 교착상태 회피
				- 자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 것으로 
				  시스템에 circular wait가 발생하지 않도록 자원 할당 상태를 검사한다.
					1. 자원할당 그래프 알고리즘(Resource Allocation Graph Algorithm)
					2. 은행원 알고리즘(Banker's algorithm)
					
			- 교착상태 무시
				- 예방과 회피방법을 활용하게 되면 자연적으로 성능상 이슈가 발생될텐데, 
				  데드락 발생에 대한 상황을 고려하는 것의 코스트가 낮다면 별다른 조치를 하지 않을 수도 있다고 한다.
				  
				- JVM을 실시간으로 모니터링 할 수 있는 오픈소스 기반 GUI 툴 -> VisualVM
				  데드락 확인 가능
				  heap덤프 및 쓰레드덤프 가능  
				  		  
		- Thread Pool(스레드 풀)
			- 스레드를 생성하는데 드는 비용이 많다. 그럼 스레드를 미리 생성해서 가져다 쓰면 되지 않을까? 
			  라는 생각에서 나온게 스레드 풀이다.
			   
			  
			  
			  
				  
				  
			    
			    
		
			  
			  
			
		
		
  			  
  		  
		  
		  
		  
		    
		  
		  
		  
		
			  
			  
			
		
					
					
				
					
				
			     	
			
			
		
			  
			  
			  	  
				  
				    
			  
			  	    
			    
			  
			
			
			
			
			
			
			