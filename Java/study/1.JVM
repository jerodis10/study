1.JVM
	1.1 JVM이란 무엇인가
	1.2 컴파일 하는 방법
	1.3 실행하는 방법
	1.4 바이트코드란 무엇인가
	1.5 JIT 컴파일러란 무엇이며 어떻게 동작하는지
	1.6 JVM 구성 요소
	1.7 JDK와 JRE의 차이
	1.8 javac 옵션
	
	
	1.1 JVM이란 무엇인가
		- JVM은 Java Virtual Machine의 줄임말로 OS 환경에 상관없이 자바 프로그램을 실행할 수 있도록 도와주는 프로그램
		- 좀더 정확히 말하자면, 자바 소스코드(*.java)를 컴파일 한 경우 바이트코드로 이루어져 있는 클래스 파일(*.class)이 생성된다.
		  JVM은 클래스 파일을 운영체제가 이해할 수 있도록 기계어로 해석해준다. JVM의 해석을 거치기 때문에 C나 C++과 같은 네이티브
		  언어에 비해 속도가 느렸지만 JIT(Just In Time) 컴파일러를 구현해 한계를 극복했다. 현재는 거의 차이가 없다고 봐도 무방.
		  
	1.2 컴파일 하는 방법
		- 자바를 개발하는 사람들은 대부분 이클립스나 인텔리제이 등 IDE툴을 이용해서 빌드를 통해 컴파일을 한다.
		  (사실 IDE툴도 PC에 설치된 Java의 경로에서 javac.exe를 툴 내부적으로 javac라는 명령어를 이용해서 컴파일한다.)
		- 하지만 리눅스에 톰캣으로 올린 스프링부트 프로젝트의 소스를 수정 후 재컴파일을 해야하는 순간이 존재하기 때문에 알아야 한다.
		  ※ javac에 대한 옵션은 맨아래에 있다.
		  
		- 터미널에서 자바를 실행
			1. 메모장을 통해 자바코드를 작성한다. 확장자는 .java로 끝나야 한다.
			2. 터미널을 통해 작성한 파일의 경로로 들어간 후 javac Hello.java 치면 컴파일 되어 Hello.class파일이 생성된 것을 
			   확인할 수 있다.
			3. Hello.class 파일을 열어보면 괴상한 문자들이 존재한다. 
			   이는 컴파일된 바이트코드로서 JVM이 해석할 수 있는 언어로 변경된것이다.
			4. javap -c "클래스명" 명령어로 해석된 바이트코드를 확인할 수 있다.   
	
	1.3 실행하는 방법	
		- 컴파일된 클래스 파일을 java Hello 명령어를 통해 실행한다.	
		
		- C언어와 자바 컴파일 과정 차이	
			- C언어 
				- *.c -> 컴파일러 -> 어셈블리어 -> 어셈블러 -> 기계어 -> 링커 -> EXE
				- c언어는 전체코드를 컴파일
				  C/C++ 소스를 컴파일하고 나면 OS상에서 바로 실행될 수 있는 실행 파일이 생성된다.
				  그러나 이렇게 생성된 실행 파일에는 OS에 종속적인 코드가 있으며, OS가 바뀌면 다시 소스를 컴파일하고 링크해야 한다.
			- java
				- *.java -> 컴파일러 -> JVM
				- 링크과정 없이 컴파일러가 바로 바이트코드를 생성
				  컴파일된 클래스파일(바이트코드)이 JVM에서 실행되어 OS에 종속적인 코드를 갖지 않으므로
				  OS가 달라져도 다시 컴파일할 필요없이 OS에 맞는 JVM만 설치하면 된다.
	
	1.4 바이트코드란 무엇인가
		- 바이트코드란 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법.		
		  흔히 코드를 작성하는 파일인 .java 파일을 컴파일 후 생기는 .class 파일 안의 내용.
		  코틀린, 스칼라, 그루비 등 여러 가지 언어로 코드를 작성한 다음 특정 컴파일러를 통해 바이트코드로만 만들어주면 
		  JVM을 통해 어플리케이션을 실행할 수 있다.
		  
		- 바이트코드는 1Byte로 이루어진 명령 코드(opcode)였기 때문에 바이트코드라 불리게 되었다. 자바의 interpreter인 JVM 안에서
	      .class 파일에 대한 interpret이 수행이 되는데, 소스 코드 전체를 한번에 번역하는 컴파일러와는 달리 소스 코드를 한 행씩
	      중간 코드를 변역 후 실행한다. OS에 독립적인 장점을 얻었지만 중간과정이 추가됨으로써 느리다는 비판을 받아왔지만
	      JIT Compiler가 등장함으로써 한계를 극복.
	
	1.5 JIT 컴파일러란 무엇이며 어떻게 동작하는지	
		- JIT 컴파일(Just-in-time-compilation) 또는 동적 번역(dynamic-translation)은 프로그램을 실제 
		  실행하는 시점(Runtime)에 기계어로 번역하는 컴파일 기법이다.(JIT 컴파일 = 인터프리터 방식 + 컴파일 방식)
		  
		- 일반적으로 기계어로 만드는 방법은 인터프리터 방식과 정적 컴파일 방식이 있다.
		  인터프리터 방식: 한 줄씩 읽어내려 가며 기계어로 변환
		  정적 컴파일 방식: 실행하기 전에 프로그램 코드를 기계어로 번역
		  
		- 위에서 말한 실행속도를 증가시키기 위해 JIT 컴파일러는 런타임 시에 JVM과 상호작용하여 적절한 바이트코드 시퀀스를 기계어로
		  컴파일한다. 즉, 번역한 코드를 캐싱하여, 동일한 코드가 있을 경우 번역작업을 거치지 않고 캐싱해둔 값을 사용합으로써 매번
		  기계어 코드 생성을 방지하여 인터프리팅 시간을 단축시킨다.
		  
		- JDK > JRE > JVM > JIT
		
		- At compile time
			1. .java (java source)
			2. Compiler
			3. .class Bytecode
		- At run time
			4.Native code
			5.JIT Compiler
			
		- JIT 컴파일러는 JRE의 구성요소로서 런타임에 자바 어플리케이션의 성능을 향상시킨다. 런타임에 JVM은 클래스 파일을 로드하고,
		  각 개별 바이트코드의 의미를 결정하며 적적한 계산을 수행한다.
		  JIT 컴파일러는 메서드 호출 내내 활성화 되며, 바이트코드를 기계어로 컴파일하여 실행한다. 
		  JVM은 컴파일된 코드를 해석하는 대신 이전에 JIT 컴파일러에 의해 컴파일된 코드를 직접 호출한다.	
		  
		- 이는 메모리와 프로세스를 사용하지 않는다는 전제하에, 자바 어플리케이션 속도가 네이티브 어플리케이션의 속도에 근접할 수 있도록
		  도움을 준다. 하지만 JIT 컴파일 또한 프로세스 시간과 메모리 사용량이 필요하며 JVM에서 JIT를 처음 사용할 경우 
		  수천 가지의 방법이 호출된다.
		  
		- JIT Compiler가 처음 바이트 코드를 읽을 때 한번 번역하고 저장소에 저장한다. 즉, 반복되는 코드를 매번 해석하지 않고 
		  런타임 때 컴파일 하면서 해당 코드를 캐싱한다. 이후에 바뀐 부분만 컴파일하고 나머지는 캐싱된 코드를 사용한다. 그래서 인터프리터는
		  읽을 때, 반복되는 코드는 컴파일된 코드를 바로 사용할 수 있어서 속도가 개선된다. 
		  인터프리터가 안읽고 캐싱된 컴파일된 코드를 바로 사용 (이부분에서 컴파일이란 바이트코드 -> 기계어)
		  
		- 뒤에 나오겠지만 아래의 그림에서 자바 인터프리터랑 JIT컴파일러가 동시에 동작되는 것이다. 성능을 좌우하는 중요한 코드(메소드)는
		  JIT컴파이러가 기계어로 미리 정적 컴파일을 수행하고 캐싱한다. 후에 똑같은 코드(메소드)가 실행되면 캐싱된 기계어를 가져와서 
		  그대로 사용한다. 나머지 덜 중요한 코드들이 인터프리터 방식으로 수행되는 것이다.  
		  
	1.6 JVM 구성 요소	  
		- JVM은 크게 3가지 구성요소로 이루어져 있다.
		
		- ClassLoader System
			- Runtime 시점에 Runtime Data Area의 Method Area에 .class파일들을 검사 후 로드하고
			  링크를 통해 배치하는 작업을 수행
		
		- Runtime Data Area
			- 프로그램이 실행되기 위해선 메모리가 필요하다. 자바 애플리케이션도 마찬가지다. OS가 관리하는 메인메모리인 RAM의 
			  일부 영역을 JVM이 필요한 만큼 OS로부터 할당받는다. OS로부터 받은 메모리 공간을 Runtime Data Area라고 부르며 
			  5개의 영역으로 용도별로 나누어서 관리한다. 초심자들은 Method Area, Heap, Stack영역만 숙지하고 있어도 될것 같다.
		
		- Execution Engine
			- Interpreter : 바이트코드 명령어를 하나씩 읽어 해석하고 실행
		    - JIT Compiler : 런타임시에 JVM과 상호작용하여 적절한 바이트코드 시퀀스를 기계어로 컴파일을 실행
			- Garbage Collector : 참조되지 않는 객체를 우선적으로 메모리에서 제거하여 메모리 공간을 확보하는 
			  					  Garbage Colleciton을 실행시켜주는 주체
			  					  
	1.7 JDK와 JRE의 차이	
		- 컴파일 타임 환경
			1. 자바 클래스 파일 (.java)
			2. 자바 컴파일러
			3. 자바 바이트 코드 (.class)
		- 런타임 환경
			4. 클래스 로더 ( <- 자바 클래스 라이브러리 파일 )
			5. 자바 가상 머신 (JVM)
				5.1.1 자바 인터프리터
				5.1.2 JIT 컴파일러
				5.2 런타임 시스템
			6. 운영체제
			7. 하드웨어  
			  					  
		- JRE(Java Runtime Environment)
			- JVM + Java class Libraries + Java Class Loader가 포함된다.	
			
			- 클래스 로더는 런타임 환경에서 바이트코드(.class)를 최초로 메모리에 로드한다.	  	
			  즉, 모든 클래스 파일이 한 번에 JVM 메모리에 로딩되지 않고, 요청 순간 로딩이 되게끔 조율하는 역할을 한다.	
			
			- 바이트코드는 JRE 위에서 동작한다.
			- JRE는 자바 어플리케이션을 실행하는데 필요한 요소만 들어있지 자바를 개발하는 데 필요한 툴은 포함되어 있지 않다.
		
		- JDK(Java Development Kit)
			- JRE 뿐만 아니라 컴파일러, 디버거 등 자바 어플리케이션을 개발하는데 필요한 도구가 포함되어 있다. 
			- JAVA9버전 부터는 JRE자체가 사라졌다. (JDK안에 다 있으니..)
	
	1.8 javac 옵션
		- 생김새 :  javac <option> <source files>
		
		1. -classpath(-cp) 
			- 컴파일러가 컴파일 할 때 필요로 하는 라이브러리나 클래스들의 경로를 지정해주는 옵션
			  스프링 프로젝트에서 리눅스에서 직접 javac로 컴파일할 때 자주 사용되는 옵션이다. 	
			  
			- javac -classpath 프로젝트경로/WEB-INF/lib/* 프로젝트경로/WEB-INF/classes/SomeFile.java
		 	  이런식으로 명령어를 작성하여 파일을 탐색할 수 있도록 경로만 잘 맞춰주면 된다.
			
			- classpath를 구분하는 기호는 리눅스는 :(콜론) / 윈도우는 ;(세미콜론)
		
		2. -source [자바버전] -target [자바버전]
			- 하위 jdk 버전에서도 작성한 자바애플리케이션이 실행되도록 할 때 사용
			  예를 들어 java 1.6에서 컴파일했지만 java 1.5에서 실행이 가능하도록 할 때 사용한다.
			  
		3. -d
			- 하위 jdk 버전에서도 작성한 자바애플리케이션이 실행되도록 할 때 사용
			  예를 들어 java 1.6에서 컴파일했지만 java 1.5에서 실행이 가능하도록 할 때 사용한다.	  
			
			-  javap -c "클래스 이름".class
			   .class의 파일의 바이트코드를 opcode로 해석한다.
			   
		* 상위버전의 바이트코드는 하위버전의 자바프로그램으로 실행 불가능
		  하위버전의 바이트코드는 상위버전의 자바프로그램으로 실행 가능	   			  