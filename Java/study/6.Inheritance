6.Inheritance
	6.1 자바 상속의 특징
	6.2 super 키워드
	6.3 메소드 오버라이딩
	6.4 다이나믹 메소드 디스패치
	6.5 추상 클래스
	6.6 final 키워드
	6.7 Object 클래스
	
	
	6.1 자바 상속의 특징
		- 부모 클래스의 생성자와 초기화 블럭은 상속되지 않는다.
  		- 부모 클래스의 private 접근 제한을 갖는 변수와 메소드는 자식한테 물려주지 않는다.
  		- 자식 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
  		- 자바에서는 다중 상속을 지원하지 않는다.
  		- 동일한 이름의 변수가 부모 클래스와 자식 클래스에 둘 다 존재할 경우 자식 클래스의 변수로 오버라이딩 된다.
  		- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.
  		- Abstract method로 정의된 speak()메소드를 Father 클래스에서도 구현했고, Mother 클래스에서도 구현했기에 
  		  어떤 speak()메소드를 호출해야 할지 자식은 알 수 없다.
  		- 자바에서 다중 상속이 필요할 경우 인터페이스를 이용해 해야한다.
  	
  	6.2 super 키워드		
  		- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.
  		- 멤버 변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속 받은 멤버와 자신의 멤버와 이름이 같을 때 
  		  super를 붙여서 구별할 수 있다.
  		- this와 마찬가지로 super 역시 static 메서드에서는 사용할 수 없고 인스턴스 메서드에만 사용할 수 있다.
  		- 부모 클래스와 자식 클래스의 멤버변수가 같더라도 this와 super를 이용해서 서로 구별할 수 있다.
  		- 부모 클래스의 메서드를 자식 클래스에서 오버라이딩한 경우에도 super를 사용해서 조상 클래스의 메서드를 호출할 수 있다.
  		
  		- this()는 같은 클래스의 다른 생성자를 호출하는 데 사용 되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.
  		- 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 
  		  그래서 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다. 이 때 조상 클래스 멤버의 초기화 작업이 
  		  수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.
  		- 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 
  		  조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.
  		- 이와 같은 조상 클래스 생성자의 호출은 클래스의 상속관계를 모든 클래스의 최고 조상인 Object 클래스 까지 거슬러 
  		  올라가면서 계속 반복된다. 따라서 Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 
  		  또는 조상의 생성자를 호출해야 한다. 그렇지 않으면 컴파일러는 생성자의 첫 줄에 'super()'를 자동으로 추가한다.  
  		  
  		- ★ 표시한 부분에 다른 생성자를 호출하지 않기 때문에 컴파일러가 삽입해주지만 컴파일 에러가 발생한다.
		  왜냐하면 부모 클래스인 Point에 기본 생성자가 없기 때문이다.
		  (생성자가 정의되어 있는 클래스에는 컴파일러가 기본 생성자를 자동적으로 추가하지 않는다.)
  		  
  	6.3 메소드 오버라이딩
  		- 오버라이딩이란 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 
  		  재정의하는 것이다. 즉, 메서드의 선언부가 기존메소드와 완전히(이름, 매개변수, 반환타입) 같아야 한다.	
  		  
  		- 오버라이딩의 조건은 다음과 같다.
			1.접근 제어자는 조상 클래스의 메서드 보다 좁은 범위로 변경할 수 없다.
			2.조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 
			3.static 메서드는 오버라이딩이 불가능하다.
			4.final로 선언된 메소드의 경우 오버라이딩이 불가능하다.
			5.private로 접근 지정자를 사용하는 경우 오버라이딩이 불가능하다. 
		
		- 하이딩
			- static 메서드는 런타임시가 아닌 컴파일시에 생성되고 메모리에 적재 된다. 다형성이란 런타임시에 해당 메서드를 
			  구현한 실제 객체를 찾아가서 호출한다. 그러나 static메서드는 컴파일시에 선언된 객체의 메서들를 찾아 호출하기 
			  때문에 다형성이 적용되지 않는다.	
			- 런타임 시에 parent2가 실제로 참조하고 있는 클래스를 찾아가는 것이 아니라 컴파일시에 결정된 클래스를 찾아가서 
			  해당 메서드를 호출하는 이와 같은 상황을 하이딩이라 한다.
			- 정적 메서드는 오버라이딩이 되지 않아서 @Override 어노테이션 선언시 컴파일 에러가 발생한다.
			- 자바의 꽃인 다형성을 해치는 방법이기 때문에 쓰지말자!!
			
	6.4 다이나믹 메소드 디스패치
		 - 메소드 디스패치란 프로그램이 어떤 메소드를 호출할 것인가를 결정하여 그것을 실행하는 과정을 말한다.
		 - 대표적으로 Static Dispatch와 Dynamic Dispatch가 있다.
		 
		 - 정적 디스패치(Static Dispatch)
		 	public class StaticDispatch {
			    static class Service {
			        void run() {
			            System.out.println("run");
			        }
			        void run(String msg) {
			            System.out.println(msg);
			        }
			    }
			    public static void main(String[] args) {
			        new Service().run(); //run 출력
			    }
			}			
			
			- 위 프로그램을 실행하면 우리는 "run"이 출력되는 것을 실행시키지 않아도 알 수 있다.
			  즉, 정적 디스패치란 위와 같이 실행 시점이 아니라도 컴파일 시점에 어느 메소드로 호출이 일어날지 결정되는 것을 말한다.
			  
		- 동적 디스패치(Dynamic Dispatch)
			public class DynamicDispatch {
			    static abstract class Service {
			        abstract void run();
			    }
			    static class MyService1 extends Service {
			        @Override
			        void run() {
			            System.out.println("1");
			        }
			    }
			    static class MyService2 extends Service {
			        @Override
			        void run() {
			            System.out.println("2");
			        }
			    }
			    public static void main(String[] args) {
			        Service svc = new MyService1();
			        svc.run();
			    }
			}
			  
			- 위 프로그램을 실행하면 코드를 작성한 우리는 1이 출력될 것을 알지만 컴파일러는 스스로 결정을 하지 못해 
			  컴파일시에는 알 수 없다. 런타임 시에 svc에 할당된 객체를 확인 후 결정하게 된다. 	  	  
			  
	6.5 추상 클래스
		- 자바에서의 추상화란 기존의 클래스에서 공통된 성질을 뽑아 조상 클래스를 만드는 것이다.
		  반대말인 구체화는 상속을 통해 클래스를 구현하고 확장하는 작업이다.
		- 추상클래스로 인스턴스를 생성할 수 없다. 추상 클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.
		- 객체들에 대해서 공통점을 찾고 그 공통점대로 객체를 묶는 행위를 추상화, 즉 일반화 한다.
		- 인간과 고래는 차이점이 많지만 그룹화하여 조금더 단순하게 볼 수 있다.
		  인간과 고래를 포유류라는 그룹에 속할 수 있고 참새와 닭은 조류라는 그룹으로 묶을 수 있다.
		  이와같이 그룹으루 분류하여 얻는 장점은
		  	1. 객체간의 차이점은 무시하고 객체들 간의 공통점을 파악하기 쉽다.
		  	2. 객체의 불필요한 세부사항을 제거함으로써 중요한 부분을 강조할 수 있다.
		  객체지향 프로그래밍에서는 복잡한 프로그래밍을 단순화하고 분류함으로써 유연한 관계를 만들어 낼 수 있다.
		  
		- class 앞에 키워드 'abstract'를 붙이기만 하면 된다. 추상 클래스는 추상메서드를 포함하고 있다는 것을 제외하고 
		  일반 클래스와 전혀 다르지 않다. 추상클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.  
		- 추상메서드가 없는 클래스라도 추상 클래스로 지정되면 인스턴스를 생성할 수 없다.
		- 추상 메서드는 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨준 것을 말한다.
		  그럼 추상메서드를 왜 사용할까? 메서드의 내용이 상속받는 자식 클래스에 따라 달라질 수 있기 때문이다.
		- 만일 조상으로부터 상속받은 추상 메서드 중 하나라도 구현하지 않는다면, 자손 클래스 역시 추상클래스로 지정해주어야 한다.
		- 추상 메서드의 접근 지정자로 private은 사용할 수 없다.
		
		- 추상 메소드의 사용 목적
		  혼자하는 코딩이 아닌 여러명이서 할 경우 제약이 필요하다. 추상 메소드와 같은 제약이 없으면 사용자에 따라 해당 메서드를 
		  오버라이딩할 수도 있고 안할수도 있기 때문이다. 반드시 필요한 메서드라면 구현을 강제화하면 커뮤니케이션의 비용 낭비 없이 
		  코드만으로도 대화할 수 있다.
		  
	6.6 final 키워드	  
		- 크게 클래스, 메서드, 멤버 및 지역변수에 사용될 수 있다.
			  
		- final class
			- 변경 및 확장이 될 수 없는 클래스이다. 따라서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
			- 대표적인 final Class로 String 클래스가 있다.  
			
		- final method
			- 변경될 수 없는 메서드이다. final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
			
		- final variables
			- 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.
			
	6.7 Object 클래스
		- Object클래스는 java.lang 패키지에 있으며 모든 자바 클래스의 최고 조상 클래스이다.
		- equals
			- 객체의 참조값을 가지고 비교하기 때문에 만약 객체안의 값이 같으면 같은 객체라고 인식하게 구현하기 위해선 
			  equals를 오버라이딩 해야 한다.
		- 개발자가 정의한 객체 비교시 반드시 equals()와 hashCode()를 함께 재정의 해야한다.
			- hash 값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때 
			  hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true여야 논리적으로 같은 객체라고 판단한다.
		    
		  
		  		  
			  
			
			
			
			